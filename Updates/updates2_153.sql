-- Makes sure that the server collation is case insensitive
DECLARE @db sysname, @collation sysname, @collation2 sysname, @collation3 sysname
DECLARE @message nvarchar(4000)

SELECT @db=db_name()

SELECT @collation = CAST(DATABASEPROPERTYEX(@db, 'Collation') AS sysname)
SELECT @collation2 = CAST(DATABASEPROPERTYEX('master', 'Collation') AS sysname)
SELECT @collation3 = CAST(DATABASEPROPERTYEX('tempdb', 'Collation') AS sysname)

IF @collation LIKE '%_CS_%' -- OR @collation2 LIKE '%_CS_%' OR @collation3 LIKE '%_CS_%'
BEGIN
	SET @message = 'Updates will not work on a database that uses a case sensitive collation. Your database uses ' + @collation +'. You must change the ' + @db + ' database to an INSENSITIVE collation, preferrably SQL_Latin1_General_CP1_CI_AS. Using Microsoft SQL Server Management Studio, you can check the collation settings on any installed database. Case insenstive collations contain _CI_ in their names (instead of _CS_).'
	RAISERROR(@message,16,1)
END

IF @collation2 LIKE '%_CS_%' OR @collation3 LIKE '%_CS_%'
BEGIN
	SET @message = 'Updates may not work on a SQL Server instance that uses a case sensitive collation. Your instance (master and\or tempdb databases) uses ' + @collation2 +'. You must move the ' + @db + ' database to a SQL Server instance that uses a case INSENSITIVE collation, preferrably SQL_Latin1_General_CP1_CI_AS. Using Microsoft SQL Server Management Studio, you can check the collation settings on any installed instances. Case insenstive collations contain _CI_ in their names (instead of _CS_). If no currently-installed instances are case insensitive then you must install a new instance and move the database.'
	PRINT @message
END
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name]='Version Update Flags' and [ID]=OBJECT_id('dbo.Constant'))
ALTER TABLE dbo.Constant ADD [Version Update Flags] int NOT NULL DEFAULT(0)
GO
IF OBJECT_id('dbo.spAdminCreateViewIfNonexistent') IS NULL
EXEC sp_executesql N'CREATE PROC dbo.spAdminCreateViewIfNonexistent AS'
GO
ALTER PROC dbo.spAdminCreateViewIfNonexistent @view sysname AS
SET @view = 'dbo.' + @view
IF OBJECT_ID(@view) IS NULL
BEGIN
	DECLARE @sql nvarchar(4000)
	SET @sql = N'CREATE VIEW ' + @view + ' AS SELECT A=0'
	EXEC sp_executesql @sql
END
GO
IF OBJECT_id('dbo.spAdminCreateSPifNonexistent') IS NULL
EXEC sp_executesql N'CREATE PROC dbo.spAdminCreateSPifNonexistent AS'
GO
ALTER PROC dbo.spAdminCreateSPifNonexistent @sp sysname, @grant_exec_to_public bit = 1 AS
SET @sp = 'dbo.' + @sp
IF OBJECT_ID(@sp) IS NULL
BEGIN
	DECLARE @sql nvarchar(4000)
	SET @sql = N'CREATE PROC ' + @sp + ' AS'
	EXEC sp_executesql @sql
	IF @grant_exec_to_public = 1
	BEGIN
		SET @sql = N'GRANT EXEC ON ' + @sp + ' TO public'
		EXEC sp_executesql @sql
	END
END
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spAdminCreateFunctionifNonexistent', 0
GO
ALTER PROC dbo.spAdminCreateFunctionifNonexistent @fn sysname, @grant_exec_to_public bit = 1 AS
SET @fn = 'dbo.' + @fn
IF OBJECT_ID(@fn) IS NULL
BEGIN
	DECLARE @sql nvarchar(4000)
	SET @sql = N'CREATE FUNCTION ' + @fn + '() RETURNS int BEGIN RETURN 0 END'
	EXEC sp_executesql @sql
	IF @grant_exec_to_public = 1
	BEGIN
		SET @sql = N'GRANT EXEC ON ' + @fn + ' TO public'
		EXEC sp_executesql @sql
	END
END
GO
IF OBJECT_id('dbo.spExecSQLAsDBO') IS NOT NULL DROP PROC dbo.spExecSQLAsDBO
IF OBJECT_id('dbo.spExecSQLAsDBObit') IS NOT NULL DROP PROC dbo.spExecSQLAsDBObit
IF OBJECT_id('dbo.spExecSQLAsDBOint') IS NOT NULL DROP PROC dbo.spExecSQLAsDBOint
IF OBJECT_id('dbo.spExecSQLAsDBOmoney') IS NOT NULL DROP PROC dbo.spExecSQLAsDBOmoney
IF OBJECT_id('dbo.spExecSQLAsDBOvarchar50') IS NOT NULL DROP PROC dbo.spExecSQLAsDBOvarchar50
IF OBJECT_id('dbo.spExecSQLAsDBOvarchar4000') IS NOT NULL DROP PROC dbo.spExecSQLAsDBOvarchar4000
IF OBJECT_id('dbo.spExecSQLAsDBOtext') IS NOT NULL DROP PROC dbo.spExecSQLAsDBOtext
IF OBJECT_id('dbo.spExecSQLAsDBOdatetime') IS NOT NULL DROP PROC dbo.spExecSQLAsDBOdatetime
IF OBJECT_id('dbo.spExecSQLAsDBONumeric') IS NOT NULL DROP PROC dbo.spExecSQLAsDBONumeric
GO
CREATE PROC dbo.spExecSQLAsDBO @sql nvarchar(MAX) AS EXEC sp_executesql @sql
GO
CREATE PROC dbo.spExecSQLAsDBONumeric @sql nvarchar(1000), @value numeric(38,9), @person_id int AS
EXEC sp_executesql @sql, N'@value numeric(38,9), @person_id int', @value, @person_id
GO
CREATE PROC dbo.spExecSQLAsDBObit @sql nvarchar(1000), @value bit, @person_id int AS 
EXEC sp_executesql @sql, N'@value bit, @person_id int', @value, @person_id
GO
CREATE PROC dbo.spExecSQLAsDBOint @sql nvarchar(1000), @value int, @person_id int AS 
EXEC sp_executesql @sql, N'@value int, @person_id int', @value, @person_id
GO
CREATE PROC dbo.spExecSQLAsDBOmoney @sql nvarchar(1000), @value money, @person_id int AS 
EXEC sp_executesql @sql, N'@value money, @person_id int', @value, @person_id
GO
CREATE PROC dbo.spExecSQLAsDBOvarchar50 @sql nvarchar(1000), @value varchar(50), @person_id int AS 
EXEC sp_executesql @sql, N'@value varchar(50), @person_id int', @value, @person_id
GO
CREATE PROC dbo.spExecSQLAsDBOvarchar4000 @sql nvarchar(1000), @value varchar(4000), @person_id int AS 
EXEC sp_executesql @sql, N'@value varchar(4000), @person_id int', @value, @person_id
GO
CREATE PROC dbo.spExecSQLAsDBOtext @sql nvarchar(1000), @value text, @person_id int AS 
EXEC sp_executesql @sql, N'@value text, @person_id int', @value, @person_id
GO
CREATE PROC dbo.spExecSQLAsDBOdatetime @sql nvarchar(1000), @value datetime, @person_id int AS 
EXEC sp_executesql @sql, N'@value datetime, @person_id int', @value, @person_id
GO
IF OBJECT_ID('dbo.spAdminTestDboImpersonationPrepare') IS NOT NULL DROP PROC dbo.spAdminTestDboImpersonationPrepare
GO
IF OBJECT_ID('dbo.PersonCustomFieldFlat') IS NULL
CREATE TABLE dbo.PersonCustomFieldFlat(PCFPersonID int PRIMARY KEY NOT NULL)
GO
IF OBJECT_id('dbo.vwPersonCustomFieldFlatSecure') IS NULL EXEC sp_executesql N'CREATE VIEW dbo.vwPersonCustomFieldFlatSecure AS SELECT PCFPersonID=0'
GO
CREATE PROC dbo.spAdminTestDboImpersonationPrepare @test_dbo_enable bit = 0 OUT AS

IF CAST(SERVERPROPERTY('productversion') AS varchar(50)) LIKE '[0-8].%' OR IS_MEMBER('db_owner')=0
BEGIN
	SET @test_dbo_enable = 0
	RETURN
END

IF OBJECT_ID('spAdminTestDboImpersonation2') IS NOT NULL DROP PROC spAdminTestDboImpersonation2
IF OBJECT_ID('dbo.spAdminTestDboImpersonation2') IS NOT NULL DROP PROC dbo.spAdminTestDboImpersonation2
EXEC sp_executesql N'CREATE PROC dbo.spAdminTestDboImpersonation2 WITH EXECUTE AS ''dbo'' AS'

IF OBJECT_ID('spAdminTestDboImpersonation') IS NOT NULL DROP PROC spAdminTestDboImpersonation
IF OBJECT_ID('dbo.spAdminTestDboImpersonation') IS NOT NULL DROP PROC dbo.spAdminTestDboImpersonation

DECLARE @sql nvarchar(4000), @sql2 nvarchar(4000)

SET @sql=N'-- @actions_mask: 1 throw error
-- @result: 1 if success, 0 if failure
CREATE PROC dbo.spAdminTestDboImpersonation @actions_mask int, @prefix nvarchar(4000), @result bit OUT AS
DECLARE @can_dbo_be_impersonated bit

SELECT @can_dbo_be_impersonated=CASE WHEN [Version Update Flags] & 2 = 0 THEN 0 ELSE 1 END FROM dbo.Constant

BEGIN TRY
	EXEC dbo.spAdminTestDboImpersonation2
END TRY
BEGIN CATCH
	BEGIN TRY
		EXEC dbo.sp_changedbowner ''NT AUTHORITY\SYSTEM''
		EXEC dbo.spAdminTestDboImpersonation2
	END TRY
	BEGIN CATCH
		-- Turns off impersonation if dbo cannot be impersonated
		IF @can_dbo_be_impersonated = 1
		BEGIN
			EXEC sp_executesql N''ALTER PROC dbo.spExecSQLAsDBO @sql nvarchar(MAX) AS
			EXEC sp_executesql @sql''

			EXEC sp_executesql N''ALTER PROC dbo.spExecSQLAsDBONumeric @sql nvarchar(1000), @value numeric(38,9), @person_id int AS
			EXEC sp_executesql @sql, N''''@value numeric(38,9), @person_id int'''', @value, @person_id''

			EXEC sp_executesql  N''ALTER PROC dbo.spExecSQLAsDBObit @sql nvarchar(1000), @value bit, @person_id int AS 
			EXEC sp_executesql @sql, N''''@value bit, @person_id int'''', @value, @person_id''

			EXEC sp_executesql  N''ALTER PROC dbo.spExecSQLAsDBOint @sql nvarchar(1000), @value int, @person_id int AS 
			EXEC sp_executesql @sql, N''''@value int, @person_id int'''', @value, @person_id''

			EXEC sp_executesql  N''ALTER PROC dbo.spExecSQLAsDBOmoney @sql nvarchar(1000), @value money, @person_id int AS 
			EXEC sp_executesql @sql, N''''@value money, @person_id int'''', @value, @person_id''

			EXEC sp_executesql  N''ALTER PROC dbo.spExecSQLAsDBOvarchar50 @sql nvarchar(1000), @value varchar(50), @person_id int AS 
			EXEC sp_executesql @sql, N''''@value varchar(50), @person_id int'''', @value, @person_id''

			EXEC sp_executesql  N''ALTER PROC dbo.spExecSQLAsDBOvarchar4000 @sql nvarchar(1000), @value varchar(4000), @person_id int AS 
			EXEC sp_executesql @sql, N''''@value varchar(4000), @person_id int'''', @value, @person_id''

			EXEC sp_executesql  N''ALTER PROC dbo.spExecSQLAsDBOtext @sql nvarchar(1000), @value text, @person_id int AS 
			EXEC sp_executesql @sql, N''''@value text, @person_id int'''', @value, @person_id''

			EXEC sp_executesql  N''ALTER PROC dbo.spExecSQLAsDBOdatetime @sql nvarchar(1000), @value datetime, @person_id int AS 
			EXEC sp_executesql @sql, N''''@value datetime, @person_id int'''', @value, @person_id''

			GRANT INSERT ON dbo.PersonCustomFieldFlat TO public
			GRANT DELETE ON dbo.PersonCustomFieldFlat TO public
			GRANT UPDATE ON dbo.PersonCustomFieldFlat TO public
			GRANT SELECT ON dbo.PersonCustomFieldFlat TO public
			-- GRANT SELECT ON dbo.vwPersonCustomField TO public    No longer supported

			GRANT INSERT ON dbo.PersonXLanguageFlat TO public
			GRANT DELETE ON dbo.PersonXLanguageFlat TO public
			GRANT UPDATE ON dbo.PersonXLanguageFlat TO public
			GRANT SELECT ON dbo.PersonXLanguageFlat TO public

			UPDATE dbo.Constant SET [Version Update Flags] = [Version Update Flags] & 0x7FFFFFFD
		END

		IF @actions_mask & 1 = 1
		BEGIN
			DECLARE @message nvarchar(4000)
			SET @message = ''WARNING: ''
			SET @message = @message + @prefix
			IF @prefix <> '''' SET @message = @message + '' ''
			SET @message = @message + ''The owner of the database is orphaned so some of the security features that are available in SQL Server are disabled. Please contact a database administrator and ask him to change the database owner. Executing the command sp_changedbowner ''''NT AUTHORITY\SYSTEM'''' and then re-opening this software should resolve this issue.''
			RAISERROR(@message, 16, 1)
		END

		SET @result = 0
		RETURN
	END CATCH
END CATCH'

SET @sql2=N'
IF @can_dbo_be_impersonated = 0 OR NOT EXISTS(SELECT * FROM syscomments WHERE [id]=OBJECT_ID(''dbo.spExecSQLAsDBO'') AND [text] LIKE ''%EXECUTE AS%'')
BEGIN
	EXEC sp_executesql N''ALTER PROC dbo.spExecSQLAsDBO @sql nvarchar(MAX) WITH EXECUTE AS ''''dbo'''' AS
	EXEC sp_executesql @sql''

	EXEC sp_executesql N''ALTER PROC dbo.spExecSQLAsDBONumeric @sql nvarchar(1000), @value numeric(38,9), @person_id int WITH EXECUTE AS ''''dbo'''' AS
	EXEC sp_executesql @sql, N''''@value numeric(38,9), @person_id int'''', @value, @person_id''

	EXEC sp_executesql  N''ALTER PROC dbo.spExecSQLAsDBObit @sql nvarchar(1000), @value bit, @person_id int WITH EXECUTE AS ''''dbo'''' AS 
	EXEC sp_executesql @sql, N''''@value bit, @person_id int'''', @value, @person_id''

	EXEC sp_executesql  N''ALTER PROC dbo.spExecSQLAsDBOint @sql nvarchar(1000), @value int, @person_id int WITH EXECUTE AS ''''dbo'''' AS 
	EXEC sp_executesql @sql, N''''@value int, @person_id int'''', @value, @person_id''

	EXEC sp_executesql  N''ALTER PROC dbo.spExecSQLAsDBOmoney @sql nvarchar(1000), @value money, @person_id int WITH EXECUTE AS ''''dbo'''' AS 
	EXEC sp_executesql @sql, N''''@value money, @person_id int'''', @value, @person_id''

	EXEC sp_executesql  N''ALTER PROC dbo.spExecSQLAsDBOvarchar50 @sql nvarchar(1000), @value varchar(50), @person_id int WITH EXECUTE AS ''''dbo'''' AS 
	EXEC sp_executesql @sql, N''''@value varchar(50), @person_id int'''', @value, @person_id''

	EXEC sp_executesql  N''ALTER PROC dbo.spExecSQLAsDBOvarchar4000 @sql nvarchar(1000), @value varchar(4000), @person_id int WITH EXECUTE AS ''''dbo'''' AS 
	EXEC sp_executesql @sql, N''''@value varchar(4000), @person_id int'''', @value, @person_id''

	EXEC sp_executesql  N''ALTER PROC dbo.spExecSQLAsDBOtext @sql nvarchar(1000), @value text, @person_id int WITH EXECUTE AS ''''dbo'''' AS 
	EXEC sp_executesql @sql, N''''@value text, @person_id int'''', @value, @person_id''

	EXEC sp_executesql  N''ALTER PROC dbo.spExecSQLAsDBOdatetime @sql nvarchar(1000), @value datetime, @person_id int WITH EXECUTE AS ''''dbo'''' AS 
	EXEC sp_executesql @sql, N''''@value datetime, @person_id int'''', @value, @person_id''

	REVOKE INSERT ON dbo.PersonCustomFieldFlat TO public
	REVOKE DELETE ON dbo.PersonCustomFieldFlat TO public
	REVOKE UPDATE ON dbo.PersonCustomFieldFlat TO public
	REVOKE SELECT ON dbo.PersonCustomFieldFlat TO public

	-- REVOKE SELECT ON dbo.vwPersonCustomField TO public
	REVOKE INSERT ON dbo.PersonXLanguageFlat TO public
	REVOKE DELETE ON dbo.PersonXLanguageFlat TO public
	REVOKE UPDATE ON dbo.PersonXLanguageFlat TO public
	REVOKE SELECT ON dbo.PersonXLanguageFlat TO public

	UPDATE dbo.Constant SET [Version Update Flags] = [Version Update Flags] | 2
END

SET @result = 1'

CREATE TABLE #BigSQLStatement([SQL] ntext COLLATE SQL_Latin1_General_CP1_CI_AS)

INSERT #BigSQLStatement([SQL]) VALUES (@sql)
DECLARE @sql_ptr binary(16)
SELECT @sql_ptr = TEXTPTR([SQL]) FROM #BigSQLStatement
UPDATETEXT #BigSQLStatement.[SQL] @sql_ptr NULL 0 @sql2
EXEC dbo.spExecuteSQLBigForSQL2000
DROP TABLE #BigSQLStatement

SET @test_dbo_enable = 1
GO
GRANT EXEC ON dbo.spAdminTestDboImpersonationPrepare TO public
GO
-- Tries to assign NT AUTHORITY\SYSTEM to dbowner if dbo cannot be impersonated
UPDATE dbo.Constant SET [Version Update Flags] = [Version Update Flags] & 0x7FFFFFFD
IF CAST(SERVERPROPERTY('productversion') AS varchar(50)) NOT LIKE '[0-8].%'
BEGIN
	IF OBJECT_ID('dbo._spTestDboImpersonation') IS NOT NULL DROP PROC dbo._spTestDboImpersonation
	EXEC sp_executesql N'CREATE PROC dbo._spTestDboImpersonation WITH EXECUTE AS ''dbo'' AS UPDATE dbo.Constant SET [Version Update Flags] = [Version Update Flags] | 2'
	EXEC sp_executesql N'BEGIN TRY EXEC dbo._spTestDboImpersonation END TRY BEGIN CATCH BEGIN TRY EXEC dbo.sp_changedbowner ''NT AUTHORITY\SYSTEM'' EXEC dbo._spTestDboImpersonation END TRY BEGIN CATCH IF @@TRANCOUNT > 0 ROLLBACK END CATCH END CATCH'
	IF OBJECT_ID('dbo._spTestDboImpersonation') IS NOT NULL DROP PROC dbo._spTestDboImpersonation
	IF @@TRANCOUNT > 0 ROLLBACK
END
GO
-- Settings to support indexed views
DECLARE @db sysname, @cmd nvarchar(4000)
SELECT @db=REPLACE(db_name(), '''', '''''')

SET @cmd = N'ALTER DATABASE [' + @db + '] SET quoted_identifier on' EXEC dbo.sp_executesql @cmd
SET @cmd = N'ALTER DATABASE [' + @db + '] SET concat_null_yields_null on' EXEC dbo.sp_executesql @cmd
SET @cmd = N'ALTER DATABASE [' + @db + '] SET ansi_null_default on' EXEC dbo.sp_executesql @cmd
SET @cmd = N'ALTER DATABASE [' + @db + '] SET ansi_nulls on' EXEC dbo.sp_executesql @cmd
SET @cmd = N'ALTER DATABASE [' + @db + '] SET ansi_padding on' EXEC dbo.sp_executesql @cmd
SET @cmd = N'ALTER DATABASE [' + @db + '] SET ansi_warnings on' EXEC dbo.sp_executesql @cmd
SET @cmd = N'ALTER DATABASE [' + @db + '] SET arithabort on' EXEC dbo.sp_executesql @cmd
SET @cmd = N'ALTER DATABASE [' + @db + '] SET numeric_roundabort off' EXEC dbo.sp_executesql @cmd

-- Database compatibility must be set to at least SQL 2005
IF EXISTS(SELECT * FROM master.dbo.sysdatabases WHERE [name]=@db AND cmptlevel < 90)
BEGIN
	IF CAST(SERVERPROPERTY('productversion') AS varchar(50)) LIKE '[1-9][0-9]%'
	BEGIN
		-- Raise the compatibility level. Only supported in SQL 2008+
		SET @cmd = N'ALTER DATABASE [' + @db + '] SET COMPATIBILITY_LEVEL=90'
		EXEC dbo.sp_executesql @cmd
	END
	ELSE
	BEGIN
		-- sp_dbcmptlevel cannot be executed from a script so the user will have to take further action
		SET @cmd = N'The compatibility level of the ' + @db + ' database must be raised to at least 90. Log in as an admin and click Company > Execute SQL. Then execute the command EXEC sp_dbcmptlevel [' + @db + N'],90'
		RAISERROR (@cmd,16,1)
	END
END
GO
IF OBJECT_ID('dbo.spExecuteSQLBigForSQL2000') IS NOT NULL DROP PROC dbo.spExecuteSQLBigForSQL2000
GO
-- Hack to get around SQL Server 2000 sp_executesql 4000 nvarchar limit
-- In 2005+ can just use nvarchar(MAX)
CREATE PROC dbo.spExecuteSQLBigForSQL2000 WITH EXEC AS 'dbo'
AS
IF CAST(SERVERPROPERTY('productversion') AS varchar(50)) NOT LIKE '[0-8].%'
BEGIN
	EXEC sp_executesql N'DECLARE @sql nvarchar(MAX) SELECT @sql = [SQL] FROM #BigSQLStatement EXEC sp_executesql @sql'
END
ELSE
BEGIN
	DECLARE @t1 nvarchar(4000), @t2 nvarchar(4000), @t3 nvarchar(4000), @t4 nvarchar(4000), @t5 nvarchar(4000), @t6 nvarchar(4000), @t7 nvarchar(4000), @t8 nvarchar(4000), @t9 nvarchar(4000), @t10 nvarchar(4000)
	DECLARE @t11 nvarchar(4000), @t12 nvarchar(4000), @t13 nvarchar(4000), @t14 nvarchar(4000), @t15 nvarchar(4000), @t16 nvarchar(4000), @t17 nvarchar(4000), @t18 nvarchar(4000), @t19 nvarchar(4000), @t20 nvarchar(4000)

	SELECT @t1 = REPLACE(SUBSTRING([SQL],1,3000), '''', '''''') FROM #BigSQLStatement
	SELECT @t2 = REPLACE(SUBSTRING([SQL],3001,3000), '''', '''''') FROM #BigSQLStatement
	SELECT @t3 = REPLACE(SUBSTRING([SQL],6001,3000), '''', '''''') FROM #BigSQLStatement
	SELECT @t4 = REPLACE(SUBSTRING([SQL],9001,3000), '''', '''''') FROM #BigSQLStatement
	SELECT @t5 = REPLACE(SUBSTRING([SQL],12001,3000), '''', '''''') FROM #BigSQLStatement
	SELECT @t6 = REPLACE(SUBSTRING([SQL],15001,3000), '''', '''''') FROM #BigSQLStatement
	SELECT @t7 = REPLACE(SUBSTRING([SQL],18001,3000), '''', '''''') FROM #BigSQLStatement
	SELECT @t8 = REPLACE(SUBSTRING([SQL],21001,3000), '''', '''''') FROM #BigSQLStatement
	SELECT @t9 = REPLACE(SUBSTRING([SQL],24001,3000), '''', '''''') FROM #BigSQLStatement
	SELECT @t10 = REPLACE(SUBSTRING([SQL],27001,3000), '''', '''''') FROM #BigSQLStatement
	SELECT @t11 = REPLACE(SUBSTRING([SQL],30001,3000), '''', '''''') FROM #BigSQLStatement
	SELECT @t12 = REPLACE(SUBSTRING([SQL],33001,3000), '''', '''''') FROM #BigSQLStatement
	SELECT @t13 = REPLACE(SUBSTRING([SQL],36001,3000), '''', '''''') FROM #BigSQLStatement
	SELECT @t14 = REPLACE(SUBSTRING([SQL],39001,3000), '''', '''''') FROM #BigSQLStatement
	SELECT @t15 = REPLACE(SUBSTRING([SQL],42001,3000), '''', '''''') FROM #BigSQLStatement
	SELECT @t16 = REPLACE(SUBSTRING([SQL],45001,3000), '''', '''''') FROM #BigSQLStatement
	SELECT @t17 = REPLACE(SUBSTRING([SQL],48001,3000), '''', '''''') FROM #BigSQLStatement
	SELECT @t18 = REPLACE(SUBSTRING([SQL],51001,3000), '''', '''''') FROM #BigSQLStatement
	SELECT @t19 = REPLACE(SUBSTRING([SQL],54001,3000), '''', '''''') FROM #BigSQLStatement
	SELECT @t20 = REPLACE(SUBSTRING([SQL],57001,3000), '''', '''''') FROM #BigSQLStatement

	-- Since [SQL] field is ntext, it uses 2 bytes per char -- max DATALENGTH = 60000 * 2
	IF EXISTS(SELECT * FROM #BigSQLStatement WHERE DATALENGTH([SQL]) > 120000) RAISERROR('SQL statement for SQL Server 2000 sp_executesql command contained more than 60000 characters. Upgrade your server to SQL Server 2005 or newer, or contact Apex support for help.',16,1)
	ELSE exec (N'sp_executesql N''' + @t1 + @t2 + @t3 + @t4 + @t5 + @t6 + @t7 + @t8 + @t9 + @t10 + @t11 + @t12 + @t13 + @t14 + @t15 + @t16 + @t17 + @t18 + @t19 + @t20 + N'''')
END
GO
-- Recompiles all trigges and stored procs where ansi nulls are set to off or quoted identifiers are set to off
DECLARE @index int, @id int, @sp sysname, @t nvarchar(4000), @i int, @prefix nvarchar(4000), @colid int

DECLARE p_cursor CURSOR LOCAL FORWARD_ONLY STATIC FOR 
SELECT [id] FROM sysobjects WHERE type='P' AND OBJECTPROPERTY([id], 'IsEncrypted' ) = 0 AND ( (OBJECTPROPERTY([id], 'ExecIsAnsiNullsOn' ) = 0 OR OBJECTPROPERTY([id], 'ExecIsQuotedIdentOn' ) = 0))
AND [id] <> OBJECT_ID(N'dbo.spExecuteSQLBigForSQL2000')

CREATE TABLE #BigSQLStatement([SQL] ntext COLLATE SQL_Latin1_General_CP1_CI_AS,[SQL2] ntext COLLATE SQL_Latin1_General_CP1_CI_AS)


OPEN p_cursor
FETCH p_cursor INTO @id
WHILE @@FETCH_STATUS=0
BEGIN
	DELETE #BigSQLStatement

	DECLARE t_cursor CURSOR LOCAL FORWARD_ONLY STATIC FOR 
	SELECT [text],colid FROM syscomments WHERE [id] = @id ORDER BY colid

	
	OPEN t_cursor
	FETCH t_cursor INTO @t, @colid

	WHILE @@FETCH_STATUS=0
	BEGIN
		IF @colid=1
		BEGIN
			SET @t = REPLACE(LTRIM(@t), '[dbo]', 'dbo')
			
			SELECT @index = PATINDEX('%PROC%',@t) + 4
			
			SELECT @i = PATINDEX('%CREATE PROC%', @t)
			IF @i > 0 SET @t = SUBSTRING(@t,@i,4000)


			SET @prefix = REPLACE(SUBSTRING(@t,1,@index),'CREATE PROC','ALTER PROC')
			SET @t = @prefix + SUBSTRING(@t,@index+1,4000)

			SET @prefix = REPLACE(SUBSTRING(@t,1,@index),'CREATE  PROC','ALTER PROC')
			SET @t = @prefix + SUBSTRING(@t,@index+1,4000)

			SET @prefix = REPLACE(SUBSTRING(@t,1,@index),'CREATE   PROC','ALTER PROC')
			SET @t = @prefix + SUBSTRING(@t,@index+1,4000)

			SET @prefix = REPLACE(SUBSTRING(@t,1,@index),'CREATE    PROC','ALTER PROC')
			SET @t = @prefix + SUBSTRING(@t,@index+1,4000)

			SET @prefix = REPLACE(SUBSTRING(@t,1,@index),'CREATE     PROC','ALTER PROC')
			SET @t = @prefix + SUBSTRING(@t,@index+1,4000)

			SET @prefix = REPLACE(SUBSTRING(@t,1,@index),'CREATE      PROC','ALTER PROC')
			SET @t = @prefix + SUBSTRING(@t,@index+1,4000)
		
			INSERT #BigSQLStatement([SQL]) VALUES (@t)
		END
		ELSE
		BEGIN
			DECLARE @sql_ptr binary(16)
			SELECT @sql_ptr = TEXTPTR([SQL]) FROM #BigSQLStatement
			UPDATETEXT #BigSQLStatement.[SQL] @sql_ptr NULL 0 @t
		END

		FETCH t_cursor INTO @t, @colid
	END

	CLOSE t_cursor
	DEALLOCATE t_cursor

	EXEC dbo.spExecuteSQLBigForSQL2000

	FETCH p_cursor INTO @id
END


CLOSE p_cursor
DEALLOCATE p_cursor

DROP TABLE #BigSQLStatement
GO
IF OBJECT_ID('dbo.spAdminDropDefault') IS NOT NULL DROP PROC dbo.spAdminDropDefault
GO
CREATE PROC dbo.spAdminDropDefault @table sysname, @column sysname AS
DECLARE @sql nvarchar(4000)
SELECT TOP 1 @sql = OBJECT_NAME(O.id) from sysconstraints D
INNER JOIN syscolumns COL ON D.id=object_id(@table) AND COL.colid = D.colid AND COL.[name] = @column
INNER JOIN sysobjects O ON D.constid = O.id AND O.Type = 'D'
SELECT @sql = 'ALTER TABLE ' + @table + ' DROP CONSTRAINT ' + @sql
EXEC sp_executesql @sql
GO
-- Dirty column should have been a bit, but was originally created as an int
IF EXISTS(SELECT * FROM syscolumns WHERE [id]=OBJECT_id('dbo.CustomField') AND [name]='Dirty' AND type=56)
BEGIN
BEGIN TRAN
	EXEC dbo.spAdminDropDefault 'dbo.CustomField', 'Dirty'
	DECLARE @batch_id int, @sql nvarchar(4000)
	SELECT @batch_id=RAND() * 2147483647
	SET @sql =  N'INSERT TempX(BatchID, [ID], X) SELECT ' + CAST(@batch_id AS nvarchar(20)) + ', FieldID, Dirty FROM dbo.CustomField'
	EXEC sp_executesql @sql
	EXEC dbo.spAdminDropDefault 'dbo.CustomField', 'Dirty'
	EXEC sp_executesql N'ALTER TABLE dbo.CustomField DROP COLUMN Dirty'
	EXEC sp_executesql N'ALTER TABLE dbo.CustomField ADD Dirty bit NOT NULL DEFAULT(0)'
	SET @sql = N'UPDATE CF SET [Dirty] = X.X FROM dbo.CustomField CF INNER JOIN dbo.TempX X ON X.BatchID=' + CAST(@batch_id AS nvarchar(20)) + ' AND CF.FieldID=X.[ID]'
	EXEC sp_executesql @sql
COMMIT TRAN
END
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [id]=OBJECT_id('dbo.CustomField') AND [name]='Dirty')
ALTER TABLE dbo.CustomField ADD Dirty bit NOT NULL DEFAULT(0)
GO
IF OBJECT_ID('dbo.spLedgerSelect') IS NOT NULL DROP PROC dbo.spLedgerSelect
IF OBJECT_ID('spLedgerSelect') IS NOT NULL DROP PROC spLedgerSelect
IF OBJECT_ID('dbo.spEmployeeTimeUpdate') IS NOT NULL DROP PROC dbo.spEmployeeTimeUpdate
IF OBJECT_ID('spPermissionUpdateObjectStoredProcsForUID') IS NOT NULL DROP PROC spPermissionUpdateObjectStoredProcsForUID
IF OBJECT_ID('dbo.spPermissionUpdateObjectStoredProcsForUID') IS NOT NULL DROP PROC dbo.spPermissionUpdateObjectStoredProcsForUID
IF OBJECT_ID('dbo.spPermissionListUsersOnContainer') IS NOT NULL DROP PROC dbo.spPermissionListUsersOnContainer
IF OBJECT_ID('dbo.spPermissionListUsersOnPerson') IS NOT NULL DROP PROC dbo.spPermissionListUsersOnPerson
IF OBJECT_ID('dbo.vwEmployeeTardy') IS NOT NULL DROP VIEW dbo.vwEmployeeTardy
IF OBJECT_ID('vwEmployeeTardy') IS NOT NULL DROP VIEW vwEmployeeTardy
IF OBJECT_id('dbo.spEmployeeTimeInsert') IS NOT NULL DROP PROC dbo.spEmployeeTimeInsert
GO
/* IF IS_SRVROLEMEMBER('sysadmin')=1 AND
EXISTS(SELECT * FROM master..sysdatabases WHERE [name]=DB_NAME() AND SUSER_SNAME(sid) IS NULL) AND -- Current db has no owner
EXISTS(SELECT * FROM sysusers WHERE [uid]=1 AND issqluser = 1 and (sid is not null and sid <> 0x0) AND -- dbo user is defined
suser_sname(sid) is not null)  EXEC dbo.sp_changedbowner 'sa' */

DROP INDEX dbo.EmployeeLeaveUsedItem.IX_EmployeeLeaveUsedItem_DuplicateDay
GO
CREATE NONCLUSTERED INDEX IX_EmployeeLeaveUsedItem_DuplicateDay ON dbo.EmployeeLeaveUsedItem 
(
	[LeaveID] ASC,
	[TypeID] ASC,
	[Day past 1900] ASC
)WITH FILLFACTOR = 90 ON [PRIMARY]
GO
-- Checks LeaveRate table to insure each type/plan/period is unique
CREATE TABLE #BADRATES(RateID int)
DECLARE @r int
SET @r=1

WHILE @r > 0
BEGIN
	INSERT #BADRATES
	SELECT MIN(P.RateID) FROM LeaveRate P 
	INNER JOIN LeaveRate P2 ON P.RateID <> P2.RateID AND P.TypeID=P2.TypeID AND P.PlanID=P2.PlanID AND ((P2.[Start Month] BETWEEN P.[Start Month] AND P.[Stop Month]) OR (P2.[Stop Month] BETWEEN P.[Start Month] And P.[Stop Month]))
	LEFT JOIN #BADRATES ON (P.RateID = #BADRATES.RateID OR P2.RateID = #BADRATES.RateID) WHERE #BADRATES.RateID IS NULL
	GROUP BY P.PlanID, P.TypeID

	SET @r=@@ROWCOUNT
END

IF EXISTS(SELECT * FROM #BADRATES)
BEGIN
	IF OBJECT_ID('dbo._LeaveRateBad') IS NOT NULL DROP TABLE _LeaveRateBad

	BEGIN TRAN

	SELECT R.* INTO dbo._LeaveRateBad FROM LeaveRate R INNER JOIN #BADRATES B ON R.RateID=B.RateID
	DELETE LeaveRate WHERE RateID IN (SELECT RateID FROM #BADRATES)

	COMMIT TRAN
END

IF NOT EXISTS(SELECT * FROM Error WHERE ErrorID=50056)
INSERT Error(ErrorID, Error) SELECT 50056, 'The effective dates for this plan/type intersect the effective dates for a duplicate plan/type'

DELETE EmployeeLeaveUnused WHERE TypeID IN
(
	SELECT DISTINCT TypeID FROM LeaveRate WHERE PeriodID IN (2049, 38914)
)

/* Deletes unused leave calculations for rolling accrual */
DELETE U FROM dbo.EmployeeLeaveUnused U
INNER JOIN (
	SELECT DISTINCT TypeID,EmployeeID FROM dbo.EmployeeLeavePlan EP
	INNER JOIN dbo.LeaveRate R ON EP.PlanID=R.PlanID AND R.PeriodID IN (2049, 38914)
) EPR ON U.TypeID=EPR.TypeID AND U.EmployeeID=EPR.EmployeeID

DROP TABLE #BADRATES
GO
-- Views must be dropped and recreated because of schema binding
IF OBJECT_ID('dbo.vwLeaveType') IS NOT NULL DROP VIEW dbo.vwLeaveType
IF OBJECT_ID('dbo.vwEmployeeLeaveUsedItemApproved') IS NOT NULL DROP VIEW dbo.vwEmployeeLeaveUsedItemApproved
IF OBJECT_ID('dbo.vwEmployeeLeaveUsedItem') IS NOT NULL DROP VIEW dbo.vwEmployeeLeaveUsedItem
GO
ALTER TABLE dbo.LeaveType ALTER COLUMN Abbreviation varchar(50) NOT NULL
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name] = 'Bank' AND [ID] = OBJECT_id('dbo.LeaveType'))
BEGIN
	ALTER TABLE dbo.LeaveType ADD Bank bit NOT NULL DEFAULT 1
	EXEC sp_executesql N'UPDATE LeaveType SET Bank = 0 FROM LeaveType V WHERE Type IN (''Paid Leave'', ''Unpaid Leave'')'
END
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name] = 'Holiday Concurrent' AND [id] = OBJECT_id('LeaveType'))
BEGIN
	ALTER TABLE dbo.LeaveType ADD [Holiday Concurrent] bit NOT NULL DEFAULT 0
	EXEC sp_executesql N'UPDATE LeaveType SET [Holiday Concurrent]=1 WHERE Type = ''FMLA'''
END
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name] = 'CBUZ Type Mask' AND [id] = OBJECT_id('LeaveType'))
ALTER TABLE dbo.LeaveType ADD [CBUZ Type Mask] int NOT NULL DEFAULT (0)
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name] = 'Suspend Accrual' AND [id] = OBJECT_id('LeaveType'))
ALTER TABLE dbo.LeaveType ADD [Suspend Accrual] bit NOT NULL DEFAULT (0)
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name] = 'Shift Off Concurrent' AND [id] = OBJECT_id('LeaveType'))
BEGIN
	ALTER TABLE dbo.LeaveType ADD [Shift Off Concurrent] bit NOT NULL DEFAULT 0
END
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name] = 'Comp Eligible' AND [id] = OBJECT_id('dbo.LeaveType'))
ALTER TABLE dbo.LeaveType ADD [Comp Eligible] bit NOT NULL DEFAULT 0
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name] = 'Occurrence' AND [id] = OBJECT_id('dbo.LeaveType'))
ALTER TABLE dbo.LeaveType ADD [Occurrence] bit NOT NULL DEFAULT 0
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name]='FlagsRO' AND [id]=OBJECT_ID('dbo.LeaveType'))
BEGIN
	ALTER TABLE dbo.LeaveType ADD FlagsRO int NOT NULL DEFAULT(0)
	EXEC sp_executesql N'UPDATE LT SET FlagsRO = FlagsRO | 1 FROM dbo.LeaveType LT WHERE EXISTS (
		SELECT * FROM dbo.TimeType TT WHERE TT.CompLeaveTypeID=LT.TypeID
	)'
END
GO
IF OBJECT_id('FK_Constant_CarryoverTargetLeaveTypeID') IS NULL
ALTER TABLE dbo.Constant ADD CONSTRAINT [FK_Constant_CarryoverTargetLeaveTypeID] FOREIGN KEY 
(
	[CarryoverTargetLeaveTypeID]
) REFERENCES dbo.[LeaveType] (
	[TypeID]
)
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name] = 'CarryoverTargetLeaveTypeID' AND [id] = OBJECT_id('dbo.LeaveLimit'))
BEGIN
	ALTER TABLE dbo.LeaveLimit ADD CarryoverTargetLeaveTypeID int NULL
	--EXEC dbo.sp_executesql N'UPDATE T SET CarryoverTargetLeaveTypeID = C.CarryoverTargetLeaveTypeID FROM dbo.LeaveLimit T INNER JOIN dbo.Constant C ON C.CarryoverSourceLeaveLimitID = T.TypeID'
END
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name] = 'CarryoverTargetLeaveTypeID' AND [id] = OBJECT_id('dbo.LeaveType'))
BEGIN
	ALTER TABLE dbo.LeaveType ADD CarryoverTargetLeaveTypeID int NULL
	EXEC dbo.sp_executesql N'UPDATE T SET CarryoverTargetLeaveTypeID = C.CarryoverTargetLeaveTypeID FROM dbo.LeaveType T INNER JOIN dbo.Constant C ON C.CarryoverSourceLeaveTypeID = T.TypeID'
END
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name] = 'Carryover Limit Seconds' AND [id] = OBJECT_id('dbo.LeaveType'))
ALTER TABLE dbo.LeaveType ADD [Carryover Limit Seconds] int NOT NULL DEFAULT(2147483647)
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name] = 'Carryover Offset Days' AND [id] = OBJECT_id('dbo.Constant'))
ALTER TABLE dbo.Constant ADD [Carryover Offset Days] int NOT NULL DEFAULT(0)
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name] = 'Carryover Offset Days' AND [id] = OBJECT_id('dbo.LeaveType'))
BEGIN
	ALTER TABLE dbo.LeaveType ADD [Carryover Offset Days] int NOT NULL DEFAULT(0)
	EXEC dbo.sp_executesql N'UPDATE T SET [Carryover Offset Days] = C.[Carryover Offset Days] FROM dbo.LeaveType T INNER JOIN dbo.Constant C ON C.CarryoverSourceLeaveTypeID = T.TypeID'
END
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [id]=OBJECT_ID('dbo.Constant') AND [name]='Carryover Multiplier')
ALTER TABLE dbo.Constant ADD [Carryover Multiplier] numeric(9,8) NOT NULL DEFAULT(1.0)
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name] = 'Carryover Multiplier' AND [id] = OBJECT_id('dbo.LeaveType'))
BEGIN
	ALTER TABLE dbo.LeaveType ADD [Carryover Multiplier] numeric(9,8) NOT NULL DEFAULT(1.0)
	EXEC dbo.sp_executesql N'UPDATE T SET [Carryover Multiplier] = C.[Carryover Multiplier] FROM dbo.LeaveType T INNER JOIN dbo.Constant C ON C.CarryoverSourceLeaveTypeID = T.TypeID'
END
GO
IF OBJECT_id('FK_LeaveType_CarryoverTargetLeaveTypeID') IS NULL
ALTER TABLE dbo.LeaveType ADD CONSTRAINT FK_LeaveType_CarryoverTargetLeaveTypeID FOREIGN KEY 
(
	CarryoverTargetLeaveTypeID
) REFERENCES dbo.[LeaveType] (
	TypeID
)
GO
CREATE VIEW dbo.vwLeaveType WITH SCHEMABINDING AS 
SELECT TypeID, [Type], Paid, Advanced, [Order], InitialPeriodID, [Initial Seconds], [OT Eligible], Abbreviation, 
Flags = Paid + Advanced * 2 + [OT Eligible] * 8 + Bank * 16 + [Holiday Concurrent] * 32 + [Suspend Accrual] * 64 + [Comp Eligible] * 128 + Occurrence * 256, 
Bank, [Holiday Concurrent], [Suspend Accrual],
FlagsRO, Comp = CAST(FlagsRO & 1 AS bit), [Comp Eligible], Occurrence,
CarryoverTargetLeaveTypeID, [Carryover Limit Seconds], [Carryover Offset Days], [Carryover Multiplier], [CBUZ Type Mask]
FROM dbo.LeaveType
GO
/* SCHEMABINDING DROPS BEGIN *********************************************************** */
IF OBJECT_id('dbo.HolidayInsertUpdate') IS NOT NULL DROP TRIGGER dbo.HolidayInsertUpdate 
IF OBJECT_ID('dbo.CustomFieldItemMarkFieldDirtyOnChange') IS NOT NULL DROP TRIGGER dbo.CustomFieldItemMarkFieldDirtyOnChange
IF OBJECT_ID('dbo.EmployeeCreateBlankEmployeeBenefitOnInsert') IS NOT NULL DROP TRIGGER dbo.EmployeeCreateBlankEmployeeBenefitOnInsert
IF OBJECT_ID('dbo.EmployeeTimeZKQImport') IS NOT NULL DROP TRIGGER dbo.EmployeeTimeZKQImport
IF OBJECT_ID('dbo.LeaveRateCheckPeriod') IS NOT NULL DROP TRIGGER dbo.LeaveRateCheckPeriod
IF OBJECT_ID('dbo.CheckPeriodOnEmployeeCompensation') IS NOT NULL DROP TRIGGER dbo.CheckPeriodOnEmployeeCompensation
IF OBJECT_ID('dbo.EmployeeBenefitRecreateFlatViewOnInsertDelete') IS NOT NULL DROP TRIGGER dbo.EmployeeBenefitRecreateFlatViewOnInsertDelete
IF OBJECT_ID('dbo.CustomFieldAddFlatTableColumnOnInsert') IS NOT NULL DROP TRIGGER dbo.CustomFieldAddFlatTableColumnOnInsert
IF OBJECT_ID('dbo.CustomFieldDropFlatTableColumnOnDelete') IS NOT NULL DROP TRIGGER dbo.CustomFieldDropFlatTableColumnOnDelete
IF OBJECT_ID('dbo.PersonCustomFieldUpdateFlatTableOnUpdate') IS NOT NULL DROP TRIGGER dbo.PersonCustomFieldUpdateFlatTableOnUpdate
IF OBJECT_id('dbo.EmployeeTimeAcroprintQImport') IS NOT NULL DROP TRIGGER dbo.EmployeeTimeAcroprintQImport
IF OBJECT_id('dbo.EmployeeTimeLogInsert') IS NOT NULL DROP TRIGGER dbo.EmployeeTimeLogInsert
IF OBJECT_id('dbo.EmployeeLeaveEarnedLogInsert') IS NOT NULL DROP TRIGGER dbo.EmployeeLeaveEarnedLogInsert
IF OBJECT_id('dbo.EmployeeLeaveEarnedLogDelete') IS NOT NULL DROP TRIGGER dbo.EmployeeLeaveEarnedLogDelete
IF OBJECT_id('dbo.EmployeeLeaveEarnedLogUpdate') IS NOT NULL DROP TRIGGER dbo.EmployeeLeaveEarnedLogUpdate
IF OBJECT_id('dbo.PersonLogInsert') IS NOT NULL DROP TRIGGER dbo.PersonLogInsert
IF OBJECT_id('dbo.PersonLogDelete') IS NOT NULL DROP TRIGGER dbo.PersonLogDelete
IF OBJECT_id('dbo.PersonLogUpdate') IS NOT NULL DROP TRIGGER dbo.PersonLogUpdate
IF OBJECT_id('dbo.PersonXLogUpdate') IS NOT NULL DROP TRIGGER dbo.PersonXLogUpdate
IF OBJECT_id('dbo.EmployeeTimeLogDelete') IS NOT NULL DROP TRIGGER dbo.EmployeeTimeLogDelete
IF OBJECT_id('dbo.EmployeeTimeLogUpdate') IS NOT NULL DROP TRIGGER dbo.EmployeeTimeLogUpdate

IF OBJECT_ID('dbo.EmployeeCompensationLogUpdate') IS NOT NULL DROP TRIGGER dbo.EmployeeCompensationLogUpdate
IF OBJECT_ID('dbo.EmployeeCompensationLogInsert') IS NOT NULL DROP TRIGGER dbo.EmployeeCompensationLogInsert
IF OBJECT_ID('dbo.EmployeeCompensationLogDelete') IS NOT NULL DROP TRIGGER dbo.EmployeeCompensationLogDelete
IF OBJECT_ID('dbo.PersonCustomFieldUpdateFlatTableOnUpdate') IS NOT NULL DROP TRIGGER dbo.PersonCustomFieldUpdateFlatTableOnUpdate
IF OBJECT_ID('dbo.PersonAddFlatTableColumnOnInsert') IS NOT NULL DROP TRIGGER dbo.PersonAddFlatTableColumnOnInsert

-- Used by some legacy custom task stored procs
--IF OBJECT_id('dbo.vwReminderTypes') IS NOT NULL DROP VIEW dbo.vwReminderTypes
IF OBJECT_id('dbo.vwPayment') IS NOT NULL DROP VIEW dbo.vwPayment
IF OBJECT_ID('dbo.vwEmployeeBenefitSecure') IS NOT NULL DROP VIEW dbo.vwEmployeeBenefitSecure
IF OBJECT_id('dbo.vwInvoice') IS NOT NULL DROP VIEW dbo.vwInvoice
IF OBJECT_id('dbo.vwInvoiceDetail') IS NOT NULL DROP VIEW dbo.vwInvoiceDetail
IF OBJECT_id('dbo.vwPersonCustomField2') IS NOT NULL DROP VIEW dbo.vwPersonCustomField2
IF OBJECT_ID('dbo.vwEmployeeBenefit') IS NOT NULL DROP VIEW dbo.vwEmployeeBenefit
IF OBJECT_id('dbo.vwMailMerge') IS NOT NULL DROP VIEW dbo.vwMailMerge

IF OBJECT_id('dbo.vwEmployeeBenefitFlat') IS NOT NULL DROP VIEW dbo.vwEmployeeBenefitFlat
IF OBJECT_id('dbo.vwEmployeeBenefitFlatForMerge') IS NOT NULL DROP VIEW dbo.vwEmployeeBenefitFlatForMerge
IF OBJECT_id('dbo.vwEmployeeTermination') IS NOT NULL DROP VIEW dbo.vwEmployeeTermination
IF OBJECT_id('dbo.vwEmployeeBINV') IS NOT NULL DROP VIEW dbo.vwEmployeeBINV
IF OBJECT_id('dbo.vwEmployeeBPMT') IS NOT NULL DROP VIEW dbo.vwEmployeeBPMT
IF OBJECT_id('dbo.vwPersonHome') IS NOT NULL DROP VIEW dbo.vwPersonHome
IF OBJECT_id('dbo.vwPersonHome') IS NULL EXEC sp_executesql N'CREATE VIEW dbo.vwPersonHome AS SELECT PersonID FROM Person'
IF OBJECT_id('dbo.vwPersonWork') IS NOT NULL DROP VIEW dbo.vwPersonWork
IF OBJECT_id('dbo.vwPersonWork') IS NULL EXEC sp_executesql N'CREATE VIEW dbo.vwPersonWork AS SELECT PersonID FROM Person'
IF OBJECT_id('dbo.vwEmployeeReview') IS NOT NULL DROP VIEW dbo.vwEmployeeReview
IF OBJECT_id('dbo.vwEmployeePayStep') IS NOT NULL DROP VIEW dbo.vwEmployeePayStep
IF OBJECT_ID('dbo.vwPersonXLanguages') IS NOT NULL DROP VIEW dbo.vwPersonXLanguages
IF OBJECT_ID('dbo.vwEmployeeSuccessorNames') IS NOT NULL DROP VIEW dbo.vwEmployeeSuccessorNames
IF OBJECT_ID('dbo.vwEmployeeSucceedsNames') IS NOT NULL DROP VIEW dbo.vwEmployeeSucceedsNames
IF OBJECT_id('dbo.vwPersonCalculated') IS NOT NULL DROP VIEW dbo.vwPersonCalculated
IF OBJECT_id('dbo.vwPaymentRefund') IS NOT NULL DROP VIEW dbo.vwPaymentRefund
IF OBJECT_ID('dbo.vwInvoiceFlat') IS NOT NULL DROP VIEW dbo.vwInvoiceFlat

-- Obsolete objects
IF OBJECT_ID('dbo.EmployeeAddEmployeeBenefitsOnInsert') IS NOT NULL DROP TRIGGER dbo.EmployeeAddEmployeeBenefitsOnInsert
IF OBJECT_ID('dbo.vwPersonCustomField3') IS NOT NULL DROP VIEW dbo.vwPersonCustomField3
IF OBJECT_ID('dbo.vwPersonCustomFieldSecure') IS NOT NULL DROP VIEW dbo.vwPersonCustomFieldSecure
IF OBJECT_ID('dbo.vwEmployeeBenefitSecureFlat') IS NOT NULL DROP VIEW dbo.vwEmployeeBenefitSecureFlat
IF OBJECT_id('dbo.vwEmployeeBINVSecure') IS NOT NULL DROP VIEW dbo.vwEmployeeBINVSecure
IF OBJECT_id('dbo.vwEmployeeBPMTSecure') IS NOT NULL DROP VIEW dbo.vwEmployeeBPMTSecure
IF OBJECT_ID('dbo.vwEmployeeFlatSecure') IS NOT NULL DROP VIEW dbo.vwEmployeeFlatSecure
IF OBJECT_ID('dbo.vwPersonCustomFieldSecureFlat') IS NOT NULL DROP VIEW dbo.vwPersonCustomFieldSecureFlat
IF OBJECT_ID('dbo.vwPersonHomeSecure') IS NOT NULL DROP VIEW dbo.vwPersonHomeSecure
IF OBJECT_ID('dbo.vwPersonWorkSecure') IS NOT NULL DROP VIEW dbo.vwPersonWorkSecure
IF OBJECT_ID('dbo.vwEmployeeOrgSecure') IS NOT NULL DROP VIEW dbo.vwEmployeeOrgSecure
IF OBJECT_id('dbo.vwPersonXSecure') IS NOT NULL DROP VIEW dbo.vwPersonXSecure
IF OBJECT_id('dbo.vwEmployeeCompensationSecure') IS NOT NULL DROP VIEW dbo.vwEmployeeCompensationSecure
IF OBJECT_ID('dbo.vwEmployeeReviewSecure') IS NOT NULL DROP VIEW dbo.vwEmployeeReviewSecure
IF OBJECT_ID('dbo.vwEmployeePayStepSecure') IS NOT NULL DROP VIEW dbo.vwEmployeePayStepSecure
IF OBJECT_ID('dbo.vwEmployeeAccountSecure') IS NOT NULL DROP VIEW dbo.vwEmployeeAccountSecure
IF OBJECT_ID('dbo.vwEmployeeTerminationSecure') IS NOT NULL DROP VIEW dbo.vwEmployeeTerminationSecure
IF OBJECT_ID('dbo.vwEmployeeLastCompensationSecure') IS NOT NULL DROP VIEW dbo.vwEmployeeLastCompensationSecure
IF OBJECT_ID('dbo.vwPersonXLanguagesSecure') IS NOT NULL DROP VIEW dbo.vwPersonXLanguagesSecure
IF OBJECT_ID('dbo.vwEmployeeUpdateInOutStatusSecure') IS NOT NULL DROP VIEW dbo.vwEmployeeUpdateInOutStatusSecure
IF OBJECT_ID('dbo.vwEmployeeSuccessorNamesSecure') IS NOT NULL DROP VIEW dbo.vwEmployeeSuccessorNamesSecure
IF OBJECT_ID('dbo.vwEmployeeSucceedsNamesSecure') IS NOT NULL DROP VIEW dbo.vwEmployeeSucceedsNamesSecure
IF OBJECT_ID('dbo.vwEmployeeLeaveUsedSecure') IS NOT NULL DROP VIEW dbo.vwEmployeeLeaveUsedSecure
IF OBJECT_ID('dbo.vwPersonTabularFlat') IS NOT NULL DROP VIEW dbo.vwPersonTabularFlat
IF OBJECT_ID('dbo.vwInvoiceSecure') IS NOT NULL DROP VIEW dbo.vwInvoiceSecure
IF OBJECT_ID('dbo.vwPaymentSecure') IS NOT NULL DROP VIEW dbo.vwPaymentSecure
IF OBJECT_ID('dbo.vwPersonCustomField') IS NOT NULL DROP VIEW dbo.vwPersonCustomField
IF OBJECT_id('dbo.vwInvoice2') IS NOT NULL DROP VIEW dbo.vwInvoice2
IF OBJECT_ID('dbo.vwEmployeeUpdateInOutStatus') IS NOT NULL DROP VIEW dbo.vwEmployeeUpdateInOutStatus

IF OBJECT_ID('dbo.fnGetEnrolled') IS NOT NULL DROP FUNCTION dbo.fnGetEnrolled
IF OBJECT_ID('dbo.fnGetEnrolledDayPast1900') IS NOT NULL DROP FUNCTION dbo.fnGetEnrolledDayPast1900
IF OBJECT_ID('dbo.fnGetExtendedHomeAddress') IS NOT NULL DROP FUNCTION dbo.fnGetExtendedHomeAddress
IF OBJECT_ID('dbo.fnGetInitials') IS NOT NULL DROP FUNCTION dbo.fnGetInitials
IF OBJECT_ID('dbo.fnGetFormalName') IS NOT NULL DROP FUNCTION dbo.fnGetFormalName
IF OBJECT_ID('dbo.fnGetSignature') IS NOT NULL DROP FUNCTION dbo.fnGetSignature
IF OBJECT_id('dbo.fnGetEnrollment') IS NOT NULL DROP FUNCTION dbo.fnGetEnrollment
IF OBJECT_id('dbo.fnGetEBStatusCode') IS NOT NULL DROP FUNCTION dbo.fnGetEBStatusCode
IF OBJECT_ID('dbo.fnGetListAs') IS NOT NULL DROP FUNCTION dbo.fnGetListAs
IF OBJECT_ID('dbo.fnGetFullName') IS NOT NULL DROP FUNCTION dbo.fnGetFullName
IF OBJECT_ID('dbo.fnGetInvoiceStatus') IS NOT NULL DROP FUNCTION dbo.fnGetInvoiceStatus
IF OBJECT_ID('dbo.fnGetInvoiceAging') IS NOT NULL DROP FUNCTION dbo.fnGetInvoiceAging
IF OBJECT_ID('dbo.fnGetAmountDueBetween') IS NOT NULL DROP FUNCTION dbo.fnGetAmountDueBetween
IF OBJECT_ID('dbo.GetDateFromDaysPast1900') IS NOT NULL DROP FUNCTION dbo.GetDateFromDaysPast1900
IF OBJECT_id('dbo.fnGetDateStringFromDaysPast1900') IS NOT NULL DROP FUNCTION dbo.fnGetDateStringFromDaysPast1900
IF OBJECT_id('dbo.fnDoesVariantIntMaskContainBit') IS NOT NULL DROP FUNCTION dbo.fnDoesVariantIntMaskContainBit
IF OBJECT_ID('dbo.fnGetFullName') IS NOT NULL DROP FUNCTION dbo.fnGetFullName
IF OBJECT_ID('dbo.fnGetEnrollmentID') IS NOT NULL DROP FUNCTION dbo.fnGetEnrollmentID
/* SCHEMABINDING DROPS END *********************************************************** */
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [ID] = OBJECT_id('dbo.EmployeeLeaveUsed') AND [name] = 'Calendar Comment')
ALTER TABLE dbo.EmployeeLeaveUsed ADD [Calendar Comment] varchar(50) NOT NULL DEFAULT('')
GO
CREATE FUNCTION dbo.GetDateFromDaysPast1900 (@days int) 
RETURNS datetime WITH SCHEMABINDING
AS
BEGIN
	DECLARE @d datetime

	IF @days IS NULL SET @d = NULL
	ELSE IF @days <= -53690 SET @d = CONVERT(datetime, '17530101', 112)
	ELSE IF @days >= 2958463 SET @d = CONVERT(datetime, '99991231', 112)
	ELSE SET @d = DATEADD(dd, @days, 0)

	RETURN @d
END
GO
CREATE VIEW dbo.vwEmployeeLeaveUsedItem WITH SCHEMABINDING AS
SELECT I.ItemID, I.LeaveID, I.TypeID, I.[Day past 1900], I.Seconds, I.[Advanced Type Mask], [Date] = dbo.GetDateFromDaysPast1900([Day past 1900]),
[Extended Type Mask] = I.TypeID | I.[Advanced Type Mask], U.EmployeeID, U.ReasonID, U.Status,
I.[PPE Day past 1900], PPE = dbo.GetDateFromDaysPast1900(I.[PPE Day past 1900]), T.[Type], T.Paid, T.[OT Eligible], T.[Order], T.Abbreviation,
I.[Created Day past 1900], U.[Calendar Comment]
FROM dbo.EmployeeLeaveUsedItem I
INNER JOIN dbo.EmployeeLeaveUsed U ON U.LeaveID=I.LeaveID
INNER JOIN dbo.LeaveType T ON I.TypeID = T.TypeID
GO
IF OBJECT_id('dbo.EmployeeLeaveUsedLink') IS NULL
BEGIN
	CREATE TABLE dbo.EmployeeLeaveUsedLink (
		ItemID int NOT NULL IDENTITY(1,1) PRIMARY KEY,
		LeaveID int NOT NULL,
		TypeID int NOT NULL,
		EmployeeID int NOT NULL
	)

	ALTER TABLE dbo.EmployeeLeaveUsedLink ADD CONSTRAINT FK_EmployeeLeaveUsedLink_LeaveID FOREIGN KEY (LeaveID) REFERENCES dbo.EmployeeLeaveUsed (LeaveID) ON DELETE CASCADE
	ALTER TABLE dbo.EmployeeLeaveUsedLink ADD CONSTRAINT FK_EmployeeLeaveUsedLink_TypeID FOREIGN KEY (TypeID) REFERENCES dbo.LeaveType (TypeID) ON DELETE CASCADE
	ALTER TABLE dbo.EmployeeLeaveUsedLink ADD CONSTRAINT FK_EmployeeLeaveUsedLink_EmployeeID FOREIGN KEY (EmployeeID) REFERENCES dbo.Employee (EmployeeID) ON DELETE CASCADE

	CREATE UNIQUE INDEX IX_EmployeeLeaveUsedLink_LeaveID_EmployeeID_TypeID ON dbo.EmployeeLeaveUsedLink(LeaveID, EmployeeID, TypeID) WITH  FILLFACTOR = 90 ON [PRIMARY]
	CREATE INDEX IX_EmployeeLeaveUsedLink_EmployeeID_TypeID ON dbo.EmployeeLeaveUsedLink(EmployeeID, TypeID) WITH  FILLFACTOR = 90 ON [PRIMARY]
	CREATE INDEX IX_EmployeeLeaveUsedLink_LeaveID ON dbo.EmployeeLeaveUsedLink(LeaveID) WITH  FILLFACTOR = 90 ON [PRIMARY]
	CREATE INDEX IX_EmployeeLeaveUsedLink_EmployeeID ON dbo.EmployeeLeaveUsedLink(EmployeeID) WITH  FILLFACTOR = 90 ON [PRIMARY]
	CREATE INDEX IX_EmployeeLeaveUsedLink_TypeID ON dbo.EmployeeLeaveUsedLink(TypeID) WITH  FILLFACTOR = 90 ON [PRIMARY]
END
GO
CREATE VIEW dbo.vwEmployeeLeaveUsedItemApproved WITH SCHEMABINDING
AS
SELECT I.[Day past 1900], I.Seconds, I.[Date], I.[Extended Type Mask], I.TypeID, I.EmployeeID, I.ReasonID, I.[Calendar Comment] FROM dbo.vwEmployeeLeaveUsedItem I WHERE I.[Status] = 2
UNION ALL
SELECT E.[Day past 1900], -E.Seconds, dbo.GetDateFromDaysPast1900(E.[Day past 1900]), E.TypeID, E.TypeID, E.EmployeeID, NULL, '' FROM dbo.EmployeeLeaveEarned E WHERE E.Seconds < 0 AND E.Auto = 0
UNION ALL
SELECT I.[Day past 1900], I.Seconds,
[Date] = dbo.GetDateFromDaysPast1900(I.[Day past 1900]), 
[Extended Type Mask] = L.TypeID,
L.TypeID, L.EmployeeID, U.ReasonID, U.[Calendar Comment]
FROM dbo.EmployeeLeaveUsedLink L 
INNER JOIN dbo.EmployeeLeaveUsed U ON U.LeaveID = L.LeaveID AND U.[Status] = 2
INNER JOIN dbo.EmployeeLeaveUsedItem I ON U.LeaveID=I.LeaveID AND ((I.TypeID | I.[Advanced Type Mask]) & L.TypeID) > 0
INNER JOIN dbo.Employee EMP ON EMP.EmployeeID = L.EmployeeID
INNER JOIN dbo.LeaveType T ON  L.TypeID = T.TypeID
GO
CREATE FUNCTION dbo.fnGetEnrollmentID(
	@today datetime, @declined int, @expires int, @first_enrolled int, @last_enrolled int, @eligible int, @notified int
)
RETURNS int AS
BEGIN
	RETURN CASE WHEN @declined IS NOT NULL THEN 5
	WHEN @expires IS NOT NULL AND dbo.GetDateFromDaysPast1900(@expires) <= @today THEN 4
	WHEN @last_enrolled IS NOT NULL OR @first_enrolled IS NOT NULL THEN 3
	WHEN @eligible IS NOT NULL THEN 2
	WHEN @notified IS NOT NULL THEN 1
	ELSE 0 END
END
GO
CREATE FUNCTION dbo.fnGetExtendedHomeAddress(@a varchar(50), @a2 varchar(50), @c varchar(50), @s varchar(50), @z varchar(50))
RETURNS varchar(400) WITH SCHEMABINDING
AS
BEGIN
	RETURN CASE WHEN @a='' THEN '' ELSE @a + CHAR(10) END +
	CASE WHEN @a2='' THEN '' ELSE @a2 + CHAR(10) END +
	CASE WHEN @c='' THEN '' ELSE @c + ', ' END +
	CASE WHEN @s='' THEN '' ELSE @s + ' ' END + @z
END
GO
CREATE FUNCTION dbo.fnGetSignature(@suffix varchar(50), @first varchar(50), @middle varchar(50), @last varchar(50), @credentials varchar(50))
RETURNS varchar(400) WITH SCHEMABINDING
AS
BEGIN
	RETURN 
		CASE 
			WHEN @first = '' THEN @last 
			ELSE @first + ' ' + 
				CASE WHEN @middle='' THEN '' ELSE @middle + ' ' END +
				@last + 
				CASE WHEN @suffix = '' THEN '' ELSE ' ' + @suffix END +
				CASE WHEN @credentials = '' THEN '' ELSE ' ' + @credentials END
		END
END
GO
CREATE FUNCTION dbo.fnGetInitials(@first varchar(50), @middle varchar(50), @last varchar(3)) RETURNS varchar(400) WITH SCHEMABINDING
AS BEGIN RETURN UPPER(SUBSTRING(@first, 1, 1) + SUBSTRING(@middle, 1, 1) + SUBSTRING(@last, 1, 1)) END
GO
CREATE FUNCTION dbo.fnGetFormalName(@male bit, @title varchar(50), @last varchar(50)) RETURNS VARCHAR(400) WITH SCHEMABINDING
AS BEGIN RETURN CASE @title WHEN '' THEN CASE @male WHEN 1 THEN 'Mr. ' ELSE 'Ms. ' END ELSE @title + ' ' END + @last END
GO
CREATE FUNCTION dbo.fnGetListAs(@first varchar(50), @middle varchar(50), @last varchar(50), @suffix varchar(50)) RETURNS varchar(400) WITH SCHEMABINDING AS
BEGIN
	RETURN @last +
	CASE WHEN @suffix = '' THEN '' ELSE ' ' + @suffix END +
	CASE WHEN @first = '' THEN '' ELSE ', ' + @first END +
	CASE WHEN @middle = '' THEN '' ELSE ' ' + @middle END
END
GO
CREATE FUNCTION dbo.fnGetFullName(@first varchar(50), @middle varchar(50), @last varchar(50), @suffix varchar(50)) RETURNS varchar(400) WITH SCHEMABINDING AS
BEGIN
	RETURN CASE WHEN @first = '' THEN '' ELSE @first + ' ' END +
	@last +
	CASE WHEN @suffix = '' THEN '' ELSE ' ' + @suffix END
END
GO
GRANT EXEC ON dbo.fnGetFullName TO public
GRANT EXEC ON dbo.fnGetListAs TO public
GRANT EXEC ON dbo.fnGetExtendedHomeAddress TO public
GRANT EXEC ON dbo.fnGetInitials TO public
GRANT EXEC ON dbo.fnGetFormalName TO public
GRANT EXEC ON dbo.fnGetSignature TO public
GO
CREATE VIEW dbo.vwPersonCalculated WITH SCHEMABINDING
AS
SELECT PersonID, [List As] = dbo.fnGetListAs([First Name], [Middle Name], [Last Name], Suffix),
	Initials = dbo.fnGetInitials(P.[First Name], P.[Middle Name], P.[Last Name]),
	[Signature] = dbo.fnGetSignature(P.Suffix, P.[First Name], P.[Middle Name], P.[Last Name], P.Credentials),
	[Full Name] = dbo.fnGetFullName([First Name], [Middle Name], [Last Name], Suffix),
	[Formal Name] = dbo.fnGetFormalName(P.Male, P.[Title], P.[Last Name]),
	[IsEmployee] = CAST(([Role Mask] & 1) AS bit),
	[IsApplicant] = CAST(([Role Mask] & 2) AS bit),
	[IsRecruiter] = CAST(([Role Mask] & 4) AS bit),
	[IsPhysician] = CAST(([Role Mask] & 8) AS bit),
	[IsEmergencyContact] = CAST(([Role Mask] & 16) AS bit),
	P.Credentials,
	P.[First Name],
	P.[Last Name],
	P.[Middle Name],
	P.[Suffix],
	P.[Title],
	P.[Role Mask]
FROM dbo.Person P
GO
CREATE UNIQUE CLUSTERED INDEX IX_vwPersonCalculated_PersonID ON dbo.vwPersonCalculated(PersonID)
GO
-- INVOICE CREATION SECTION Begin
IF OBJECT_id('dbo.InvoiceDetail') IS NOT NULL
BEGIN
	DECLARE @r int
	EXEC sp_executesql N'SELECT @r=COUNT(*) FROM InvoiceDetail', N'@r int out', @r=@r OUT
	IF @r = 0 EXEC sp_executesql N'DROP TABLE dbo.InvoiceDetail'
END
GO
IF OBJECT_id('dbo.InvoiceTemplate') IS NOT NULL
BEGIN
	DECLARE @r int
	EXEC sp_executesql N'SELECT @r=COUNT(*) FROM InvoiceTemplate', N'@r int out', @r=@r OUT
	IF @r = 0
	BEGIN
		IF EXISTS (SELECT * FROM dbo.sysobjects WHERE id = OBJECT_id(N'dbo.[FK_Invoice_InvoiceTemplate]') AND type = 'F')
		ALTER TABLE dbo.Invoice DROP  CONSTRAINT [FK_Invoice_InvoiceTemplate]

		EXEC sp_executesql N'DROP TABLE dbo.InvoiceTemplate'
	END
END
GO
IF OBJECT_id('dbo.InvoiceTemplate') IS NULL
BEGIN
	CREATE TABLE dbo.InvoiceTemplate(
		TemplateID [int] IDENTITY(1,1) NOT NULL PRIMARY KEY,
		Template varchar(50) NOT NULL,
		Note varchar(1000) NOT NULL,
		[Sender Text] varchar(450) NOT NULL,
		[Remit Text] varchar(450) NOT NULL,
		Logo image NULL
	)
END
GO
IF NOT EXISTS(SELECT * FROM InvoiceTemplate)
BEGIN
	INSERT InvoiceTemplate VALUES('Default Invoice', 
	'Payment is due twenty days from the date of this invoice. If payment is not received then benefits will be terminated effective the last day of the month, and you will be responsible for any medical care expenses that you may have received after the termination date.' + CHAR(10)  + CHAR(10) +
	'Please make your check or money order payable to: IHSS Public Authority and be sure to include your invoice number.' + CHAR(10)  + CHAR(10) +
	'If you have any questions then please call one of our Health Benefits Specialists', '', '',
	NULL)

	INSERT InvoiceTemplate VALUES('Statement', 
	'Payment is due twenty days from the date of an invoice. If payment is not received then benefits will be terminated effective the last day of the month, and you will be responsible for any medical care expenses that you may have received after the termination date.' + CHAR(10)  + CHAR(10) +
	'Please make your check or money order payable to: IHSS Public Authority and be sure to include your invoice number.' + CHAR(10)  + CHAR(10) +
	'If you have any questions then please call one of our Health Benefits Specialists', '', '',
	NULL)
END
GO
IF OBJECT_id('dbo.Invoice') IS NOT NULL
BEGIN
	DECLARE @r int
	EXEC sp_executesql N'SELECT @r=COUNT(*) FROM Invoice', N'@r int out', @r=@r OUT
	IF @r = 0
	BEGIN
		IF EXISTS (SELECT * FROM dbo.sysobjects WHERE id = OBJECT_id(N'dbo.[FK_PaymentDetail_Invoice]') AND type = 'F')
		ALTER TABLE dbo.PaymentDetail DROP  CONSTRAINT [FK_PaymentDetail_Invoice]

		IF EXISTS (SELECT * FROM dbo.sysobjects WHERE id = OBJECT_id(N'dbo.[FK_Invoice_GLBatch]') AND type = 'F')
		ALTER TABLE dbo.Invoice DROP  CONSTRAINT [FK_Invoice_GLBatch]

		IF EXISTS (SELECT * FROM dbo.sysobjects WHERE id = OBJECT_id(N'dbo.[FK_Invoice_Template]') AND type = 'F')
		ALTER TABLE dbo.Invoice DROP  CONSTRAINT [FK_Invoice_Template]


		IF EXISTS (SELECT * FROM dbo.sysobjects WHERE id = OBJECT_id(N'dbo.[FK_Note_Invoice]') AND type = 'F')
		ALTER TABLE dbo.Note DROP  CONSTRAINT [FK_Note_Invoice]

		IF EXISTS (SELECT * FROM dbo.sysobjects WHERE id = OBJECT_id(N'dbo.FK_Invoice_InvoiceCredit') AND type = 'F')
		ALTER TABLE dbo.InvoiceCredit DROP  CONSTRAINT FK_Invoice_InvoiceCredit

		EXEC sp_executesql N'DROP TABLE dbo.Invoice'
	END
END
GO
IF OBJECT_id('dbo.PaymentDetail') IS NOT NULL
BEGIN
	DECLARE @r int
	EXEC sp_executesql N'SELECT @r=COUNT(*) FROM PaymentDetail', N'@r int out', @r=@r OUT
	IF @r = 0 EXEC sp_executesql N'DROP TABLE dbo.PaymentDetail'
END
GO
IF OBJECT_id('dbo.Payment') IS NOT NULL
BEGIN
	DECLARE @r int
	EXEC sp_executesql N'SELECT @r=COUNT(*) FROM Payment', N'@r int out', @r=@r OUT
	IF @r = 0
	BEGIN
		IF EXISTS (SELECT * FROM dbo.sysobjects WHERE id = OBJECT_id(N'dbo.FK_Note_Payment') AND type = 'F')
		ALTER TABLE dbo.Note DROP  CONSTRAINT [FK_Note_Payment]

		IF EXISTS (SELECT * FROM dbo.sysobjects WHERE id = OBJECT_id(N'dbo.FK_Payment_PaymentRefund') AND type = 'F')
		ALTER TABLE dbo.PaymentRefund DROP  CONSTRAINT [FK_Payment_PaymentRefund]

		EXEC sp_executesql N'DROP TABLE dbo.Payment'
	END
END
GO
IF OBJECT_id('dbo.InvoiceCredit') IS NOT NULL
BEGIN
	DECLARE @r int
	EXEC sp_executesql N'SELECT @r=COUNT(*) FROM InvoiceCredit', N'@r int out', @r=@r OUT
	IF @r = 0 EXEC sp_executesql N'DROP TABLE dbo.InvoiceCredit'
END
GO
IF OBJECT_id('dbo.Template') IS NOT NULL
BEGIN
	DECLARE @r int
	EXEC sp_executesql N'SELECT @r=COUNT(*) FROM Template', N'@r int out', @r=@r OUT
	IF @r = 0 EXEC sp_executesql N'DROP TABLE dbo.Template'
END
GO
IF OBJECT_id('dbo.PaymentRefund') IS NOT NULL
BEGIN
	DECLARE @r int
	EXEC sp_executesql N'SELECT @r=COUNT(*) FROM PaymentRefund', N'@r int out', @r=@r OUT
	IF @r = 0 EXEC sp_executesql N'DROP TABLE dbo.PaymentRefund'
END
GO
IF OBJECT_id('dbo.PaymentType') IS NOT NULL
BEGIN
	DECLARE @r int
	EXEC sp_executesql N'SELECT @r=COUNT(*) FROM PaymentType', N'@r int out', @r=@r OUT
	IF @r = 0 EXEC sp_executesql N'DROP TABLE dbo.PaymentType'
END
GO
IF OBJECT_id('dbo.InvoiceType') IS NOT NULL
BEGIN
	DECLARE @r int
	EXEC sp_executesql N'SELECT @r=COUNT(*) FROM InvoiceType', N'@r int out', @r=@r OUT
	IF @r = 0 EXEC sp_executesql N'DROP TABLE dbo.InvoiceType'
END
GO
IF OBJECT_id('dbo.Payer') IS NOT NULL DROP TABLE dbo.Payer
GO
IF OBJECT_id('dbo.Invoice') IS NULL
BEGIN
	CREATE TABLE dbo.Invoice(
		[InvoiceID] [int] IDENTITY(1,1) NOT NULL PRIMARY KEY,
		[EmployeeID] [int] NOT NULL,
		[TemplateID] [int] NOT NULL,
		[Due Day past 1900] [int] NOT NULL,

		/* Columns updates by spInvoiceInsert and spInvoiceUpdate */
		[Created Day past 1900] [int] NOT NULL DEFAULT (datediff(day,0,GETDATE())),
		[Created By] [varchar](128) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL DEFAULT (suser_sname()),
		[Last Updated Day past 1900] [int] NOT NULL DEFAULT (datediff(day,0,GETDATE())),
		[Last Updated By] [varchar](128) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL DEFAULT (suser_sname()),

		/* Columns calculated by spInvoiceCalc */
		[Payment Transactions] varchar(450) NOT NULL DEFAULT(''),
		[Total] money NOT NULL DEFAULT(0),
		Credit money NOT NULL DEFAULT(0),
		Payment money NOT NULL DEFAULT(0),
		Balance money NOT NULL DEFAULT(0),
		BatchID int NULL
	)
	CREATE INDEX IX_Invoice_BatchID ON Invoice(BatchID)
	CREATE INDEX IX_Invoice_EmployeeID ON Invoice(EmployeeID)
	CREATE INDEX IX_Invoice_BatchIDEmployeeID ON Invoice(BatchID, EmployeeID)

	ALTER TABLE dbo.Note  ADD  CONSTRAINT [FK_Note_Invoice] FOREIGN KEY([InvoiceID]) REFERENCES dbo.Invoice ([InvoiceID]) ON DELETE CASCADE
	ALTER TABLE dbo.Invoice ADD  CONSTRAINT [FK_Invoice_InvoiceTemplate] FOREIGN KEY([TemplateID]) REFERENCES dbo.[InvoiceTemplate] ([TemplateID])
	ALTER TABLE dbo.Invoice ADD  CONSTRAINT [FK_Invoice_Employee] FOREIGN KEY(EmployeeID) REFERENCES dbo.Employee (EmployeeID)

	ALTER TABLE dbo.Invoice ADD  CONSTRAINT [CK_Invoice_PaymentsPlusCreditsGreaterThanTotal] CHECK ((Payment + [Credit] <= Total))
END
GO
IF OBJECT_id('dbo.PaymentType') IS NULL
BEGIN
	CREATE TABLE dbo.PaymentType(
		TypeID int IDENTITY(1,1) NOT NULL PRIMARY KEY,
		[Type] varchar(50) NOT NULL,
		[Order] int NOT NULL
	)
END
GO
IF NOT EXISTS(SELECT * FROM PaymentType)
BEGIN
	EXEC sp_executesql N' INSERT PaymentType ([Type], [Order]) SELECT ''Check'', 0 UNION SELECT ''Money Order'', 1'
END
GO
IF OBJECT_id('dbo.InvoiceCredit') IS NULL
BEGIN
	CREATE TABLE dbo.InvoiceCredit
	(
		CreditID int IDENTITY(1,1) NOT NULL PRIMARY KEY,
		InvoiceID int NOT NULL,
		Amount money NOT NULL,
		Comment varchar(50) NOT NULL,
		[Day past 1900] int NOT NULL
	)

	ALTER TABLE dbo.InvoiceCredit ADD CONSTRAINT [FK_Invoice_InvoiceCredit] FOREIGN KEY(InvoiceID) REFERENCES dbo.Invoice(InvoiceID) ON DELETE CASCADE
END
GO
IF OBJECT_id('dbo.InvoiceDetail') IS NULL
BEGIN
	CREATE TABLE dbo.InvoiceDetail(
		[DetailID] [int] IDENTITY(1,1) NOT NULL PRIMARY KEY,
		[InvoiceID] [int] NOT NULL,
		[Day past 1900] [int] NOT NULL,
		[Text] [varchar](50) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
		[Units] [numeric](9, 4) NOT NULL,
		[Unit Rate] money NOT NULL,
		[Fixed] money NOT NULL,
		[Split Amount] money NOT NULL,
		[Order] [int] NOT NULL
	)

	ALTER TABLE dbo.InvoiceDetail ADD  CONSTRAINT FK_InvoiceDetail_Invoice FOREIGN KEY([InvoiceID]) REFERENCES dbo.Invoice ([InvoiceID]) ON DELETE CASCADE
END
GO
IF OBJECT_ID('FK_InvoiceDetail_Invoice') IS NOT NULL
BEGIN
	ALTER TABLE dbo.InvoiceDetail DROP CONSTRAINT FK_InvoiceDetail_Invoice
	ALTER TABLE dbo.InvoiceDetail ADD CONSTRAINT FK_InvoiceDetail_Invoice FOREIGN KEY([InvoiceID]) REFERENCES dbo.Invoice ([InvoiceID]) ON DELETE CASCADE
END
GO
IF OBJECT_id('dbo.Payment') IS NULL
BEGIN
	CREATE TABLE dbo.Payment(
		[PaymentID] [int] IDENTITY(1,1) NOT NULL PRIMARY KEY,
		[EmployeeID] [int] NOT NULL,
		[TypeID] [int] NOT NULL,
		[Transaction Number] [varchar](50) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
		[Total] money NOT NULL,
		[Received Day past 1900] [int] NOT NULL,

		/* Columns created by spPaymentInsert and spPaymentUpdate */
		[Created Day past 1900] [int] NOT NULL DEFAULT (datediff(day,0,GETDATE())),
		[Created By] [varchar](128) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL DEFAULT (suser_sname()),
		[Last Updated Day past 1900] [int] NOT NULL DEFAULT (datediff(day,0,GETDATE())),
		[Last Updated By] [varchar](128) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL DEFAULT (suser_sname()),
		
		/* Columns calculated by spPaymentCalc */
		Split bit NOT NULL DEFAULT(0),
		Refund money NOT NULL DEFAULT(0),
		Applied money NOT NULL DEFAULT(0),
		Unapplied money NOT NULL DEFAULT(0),

		Invoices varchar(400) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL DEFAULT('')
	)

	ALTER TABLE dbo.Payment ADD  CONSTRAINT [FK_Payment_Employee] FOREIGN KEY([EmployeeID]) REFERENCES dbo.[Employee] ([EmployeeID])
	ALTER TABLE dbo.Payment ADD  CONSTRAINT [FK_Payment_Type] FOREIGN KEY([TypeID]) REFERENCES dbo.[PaymentType] ([TypeID])
	ALTER TABLE dbo.Payment ADD  CONSTRAINT [CK_Payment_AppliedPlusRefundMoreThanTotal] CHECK (Applied + Refund <= [Total])
END
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [ID] = OBJECT_id('dbo.Payment') AND [name] = 'Invoices')
ALTER TABLE Payment ADD Invoices varchar(400) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL DEFAULT('')
GO
IF OBJECT_id('dbo.PaymentRefund') IS NULL
BEGIN
	CREATE TABLE dbo.PaymentRefund
	(
		RefundID int IDENTITY(1,1) NOT NULL PRIMARY KEY,
		PaymentID int NOT NULL,
		Amount money NOT NULL,
		Comment varchar(50) NOT NULL,
		[Day past 1900] int NOT NULL
	)

	ALTER TABLE dbo.PaymentRefund ADD  CONSTRAINT [FK_Payment_PaymentRefund] FOREIGN KEY(PaymentID)
	REFERENCES dbo.Payment(PaymentID)
END
GO
IF OBJECT_id('dbo.PaymentDetail') IS NULL
BEGIN
	CREATE TABLE dbo.PaymentDetail(
		[DetailID] [int] IDENTITY(1,1) NOT NULL PRIMARY KEY,
		[PaymentID] [int] NOT NULL,
		[InvoiceID] [int] NOT NULL,
		[Comment] [varchar](50) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
		[Applied] money NOT NULL
	)

	ALTER TABLE dbo.PaymentDetail  ADD  CONSTRAINT [FK_PaymentDetail_Invoice] FOREIGN KEY([InvoiceID]) REFERENCES dbo.Invoice ([InvoiceID])
	ALTER TABLE dbo.PaymentDetail ADD  CONSTRAINT [FK_PaymentDetail_Payment] FOREIGN KEY([PaymentID]) REFERENCES dbo.Payment ([PaymentID]) ON DELETE CASCADE
END
GO
IF OBJECT_id('dbo.ReportTemplate3') IS NULL
CREATE TABLE dbo.ReportTemplate3(
	TemplateID int NOT NULL PRIMARY KEY CLUSTERED IDENTITY(1,1),
	BasisID int NOT NULL,
	Flags int NOT NULL,
	Tag int NOT NULL,
	ParentMenuID int NOT NULL,
	Template varchar(50) NOT NULL,
	[Fields Stream] image NOT NULL,
	CONSTRAINT CK_ReportTemplate3_TemplateNotBlank CHECK (Template <> '')
)
GO
CREATE FUNCTION dbo.fnGetAmountDueBetween(@employee_id int, @today datetime, @range_start int, @range_stop int)
RETURNS money WITH SCHEMABINDING
BEGIN
	DECLARE @sum money, @today_day int
	SELECT @today_day = DATEDIFF(d, 0, @today)
	SELECT @sum = SUM(I.Balance) FROM dbo.Invoice I WHERE EmployeeID=@employee_id AND @today_day - I.[Due Day past 1900] BETWEEN @range_start AND @range_stop
	RETURN ISNULL(@sum, 0)
END
GO
CREATE FUNCTION dbo.fnGetInvoiceStatus (@total money, @payment money, @credit money, @due_day int, @today datetime)
RETURNS varchar(50) WITH SCHEMABINDING
BEGIN
	DECLARE @days_past_due int, @days_past_due_msg varchar(50)
	SELECT @days_past_due = DATEDIFF(d, dbo.GetDateFromDaysPast1900(@due_day), @today)
	SELECT @days_past_due_msg = CAST(@days_past_due AS varchar(50))
	RETURN CASE
	WHEN @payment = @total THEN 'Paid In Full' 
	WHEN @credit = @total THEN 'Credited'
	WHEN @payment + @credit = @total THEN 'Partially Paid, Rest Credited'
	WHEN @payment > 0 AND DATEDIFF(d,0,@today) < @due_day THEN 'Open, Partially Paid'
	WHEN @days_past_due < 0 THEN 'Open'
	WHEN @payment > 0 AND @days_past_due = 0 THEN 'Due, Partially Paid'
	WHEN @days_past_due = 0 THEN 'Due'
	WHEN @payment > 0 AND DATEDIFF(d,0,@today) = @due_day + 1 THEN 'Past Due 1 Day, Partially Paid'
	WHEN @payment > 0 THEN 'Past Due ' + @days_past_due_msg + ' Days, Partially Paid'
	WHEN @days_past_due = 1 THEN 'Past Due 1 Day'
	ELSE 'Past Due ' + @days_past_due_msg + ' Days'
	END
END
GO
CREATE FUNCTION dbo.fnGetInvoiceAging(@balance money, @due_day int, @today datetime) RETURNS varchar(50) WITH SCHEMABINDING
BEGIN
	DECLARE @days_past_due int
	SELECT @days_past_due = DATEDIFF(d, dbo.GetDateFromDaysPast1900(@due_day), @today)
	RETURN CASE 
	WHEN @balance = 0 THEN '  Closed'
	WHEN @days_past_due < 0 THEN '  Current'
	WHEN @days_past_due = 0 THEN '  Due Today'
	WHEN @days_past_due < 30 THEN ' 1-30 Days Past Due'
	WHEN @days_past_due < 60 THEN ' 31-60 Days Past Due'
	WHEN @days_past_due < 90 THEN ' 61-90 Days Past Due'
	WHEN @days_past_due < 120 THEN ' 91-120 Days Past Due'
	WHEN @days_past_due < 180 THEN '121-180 Days Past Due'
	ELSE '181+ Days'
	END
END
GO
CREATE FUNCTION dbo.fnDoesVariantIntMaskContainBit(@mask sql_variant, @bit int) RETURNS bit AS
BEGIN
	DECLARE @i int
	SET @i = 0
	IF @mask IS NOT NULL AND SQL_VARIANT_PROPERTY(@mask,'BaseType') = 'int' SET @i = CAST(@mask AS int)
	RETURN CASE WHEN (@i & @bit) = 0 THEN 0 ELSE 1 END
END
GO
IF NOT EXISTS (SELECT * FROM syscolumns WHERE [name]='PermissionAttributeID' AND [id] = OBJECT_id('dbo.CustomField'))
ALTER TABLE dbo.CustomField ADD PermissionAttributeID int NOT NULL DEFAULT(4194304)
GO
-- This stored proc is needed by some of the views
EXEC dbo.spAdminCreateSPifNonexistent 'spAdminDependentViews_Identify'
GO
ALTER PROC dbo.spAdminDependentViews_Identify @object sysname
AS
SET NOCOUNT ON

DECLARE @r int, @l int
SELECT @r = 1, @l = 1

CREATE TABLE #D(ID int)
CREATE TABLE #T(ID int)
INSERT #T SELECT OBJECT_ID(@object)

WHILE @r > 0 AND @l < 10
BEGIN
	DELETE #D

	INSERT #D
	/* SELECT DISTINCT O.[id] FROM sysdepends D
	INNER JOIN sysobjects O ON D.[id]= O.[id] AND O.xtype='V'
	INNER JOIN syscomments C ON C.[id] = O.[id] AND [text] NOT LIKE '%WITH SCHEMABINDING%'
	INNER JOIN #T ON #T.[ID] = D.[depid] */
	SELECT DISTINCT o.[id] from 
	syscomments C 
	inner join sysobjects O on c.[id]=O.[id] and O.xtype='V' AND [text] NOT LIKE '%WITH SCHEMABINDING%'  
	inner join #T ON O.[id] != #T.[id] AND C.text like '%' + OBJECT_NAME(#T.[ID]) + '%'

	DELETE #T
	INSERT #T SELECT [ID] FROM #D
	
	INSERT #DEPENDENT_VIEWS SELECT [ID] FROM #D WHERE [ID] NOT IN (SELECT [ID] FROM #DEPENDENT_VIEWS)

	SET @r = @@ROWCOUNT
	SET @l = @l + 1
END
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spAdminDependentViews_Refresh'
GO
ALTER PROC dbo.spAdminDependentViews_Refresh
AS
DECLARE @view sysname

DECLARE v_cursor CURSOR LOCAL FORWARD_ONLY STATIC FOR 
SELECT OBJECT_NAME(ID) FROM #DEPENDENT_VIEWS ORDER BY [Order]

OPEN v_cursor

DECLARE @sql nvarchar(4000)
FETCH v_cursor INTO @view
WHILE @@FETCH_STATUS = 0
BEGIN
	SET @sql = 'EXEC dbo.sp_refreshview ''' + @view + ''''
	EXEC dbo.spExecSQLAsDBO @sql
	FETCH v_cursor INTO @view	
END

CLOSE v_cursor
DEALLOCATE v_cursor
GO
IF OBJECT_ID('dbo.fnGetTypeNameForCustomFieldType') IS NOT NULL DROP FUNCTION dbo.fnGetTypeNameForCustomFieldType
GO
CREATE FUNCTION dbo.fnGetTypeNameForCustomFieldType(@type_id int)
RETURNS varchar(50)
AS
BEGIN
	RETURN CASE @type_id
		WHEN 1 THEN 'int'
		WHEN 2 THEN 'decimal(29,6)'
		WHEN 3 THEN 'bit'
		WHEN 5 THEN 'datetime'
		ELSE 'varchar(4000)'
	END
END
GO
IF OBJECT_id('dbo.spPersonCustomFieldBuildSecureView') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spPersonCustomFieldBuildSecureView AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spPersonCustomFieldBuildSecureView TO public'
END
GO
-- Builds a secure view of all the information in PersonCustomFieldFlat
-- Locks down each cell by the permissions on person\permission attribute for the custom column
ALTER PROC dbo.spPersonCustomFieldBuildSecureView
AS
SET NOCOUNT ON

DECLARE @sql nvarchar(MAX), @col sysname, @field_id varchar(50)

IF EXISTS(SELECT * FROM dbo.CustomField WHERE PermissionAttributeID <> 4194304)
BEGIN
	SET @sql = 'ALTER VIEW dbo.vwPersonCustomFieldFlatSecure AS SELECT P.PCFPersonID'

	DECLARE c_cursor CURSOR LOCAL FORWARD_ONLY STATIC FOR
	SELECT [name],FieldID=SUBSTRING([name],4,CHARINDEX('_',[name],5)-4) FROM syscolumns 
	WHERE [id]=OBJECT_ID('dbo.PersonCustomFieldFlat') AND [name] != 'PCFPersonID' AND LEN([name]) >= 5
	OPEN c_cursor 
	FETCH c_cursor INTO @col,@field_id
	WHILE @@FETCH_STATUS = 0
	BEGIN
		-- CF_44_XText = CASE WHEN (dbo.fnPermissionGetOnPersonForCurrentUser(P.PCFPersonID,F44.PermissionAttributeID)&1) = 1 THEN P.CF_44_XText ELSE 'Permission Denied' END
		SET @sql = @sql + ',' + @col  + '=CASE WHEN(dbo.fnPermissionGetOnPersonForCurrentUser(P.PCFPersonID,F' + @field_id + '.PermissionAttributeID)&1)=1 THEN P.' + @col + ' ELSE NULL END'
		FETCH c_cursor INTO @col,@field_id
	END
	CLOSE c_cursor
	DEALLOCATE c_cursor
	
	SET @sql = @sql + ' FROM dbo.PersonCustomFieldFlat P'

	DECLARE c_cursor CURSOR LOCAL FORWARD_ONLY STATIC FOR
	SELECT DISTINCT FieldID=SUBSTRING([name],4,CHARINDEX('_',[name],5)-4) FROM syscolumns 
	WHERE [id]=OBJECT_ID('dbo.PersonCustomFieldFlat') AND [name] != 'PCFPersonID' AND LEN([name]) >= 5
	OPEN c_cursor 
	FETCH c_cursor INTO @field_id
	WHILE @@FETCH_STATUS = 0
	BEGIN
		-- INNER JOIN dbo.CustomField F44 ON F44.FieldID=44
		SET @sql = @sql + ' INNER JOIN dbo.CustomField F' + @field_id + ' ON F' + @field_id + '.FieldID=' + @field_id
		FETCH c_cursor INTO @field_id
	END
	CLOSE c_cursor
	DEALLOCATE c_cursor
	
	EXEC dbo.spExecSQLAsDBO @sql
END
ELSE
BEGIN
	SET @sql = 'ALTER VIEW dbo.vwPersonCustomFieldFlatSecure AS SELECT * FROM dbo.PersonCustomFieldFlat WHERE (dbo.fnPermissionGetOnPersonForCurrentUser(PCFPersonID,4194304)&1) = 1'
	EXEC dbo.spExecSQLAsDBO @sql
END
GO
IF OBJECT_ID('dbo.spPersonCustomFieldDeleteFlatTableColumn') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spPersonCustomFieldDeleteFlatTableColumn AS'
GO
ALTER PROC dbo.spPersonCustomFieldDeleteFlatTableColumn @field_id int 
AS
DECLARE @id sysname, @colValue sysname, @colText sysname
SELECT @id = 'CF_' + CAST(@field_id AS varchar(50)) + N'_X'
SELECT @colValue = @id + 'Value', @colText = @id + 'Text'

IF EXISTS(SELECT * FROM dbo.syscolumns WHERE [id]=OBJECT_ID('dbo.PersonCustomFieldFlat') AND [name]=@colValue)
BEGIN
	DECLARE @sql nvarchar(4000)

	CREATE TABLE #DEPENDENT_VIEWS(ID int, [Order] int NOT NULL identity(1,1))
	EXEC dbo.spAdminDependentViews_Identify 'dbo.PersonCustomFieldFlat'

	SET @sql = 'ALTER TABLE dbo.PersonCustomFieldFlat DROP COLUMN ' + @colValue
	EXEC dbo.spExecSQLAsDBO @sql

	SET @sql = 'ALTER TABLE dbo.PersonCustomFieldFlat DROP COLUMN ' + @colText
	EXEC dbo.spExecSQLAsDBO @sql
	
	EXEC dbo.spPersonCustomFieldBuildSecureView

	-- Views should be refreshed in order of dependency but for some reason they're not. Explictly refreshing vwemployee secure seams to work around it.
	--SET @sql = 'EXEC sp_refreshview ''dbo.vwEmployeeSecure'''
	--EXEC dbo.spExecSQLAsDBO @sql
	EXEC dbo.spAdminDependentViews_Refresh
END
GO
-- fnGetCustomFieldText defines later on with rest of functions. But it needs to exist for spPersonCustomFieldInsertFlatTableColumn
IF OBJECT_ID('dbo.fnGetCustomFieldText') IS NULL EXEC sp_executesql N'CREATE FUNCTION dbo.fnGetCustomFieldText(@field_id int, @value sql_variant) RETURNS varchar(MAX) AS BEGIN RETURN '''' END'
GO
IF OBJECT_ID('dbo.spPersonCustomFieldInsertFlatTableColumn') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spPersonCustomFieldInsertFlatTableColumn AS'
GO
ALTER PROC dbo.spPersonCustomFieldInsertFlatTableColumn @field_id int, @fill_new_field bit, @refresh_dependent_views bit = 1
WITH EXEC AS 'dbo'
AS
DECLARE @id sysname, @colValue sysname, @colText sysname, @fid varchar(50)
SELECT @fid = CAST(@field_id AS varchar(50))
SELECT @id = 'CF_' + @fid + N'_X'
SELECT @colValue = @id + 'Value', @colText = @id + 'Text'

IF NOT EXISTS(SELECT * FROM dbo.syscolumns WHERE [id]=OBJECT_ID('dbo.PersonCustomFieldFlat') AND [name]=@colValue)
BEGIN
	DECLARE @sql nvarchar(4000), @type_id int, @type varchar(50)

	SELECT @type_id = TypeID, @type = dbo.fnGetTypeNameForCustomFieldType(TypeID) FROM dbo.CustomField F WHERE FieldID=@field_id

	CREATE TABLE #DEPENDENT_VIEWS(ID int, [Order] int NOT NULL identity(1,1))
	IF @refresh_dependent_views = 1 EXEC dbo.spAdminDependentViews_Identify 'dbo.PersonCustomFieldFlat'

	SET @sql = 'ALTER TABLE dbo.PersonCustomFieldFlat ADD ' + @colValue + ' ' + @type + ' NULL'
	EXEC sp_executesql @sql

	SET @sql = 'ALTER TABLE dbo.PersonCustomFieldFlat ADD ' + @colText + ' varchar(50) NULL'
	EXEC sp_executesql @sql

	IF @fill_new_field=1 
	BEGIN
--		SET @sql = N'UPDATE F SET ' +
--		@colValue + '=CAST(PCF.Value2 AS ' + @type + '),' + @colText + '=PCF.Text ' +
--		'FROM dbo.PersonCustomFieldFlat F ' +
--		'INNER JOIN dbo.vwPersonCustomField PCF ON F.PCFPersonID=PCF.PersonID AND PCF.FieldID=' + CAST(@field_id AS varchar(50))

		SET @sql = N'UPDATE F SET ' +
		@colValue + '=CAST(PCF.Value AS ' + @type + '),' + @colText + '=dbo.fnGetCustomFieldText(' + @fid + ',PCF.Value) ' +
		'FROM dbo.PersonCustomFieldFlat F ' +
		'INNER JOIN dbo.PersonCustomField PCF ON F.PCFPersonID=PCF.PersonID AND PCF.FieldID=' + @fid

		EXEC sp_executesql @sql
	END
	ELSE
	BEGIN
		IF @type_id = 3 SET @sql = N'UPDATE F SET ' + @colValue + '=CAST(0 AS bit), ' + @colText + '=''0'' FROM dbo.PersonCustomFieldFlat F'
		ELSE SET @sql = N'UPDATE F SET ' + @colText + '='''' FROM dbo.PersonCustomFieldFlat F'
		EXEC sp_executesql @sql
	END
	
	EXEC dbo.spPersonCustomFieldBuildSecureView

	-- Views should be refreshed in order of dependency but for some reason they're not. Explictly refreshing vwemployee secure seams to work around it.
	--SET @sql = 'EXEC sp_refreshview ''dbo.vwEmployeeSecure'''
	--EXEC dbo.spExecSQLAsDBO @sql
	IF @refresh_dependent_views = 1 EXEC dbo.spAdminDependentViews_Refresh
END
GO
/* TABLE CHANGES BEGIN ************************************************************************************* */
GO
IF OBJECT_ID('dbo.CalendarRemark') IS NULL
BEGIN
	CREATE TABLE dbo.CalendarRemark(
		[RemarkID] [int] IDENTITY(1,1) NOT NULL PRIMARY KEY,
		[Remark] [varchar](4000) NOT NULL,
		[Day past 1900] [int] NOT NULL,
		[Created Day past 1900] [int] NOT NULL DEFAULT (datediff(day,0,getdate())),
		[Created By] [varchar](128) NOT NULL DEFAULT (suser_sname())
	)

	ALTER TABLE [dbo].[CalendarRemark]  WITH CHECK ADD  CONSTRAINT [CK_CalendarRemark_BlankRemark] CHECK  ((len([Remark]) > 0))
END
GO
ALTER TABLE dbo.CalendarRemark ALTER COLUMN Remark varchar(4000) NOT NULL

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name] = 'Created Day past 1900' AND [id] = OBJECT_id('dbo.CalendarRemark'))
ALTER TABLE dbo.CalendarRemark ADD [Created Day past 1900] [int] NOT NULL DEFAULT (datediff(day,0,getdate()))

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name] = 'Created By' AND [id] = OBJECT_id('dbo.CalendarRemark'))
ALTER TABLE dbo.CalendarRemark ADD [Created By] [varchar](128) NOT NULL DEFAULT (suser_sname())
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE ID=OBJECT_id('EmployeeCompensation') AND [name]='Employee Seconds per Week')
ALTER TABLE dbo.EmployeeCompensation ADD [Employee Seconds per Week] int NULL
GO
IF OBJECT_id('dbo.TempPersonPermission') IS NULL
BEGIN
	CREATE TABLE dbo.TempPersonPermission(
		[ItemID] [int] IDENTITY(1,1) NOT NULL PRIMARY KEY,
		[BatchID] [int] NOT NULL,
		[PersonID] [int] NULL,
		[AttributeID] [int] NOT NULL,
		[Permission Mask] [int] NOT NULL,
		[Created] [smalldatetime] NOT NULL,
		[Deny Mask] [int] NOT NULL
	)

	ALTER TABLE [dbo].[TempPersonPermission] ADD  CONSTRAINT [DF_TempPersonPermission_PermissionMask]  DEFAULT (0) FOR [Permission Mask]
	ALTER TABLE [dbo].[TempPersonPermission] ADD  CONSTRAINT [DF_TempPersonPermission_Created]  DEFAULT (getdate()) FOR [Created]
	ALTER TABLE [dbo].[TempPersonPermission] ADD  CONSTRAINT [DF_TempPersonPermission_DenyMask]  DEFAULT ((0)) FOR [Deny Mask]
END
GO
IF OBJECT_id('dbo.PermissionCached') IS NULL
BEGIN
	CREATE TABLE dbo.PermissionCached(
		SID varbinary(85) NOT NULL, 
		PersonID int NOT NULL, 
		AttributeID int NOT NULL, 
		[Permission Mask] int NOT NULL, 
		Created datetime NOT NULL DEFAULT(GETDATE())
	) 

	CREATE UNIQUE INDEX PermissionCached_SIDPersonIDAttributeID ON dbo.PermissionCached(SID, PersonID, AttributeID) WITH IGNORE_DUP_KEY
	CREATE INDEX PermissionCached_SIDCreated ON dbo.PermissionCached(SID, Created)
	CREATE CLUSTERED INDEX PermissionCached_Created ON dbo.PermissionCached(Created)
END
GO
IF OBJECT_ID('dbo.EmployeeTimeCached') IS NULL
BEGIN
CREATE TABLE dbo.EmployeeTimeCached(
ETCID int NOT NULL IDENTITY(1,1) PRIMARY KEY,
EmployeeID int NOT NULL,
OriginalTypeID int NOT NULL, 
CalculatedTypeID int NOT NULL,
[In Day past 1900] int NOT NULL, 
[OT Eligible] bit NOT NULL,
[OT Disable] bit NOT NULL,
[Pay Rate] money NOT NULL,
[Fixed Pay] money NOT NULL DEFAULT(0),
[Fixed Items] int DEFAULT(0),
Regular bit DEFAULT(0),
[In Seconds] int NOT NULL,
[Out Seconds] int NOT NULL,
TimeSchemaID int NOT NULL,
ShiftDiffItemID int NULL,
TempShiftDiffSeconds int NULL,
TempShiftDiffItemID int NULL,
OriginalTimeItemID int NULL,
CopyTimeItemID int NULL,
[Time Seconds] int NOT NULL DEFAULT(0),
[Holiday Seconds] int NOT NULL DEFAULT(0),
[OT Seconds] int NOT NULL DEFAULT(0),
Flags int NOT NULL DEFAULT(0),
[Actual In] datetime NULL,
[Actual Out] datetime NULL,
[Base Seconds] int NOT NULL DEFAULT(0),
[X2 Seconds] int NOT NULL DEFAULT(0),
Created datetime DEFAULT(GETDATE())
)

ALTER TABLE dbo.EmployeeTimeCached ADD CONSTRAINT FK_EmployeeTimeCached_Employee FOREIGN KEY (EmployeeID) REFERENCES dbo.Employee(EmployeeID) ON DELETE CASCADE
END
GO
DELETE dbo.EmployeeTimeCached
GO
IF NOT EXISTS(SELECT * FROM sysindexes WHERE [ID] = OBJECT_id('EmployeeTimeCached') AND [name] = 'IX_EmployeeTimeCached_OriginalTimeItemID')
CREATE INDEX IX_EmployeeTimeCached_OriginalTimeItemID ON dbo.EmployeeTimeCached(OriginalTimeItemID)

IF NOT EXISTS(SELECT * FROM sysindexes WHERE [ID] = OBJECT_id('EmployeeTimeCached') AND [name] = 'IX_EmployeeTimeCached_CopyTimeItemID')
CREATE INDEX IX_EmployeeTimeCached_CopyTimeItemID ON dbo.EmployeeTimeCached(OriginalTimeItemID)

IF NOT EXISTS(SELECT * FROM sysindexes WHERE [ID] = OBJECT_id('EmployeeTimeCached') AND [name] = 'IX_EmployeeTimeCached_EmployeeID')
CREATE INDEX IX_EmployeeTimeCached_EmployeeID ON dbo.EmployeeTimeCached(EmployeeID)

IF NOT EXISTS(SELECT * FROM sysindexes WHERE [ID] = OBJECT_id('EmployeeTimeCached') AND [name] = 'IX_EmployeeTimeCached_EmployeeIDDay')
CREATE INDEX IX_EmployeeTimeCached_EmployeeIDDay ON dbo.EmployeeTimeCached(EmployeeID, [In Day past 1900])

IF NOT EXISTS(SELECT * FROM sysindexes WHERE [ID] = OBJECT_id('EmployeeTimeCached') AND [name] = 'IX_EmployeeTimeCached_Created')
CREATE INDEX IX_EmployeeTimeCached_Created ON dbo.EmployeeTimeCached(Created)
GO
IF EXISTS(SELECT * FROM sysindexes WHERE [ID] = OBJECT_id('EmployeeTimeCached') AND [name] = 'IX_EmployeeTimeCached_Duplicate')
EXEC sp_executesql N'DROP INDEX IX_EmployeeTimeCached_Duplicate ON dbo.EmployeeTimeCached'
GO
IF NOT EXISTS(SELECT * FROM sysindexes WHERE [ID] = OBJECT_id('EmployeeTimeCached') AND [name] = 'IX_EmployeeTimeCached_Duplicate')
CREATE INDEX IX_EmployeeTimeCached_Duplicate ON dbo.EmployeeTimeCached(OriginalTimeItemID, CopyTimeItemID, OriginalTypeID, CalculatedTypeID, [In Day past 1900], [Time Seconds], [Base Seconds])
GO
IF OBJECT_ID('dbo.EmployeeTimeClearCache') IS NULL EXEC sp_executesql N'CREATE TRIGGER dbo.EmployeeTimeClearCache ON dbo.EmployeeTime FOR INSERT,DELETE,UPDATE AS SELECT A=0'
GO
ALTER TRIGGER dbo.EmployeeTimeClearCache ON dbo.EmployeeTime FOR INSERT,UPDATE,DELETE
AS
SET NOCOUNT ON
DELETE C FROM dbo.EmployeeTimeCached C INNER JOIN inserted I ON C.CopyTimeItemID = I.ItemID
DELETE C FROM dbo.EmployeeTimeCached C INNER JOIN deleted D ON C.CopyTimeItemID = D.ItemID

SELECT EmployeeID, MN=MIN(DATEDIFF(d,0,[In])) INTO #EI FROM inserted GROUP BY EmployeeID
INSERT #EI SELECT EmployeeID, MN=MIN(DATEDIFF(d,0,[In])) FROM deleted GROUP BY EmployeeID

SELECT DISTINCT CopyTimeItemID INTO #ED FROM dbo.EmployeeTimeCached C INNER JOIN #EI ON C.EmployeeID=#EI.EmployeeID AND C.[In Day past 1900] >= MN
DELETE C FROM dbo.EmployeeTimeCached C INNER JOIN #ED ON C.CopyTimeItemID=#ED.CopyTimeItemID
GO
IF OBJECT_ID('dbo.EmployeeTimeClearTimeCache') IS NOT NULL EXEC sp_executesql N'DROP TRIGGER dbo.EmployeeTimeClearTimeCache'
GO
IF OBJECT_ID('dbo.EmployeeLeaveEarnedClearTimeCache') IS NULL EXEC sp_executesql N'CREATE TRIGGER dbo.EmployeeLeaveEarnedClearTimeCache ON dbo.EmployeeLeaveEarned FOR INSERT,DELETE,UPDATE AS SELECT A=0'
GO
ALTER TRIGGER dbo.EmployeeLeaveEarnedClearTimeCache ON dbo.EmployeeLeaveEarned FOR INSERT,UPDATE,DELETE
AS
SET NOCOUNT ON
SELECT EmployeeID, MN=MIN([Day past 1900]) INTO #EI FROM inserted WHERE [Auto]=0 GROUP BY EmployeeID
INSERT #EI SELECT EmployeeID, MN=MIN([Day past 1900]) FROM deleted WHERE [Auto]=0 GROUP BY EmployeeID

SELECT DISTINCT CopyTimeItemID INTO #ED FROM dbo.EmployeeTimeCached C INNER JOIN #EI ON C.EmployeeID=#EI.EmployeeID AND C.[In Day past 1900] >= MN
DELETE C FROM dbo.EmployeeTimeCached C INNER JOIN #ED ON C.CopyTimeItemID=#ED.CopyTimeItemID
GO
IF OBJECT_ID('dbo.EmployeeLeaveUsedItemClearTimeCache') IS NULL EXEC sp_executesql N'CREATE TRIGGER dbo.EmployeeLeaveUsedItemClearTimeCache ON dbo.EmployeeLeaveUsedItem FOR INSERT,DELETE,UPDATE AS SELECT A=0'
GO
ALTER TRIGGER dbo.EmployeeLeaveUsedItemClearTimeCache ON dbo.EmployeeLeaveUsedItem FOR INSERT,UPDATE,DELETE
AS
SET NOCOUNT ON
SELECT U.EmployeeID, MN=MIN([Day past 1900]) INTO #EI
FROM inserted I
INNER JOIN dbo.EmployeeLeaveUsed U ON I.LeaveID=U.LeaveID GROUP BY EmployeeID

INSERT #EI 
SELECT U.EmployeeID, MN=MIN([Day past 1900])
FROM deleted D
INNER JOIN dbo.EmployeeLeaveUsed U ON D.LeaveID=U.LeaveID GROUP BY EmployeeID

SELECT DISTINCT CopyTimeItemID INTO #ED FROM dbo.EmployeeTimeCached C INNER JOIN #EI ON C.EmployeeID=#EI.EmployeeID AND C.[In Day past 1900] >= MN
DELETE C FROM dbo.EmployeeTimeCached C INNER JOIN #ED ON C.CopyTimeItemID=#ED.CopyTimeItemID
GO
IF OBJECT_ID('dbo.EmployeeLeaveUsedClearTimeCache') IS NULL EXEC sp_executesql N'CREATE TRIGGER dbo.EmployeeLeaveUsedClearTimeCache ON dbo.EmployeeLeaveUsed FOR DELETE,UPDATE AS SELECT A=0'
GO
ALTER TRIGGER dbo.EmployeeLeaveUsedClearTimeCache ON dbo.EmployeeLeaveUsed FOR UPDATE,DELETE
AS
SET NOCOUNT ON
SELECT U.EmployeeID, MN=MIN([Day past 1900]) INTO #EI
FROM inserted U
INNER JOIN dbo.EmployeeLeaveUsedItem I ON I.LeaveID=U.LeaveID GROUP BY EmployeeID

INSERT #EI 
SELECT U.EmployeeID, MN=MIN([Day past 1900])
FROM deleted U
INNER JOIN dbo.EmployeeLeaveUsedItem I ON I.LeaveID=U.LeaveID GROUP BY EmployeeID

SELECT DISTINCT CopyTimeItemID INTO #ED FROM dbo.EmployeeTimeCached C INNER JOIN #EI ON C.EmployeeID=#EI.EmployeeID AND C.[In Day past 1900] >= MN
DELETE C FROM dbo.EmployeeTimeCached C INNER JOIN #ED ON C.CopyTimeItemID=#ED.CopyTimeItemID
GO
IF OBJECT_ID('dbo.PayrollPeriodException') IS NULL
CREATE TABLE dbo.PayrollPeriodException(
	OldStartDay int NOT NULL,
	NewStartDay int NOT NULL,
	NewStopDay int NOT NULL
)
GO
IF NOT EXISTS(SELECT * FROM dbo.AuditSetting WHERE ObjectID=4194304)
INSERT dbo.AuditSetting(ObjectID,[Object],[Possible Event Mask],[Audit Event Mask])
SELECT 4194304,'Custom Fields',10,0
GO
ALTER TABLE dbo.Note ALTER COLUMN [Note] varchar(MAX) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL 
GO 
ALTER TABLE dbo.AuditTrail ALTER COLUMN [Event] varchar(MAX) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL 
GO
IF NOT EXISTS(SELECT * FROM dbo.AuditSetting WHERE ObjectID=1024)
INSERT dbo.AuditSetting(ObjectID, [Object], [Possible Event Mask], [Audit Event Mask])
SELECT 1024, 'Communication History', 14, 0
GO
DBCC CHECKIDENT ('dbo.TempX', RESEED, 0)
DBCC CHECKIDENT ('dbo.TempUser', RESEED, 0)
DBCC CHECKIDENT ('dbo.TempXYZ', RESEED, 0)
DBCC CHECKIDENT ('dbo.TempPersonPermission', RESEED, 0)
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name] = 'LeaveID' AND [id] = OBJECT_id('dbo.Occurrence'))
ALTER TABLE dbo.Occurrence ADD LeaveID int NULL
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name] = 'Unions' AND [id] = OBJECT_id('dbo.PersonX'))
ALTER TABLE dbo.PersonX ADD Unions varchar(400) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL DEFAULT('')
GO
IF NOT EXISTS(SELECT * FROM ColumnGrid WHERE FieldID=1080)
INSERT ColumnGrid(FieldID, [Table], [Key], colid, AttributeID, Field, Label, Importable, Reportable, [Order])
SELECT 1080, 'PersonX', 'PersonID', colid, 4, 'Unions', 'Unions', 0, 1, 1105
FROM syscolumns WHERE [id] = OBJECT_id('PersonX') AND [name] = 'Unions'
GO
UPDATE dbo.Department SET [Department] = LTRIM(RTRIM([Department]))
GO
UPDATE dbo.Project SET [Project] = LTRIM(RTRIM([Project]))
GO
IF OBJECT_id('dbo.InOutStatus') IS NULL
BEGIN
	BEGIN TRAN

	CREATE TABLE dbo.InOutStatus (
		StatusID int NOT NULL IDENTITY(1,1) PRIMARY KEY,
		[Status] varchar(50) NOT NULL,
		[In] bit,
		Color int,
		[Order] int
	)
	
	INSERT InOutStatus(Status,[In],Color,[Order]) VALUES('In', 1, 0x00FF00, 1)
	INSERT InOutStatus(Status,[In],Color,[Order]) VALUES('Gone for Day', 0, 0xFF0000, 3)
	INSERT InOutStatus(Status,[In],Color,[Order]) VALUES('Out to Lunch', 0, 0xFF0000, 2)
	INSERT InOutStatus(Status,[In],Color,[Order]) VALUES('On Leave', 0, 0xFF0000, 4)
	INSERT InOutStatus(Status,[In],Color,[Order]) VALUES('Offsite', 0, 0xFF0000, 5)
	INSERT InOutStatus(Status,[In],Color,[Order]) VALUES('On Call', 0, 0xFF0000, 6)


	COMMIT TRAN
END
GO
IF OBJECT_ID('dbo.UserFieldItem') IS NULL
CREATE TABLE dbo.UserFieldItem(
	ItemID int NOT NULL IDENTITY(1,1) PRIMARY KEY,
	FieldID int NOT NULL,
	Item varchar(50) NOT NULL
)
GO
UPDATE dbo.EmployeeProject SET Comment='' WHERE Comment IS NULL
ALTER TABLE dbo.EmployeeProject ALTER COLUMN Comment varchar(50) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [ID]=OBJECT_id('Employee') AND [name]='SyncID')
ALTER TABLE dbo.Employee ADD SyncID varchar(50) NOT NULL DEFAULT('')
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [ID]=OBJECT_id('Project') AND [name]='TerminalInOutMode')
ALTER TABLE dbo.Project ADD [TerminalInOutMode] tinyint NULL
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [ID]=OBJECT_id('Project') AND [name]='InStatusID')
ALTER TABLE dbo.Project ADD InStatusID int NULL
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [ID]=OBJECT_id('Project') AND [name]='OutStatusID')
ALTER TABLE dbo.Project ADD OutStatusID int NULL
GO
IF OBJECT_id('FK_Project_InStatus') IS NULL
ALTER TABLE dbo.Project WITH NOCHECK ADD CONSTRAINT FK_Project_InStatus FOREIGN KEY (InStatusID) REFERENCES dbo.InOutStatus(StatusID)
GO
IF OBJECT_id('FK_Project_OutStatus') IS NULL
ALTER TABLE dbo.Project WITH NOCHECK ADD CONSTRAINT FK_Project_OutStatus FOREIGN KEY (OutStatusID) REFERENCES dbo.InOutStatus(StatusID)
GO
IF OBJECT_ID('dbo.EmployeeUserFieldItem') IS NULL
BEGIN
	CREATE TABLE dbo.EmployeeUserFieldItem (
		EItemID int IDENTITY (1, 1) NOT NULL,
		EmployeeID int NOT NULL,
		ItemID int NOT NULL
	)
	ALTER TABLE dbo.EmployeeUserFieldItem WITH NOCHECK ADD CONSTRAINT [PK_EmployeeUserFieldItem] PRIMARY KEY CLUSTERED (EItemID)
END
GO
IF OBJECT_id('FK_EmployeeUserFieldItem_Employee') IS NULL
ALTER TABLE dbo.EmployeeUserFieldItem WITH NOCHECK ADD CONSTRAINT FK_EmployeeUserFieldItem_Employee FOREIGN KEY (EmployeeID) REFERENCES dbo.Employee(EmployeeID)
GO
IF OBJECT_id('FK_EmployeeUserFieldItem_UserFieldItem') IS NULL
ALTER TABLE dbo.EmployeeUserFieldItem WITH NOCHECK ADD CONSTRAINT FK_EmployeeUserFieldItem_UserFieldItem FOREIGN KEY (ItemID) REFERENCES dbo.UserFieldItem(ItemID)
GO
IF NOT EXISTS(SELECT * FROM sysindexes WHERE name='IX_EmployeeUserFieldItem_EmployeeID')
CREATE  INDEX [IX_EmployeeUserFieldItem_EmployeeID] ON dbo.[EmployeeUserFieldItem]([EmployeeID])
GO
IF NOT EXISTS(SELECT * FROM sysindexes WHERE name='IX_EmployeeUserFieldItem_ItemID')
CREATE  INDEX [IX_EmployeeUserFieldItem_ItemID] ON dbo.[EmployeeUserFieldItem]([ItemID])
GO
IF NOT EXISTS(SELECT * FROM sysindexes WHERE name='IX_EmployeeUserFieldItem_EmployeeIDItemID')
CREATE UNIQUE INDEX [IX_EmployeeUserFieldItem_EmployeeIDItemID] ON dbo.[EmployeeUserFieldItem](EmployeeID,[ItemID])
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [ID]=OBJECT_id('Project') AND [name]='Terminal Work Code')
ALTER TABLE dbo.Project ADD [Terminal Work Code] [smallint] NOT NULL DEFAULT(0)
GO
IF NOT EXISTS(SELECT * FROM dbo.Project WHERE [Terminal Work Code] <> 0)
BEGIN
	SELECT ProjectID, Number=LTRIM(RTRIM([Number])) INTO #PNumber FROM dbo.Project WHERE ISNUMERIC([Number])=1
	DELETE #PNumber WHERE [Number] LIKE '%[^0-9]%'
	DELETE #PNumber WHERE [Number] > 32767
		
	UPDATE P SET [Terminal Work Code] = #PNumber.[Number] 
	FROM dbo.Project P
	INNER JOIN #PNumber ON P.ProjectID=#PNumber.ProjectID
	DROP TABLE #PNumber
END
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [id]=OBJECT_id('dbo.Subfolder') AND [name]='AttributeID')
ALTER TABLE dbo.Subfolder ADD AttributeID int NULL
GO
IF OBJECT_id('FK_Subfolder_PermissionAttribute') IS NOT NULL
ALTER TABLE dbo.Subfolder ADD 
CONSTRAINT FK_Subfolder_PermissionAttribute FOREIGN KEY 
(
	AttributeID
) REFERENCES dbo.PermissionAttribute (
	AttributeID
)
GO
IF NOT EXISTS(SELECT * FROM dbo.PermissionAttribute WHERE AttributeID=1001)
INSERT dbo.PermissionAttribute(AttributeID,Attribute,[Scope Possible Mask],[Permission Possible Mask])
SELECT 1001,'Folders Sub 1',16383,15
GO
IF NOT EXISTS(SELECT * FROM dbo.PermissionAttribute WHERE AttributeID=1002)
INSERT dbo.PermissionAttribute(AttributeID,Attribute,[Scope Possible Mask],[Permission Possible Mask])
SELECT 1002,'Folders Sub 2',16383,15
GO
IF NOT EXISTS(SELECT * FROM dbo.PermissionAttribute WHERE AttributeID=1003)
INSERT dbo.PermissionAttribute(AttributeID,Attribute,[Scope Possible Mask],[Permission Possible Mask])
SELECT 1003,'Folders Sub 3',16383,15
GO
IF NOT EXISTS(SELECT * FROM dbo.PermissionAttribute WHERE AttributeID=1004)
INSERT dbo.PermissionAttribute(AttributeID,Attribute,[Scope Possible Mask],[Permission Possible Mask])
SELECT 1004,'Folders Sub 4',16383,15
GO
IF NOT EXISTS(SELECT * FROM dbo.PermissionAttribute WHERE AttributeID=1005)
INSERT dbo.PermissionAttribute(AttributeID,Attribute,[Scope Possible Mask],[Permission Possible Mask])
SELECT 1005,'Folders Sub 5',16383,15
GO
IF NOT EXISTS(SELECT * FROM dbo.PermissionAttribute WHERE AttributeID=1006)
INSERT dbo.PermissionAttribute(AttributeID,Attribute,[Scope Possible Mask],[Permission Possible Mask])
SELECT 1006,'Folders Sub 6',16383,15
GO
IF NOT EXISTS(SELECT * FROM dbo.PermissionAttribute WHERE AttributeID=1007)
INSERT dbo.PermissionAttribute(AttributeID,Attribute,[Scope Possible Mask],[Permission Possible Mask])
SELECT 1007,'Folders Sub 7',16383,15
GO
IF NOT EXISTS(SELECT * FROM dbo.PermissionAttribute WHERE AttributeID=1008)
INSERT dbo.PermissionAttribute(AttributeID,Attribute,[Scope Possible Mask],[Permission Possible Mask])
SELECT 1008,'Folders Sub 8',16383,15
GO
IF NOT EXISTS(SELECT * FROM dbo.PermissionAttribute WHERE AttributeID=1009)
INSERT dbo.PermissionAttribute(AttributeID,Attribute,[Scope Possible Mask],[Permission Possible Mask])
SELECT 1009,'Folders Sub 9',16383,15
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [id]=OBJECT_id('dbo.Subfolder') AND [name]='AttributeID')
ALTER TABLE dbo.Subfolder ADD AttributeID int NULL
GO
IF OBJECT_id('FK_Subfolder_Attribute') IS NULL
ALTER TABLE dbo.Subfolder WITH NOCHECK ADD CONSTRAINT FK_Subfolder_Attribute FOREIGN KEY(AttributeID) REFERENCES dbo.PermissionAttribute(AttributeID)
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [id]=OBJECT_id('dbo.Subfolder') AND [name]='Options')
ALTER TABLE dbo.Subfolder ADD Options int DEFAULT(0) NOT NULL
GO
IF OBJECT_ID('dbo.Equipment') IS NULL
BEGIN
	CREATE TABLE [dbo].[Equipment](
		[EquipmentID] [int] IDENTITY(1,1) NOT NULL,
		[Description] [varchar](50) NOT NULL,
		[Manufacturer] [varchar](50) NOT NULL,
		[Serial Number] [varchar](50) NOT NULL,
		[Model] [varchar](50) NOT NULL,
		[Make] [varchar](50) NOT NULL,
		[Service Tag] [varchar](50) NOT NULL,
		[Last Serviced Day past 1900] [int] NULL,
		[Note] [varchar](4000) NOT NULL,
		[Purchase Day past 1900] [int] NULL,
		[Purchase Price] [money] NULL,
		[EmployeeID] [int] NULL,
		[Checked Out Day past 1900] [int] NULL,
		[Due Day past 1900] [int] NULL,
		[ReturnedByEmployeeID] [int] NULL,
		[CheckedOutByEmployeeID] [int] NULL,
		[Returned Day past 1900] [int] NULL,
		[Last Price] [money] NULL,
		[Last Price Day past 1900] [int] NULL,
		[TypeID] [int] NOT NULL,
		[Billing Address] [varchar](50) NOT NULL,
		[Billing Address (cont.)] [varchar](50) NOT NULL,
		[Billing City] [varchar](50) NOT NULL,
		[Billing State / Region] [varchar](50) NOT NULL,
		[Billing ZIP / Postal Code] [varchar](50) NOT NULL,
		[Total Limit] [money] NULL,
		[Daily Limit] [money] NULL,
		[Purchase Limit] [money] NULL,
		[Issuer] [varchar](50) NOT NULL,
		[CVV] [varchar](50) NOT NULL,
		[Name on Card] [varchar](50) NOT NULL,
		[Number] [varchar](50) NOT NULL,
		[Pin] [varchar](50) NOT NULL,
		[SIMM] [varchar](50) NOT NULL,
		[IMEI] [varchar](50) NOT NULL,
		[Service] [varchar](50) NOT NULL,
		[Accessories] [varchar](50) NOT NULL,
		[IP] [varchar](50) NOT NULL,
		[OS] [varchar](50) NOT NULL,
		[CPU] [varchar](50) NOT NULL,
		[RAM] [varchar](50) NOT NULL,
		[HD] [varchar](50) NOT NULL,
		[HD2] [varchar](50) NOT NULL,
		[Role] [varchar](50) NOT NULL,
		[Service Pack] [varchar](50) NOT NULL,
		[Location] [varchar](50) NOT NULL,
		[Serial Number (2)] [varchar](50) NOT NULL,
		[UICC] [varchar](50) NOT NULL,
		[Provider] [varchar](50) NOT NULL,
		[Product Key] [varchar](50) NOT NULL,
		[User1] [varchar](50) NOT NULL,
		[User2] [varchar](50) NOT NULL,
		[User3] [varchar](50) NOT NULL,
		[User4] [varchar](50) NOT NULL,
		[User5] [varchar](50) NOT NULL,
		[User6] [varchar](50) NOT NULL,
		[User7] [varchar](50) NOT NULL,
		[User8] [varchar](50) NOT NULL,
		[User9] [varchar](50) NOT NULL,
		[Service Start Day past 1900] [int] NULL,
		[Expiration Day past 1900] [int] NULL,
		[VIN] [varchar](50) NOT NULL,
		[Year] [int] NULL,
	 CONSTRAINT [PK_Equipment] PRIMARY KEY CLUSTERED 
	(
		[EquipmentID] ASC
	)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 90) ON [PRIMARY],
	 CONSTRAINT [IX_Equipment_Description] UNIQUE NONCLUSTERED 
	(
		[Description] ASC
	)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 90) ON [PRIMARY]
	) ON [PRIMARY]
END
GO
-- Adds new fields to equipment
IF NOT EXISTS(SELECT * FROM dbo.syscolumns WHERE [name]='ReturnedByEmployeeID' AND [id]=OBJECT_id('dbo.Equipment'))
BEGIN
BEGIN TRAN
	ALTER TABLE dbo.Equipment ADD ReturnedByEmployeeID int NULL
	ALTER TABLE dbo.Equipment ADD CheckedOutByEmployeeID int NULL
	ALTER TABLE dbo.Equipment ADD [Returned Day past 1900] int NULL
	ALTER TABLE dbo.Equipment ADD [Last Price] money NULL
	ALTER TABLE dbo.Equipment ADD [Last Price Day past 1900] int NULL
	ALTER TABLE dbo.Equipment WITH NOCHECK ADD CONSTRAINT FK_Equipment_Returned_By FOREIGN KEY(ReturnedByEmployeeID) REFERENCES dbo.Employee(EmployeeID)
	ALTER TABLE dbo.Equipment WITH NOCHECK ADD CONSTRAINT FK_Equipment_Checked_Out_By FOREIGN KEY(CheckedOutByEmployeeID) REFERENCES dbo.Employee(EmployeeID)
COMMIT TRAN
END
GO
IF OBJECT_ID('dbo.LeaveTypeExternal') IS NOT NULL
BEGIN
	EXEC sp_executesql N'IF NOT EXISTS(SELECT * FROM dbo.LeaveTypeExternal) DROP TABLE dbo.LeaveTypeExternal'
END
GO
IF OBJECT_ID('dbo.LeaveTypeExternal') IS NULL
BEGIN
	CREATE TABLE dbo.LeaveTypeExternal(
		ExternalID [int] IDENTITY(1,1) NOT NULL PRIMARY KEY,
		Code varchar(50) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
		Comment varchar(50) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL DEFAULT(''),
		LeaveTypeID int NULL,
		[Advanced Type Mask] int NOT NULL DEFAULT(0),
		TimeTypeID int NULL,
		Flags int NOT NULL DEFAULT(0)
	)
	
	CREATE UNIQUE INDEX IX_LeaveTypeExternal_Code ON dbo.LeaveTypeExternal(Code)
	ALTER TABLE dbo.LeaveTypeExternal ADD  CONSTRAINT [FK_LeaveTypeExternal_LeaveType] FOREIGN KEY(LeaveTypeID) REFERENCES dbo.LeaveType(TypeID)
	ALTER TABLE dbo.LeaveTypeExternal ADD  CONSTRAINT [FK_LeaveTypeExternal_TimeType] FOREIGN KEY(TimeTypeID) REFERENCES dbo.TimeType(TypeID)
END
GO
IF NOT EXISTS(SELECT * FROM dbo.syscolumns WHERE [name]='Seconds in Day' AND [id]=OBJECT_ID('dbo.EmployeeLeavePlan'))
ALTER TABLE dbo.EmployeeLeavePlan ADD [Seconds in Day] [int] NOT NULL DEFAULT(28800)
GO
IF OBJECT_id('FK_CustomField_PermissionAttribute') IS NULL
ALTER TABLE dbo.CustomField ADD CONSTRAINT FK_CustomField_PermissionAttribute FOREIGN KEY (PermissionAttributeID) REFERENCES dbo.PermissionAttribute (AttributeID) 
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name] = 'VisaStatusID' AND [id] = OBJECT_id('dbo.PersonX'))
ALTER TABLE dbo.PersonX ADD VisaStatusID int NULL
GO
IF OBJECT_ID('dbo.VisaStatus') IS NULL
BEGIN
	CREATE TABLE dbo.VisaStatus(
		StatusID [int] IDENTITY(1,1) NOT NULL PRIMARY KEY,
		[Status] [varchar](50) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
		Flags int NOT NULL DEFAULT(0)
	)
	
	ALTER TABLE dbo.PersonX ADD  CONSTRAINT [FK_PersonX_VisaStatus] FOREIGN KEY(VisaStatusID) REFERENCES dbo.VisaStatus (StatusID)
END
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name] = 'Exit Interview Day past 1900' AND [id] = OBJECT_id('dbo.Employee'))
ALTER TABLE dbo.Employee ADD [Exit Interview Day past 1900] int NULL
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name] = 'ExitInterviewByEmployeeID' AND [id] = OBJECT_id('dbo.Employee'))
BEGIN
	ALTER TABLE dbo.Employee ADD ExitInterviewByEmployeeID int NULL
	ALTER TABLE dbo.Employee ADD  CONSTRAINT [FK_Employee_ExitInterviewBy] FOREIGN KEY(ExitInterviewByEmployeeID) REFERENCES dbo.Employee (EmployeeID)
END
GO
IF NOT EXISTS(SELECT * FROM ColumnGrid WHERE FieldID=1070)
INSERT ColumnGrid(FieldID,[Table],[Key],colid,AttributeID,Field,Label,Importable,Reportable,[Order])
SELECT 1070,'','',0,1,'Daily Pay','Daily Pay',1,1,1359
GO
-- New field, EmployeeLeaveUsed.[Advanced Seconds]
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name] = 'Advanced Seconds' AND [id] = OBJECT_id('dbo.EmployeeLeaveUsed'))
ALTER TABLE dbo.EmployeeLeaveUsed ADD [Advanced Seconds] int NOT NULL DEFAULT (0)
GO
IF NOT EXISTS(SELECT * FROM dbo.EmployeeLeaveUsed WHERE [Advanced Seconds] > 0)
UPDATE U SET [Advanced Seconds] = ISNULL((
	SELECT SUM(Seconds) FROM EmployeeLeaveUsedItem I WHERE I.LeaveID = U.LeaveID AND [Advanced Type Mask] > 0
), 0) FROM dbo.EmployeeLeaveUsed U
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [ID]=OBJECT_id('dbo.TempXYZ') AND name='N')
ALTER TABLE dbo.TempXYZ ADD [N] varchar(8000) DEFAULT('')
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [ID]=OBJECT_id('dbo.TempXYZ') AND name='I')
BEGIN
BEGIN TRAN
	ALTER TABLE dbo.TempXYZ ADD [I] int NULL
	CREATE INDEX IX_TempXYZ_I ON TempXYZ(BatchID,I)
	CREATE INDEX IX_TempXYZ_ItemID ON TempXYZ(ItemID)
COMMIT TRAN
END
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [ID]=OBJECT_id('dbo.TempXYZ') AND name='J')
BEGIN
BEGIN TRAN
	ALTER TABLE dbo.TempXYZ ADD [J] int NULL
	CREATE INDEX IX_TempXYZ_J ON TempXYZ(BatchID,J)
COMMIT TRAN
END
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [ID] = OBJECT_id('dbo.LeaveRate') AND [name] = 'LimitPeriodID')
BEGIN
	ALTER TABLE dbo.LeaveRate ADD [LimitPeriodID] int NOT NULL DEFAULT(0)
	ALTER TABLE dbo.LeaveRate ADD [Limit Month] int NOT NULL DEFAULT(1)
	ALTER TABLE dbo.LeaveRate ADD [Limit Day] int NOT NULL DEFAULT(1)
	ALTER TABLE dbo.LeaveRate ADD [Limit Max Seconds] int NOT NULL DEFAULT(2147483647)
END
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [ID] = OBJECT_id('dbo.LeaveRate') AND [name] = 'ExcludeMonthMask')
BEGIN
	ALTER TABLE dbo.LeaveRate ADD [ExcludeMonthMask] int NOT NULL DEFAULT(0)
END
GO
IF OBJECT_ID('dbo.RTWItem') IS NULL
BEGIN
	CREATE TABLE dbo.RTWItem(
		ItemID int NOT NULL,
		[Item] varchar(50) NOT NULL DEFAULT(''),
		[Order] int NOT NULL DEFAULT(0)
	)
END
GO
-- New field, EmployeeLeaveUsedItem.[RTW Day past 1900]
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name] = 'RTW Day past 1900' AND [id] = OBJECT_id('dbo.EmployeeLeaveUsed'))
ALTER TABLE dbo.EmployeeLeaveUsed ADD [RTW Day past 1900] int NULL
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name] = 'RTW Mask' AND [id] = OBJECT_id('dbo.EmployeeLeaveUsed'))
ALTER TABLE dbo.EmployeeLeaveUsed ADD [RTW Mask] int NOT NULL DEFAULT (0)
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name] = 'Timecard Filter Shift Offset' AND [id] = OBJECT_id('dbo.Constant'))
ALTER TABLE dbo.Constant ADD [Timecard Filter Shift Offset] int NOT NULL DEFAULT(0)
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name] = 'Comp Rate Round Seconds' AND [id] = OBJECT_id('dbo.Constant'))
ALTER TABLE dbo.Constant ADD [Comp Rate Round Seconds] int NOT NULL DEFAULT(1)
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name] = 'Carryover Limit Seconds' AND [id] = OBJECT_id('dbo.LeaveLimit'))
ALTER TABLE dbo.LeaveLimit ADD [Carryover Limit Seconds] int NOT NULL DEFAULT(2147483647)
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name] = 'Carryover Offset Days' AND [id] = OBJECT_id('dbo.LeaveLimit'))
BEGIN
	ALTER TABLE dbo.LeaveLimit ADD [Carryover Offset Days] int NOT NULL DEFAULT(0)
	--EXEC dbo.sp_executesql N'UPDATE T SET [Carryover Offset Days] = C.[Carryover Offset Days] FROM dbo.LeaveLimit T INNER JOIN dbo.Constant C ON C.CarryoverSourceLeaveLimitID = T.TypeID'
END
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name] = 'Carryover Multiplier' AND [id] = OBJECT_id('dbo.LeaveLimit'))
BEGIN
	ALTER TABLE dbo.LeaveLimit ADD [Carryover Multiplier] numeric(9,8) NOT NULL DEFAULT(1.0)
	--EXEC dbo.sp_executesql N'UPDATE T SET [Carryover Multiplier] = C.[Carryover Multiplier] FROM dbo.LeaveLimit T INNER JOIN dbo.Constant C ON C.CarryoverSourceLeaveLimitID = T.TypeID'
END
GO
IF OBJECT_id('FK_LeaveLimit_CarryoverTargetLeaveTypeID') IS NULL
ALTER TABLE dbo.LeaveLimit ADD CONSTRAINT FK_LeaveLimit_CarryoverTargetLeaveTypeID FOREIGN KEY 
(
	CarryoverTargetLeaveTypeID
) REFERENCES dbo.[LeaveType] (
	TypeID
)
GO
--IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name] = 'Last Approved' AND [id] = OBJECT_id('dbo.Employee'))
--ALTER TABLE dbo.Employee ADD [Last Approved] datetime NULL
IF NOT EXISTS(SELECT * FROM dbo.PermissionAttribute WHERE AttributeID=11)
INSERT dbo.PermissionAttribute(AttributeID,Attribute,[Scope Possible Mask],[Permission Possible Mask])
SELECT 11,'Folders',16383,15
GO

IF NOT EXISTS(SELECT * FROM dbo.PermissionAttribute WHERE AttributeID=1001)
INSERT dbo.PermissionAttribute(AttributeID,Attribute,[Scope Possible Mask],[Permission Possible Mask])
SELECT 1001,'Folders Sub 1',16383,15
GO
IF NOT EXISTS(SELECT * FROM dbo.PermissionAttribute WHERE AttributeID=1002)
INSERT dbo.PermissionAttribute(AttributeID,Attribute,[Scope Possible Mask],[Permission Possible Mask])
SELECT 1002,'Folders Sub 2',16383,15
GO
IF NOT EXISTS(SELECT * FROM dbo.PermissionAttribute WHERE AttributeID=1003)
INSERT dbo.PermissionAttribute(AttributeID,Attribute,[Scope Possible Mask],[Permission Possible Mask])
SELECT 1003,'Folders Sub 3',16383,15
GO
IF NOT EXISTS(SELECT * FROM dbo.PermissionAttribute WHERE AttributeID=1004)
INSERT dbo.PermissionAttribute(AttributeID,Attribute,[Scope Possible Mask],[Permission Possible Mask])
SELECT 1004,'Folders Sub 4',16383,15
GO
IF NOT EXISTS(SELECT * FROM dbo.PermissionAttribute WHERE AttributeID=1005)
INSERT dbo.PermissionAttribute(AttributeID,Attribute,[Scope Possible Mask],[Permission Possible Mask])
SELECT 1005,'Folders Sub 5',16383,15
GO
IF NOT EXISTS(SELECT * FROM dbo.PermissionAttribute WHERE AttributeID=1006)
INSERT dbo.PermissionAttribute(AttributeID,Attribute,[Scope Possible Mask],[Permission Possible Mask])
SELECT 1006,'Folders Sub 6',16383,15
GO
IF NOT EXISTS(SELECT * FROM dbo.PermissionAttribute WHERE AttributeID=1007)
INSERT dbo.PermissionAttribute(AttributeID,Attribute,[Scope Possible Mask],[Permission Possible Mask])
SELECT 1007,'Folders Sub 7',16383,15
GO
IF NOT EXISTS(SELECT * FROM dbo.PermissionAttribute WHERE AttributeID=1008)
INSERT dbo.PermissionAttribute(AttributeID,Attribute,[Scope Possible Mask],[Permission Possible Mask])
SELECT 1008,'Folders Sub 8',16383,15
GO
IF NOT EXISTS(SELECT * FROM dbo.PermissionAttribute WHERE AttributeID=1009)
INSERT dbo.PermissionAttribute(AttributeID,Attribute,[Scope Possible Mask],[Permission Possible Mask])
SELECT 1009,'Folders Sub 9',16383,15
GO
IF NOT EXISTS(SELECT * FROM dbo.PermissionAttribute WHERE AttributeID=12)
INSERT dbo.PermissionAttribute(AttributeID,Attribute,[Scope Possible Mask],[Permission Possible Mask])
SELECT 12,'Delete Employee',16383,8
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name] = 'Debounce Minutes' AND [id] = OBJECT_id('dbo.Constant'))
ALTER TABLE dbo.Constant ADD [Debounce Minutes] int NOT NULL DEFAULT(4)
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name] = 'Payroll PPE Offset Seconds' AND [id] = OBJECT_id('dbo.Constant'))
ALTER TABLE dbo.Constant ADD [Payroll PPE Offset Seconds] int NOT NULL DEFAULT(0)
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name] = 'Audit Trail Last Purged Day past 1900' AND [id] = OBJECT_id('dbo.Constant'))
ALTER TABLE dbo.Constant ADD [Audit Trail Last Purged Day past 1900] int NOT NULL DEFAULT(0)
GO
IF OBJECT_ID('dbo.LeaveTypeShift') IS NULL
BEGIN
	CREATE TABLE dbo.LeaveTypeShift 
	(
		ItemID int NOT NULL PRIMARY KEY IDENTITY(1,1),
		TypeID int NOT NULL,
		ShiftID int NOT NULL,
		Flags int NOT NULL -- 1: Shift off concurrent, 2: Not shift off concurrent
	)

	ALTER TABLE dbo.LeaveTypeShift ADD CONSTRAINT FK_LeaveTypeShift_Shift FOREIGN KEY (ShiftID) REFERENCES dbo.Shift (ShiftID)
	ALTER TABLE dbo.LeaveTypeShift ADD CONSTRAINT FK_LeaveTypeShift_Type FOREIGN KEY (TypeID) REFERENCES dbo.LeaveType (TypeID)
END
GO
IF NOT EXISTS(SELECT * FROM sysindexes WHERE [ID] = OBJECT_id('dbo.LeaveTypeShift') AND [name] = 'IX_LeaveTypeShift_TypeShift')
CREATE INDEX IX_LeaveTypeShift_TypeShift ON dbo.LeaveTypeShift(TypeID, ShiftID)
GO
IF OBJECT_ID('CK_Constant_InvalidPayrollPeriod') IS NOT NULL
ALTER TABLE [dbo].[Constant] DROP CONSTRAINT CK_Constant_InvalidPayrollPeriod

IF NOT EXISTS(SELECT * FROM LeaveRatePeriod WHERE PeriodID=281088)
INSERT LeaveRatePeriod (PeriodID,GroupID,Period,Example,Payroll,[Order],[Weekday])
VALUES (281088,512,'Leave per Hour Worked','Periodically click "Leave > Enter Timecards or Leave for Many Employees" to apply credits',0,30000,0)

IF NOT EXISTS(SELECT * FROM Period WHERE PeriodID=1024)
INSERT Period(PeriodID,Period,Seconds) VALUES(1024,'Quarterly',1872000)

IF NOT EXISTS(SELECT * FROM LeaveRatePeriod WHERE PeriodID=281600)
INSERT LeaveRatePeriod(PeriodID,GroupID,Period,Example,Payroll,[Order],[Weekday]) 
VALUES(281600,1024,'Quarterly I','Jan 1, Apr 1, Jul 1, Oct 1 ..',0,6500,0)

IF NOT EXISTS(SELECT * FROM LeaveRatePeriod WHERE PeriodID=283648)
INSERT LeaveRatePeriod(PeriodID,GroupID,Period,Example,Payroll,[Order],[Weekday]) 
VALUES(283648,1024,'Quarterly II','Mar 31, Jun 30, Sep 30, Dec 31 ..',0,6510,0)

IF NOT EXISTS(SELECT * FROM LeaveRatePeriod WHERE PeriodID=285696)
INSERT LeaveRatePeriod(PeriodID,GroupID,Period,Example,Payroll,[Order],[Weekday]) 
VALUES(285696,1024,'Every 3 Months of Seniority I','If seniority starts Jan 3 then credit Jan 3, Apr 3, Jul 3 ..',0,6530,0)

IF NOT EXISTS(SELECT * FROM LeaveRatePeriod WHERE PeriodID=287744)
INSERT LeaveRatePeriod(PeriodID,GroupID,Period,Example,Payroll,[Order],[Weekday]) 
VALUES(287744,1024,'Every 3 Months of Seniority II','If seniority starts Jan 3 then credit Jan 3, Apr 2, Jul 2 ..',0,6540,0)

IF NOT EXISTS(SELECT * FROM LeaveRatePeriod WHERE PeriodID=289792)
INSERT LeaveRatePeriod(PeriodID,GroupID,Period,Example,Payroll,[Order],[Weekday]) 
VALUES(289792,1024,'Every 3 Months of Seniority III','If seniority starts Jan 3 then credit Apr 3, Jul 3, Oct 3 ..',0,6550,0)

IF NOT EXISTS(SELECT * FROM LeaveRatePeriod WHERE PeriodID=291840)
INSERT LeaveRatePeriod(PeriodID,GroupID,Period,Example,Payroll,[Order],[Weekday]) 
VALUES(291840,1024,'Every 3 Months of Seniority IV','If seniority starts Jan 3 then credit Apr 2, Jul 2, Oct 2 ..',0,6560,0)

IF NOT EXISTS(SELECT * FROM LeaveRatePeriod WHERE PeriodID=176160)
INSERT LeaveRatePeriod(PeriodID,GroupID,Period,Example,Payroll,[Order],[Weekday]) 
VALUES(176160,32,'5th and 20th of Each Month','',1,10512,0)

IF NOT EXISTS(SELECT * FROM LeaveRatePeriod WHERE PeriodID=178208)
INSERT LeaveRatePeriod(PeriodID,GroupID,Period,Example,Payroll,[Order],[Weekday]) 
VALUES(178208,32,'10th and 25th of Each Month','',1,10600,0)

IF NOT EXISTS(SELECT * FROM LeaveRatePeriod WHERE PeriodID=180256)
INSERT LeaveRatePeriod(PeriodID,GroupID,Period,Example,Payroll,[Order],[Weekday]) 
VALUES(180256,32,'11th and 27th of Each Month','',1,10610,0)
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [ID] = OBJECT_id('dbo.EmployeeLeaveUsed') AND [name] = 'PendingDeleteLeaveID')
BEGIN
	ALTER TABLE dbo.EmployeeLeaveUsed ADD PendingDeleteLeaveID int NULL
	ALTER TABLE dbo.EmployeeLeaveUsed ADD PendingDeleteLeaveText varchar(400) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL DEFAULT ''

	ALTER TABLE dbo.EmployeeLeaveUsed ADD CONSTRAINT PendingDeleteLeaveID FOREIGN KEY (PendingDeleteLeaveID) REFERENCES dbo.EmployeeLeaveUsed (LeaveID)
	CREATE INDEX IX_EEmployeeLeaveUsed_PendingDeleteLeaveID ON dbo.EmployeeLeaveUsed(PendingDeleteLeaveText) WITH  FILLFACTOR = 90
END
GO
IF NOT EXISTS(SELECT * FROM sysindexes WHERE name='IX_Task_TaskID')
CREATE INDEX IX_Task_TaskID ON dbo.TaskOccurence(TaskID)
GO
IF NOT EXISTS(SELECT * FROM sysindexes WHERE name='IX_ReminderType_OwnerID')
CREATE INDEX IX_ReminderType_OwnerID ON dbo.ReminderType(OwnerID)
GO
IF OBJECT_id('dbo.EEORace') IS NULL
BEGIN
	CREATE TABLE dbo.EEORace
	(
		EEOReportColumn int NOT NULL PRIMARY KEY,
		Race varchar(50) NOT NULL
	)

	INSERT EEORace VALUES(0,'Hispanic')
	INSERT EEORace VALUES(1,'White (Not of Hispanic Origin)')
	INSERT EEORace VALUES(2,'Black (Not of Hispanic Origin)')
	INSERT EEORace VALUES(3,'Native Hawaiian/Other Pacific Islander')
	INSERT EEORace VALUES(4,'Asian')
	INSERT EEORace VALUES(5,'American Indian or Alaskan Native')
	INSERT EEORace VALUES(6,'Two or More')
END
GO
IF OBJECT_id('dbo.EEOJobCategory') IS NULL
BEGIN
	CREATE TABLE dbo.EEOJobCategory
	(
		EEOReportRow int NOT NULL PRIMARY KEY,
		Category varchar(50) NOT NULL
	)

	INSERT EEOJobCategory VALUES(0,'Executives/Senior Level Officials and Managers')
	INSERT EEOJobCategory VALUES(1,'First/Mid-Level Officials and Managers')
	INSERT EEOJobCategory VALUES(2,'Professionals')
	INSERT EEOJobCategory VALUES(3,'Technicians')
	INSERT EEOJobCategory VALUES(4,'Sales Workers')
	INSERT EEOJobCategory VALUES(5,'Administrative Support Workers')
	INSERT EEOJobCategory VALUES(6,'Craft Workers')
	INSERT EEOJobCategory VALUES(7,'Operatives')
	INSERT EEOJobCategory VALUES(8,'Laborers And Helpers')
	INSERT EEOJobCategory VALUES(9,'Service Workers')
END
ELSE
BEGIN
	UPDATE dbo.EEOJobCategory SET Category='Executives/Senior Level Officials and Managers' WHERE EEOReportRow=0
	UPDATE dbo.EEOJobCategory SET Category='First/Mid-Level Officials and Managers' WHERE EEOReportRow=1
	UPDATE dbo.EEOJobCategory SET Category='Professionals' WHERE EEOReportRow=2
	UPDATE dbo.EEOJobCategory SET Category='Technicians' WHERE EEOReportRow=3
	UPDATE dbo.EEOJobCategory SET Category='Sales Workers' WHERE EEOReportRow=4
	UPDATE dbo.EEOJobCategory SET Category='Administrative Support Workers' WHERE EEOReportRow=5
	UPDATE dbo.EEOJobCategory SET Category='Craft Workers' WHERE EEOReportRow=6
	UPDATE dbo.EEOJobCategory SET Category='Operatives' WHERE EEOReportRow=7
	UPDATE dbo.EEOJobCategory SET Category='Laborers And Helpers' WHERE EEOReportRow=8
	UPDATE dbo.EEOJobCategory SET Category='Service Workers' WHERE EEOReportRow=9
END
GO
IF NOT EXISTS(SELECT * FROM sysindexes WHERE name='IX_EmployeeLeaveUnused_E')
CREATE INDEX IX_EmployeeLeaveUnused_E ON dbo.EmployeeLeaveUnused([EmployeeID]) WITH  FILLFACTOR = 90
GO
IF NOT EXISTS(SELECT * FROM sysindexes WHERE name='IX_EmployeeLeaveUsed_Employee')
CREATE INDEX IX_EmployeeLeaveUsed_Employee ON dbo.EmployeeLeaveUsed([EmployeeID]) WITH  FILLFACTOR = 90
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [ID] = OBJECT_id('dbo.LeavePlan') AND [name] = 'Prorate Accrual Rounding Seconds')
BEGIN
	ALTER TABLE dbo.LeavePlan ADD [Prorate Accrual Rounding Seconds] int NOT NULL DEFAULT(1)
END
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [ID] = OBJECT_id('dbo.LeavePlan') AND [name] = 'Flags')
BEGIN
	ALTER TABLE dbo.LeavePlan ADD [Flags] int NOT NULL DEFAULT(0)
END
GO
IF NOT EXISTS(SELECT * FROM sysindexes WHERE name='IX_Temp_BatchIDID')
CREATE UNIQUE NONCLUSTERED INDEX IX_Temp_BatchIDID ON [dbo].[TempX] ([BatchID] ASC,[ID] ASC)
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [ID] = OBJECT_id('dbo.Constant') AND [name] = 'DTTimeTypeID')
BEGIN
	ALTER TABLE dbo.Constant ADD DTTimeTypeID int NULL
	ALTER TABLE dbo.Constant
		ADD CONSTRAINT [FK_Constant_DTTimeType] FOREIGN KEY 
		(
			[DTTimeTypeID]
		) REFERENCES dbo.[TimeType] (
			[TypeID]
		)
END
GO
-- Caches calculated work days per week
IF OBJECT_ID('dbo.WorkDaysInPeriodCache') IS NULL
CREATE TABLE dbo.WorkDaysInPeriodCache ([Start] int NOT NULL, [Stop] int NOT NULL, WorkDays int NOT NULL,
CONSTRAINT PK_WorkDaysInPeriodCache PRIMARY KEY ([Start], [Stop]))
GO
IF OBJECT_id('dbo.spAdminGetWorkDays') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spAdminGetWorkDays AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spAdminGetWorkDays TO public'
END
GO
ALTER PROC dbo.spAdminGetWorkDays @start_date datetime, @stop_date datetime, @work_days int out AS
DECLARE @start int, @stop int, @suspend_seconds int
SELECT @start = DATEDIFF(d,0,@start_date), @stop = DATEDIFF(d,0,@stop_date)
SELECT @work_days = WorkDays FROM dbo.WorkDaysInPeriodCache WHERE [Start] = @start AND [Stop] = @stop
IF @@ROWCOUNT = 0 
BEGIN
	DECLARE @d datetime
	SELECT @work_days=0, @d = @start_date
	
	-- Count work days from @start to @stop
	WHILE @d <= @stop_date
	BEGIN
		DECLARE @dow int, @periods int
		SET @dow = (@@datefirst - 2 + datepart(weekday, @d)) % 7 -- normalize day of week (dow): 0-4 = M-F, 5-6 = Sat-Sun
		IF @dow = 0 AND DATEADD(day,5,@d) <= @stop_date -- Monday
		BEGIN
			SET @periods = (DATEDIFF(day,@d,@stop_date) + 2) / 7
			SET @work_days = @work_days + @periods * 5
			SET @d = DATEADD(d, 7 * @periods, @d)
		END
		ELSE
		BEGIN
			IF @dow < 5 SET @work_days = @work_days + 1
			SET @d = DATEADD(d,1,@d)
		END
	END
	
	INSERT WorkDaysInPeriodCache([Start], [Stop], WorkDays) VALUES (@start, @stop, @work_days)
END
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [ID] = OBJECT_id('dbo.Department') AND [name] = 'LeaveKeeperID')
ALTER TABLE dbo.Department ADD LeaveKeeperID int NULL
GO
IF NOT EXISTS(SELECT * FROM sysindexes WHERE [ID] = OBJECT_id('Department') AND [name] = 'IX_Department_LeaveKeeperID')
CREATE INDEX IX_Department_LeaveKeeperID ON dbo.Department(LeaveKeeperID) WITH FILLFACTOR = 90
GO
IF NOT EXISTS(SELECT * FROM sysindexes WHERE [ID] = OBJECT_id('Department') AND [name] = 'IX_Department_DepartmentIDLeaveKeeperID')
CREATE INDEX IX_Department_DepartmentIDLeaveKeeperID ON dbo.Department(DepartmentID,LeaveKeeperID) WITH FILLFACTOR = 90
GO
IF OBJECT_id('FK_Department_EmployeeID') IS NULL
ALTER TABLE dbo.Department ADD CONSTRAINT [FK_Department_EmployeeID] FOREIGN KEY 
(
	LeaveKeeperID
) REFERENCES dbo.Employee (
	EmployeeID
)
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [ID] = OBJECT_id('dbo.Division') AND [name] = 'LeaveKeeperID')
ALTER TABLE dbo.Division ADD LeaveKeeperID int NULL
GO
IF NOT EXISTS(SELECT * FROM sysindexes WHERE [ID] = OBJECT_id('Division') AND [name] = 'IX_Division_LeaveKeeperID')
CREATE INDEX IX_Division_LeaveKeeperID ON dbo.Division(LeaveKeeperID) WITH FILLFACTOR = 90
GO
IF NOT EXISTS(SELECT * FROM sysindexes WHERE [ID] = OBJECT_id('Division') AND [name] = 'IX_Division_DivisionIDLeaveKeeperID')
CREATE INDEX IX_Division_DivisionIDLeaveKeeperID ON dbo.Division(DivisionID,LeaveKeeperID) WITH FILLFACTOR = 90
GO
IF OBJECT_id('FK_Division_EmployeeID') IS NULL
ALTER TABLE dbo.Division ADD CONSTRAINT [FK_Division_EmployeeID] FOREIGN KEY 
(
	LeaveKeeperID
) REFERENCES dbo.Employee (
	EmployeeID
)
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [id]=OBJECT_ID('dbo.Person') AND [name]='PFlags')
ALTER TABLE dbo.Person ADD PFlags int NOT NULL DEFAULT(0)
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [id]=OBJECT_id('dbo.TimeType') AND [name]='Comp Rate')
ALTER TABLE dbo.TimeType ADD [Comp Rate] smallmoney NOT NULL DEFAULT(1)
GO
IF OBJECT_ID('dbo.ShiftSchedule') IS NOT NULL
BEGIN
IF NOT EXISTS(SELECT * FROM dbo.ShiftSchedule) DROP TABLE dbo.ShiftSchedule
END
GO
IF OBJECT_ID('dbo.ShiftSchedule') IS NULL
BEGIN
	CREATE TABLE dbo.ShiftSchedule(
		[ItemID] [int] PRIMARY KEY IDENTITY(1,1) NOT NULL,
		ShiftID [int] NOT NULL,
		[Day of Shift] [int] NOT NULL,
		[Start Seconds] [int] NOT NULL,
		[Stop Seconds] [int] NOT NULL,
		[Lunch Start] int NOT NULL DEFAULT(0),
		[Lunch Seconds] int NOT NULL DEFAULT(0),
		[Length Seconds] int NOT NULL DEFAULT(0),
		Flags int NOT NULL DEFAULT(0)
	)
	
	ALTER TABLE dbo.ShiftSchedule  WITH CHECK ADD  CONSTRAINT [FK_ShiftSchedule_Shift] FOREIGN KEY([ShiftID])
	REFERENCES dbo.Shift ([ShiftID]) ON DELETE CASCADE
END
GO
IF OBJECT_ID('dbo.ShiftBreak') IS NULL
BEGIN
	CREATE TABLE dbo.ShiftBreak(
		[ItemID] [int] PRIMARY KEY IDENTITY(1,1) NOT NULL,
		ShiftID [int] NOT NULL,
		[Start] [int] NOT NULL,
		[Seconds] [int] NOT NULL,
		[Break Start] [int] NOT NULL,
		[Break Seconds] [int] NOT NULL
	)

	ALTER TABLE dbo.ShiftBreak  WITH CHECK ADD  CONSTRAINT [CK_ShiftBreak_Seconds] CHECK  (([Seconds] > 0 and [Break Seconds] > 0))
	ALTER TABLE dbo.ShiftBreak CHECK CONSTRAINT [CK_ShiftBreak_Seconds]
	ALTER TABLE dbo.ShiftBreak  WITH CHECK ADD  CONSTRAINT [CK_ShiftBreak_Start] CHECK  (([Start] >= 0 and [Start] <= 86400 and ([Break Start] >= 0 and [Break Start] <= 86400)))
	ALTER TABLE dbo.ShiftBreak CHECK CONSTRAINT [CK_ShiftBreak_Start]
	ALTER TABLE dbo.ShiftBreak  WITH CHECK ADD  CONSTRAINT [FK_ShiftBreak_Shift] FOREIGN KEY([ShiftID])
	REFERENCES dbo.Shift ([ShiftID]) ON DELETE CASCADE
END
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [id]=OBJECT_id('dbo.ShiftBreak') AND [name]='Day of Shift')
ALTER TABLE dbo.ShiftBreak ADD [Day of Shift] int NULL
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [id]=OBJECT_id('dbo.ShiftBreak') AND [name]='Flags')
ALTER TABLE dbo.ShiftBreak ADD [Flags] int NOT NULL DEFAULT(0)
GO
IF OBJECT_ID('dbo.ShiftSlant') IS NULL
BEGIN
	CREATE TABLE dbo.ShiftSlant (
		SlantID int NOT NULL IDENTITY(1,1) PRIMARY KEY,
		ShiftID int,
		[Range Start Seconds Past Midnight] int NOT NULL,
		[Range Stop Seconds Past Midnight] int NOT NULL,
		[Slant to Seconds Past Midnight] int NOT NULL,
		[Day of Week Mask] int NOT NULL,
		[In Out Mask] int NOT NULL
	)

	ALTER TABLE ShiftSlant ADD CONSTRAINT FK_ShiftSlant_Shift FOREIGN KEY (ShiftID) REFERENCES Shift (ShiftID) ON DELETE CASCADE
	CREATE INDEX IX_ShiftSlant_ShiftID ON ShiftSlant(ShiftID)
END
GO
IF OBJECT_ID('dbo.Document') IS NULL
BEGIN
	CREATE TABLE dbo.Document (
		DocumentID int NOT NULL PRIMARY KEY IDENTITY(1,1),
		EmployeeID int NULL,
		Document sysname NOT NULL,
		Subfolder sysname NOT NULL,
		[Path] sysname NOT NULL,
		Created datetime NOT NULL DEFAULT(GETDATE())
	)
END
GO
IF OBJECT_ID('dbo.CourseType') IS NULL
BEGIN
	CREATE TABLE dbo.CourseType(
		TypeID int IDENTITY(1,1) NOT NULL,
		[Type] varchar(50) NOT NULL,
		CONSTRAINT PK_CourseType PRIMARY KEY CLUSTERED (TypeID ASC)
	)

	INSERT dbo.CourseType([Type]) VALUES('General')
	INSERT dbo.CourseType([Type]) VALUES('Continuing Education')
	INSERT dbo.CourseType([Type]) VALUES('Safety')
END
GO
IF OBJECT_ID('dbo.CreditType') IS NULL
BEGIN
	CREATE TABLE dbo.CreditType (
		CreditTypeID int IDENTITY(1,1) NOT NULL,
		[Type] varchar(50) NOT NULL,
		[Abbreviated Type] varchar(8) NOT NULL,
		CONSTRAINT PK_CreditType PRIMARY KEY CLUSTERED (CreditTypeID ASC)
	)
	
	INSERT dbo.CreditType([Type],[Abbreviated Type]) VALUES('Safety','Safety')
	INSERT dbo.CreditType([Type],[Abbreviated Type]) VALUES('Professional Development','Prof')
END
GO
IF OBJECT_ID('dbo.Course') IS NULL
BEGIN
	CREATE TABLE dbo.Course(
		CourseID int IDENTITY(1,1) NOT NULL,
		TypeID int NOT NULL,
		Course varchar(50) NOT NULL,
		[Abbreviated Name] varchar(12) NOT NULL,
		Flags int DEFAULT(1), -- 1: Active
		[Next Day past 1900] int NULL
		CONSTRAINT PK_Course PRIMARY KEY CLUSTERED (CourseID ASC)
	)
	ALTER TABLE dbo.Course ADD CONSTRAINT FK_Course_CourseType FOREIGN KEY(TypeID) REFERENCES dbo.CourseType(TypeID)
	CREATE INDEX IX_Course_Type ON dbo.Course(TypeID)
	
	INSERT dbo.Course(TypeID,Course,[Abbreviated Name],Flags) VALUES(1,'MS Office','MS Office',1)
	INSERT dbo.Course(TypeID,Course,[Abbreviated Name],Flags) VALUES(1,'Course2','Course2',1)
	INSERT dbo.Course(TypeID,Course,[Abbreviated Name],Flags) VALUES(1,'Course3','Course3',1)
	
	INSERT dbo.Course(TypeID,Course,[Abbreviated Name],Flags) VALUES(2,'ContEd1','ContEd1',1)
	INSERT dbo.Course(TypeID,Course,[Abbreviated Name],Flags) VALUES(2,'ContEd2','ContEd2',1)
	INSERT dbo.Course(TypeID,Course,[Abbreviated Name],Flags) VALUES(2,'ContEd3','ContEd3',1)
	
	INSERT dbo.Course(TypeID,Course,[Abbreviated Name],Flags) VALUES(3,'Safety 101','Safety101',1)
	INSERT dbo.Course(TypeID,Course,[Abbreviated Name],Flags) VALUES(3,'Workplace Safety','SafetyWork',1)
	INSERT dbo.Course(TypeID,Course,[Abbreviated Name],Flags) VALUES(3,'Safety Management','SafetyMng',1)
END
GO
IF NOT EXISTS(SELECT * FROM dbo.syscolumns WHERE [id]=OBJECT_ID('dbo.Course') AND [name]='Next Day past 1900')
ALTER TABLE dbo.Course ADD [Next Day past 1900] int NULL
GO
IF OBJECT_ID('dbo.CourseCredit') IS NULL
BEGIN
	CREATE TABLE dbo.CourseCredit (
		ItemID int IDENTITY(1,1) NOT NULL,
		CourseID int NOT NULL,
		CreditTypeID int,
		Credits numeric(9,4) NOT NULL,
		CONSTRAINT PK_CourseCredit PRIMARY KEY CLUSTERED (ItemID ASC)
	)
	ALTER TABLE dbo.CourseCredit ADD CONSTRAINT FK_CourseCredit_EmployeeCourse FOREIGN KEY(CourseID) REFERENCES dbo.Course(CourseID) ON DELETE CASCADE
	ALTER TABLE dbo.CourseCredit ADD CONSTRAINT FK_CourseCredit_CreditType FOREIGN KEY(CreditTypeID) REFERENCES dbo.CreditType(CreditTypeID)
	CREATE INDEX IX_CourseCredit_CreditType ON dbo.CourseCredit(CreditTypeID)
	CREATE INDEX IX_CourseCredit_EmployeeCourse ON dbo.CourseCredit(CourseID)
	CREATE UNIQUE INDEX IX_CourseCredit_CreditTypeCourse ON dbo.CourseCredit(CreditTypeID,CourseID)
END
GO
IF OBJECT_ID('dbo.CourseSession') IS NULL
BEGIN
	CREATE TABLE dbo.CourseSession(
		ItemID int IDENTITY(1,1) NOT NULL,
		CourseID int NOT NULL,
		[Start] datetime NOT NULL,
		[Stop] datetime NOT NULL,
		Location varchar(50) NOT NULL,
		Instructor varchar(50) NOT NULL,
		Seats int NULL,
		CONSTRAINT PK_CourseSession PRIMARY KEY CLUSTERED (ItemID ASC)
	)
	ALTER TABLE dbo.CourseSession ADD CONSTRAINT FK_CourseSession_Course FOREIGN KEY(CourseID) REFERENCES dbo.Course(CourseID)
	CREATE INDEX IX_CourseSession_Course ON dbo.CourseSession(CourseID)
END
GO
IF OBJECT_ID('dbo.EmployeeCourseEventStatus') IS NULL
BEGIN
	CREATE TABLE dbo.EmployeeCourseEventStatus (
		StatusID int NOT NULL,
		[Status] varchar(50),
		[Order] int,
		CONSTRAINT PK_EmployeeCourseStatus PRIMARY KEY CLUSTERED (StatusID ASC)
	)
	
	INSERT dbo.EmployeeCourseEventStatus([StatusID],[Status],[Order]) VALUES(8, 'Pending', 0)
	INSERT dbo.EmployeeCourseEventStatus([StatusID],[Status],[Order]) VALUES(1, 'Approved', 10)
	INSERT dbo.EmployeeCourseEventStatus([StatusID],[Status],[Order]) VALUES(2, 'Denied', 20)
END
GO
IF OBJECT_ID('dbo.EmployeeCourse') IS NULL
BEGIN
	CREATE TABLE dbo.EmployeeCourse (
		EmployeeCourseID int IDENTITY(1,1) NOT NULL,
		EmployeeID int NOT NULL,
		CourseID int NOT NULL,
		[Expires Day past 1900] int NULL,
		Flags int NOT NULL, -- 1: Required
		CONSTRAINT PK_EmployeeCourse PRIMARY KEY CLUSTERED (EmployeeCourseID ASC)
	)

	ALTER TABLE dbo.EmployeeCourse ADD CONSTRAINT FK_EmployeeCourse_Employee FOREIGN KEY(EmployeeID) REFERENCES dbo.Employee(EmployeeID) ON DELETE CASCADE
	CREATE UNIQUE INDEX IX_EmployeeCourse_EmployeeCourse ON dbo.EmployeeCourse(EmployeeID,CourseID)
	CREATE INDEX IX_EmployeeCourse_Employee ON dbo.EmployeeCourse(EmployeeID)
	CREATE INDEX IX_EmployeeCourse_Course ON dbo.EmployeeCourse(CourseID)
END
GO
IF OBJECT_ID('dbo.EmployeeCourseEvent') IS NULL
BEGIN
	CREATE TABLE dbo.EmployeeCourseEvent (
		ItemID int IDENTITY(1,1) NOT NULL,
		EmployeeCourseID int NOT NULL,
		[Completed Day past 1900] int NOT NULL,
		Cost money NOT NULL,
		StatusID int NOT NULL,
		Location varchar(50) NOT NULL,
		Comment varchar(50) NOT NULL,
		Flags int NOT NULL, -- 1: Verified
		CONSTRAINT PK_EmployeeCourseEvent PRIMARY KEY CLUSTERED (ItemID ASC)
	)
	ALTER TABLE dbo.EmployeeCourseEvent ADD CONSTRAINT FK_EmployeeCourseEvent_EmployeeCourse FOREIGN KEY(EmployeeCourseID) REFERENCES dbo.EmployeeCourse(EmployeeCourseID) ON DELETE CASCADE
	ALTER TABLE dbo.EmployeeCourseEvent ADD CONSTRAINT FK_EmployeeCourseEvent_Status FOREIGN KEY(StatusID) REFERENCES dbo.EmployeeCourseEventStatus(StatusID)
	CREATE INDEX IX_EmployeeCourseEvent_EmployeeCourse ON dbo.EmployeeCourseEvent(EmployeeCourseID)
END
GO
UPDATE dbo.EmployeeCourseEvent SET StatusID=1 WHERE StatusID IS NULL
IF EXISTS(select * FROM sysindexes WHERE [id]=OBJECT_ID('dbo.EmployeeCourseEvent') AND [name]='IX_EmployeeCourseEvent_Status') DROP INDEX EmployeeCourseEvent.IX_EmployeeCourseEvent_Status
ALTER TABLE dbo.EmployeeCourseEvent ALTER COLUMN StatusID int NOT NULL
CREATE INDEX IX_EmployeeCourseEvent_Status ON dbo.EmployeeCourseEvent(StatusID)
GO
IF OBJECT_ID('dbo.EmployeeCourseCredit') IS NULL
BEGIN
	CREATE TABLE dbo.EmployeeCourseCredit (
		ItemID int IDENTITY(1,1) NOT NULL,
		EmployeeCourseID int NOT NULL,
		CreditTypeID int,
		Credits numeric(9,4) NOT NULL,
		CONSTRAINT PK_EmployeeCourseCredit PRIMARY KEY CLUSTERED (ItemID ASC)
	)
	ALTER TABLE dbo.EmployeeCourseCredit ADD CONSTRAINT FK_EmployeeCourseCredit_EmployeeCourse FOREIGN KEY(EmployeeCourseID) REFERENCES dbo.EmployeeCourse(EmployeeCourseID) ON DELETE CASCADE
	ALTER TABLE dbo.EmployeeCourseCredit ADD CONSTRAINT FK_EmployeeCourseCredit_CreditType FOREIGN KEY(CreditTypeID) REFERENCES dbo.CreditType(CreditTypeID)
	CREATE INDEX IX_EmployeeCourseCredit_CreditType ON dbo.EmployeeCourseCredit(CreditTypeID)
	CREATE INDEX IX_EmployeeCourseCredit_EmployeeCourse ON dbo.EmployeeCourseCredit(EmployeeCourseID)
	CREATE UNIQUE INDEX IX_EmployeeCourseCredit_CreditTypeEmployeeCourse ON dbo.EmployeeCourseCredit(CreditTypeID,EmployeeCourseID)
END
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name] = 'Timecard Max 24 Hours per Day' AND [id] = OBJECT_id('dbo.Constant'))
BEGIN
	ALTER TABLE dbo.Constant ADD [Timecard Max 24 Hours per Day] bit NOT NULL DEFAULT(1)
	IF (SELECT COUNT(*) FROM dbo.EmployeeTime WHERE Seconds > 24 * 3600) >= 10 EXEC sp_executesql N'UPDATE dbo.Constant SET [Timecard Max 24 Hours per Day]=0'
END

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name] = 'Occurrence Flags' AND [id] = OBJECT_id('dbo.Constant'))
ALTER TABLE dbo.Constant ADD [Occurrence Flags] bit NOT NULL DEFAULT(0) -- 1: don't split out types

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name] = 'Expense KM' AND [id] = OBJECT_id('dbo.Constant'))
ALTER TABLE dbo.Constant ADD [Expense KM] bit NOT NULL DEFAULT(0)

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name] = 'Expense Reimbursement Rate' AND [id] = OBJECT_id('dbo.Constant'))
ALTER TABLE dbo.Constant ADD [Expense Reimbursement Rate] money NOT NULL DEFAULT(0.38)
GO
IF OBJECT_ID('dbo.EquipmentType') IS NULL
CREATE TABLE dbo.EquipmentType (TypeID int NOT NULL IDENTITY(1,1), [Type] varchar(50) NOT NULL, [Column Mask] int NOT NULL, Flags int NOT NULL, CONSTRAINT PK_EquipmentType PRIMARY KEY CLUSTERED (TypeID ASC) )
GO
IF NOT EXISTS(SELECT * FROM dbo.EquipmentType)
INSERT dbo.EquipmentType([Type],[Column Mask],Flags) VALUES('Unspecified',0x7FFFFFFF,0)
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name] = 'TypeID' AND [id] = OBJECT_id('dbo.Equipment'))
ALTER TABLE dbo.Equipment ADD TypeID int NOT NULL DEFAULT(1)
GO
IF NOT EXISTS (SELECT * FROM sysindexes WHERE [name]='IX_Equipmet_Type' AND [id]=OBJECT_ID('dbo.Equipment'))
CREATE INDEX IX_Equipmet_Type ON dbo.Equipment(TypeID)
GO
IF EXISTS(SELECT * FROM dbo.Equipment WHERE TypeID NOT IN (SELECT TypeID FROM dbo.EquipmentType))
UPDATE dbo.Equipment SET TypeID = (SELECT TOP 1 TypeID FROM dbo.EquipmentType) WHERE TypeID NOT IN (SELECT TypeID FROM dbo.EquipmentType)
GO
IF OBJECT_ID('FK_Equipment_Type') IS NULL
ALTER TABLE dbo.Equipment ADD CONSTRAINT FK_Equipment_Type FOREIGN KEY(TypeID) REFERENCES dbo.EquipmentType(TypeID)
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name] = 'EmployeeNumberNumeric' AND [id] = OBJECT_id('dbo.Employee'))
BEGIN
	ALTER TABLE dbo.Employee ADD EmployeeNumberNumeric numeric(38,6) NULL
	EXEC sp_executesql N'UPDATE dbo.Employee SET EmployeeNumberNumeric=CAST([Employee Number] AS numeric(38,6)) WHERE ISNUMERIC([Employee Number])=1'
	EXEC sp_executesql N'CREATE INDEX IX_Employee_EmployeeNumberNumeric ON dbo.Employee(EmployeeNumberNumeric)'
END
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name] = 'Billing Address' AND [id] = OBJECT_id('dbo.Equipment'))
ALTER TABLE dbo.Equipment ADD [Billing Address] VARCHAR(50) NOT NULL DEFAULT('')

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name] = 'Billing Address (cont.)' AND [id] = OBJECT_id('dbo.Equipment'))
ALTER TABLE dbo.Equipment ADD [Billing Address (cont.)] VARCHAR(50) NOT NULL DEFAULT('')

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name] = 'Billing City' AND [id] = OBJECT_id('dbo.Equipment'))
ALTER TABLE dbo.Equipment ADD [Billing City] VARCHAR(50) NOT NULL DEFAULT('')

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name] = 'Billing State / Region' AND [id] = OBJECT_id('dbo.Equipment'))
ALTER TABLE dbo.Equipment ADD [Billing State / Region] VARCHAR(50) NOT NULL DEFAULT('')

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name] = 'Billing ZIP / Postal Code' AND [id] = OBJECT_id('dbo.Equipment'))
ALTER TABLE dbo.Equipment ADD [Billing ZIP / Postal Code] VARCHAR(50) NOT NULL DEFAULT('')

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name] = 'Total Limit' AND [id] = OBJECT_id('dbo.Equipment'))
ALTER TABLE dbo.Equipment ADD [Total Limit] money NULL

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name] = 'Daily Limit' AND [id] = OBJECT_id('dbo.Equipment'))
ALTER TABLE dbo.Equipment ADD [Daily Limit] money NULL

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name] = 'Purchase Limit' AND [id] = OBJECT_id('dbo.Equipment'))
ALTER TABLE dbo.Equipment ADD [Purchase Limit] money NULL

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name] = 'Issuer' AND [id] = OBJECT_id('dbo.Equipment'))
ALTER TABLE dbo.Equipment ADD [Issuer] VARCHAR(50) NOT NULL DEFAULT('')

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name] = 'CVV' AND [id] = OBJECT_id('dbo.Equipment'))
ALTER TABLE dbo.Equipment ADD [CVV] VARCHAR(50) NOT NULL DEFAULT('')

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name] = 'Name on Card' AND [id] = OBJECT_id('dbo.Equipment'))
ALTER TABLE dbo.Equipment ADD [Name on Card] VARCHAR(50) NOT NULL DEFAULT('')

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name] = 'Number' AND [id] = OBJECT_id('dbo.Equipment'))
ALTER TABLE dbo.Equipment ADD [Number] VARCHAR(50) NOT NULL DEFAULT('')

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name] = 'Pin' AND [id] = OBJECT_id('dbo.Equipment'))
ALTER TABLE dbo.Equipment ADD [Pin] VARCHAR(50) NOT NULL DEFAULT('')

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name] = 'SIMM' AND [id] = OBJECT_id('dbo.Equipment'))
ALTER TABLE dbo.Equipment ADD [SIMM] VARCHAR(50) NOT NULL DEFAULT('')

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name] = 'IMEI' AND [id] = OBJECT_id('dbo.Equipment'))
ALTER TABLE dbo.Equipment ADD [IMEI] VARCHAR(50) NOT NULL DEFAULT('')

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name] = 'Service' AND [id] = OBJECT_id('dbo.Equipment'))
ALTER TABLE dbo.Equipment ADD [Service] VARCHAR(50) NOT NULL DEFAULT('')

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name] = 'Accessories' AND [id] = OBJECT_id('dbo.Equipment'))
ALTER TABLE dbo.Equipment ADD [Accessories] VARCHAR(50) NOT NULL DEFAULT('')

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name] = 'IP' AND [id] = OBJECT_id('dbo.Equipment'))
ALTER TABLE dbo.Equipment ADD [IP] VARCHAR(50) NOT NULL DEFAULT('')

--IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name] = 'Applications' AND [id] = OBJECT_id('dbo.Equipment'))
--ALTER TABLE dbo.Equipment ADD [Applications] VARCHAR(400) NOT NULL DEFAULT('')

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name] = 'OS' AND [id] = OBJECT_id('dbo.Equipment'))
ALTER TABLE dbo.Equipment ADD [OS] VARCHAR(50) NOT NULL DEFAULT('')

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name] = 'CPU' AND [id] = OBJECT_id('dbo.Equipment'))
ALTER TABLE dbo.Equipment ADD CPU VARCHAR(50) NOT NULL DEFAULT('')

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name] = 'RAM' AND [id] = OBJECT_id('dbo.Equipment'))
ALTER TABLE dbo.Equipment ADD [RAM] VARCHAR(50) NOT NULL DEFAULT('')

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name] = 'HD' AND [id] = OBJECT_id('dbo.Equipment'))
ALTER TABLE dbo.Equipment ADD [HD] VARCHAR(50) NOT NULL DEFAULT('')

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name] = 'HD2' AND [id] = OBJECT_id('dbo.Equipment'))
ALTER TABLE dbo.Equipment ADD [HD2] VARCHAR(50) NOT NULL DEFAULT('')

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name] = 'Role' AND [id] = OBJECT_id('dbo.Equipment'))
ALTER TABLE dbo.Equipment ADD [Role] VARCHAR(50) NOT NULL DEFAULT('')

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name] = 'Service Pack' AND [id] = OBJECT_id('dbo.Equipment'))
ALTER TABLE dbo.Equipment ADD [Service Pack] VARCHAR(50) NOT NULL DEFAULT('')

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name] = 'Location' AND [id] = OBJECT_id('dbo.Equipment'))
ALTER TABLE dbo.Equipment ADD [Location] VARCHAR(50) NOT NULL DEFAULT('')

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name] = 'Serial Number (2)' AND [id] = OBJECT_id('dbo.Equipment'))
ALTER TABLE dbo.Equipment ADD [Serial Number (2)] VARCHAR(50) NOT NULL DEFAULT('')

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name] = 'UICC' AND [id] = OBJECT_id('dbo.Equipment'))
ALTER TABLE dbo.Equipment ADD [UICC] VARCHAR(50) NOT NULL DEFAULT('')

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name] = 'Provider' AND [id] = OBJECT_id('dbo.Equipment'))
ALTER TABLE dbo.Equipment ADD Provider VARCHAR(50) NOT NULL DEFAULT('')

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name] = 'Product Key' AND [id] = OBJECT_id('dbo.Equipment'))
ALTER TABLE dbo.Equipment ADD [Product Key] VARCHAR(50) NOT NULL DEFAULT('')

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name] = 'User1' AND [id] = OBJECT_id('dbo.Equipment'))
ALTER TABLE dbo.Equipment ADD User1 VARCHAR(50) NOT NULL DEFAULT('')

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name] = 'User2' AND [id] = OBJECT_id('dbo.Equipment'))
ALTER TABLE dbo.Equipment ADD User2 VARCHAR(50) NOT NULL DEFAULT('')

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name] = 'User3' AND [id] = OBJECT_id('dbo.Equipment'))
ALTER TABLE dbo.Equipment ADD User3 VARCHAR(50) NOT NULL DEFAULT('')

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name] = 'User4' AND [id] = OBJECT_id('dbo.Equipment'))
ALTER TABLE dbo.Equipment ADD User4 VARCHAR(50) NOT NULL DEFAULT('')

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name] = 'User5' AND [id] = OBJECT_id('dbo.Equipment'))
ALTER TABLE dbo.Equipment ADD User5 VARCHAR(50) NOT NULL DEFAULT('')

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name] = 'User6' AND [id] = OBJECT_id('dbo.Equipment'))
ALTER TABLE dbo.Equipment ADD User6 VARCHAR(50) NOT NULL DEFAULT('')

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name] = 'User7' AND [id] = OBJECT_id('dbo.Equipment'))
ALTER TABLE dbo.Equipment ADD User7 VARCHAR(50) NOT NULL DEFAULT('')

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name] = 'User8' AND [id] = OBJECT_id('dbo.Equipment'))
ALTER TABLE dbo.Equipment ADD User8 VARCHAR(50) NOT NULL DEFAULT('')

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name] = 'User9' AND [id] = OBJECT_id('dbo.Equipment'))
ALTER TABLE dbo.Equipment ADD User9 VARCHAR(50) NOT NULL DEFAULT('')

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name] = 'Service Start Day past 1900' AND [id] = OBJECT_id('dbo.Equipment'))
ALTER TABLE dbo.Equipment ADD [Service Start Day past 1900] int NULL

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name] = 'Expiration Day past 1900' AND [id] = OBJECT_id('dbo.Equipment'))
ALTER TABLE dbo.Equipment ADD [Expiration Day past 1900] int NULL
GO
IF NOT EXISTS(SELECT * FROM dbo.syscolumns WHERE [name]='Timecard Leave Type Mask' AND [id]=OBJECT_ID('dbo.Constant'))
ALTER TABLE dbo.Constant ADD [Timecard Leave Type Mask] int NOT NULL DEFAULT(0x7FFFFFFF)
GO
IF NOT EXISTS(SELECT * FROM dbo.syscolumns WHERE [name]='FTE' AND [id]=OBJECT_ID('dbo.EmployeeLeavePlan'))
ALTER TABLE dbo.EmployeeLeavePlan ADD FTE numeric(9,4) NOT NULL DEFAULT(1)
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [ID] = OBJECT_id('dbo.LeaveLimit') AND [name] = 'Enable After Months')
ALTER TABLE dbo.LeaveLimit ADD [Enable After Months] int NOT NULL default(0)
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [ID] = OBJECT_id('dbo.LeaveLimit') AND [name] = 'Flags')
ALTER TABLE dbo.LeaveLimit ADD [Flags] int NOT NULL default(0)
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name] = 'VIN' AND [id] = OBJECT_id('dbo.Equipment'))
ALTER TABLE dbo.Equipment ADD [VIN] VARCHAR(50) NOT NULL DEFAULT('')
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name] = 'Year' AND [id] = OBJECT_id('dbo.Equipment'))
ALTER TABLE dbo.Equipment ADD [Year] int NULL
GO
IF OBJECT_ID('dbo.EquipmentTypeAccessory') IS NULL
BEGIN
	CREATE TABLE dbo.EquipmentTypeAccessory (
		AccessoryID int IDENTITY(1,1) NOT NULL PRIMARY KEY,
		TypeID int NOT NULL,
		Accessory varchar(50) NOT NULL
	)

	ALTER TABLE dbo.EquipmentTypeAccessory ADD CONSTRAINT FK_EquipmentTypeAccessory FOREIGN KEY (TypeID) REFERENCES dbo.EquipmentType (TypeID) ON DELETE CASCADE

	CREATE INDEX IX_EquipmentTypeAccessory_TypeID ON dbo.EquipmentTypeAccessory(TypeID)
END
GO
IF OBJECT_ID('dbo.EquipmentAccessory') IS NULL
BEGIN
	CREATE TABLE dbo.EquipmentAccessory (
		ItemID int IDENTITY(1,1) NOT NULL PRIMARY KEY,
		EquipmentID int NOT NULL,
		AccessoryID int NOT NULL
	)

	IF OBJECT_id('dbo.FK_EquipmentAccessory') IS NULL
	ALTER TABLE dbo.EquipmentAccessory ADD CONSTRAINT FK_EquipmentAccessory FOREIGN KEY (EquipmentID) REFERENCES dbo.Equipment(EquipmentID) ON DELETE CASCADE

	IF OBJECT_id('dbo.FK_EquipmentAccessory') IS NULL
	ALTER TABLE dbo.EquipmentAccessory ADD CONSTRAINT FK_EquipmentAccessory FOREIGN KEY (AccessoryID) REFERENCES dbo.EquipmentTypeAccessory(AccessoryID) ON DELETE CASCADE

	CREATE UNIQUE INDEX IX_EquipmentAccessory_EquipmentIDAccessoryID ON dbo.EquipmentAccessory(EquipmentID,AccessoryID) WITH IGNORE_DUP_KEY
	CREATE INDEX IX_EquipmentAccessory_EquipmentID ON dbo.EquipmentAccessory(EquipmentID)
	CREATE INDEX IX_EquipmentAccessory_AccessoryID ON dbo.EquipmentAccessory(AccessoryID)
END
GO
IF OBJECT_ID('dbo.HolidayPlan') IS NULL
BEGIN
	CREATE TABLE dbo.HolidayPlan (
		PlanID int PRIMARY KEY IDENTITY(1,1),
		[Plan] varchar(50) NOT NULL,
		Flags int NOT NULL
	)
END
GO
IF (SELECT COUNT(*) FROM dbo.HolidayPlan) = 0 INSERT dbo.HolidayPlan([Plan],Flags) VALUES ('Holidays',1)
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [id]=OBJECT_ID('dbo.Holiday') AND [name]='PlanID')
ALTER TABLE dbo.Holiday ADD PlanID int NOT NULL DEFAULT (1)
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [id]=OBJECT_ID('dbo.Holiday') AND [name]='Flags')
ALTER TABLE dbo.Holiday ADD Flags int NOT NULL DEFAULT (0)
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [id]=OBJECT_ID('dbo.Holiday') AND [name]='Length')
ALTER TABLE dbo.Holiday ADD [Length] int NOT NULL DEFAULT (1)
GO
IF OBJECT_ID('CK_Holiday_DayOfMonth') IS NOT NULL ALTER TABLE [dbo].[Holiday] DROP CONSTRAINT [CK_Holiday_DayOfMonth]
GO
ALTER TABLE [dbo].[Holiday]  WITH NOCHECK ADD  
CONSTRAINT [CK_Holiday_DayOfMonth] CHECK  (([Month] >= 1 and [Month] <= 12 and ([Day] >= 1 and [Day] <= [dbo].[GetLastDayOfMonth]([Month], [Year]))))
GO
IF OBJECT_ID('FK_Holiday_HolidayPlan') IS NULL
ALTER TABLE dbo.Holiday WITH NOCHECK ADD CONSTRAINT FK_Holiday_HolidayPlan FOREIGN KEY (PlanID) REFERENCES dbo.HolidayPlan (PlanID)

IF NOT EXISTS(SELECT * FROM sysindexes WHERE [name]='IX_Holiday_PlanID') CREATE INDEX IX_Holiday_PlanID ON dbo.Holiday(PlanID)
GO
IF OBJECT_ID('dbo.HolidayCalculated') IS NULL
BEGIN
	CREATE TABLE dbo.HolidayCalculated (
		ItemID int NOT NULL PRIMARY KEY IDENTITY(1,1),
		HolidayID int NOT NULL,
		Holiday varchar(50) NOT NULL,
		PlanID int NOT NULL,
		X datetime NOT NULL,
		Y datetime NOT NULL,
		A int NOT NULL,
		B int NOT NULL,
		YR int NULL,
		[Week] bit NOT NULL
	)

	CREATE INDEX IX_HolidayCalculated_HolidayID ON dbo.HolidayCalculated(HolidayID)
	CREATE INDEX IX_HolidayCalculated_PlanID ON dbo.HolidayCalculated(PlanID)
	CREATE INDEX IX_HolidayCalculated_X ON dbo.HolidayCalculated(X)
	CREATE INDEX IX_HolidayCalculated_Y ON dbo.HolidayCalculated(Y)
	CREATE INDEX IX_HolidayCalculated_A ON dbo.HolidayCalculated(A)
	CREATE INDEX IX_HolidayCalculated_B ON dbo.HolidayCalculated(B)
	CREATE INDEX IX_HolidayCalculated_YR ON dbo.HolidayCalculated(YR)

	ALTER TABLE dbo.HolidayCalculated ADD CONSTRAINT [FK_HolidayCalculated_Holiday] FOREIGN KEY (HolidayID) REFERENCES dbo.Holiday (HolidayID) ON DELETE CASCADE
END
GO
GRANT SELECT ON dbo.HolidayCalculated TO public
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [id]=OBJECT_ID('dbo.Employee') AND [name]='HolidayPlanID')
ALTER TABLE dbo.Employee ADD HolidayPlanID int NOT NULL DEFAULT (1)

IF NOT EXISTS(SELECT * FROM sysindexes WHERE [name]='IX_Employee_HolidayPlanID') CREATE INDEX IX_Employee_HolidayPlanID ON dbo.Employee(HolidayPlanID)
GO
IF OBJECT_ID('FK_Employee_HolidayPlan') IS NULL
ALTER TABLE dbo.Employee WITH NOCHECK ADD CONSTRAINT FK_Employee_HolidayPlan FOREIGN KEY (HolidayPlanID) REFERENCES dbo.HolidayPlan (PlanID)
GO
ALTER TABLE dbo.EmployeeExpense ALTER COLUMN [Employee Comment] varchar(400) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL
ALTER TABLE dbo.EmployeeExpense ALTER COLUMN [Manager Comment] varchar(400) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [id]=OBJECT_ID('dbo.EmployeeExpense') AND [name]='Attachment')
ALTER TABLE dbo.EmployeeExpense ADD Attachment image NULL

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [id]=OBJECT_ID('dbo.EmployeeExpense') AND [name]='Attachment Name')
ALTER TABLE dbo.EmployeeExpense ADD [Attachment Name] varchar(50) NOT NULL DEFAULT('')

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [id]=OBJECT_ID('dbo.EmployeeExpense') AND [name]='Reimbursed Check Number')
ALTER TABLE dbo.EmployeeExpense ADD [Reimbursed Check Number] varchar(50) NOT NULL DEFAULT('')

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [id]=OBJECT_ID('dbo.EmployeeExpense') AND [name]='Created Day past 1900')
ALTER TABLE dbo.EmployeeExpense ADD [Created Day past 1900] int NOT NULL DEFAULT(DATEDIFF(d,0,GETDATE()))

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [id]=OBJECT_ID('dbo.EmployeeExpense') AND [name]='Miles')
ALTER TABLE dbo.EmployeeExpense ADD [Miles] numeric(9,2) NOT NULL DEFAULT(0)

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [id]=OBJECT_ID('dbo.EmployeeExpense') AND [name]='GLAccountID')
BEGIN
	ALTER TABLE dbo.EmployeeExpense ADD GLAccountID int NULL

	ALTER TABLE dbo.EmployeeExpense ADD CONSTRAINT FK_EmployeeExpense_GLAccount FOREIGN KEY(GLAccountID)
	REFERENCES dbo.GLAccount(AccountID)

	CREATE NONCLUSTERED INDEX IX_EmployeeExpense_GLAccountID ON dbo.EmployeeExpense(GLAccountID)
	CREATE NONCLUSTERED INDEX IX_EmployeeExpense_AccountIDGLAccountID ON dbo.EmployeeExpense(AccountID,GLAccountID)
END

IF EXISTS(SELECT * FROM syscolumns WHERE [id]=OBJECT_ID('dbo.GLAccount') AND [name]='Number' AND xtype=56)
BEGIN
	IF EXISTS(SELECT * FROM sysindexes WHERE [name] = 'IX_GLAccount_Number') DROP INDEX dbo.GLAccount.IX_GLAccount_Number
	ALTER TABLE dbo.GLAccount ALTER COLUMN Number varchar(50) NOT NULL
END

IF OBJECT_ID('CK_EmployeeExpense_ReimbursementApproved') IS NULL AND NOT EXISTS(SELECT * FROM dbo.EmployeeExpense WHERE [Day Reimbursed] IS NULL AND StatusID NOT IN (1,5))
ALTER TABLE dbo.EmployeeExpense ADD CONSTRAINT CK_EmployeeExpense_ReimbursementApproved CHECK ([Day Reimbursed] IS NULL OR StatusID IN (1,5))
GO
IF OBJECT_ID('dbo.AttachmentTemp') IS NULL
CREATE TABLE dbo.AttachmentTemp(
	AttachmentID int NOT NULL PRIMARY KEY IDENTITY(1,1),
	[Attachment] image NOT NULL,
	[Name] varchar(50) NOT NULL,
	[Type] varchar(50) NOT NULL,
	[SID] varbinary(85) DEFAULT SUSER_SID(),
	Created datetime DEFAULT GETDATE()
)
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [id]=OBJECT_ID('dbo.EmployeeExpense') AND [name]='Attachment Name')
ALTER TABLE dbo.EmployeeExpense ADD [Attachment Name] varchar(50) NOT NULL DEFAULT('')

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [id]=OBJECT_ID('dbo.EmployeeExpense') AND [name]='Attachment MIME Type')
ALTER TABLE dbo.EmployeeExpense ADD [Attachment MIME Type] varchar(50) NOT NULL DEFAULT('')

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [id]=OBJECT_ID('dbo.EmployeeExpense') AND [name]='Miles')
ALTER TABLE dbo.EmployeeExpense ADD [Miles] numeric(9,2) NOT NULL DEFAULT(0)

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [id]=OBJECT_ID('dbo.EmployeeExpense') AND [name]='Reimbursed Check Number')
ALTER TABLE dbo.EmployeeExpense ADD [Reimbursed Check Number] varchar(50) NOT NULL DEFAULT('')

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [id]=OBJECT_ID('dbo.PersonXTraining') AND [name]='Comments')
ALTER TABLE dbo.PersonXTraining ADD Comments varchar(50) NOT NULL DEFAULT('')

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [id]=OBJECT_ID('dbo.PersonXTraining') AND [name]='Expires Day past 1900')
ALTER TABLE dbo.PersonXTraining ADD [Expires Day past 1900] int NULL

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [id]=OBJECT_ID('dbo.PersonXTraining') AND [name]='Hours')
ALTER TABLE dbo.PersonXTraining ADD Hours numeric(9,4) NOT NULL DEFAULT(0)

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [id]=OBJECT_ID('dbo.PersonXTraining') AND [name]='Flags')
ALTER TABLE dbo.PersonXTraining ADD Flags int NOT NULL DEFAULT(0)

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [id]=OBJECT_ID('dbo.LeaveRate') AND [name]='Ineligible Months')
ALTER TABLE dbo.LeaveRate ADD [Ineligible Months] int NOT NULL DEFAULT(0)

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [id]=OBJECT_ID('dbo.LeaveRate') AND [name]='Flags')
ALTER TABLE dbo.LeaveRate ADD [Flags] int NOT NULL DEFAULT(0)
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name]='OrgUserField1' AND [id]=OBJECT_ID('dbo.Employee'))
ALTER TABLE dbo.Employee ADD OrgUserField1 int NULL
GO
IF OBJECT_id('FK_Employee_UserField1') IS NULL
ALTER TABLE dbo.Employee  WITH CHECK ADD CONSTRAINT FK_Employee_UserField1 FOREIGN KEY(OrgUserField1)
REFERENCES dbo.UserFieldItem(ItemID)
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [id]=OBJECT_ID('dbo.EmployeeTime') AND [name]='Last Approved Day past 1900') 
ALTER TABLE dbo.EmployeeTime ADD [Last Approved Day past 1900] int NULL
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [id]=OBJECT_ID('dbo.EmployeeTime') AND [name]='Last Approved by') 
ALTER TABLE dbo.EmployeeTime ADD [Last Approved by] sysname NOT NULL  DEFAULT('')
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [id]=OBJECT_ID('dbo.EmployeeTime') AND [name]='Last Submitted Day past 1900') 
ALTER TABLE dbo.EmployeeTime ADD [Last Submitted Day past 1900] int NULL
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [id]=OBJECT_ID('dbo.EmployeeTime') AND [name]='Last Submitted by') 
ALTER TABLE dbo.EmployeeTime ADD [Last Submitted by] sysname NOT NULL DEFAULT('')
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [id]=OBJECT_ID('dbo.EmployeeTime') AND [name]='Time Flags') 
ALTER TABLE dbo.EmployeeTime ADD [Time Flags] int NOT NULL DEFAULT(0)
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [id]=OBJECT_id('dbo.Employee') AND [name]='InOutStatusID')
ALTER TABLE dbo.Employee ADD InOutStatusID int NOT NULL DEFAULT(1)

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [id]=OBJECT_id('dbo.Employee') AND [name]='InOutReturn')
ALTER TABLE dbo.Employee ADD InOutReturn smalldatetime NULL

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [id]=OBJECT_id('dbo.Employee') AND [name]='InOutLastSource')
ALTER TABLE dbo.Employee ADD InOutLastSource varchar(50) NOT NULL DEFAULT('')

IF OBJECT_ID('FK_Employee_InOutStatus') IS NULL
ALTER TABLE dbo.Employee WITH NOCHECK ADD CONSTRAINT FK_Employee_InOutStatus FOREIGN KEY(InOutStatusID) REFERENCES dbo.InOutStatus(StatusID)

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [id]=OBJECT_id('dbo.Employee') AND [name]='InOutLastUpdated')
ALTER TABLE dbo.Employee ADD InOutLastUpdated smalldatetime NULL

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [id]=OBJECT_id('dbo.Employee') AND [name]='InOutComment')
ALTER TABLE dbo.Employee ADD InOutComment varchar(50) NOT NULL DEFAULT('')
GO
IF NOT EXISTS(SELECT * FROM dbo.Error WHERE ErrorID=50058)
INSERT dbo.Error(ErrorID, Error) VALUES(50058, 'You cannot delete the last position.')
GO
IF OBJECT_id('dbo.TaskEmail') IS NOT NULL AND NOT EXISTS(SELECT * FROM dbo.syscolumns WHERE [name]='Text' AND [id]=OBJECT_id('dbo.TaskEmail'))
DROP TABLE dbo.TaskEmail

IF OBJECT_id('dbo.TaskEmail') IS NULL
BEGIN
	CREATE TABLE dbo.[TaskEmail] (
		[EmailID] [int] NOT NULL ,
		[Recipient] [varchar] (50) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL ,
		[Reminder] [bit] NOT NULL ,
		[ID] [int] NOT NULL ,
		[Sent] [smalldatetime] NOT NULL DEFAULT GETDATE(),
		Source varchar(50) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL DEFAULT '',
		[Text] varchar(400) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL DEFAULT ''
	) ON [PRIMARY]
	
	
	ALTER TABLE dbo.[TaskEmail] WITH NOCHECK ADD 
		CONSTRAINT [PK_TaskEmail] PRIMARY KEY  CLUSTERED 
		(
			[EmailID]
		)  ON [PRIMARY] 
	CREATE  INDEX IX_TaskEmail_Sent ON dbo.TaskEmail([Sent])
	CREATE  INDEX IX_TaskEmail ON dbo.TaskEmail([Recipient], [ID])
END
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name]='Source' AND [id]=OBJECT_ID('dbo.TaskEmail'))
ALTER TABLE dbo.TaskEmail ADD Source varchar(50) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL DEFAULT ''
GO
/*IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name]='LDAPGuid' AND [id]=OBJECT_ID('Person'))
ALTER TABLE dbo.Person ADD LDAPGuid binary(16) NULL

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name]='LDAP Last Synched' AND [id]=OBJECT_ID('Person'))
ALTER TABLE dbo.Person ADD [LDAP Last Synched] datetime NULL
*/
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [ID] = OBJECT_ID('dbo.EmployeeLeaveUsed') AND [Name] = 'First Day Used')
ALTER TABLE dbo.EmployeeLeaveUsed ADD [First Day Used] int NULL

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [ID] = OBJECT_ID('dbo.EmployeeLeaveUsed') AND [Name] = 'Last Day Used')
ALTER TABLE dbo.EmployeeLeaveUsed ADD [Last Day Used] int NULL
GO
UPDATE U SET [First Day Used] = (
	SELECT MIN(I.[Day past 1900]) FROM EmployeeLeaveUsedItem I WHERE I.LeaveID = U.LeaveID
), [Last Day Used] = (
	SELECT MAX(I.[Day past 1900]) FROM EmployeeLeaveUsedItem I WHERE I.LeaveID = U.LeaveID
) FROM EmployeeLeaveUsed U
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [id]=OBJECT_id('dbo.PermissionScopeAttribute') AND [name]='Deny Mask')
ALTER TABLE dbo.PermissionScopeAttribute ADD [Deny Mask] int NOT NULL DEFAULT(0)

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [id]=OBJECT_id('dbo.TempPersonPermission') AND [name]='Deny Mask')
ALTER TABLE dbo.TempPersonPermission ADD [Deny Mask] int NOT NULL DEFAULT(0)
GO
IF OBJECT_ID('dbo.EmployeeAuthorizedOT') IS NULL
BEGIN
	CREATE TABLE dbo.EmployeeAuthorizedOT (
		AuthorizedID int NOT NULL PRIMARY KEY IDENTITY(1,1),
		EmployeeID int NOT NULL,
		[Start Day past 1900] int NOT NULL,
		[Stop Day past 1900] int NOT NULL,
		[Employee Comment] varchar(50) NOT NULL DEFAULT(''),
		[Manager Comment] varchar(50) NOT NULL DEFAULT(''),
		StatusID int NOT NULL -- 1 approved, 2 denied, 5 approved with changes, 8 pending
	)
END
GO
IF OBJECT_ID('FK_EmployeeAuthorizedOT_Employee') IS NULL
ALTER TABLE dbo.EmployeeAuthorizedOT ADD 
CONSTRAINT FK_EmployeeAuthorizedOT_Employee FOREIGN KEY (EmployeeID) REFERENCES dbo.Employee (EmployeeID) ON DELETE CASCADE
GO
IF OBJECT_ID('CK_EmployeeAuthorizedOT_StatusID') IS NULL
ALTER TABLE dbo.EmployeeAuthorizedOT ADD CONSTRAINT CK_EmployeeAuthorizedOT_StatusID CHECK (StatusID IN (1,2,5,8))
GO
IF OBJECT_ID('CK_EmployeeAuthorizedOT_StartStop') IS NULL
ALTER TABLE dbo.EmployeeAuthorizedOT ADD CONSTRAINT CK_EmployeeAuthorizedOT_StartStop CHECK ([Stop Day past 1900] >= [Start Day past 1900])
GO
IF NOT EXISTS(SELECT * FROM sysindexes WHERE [name] = 'IX_EmployeeAuthorizedOT_EmployeeID' AND [id] = OBJECT_id('dbo.EmployeeAuthorizedOT'))
CREATE INDEX IX_EmployeeAuthorizedOT_EmployeeID ON dbo.EmployeeAuthorizedOT(EmployeeID)
GO
IF NOT EXISTS(SELECT * FROM sysindexes WHERE [name] = 'IX_EmployeeAuthorizedOT_EmployeeIDStartStop' AND [id] = OBJECT_id('dbo.EmployeeAuthorizedOT'))
CREATE INDEX IX_EmployeeAuthorizedOT_EmployeeIDStartStop ON dbo.EmployeeAuthorizedOT(EmployeeID, [Start Day past 1900], [Stop Day past 1900])
GO
IF OBJECT_ID('dbo.EmployeeTimeExceptionItem') IS NULL
CREATE TABLE dbo.EmployeeTimeExceptionItem (
	ExceptionID int PRIMARY KEY NOT NULL,
	Exception varchar(50) NOT NULL,
	[Order] int NOT NULL
)
GO
IF NOT EXISTS (SELECT * FROM dbo.EmployeeTimeExceptionItem WHERE ExceptionID=1)
INSERT dbo.EmployeeTimeExceptionItem(ExceptionID, Exception, [Order])
SELECT 1, 'In punch time outside of shift time.', 10

IF NOT EXISTS (SELECT * FROM dbo.EmployeeTimeExceptionItem WHERE ExceptionID=2)
INSERT dbo.EmployeeTimeExceptionItem(ExceptionID, Exception, [Order])
SELECT 2, 'No in punch during "on" day of shift.', 20

IF NOT EXISTS (SELECT * FROM dbo.EmployeeTimeExceptionItem WHERE ExceptionID=4)
INSERT dbo.EmployeeTimeExceptionItem(ExceptionID, Exception, [Order])
SELECT 4, 'No in punch (regardless of shift).', 30

IF NOT EXISTS (SELECT * FROM dbo.EmployeeTimeExceptionItem WHERE ExceptionID=8)
INSERT dbo.EmployeeTimeExceptionItem(ExceptionID, Exception, [Order])
SELECT 8, 'In punch during "off" day of shift.', 40

IF NOT EXISTS (SELECT * FROM dbo.EmployeeTimeExceptionItem WHERE ExceptionID=0x10)
INSERT dbo.EmployeeTimeExceptionItem(ExceptionID, Exception, [Order])
SELECT 0x10, 'Out punch outside of shift.', 50

IF NOT EXISTS (SELECT * FROM dbo.EmployeeTimeExceptionItem WHERE ExceptionID=0x20)
INSERT dbo.EmployeeTimeExceptionItem(ExceptionID, Exception, [Order])
SELECT 0x20, 'No out punch.', 60

IF NOT EXISTS (SELECT * FROM dbo.EmployeeTimeExceptionItem WHERE ExceptionID=0x40)
INSERT dbo.EmployeeTimeExceptionItem(ExceptionID, Exception, [Order])
SELECT 0x40, 'Employee not enrolled in project.', 70

IF NOT EXISTS (SELECT * FROM dbo.EmployeeTimeExceptionItem WHERE ExceptionID=0x80)
INSERT dbo.EmployeeTimeExceptionItem(ExceptionID, Exception, [Order])
SELECT 0x80, 'Pay rate is 0.', 80

IF NOT EXISTS (SELECT * FROM dbo.EmployeeTimeExceptionItem WHERE ExceptionID=0x100)
INSERT dbo.EmployeeTimeExceptionItem(ExceptionID, Exception, [Order])
SELECT 0x100, 'Project is unassigned.', 90

IF NOT EXISTS (SELECT * FROM dbo.EmployeeTimeExceptionItem WHERE ExceptionID=0x200)
INSERT dbo.EmployeeTimeExceptionItem(ExceptionID, Exception, [Order])
SELECT 0x200, 'OT is unauthorized.', 100

IF NOT EXISTS (SELECT * FROM dbo.EmployeeTimeExceptionItem WHERE ExceptionID=0x400)
INSERT dbo.EmployeeTimeExceptionItem(ExceptionID, Exception, [Order])
SELECT 0x400, 'Out punch preceeds in punch.', 110

IF NOT EXISTS (SELECT * FROM dbo.EmployeeTimeExceptionItem WHERE ExceptionID=0x800)
INSERT dbo.EmployeeTimeExceptionItem(ExceptionID, Exception, [Order])
SELECT 0x800, 'Adjustment. Time inside date range. PPE outside.', 120

IF NOT EXISTS (SELECT * FROM dbo.EmployeeTimeExceptionItem WHERE ExceptionID=0x1000)
INSERT dbo.EmployeeTimeExceptionItem(ExceptionID, Exception, [Order])
SELECT 0x1000, 'Adjustment. PPE inside date range. Time outside.', 130

IF NOT EXISTS (SELECT * FROM dbo.EmployeeTimeExceptionItem WHERE ExceptionID=0x2000)
INSERT dbo.EmployeeTimeExceptionItem(ExceptionID, Exception, [Order])
SELECT 0x2000, 'Pending time preceeds date range.', 140

IF NOT EXISTS (SELECT * FROM dbo.EmployeeTimeExceptionItem WHERE ExceptionID=0x4000)
INSERT dbo.EmployeeTimeExceptionItem(ExceptionID, Exception, [Order])
SELECT 0x4000, 'Late punch.', 45
GO
IF OBJECT_ID('dbo.spEmployeeTimeExceptionItemList') IS NOT NULL DROP PROC dbo.spEmployeeTimeExceptionItemList 
GO
CREATE PROC dbo.spEmployeeTimeExceptionItemList AS SELECT ExceptionID, Exception, [Order] FROM dbo.EmployeeTimeExceptionItem ORDER BY [Order]
GO
GRANT EXEC ON dbo.spEmployeeTimeExceptionItemList TO public
GO
IF NOT EXISTS(SELECT * FROM dbo.LeaveRatePeriod WHERE PeriodID=16386)
INSERT dbo.LeaveRatePeriod(PeriodID,GroupID,Period,Example,Payroll,[Order],Tag,[Weekday])
SELECT 16386, 2, 'Every January 1 (III)', 'Credit on date of hire and then credit every Jan 1',0,272,null,0

IF NOT EXISTS(SELECT * FROM dbo.LeaveRatePeriod WHERE PeriodID=18434)
INSERT dbo.LeaveRatePeriod(PeriodID,GroupID,Period,Example,Payroll,[Order],Tag,[Weekday])
SELECT 18434, 2, 'Every January 1 (II)', 'If senority starts Apr 3 then credit 40hrs on Apr 3 and credit all on Jan 1',0,270,null,0

IF NOT EXISTS(SELECT * FROM dbo.LeaveRatePeriod WHERE PeriodID=20482)
INSERT dbo.LeaveRatePeriod(PeriodID, GroupID, Period, Example, Payroll, [Order], [Weekday])
SELECT 20482, 2, 'Annual Credit', 'If seniority starts Jan 3 then credit on 3rd day of first eligible month', 0, 250, 0

IF NOT EXISTS(SELECT * FROM dbo.LeaveRatePeriod WHERE PeriodID=279040)
INSERT dbo.LeaveRatePeriod(PeriodID, GroupID, Period, Example, Payroll, [Order], [Weekday])
SELECT 279040, 512, 'Leave per 1000 Hrs Worked', 'Periodically click "Leave > Enter Timecards or Leave for Many Employees" to apply credits', 0, 30001, 0
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name]='PrimaryLanguages2' AND [id]=OBJECT_ID('dbo.PersonX'))
ALTER TABLE dbo.PersonX ADD PrimaryLanguages2 varchar(400) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL DEFAULT('')

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name]='SecondaryLanguages2' AND [id]=OBJECT_ID('dbo.PersonX'))
ALTER TABLE dbo.PersonX ADD SecondaryLanguages2 varchar(400) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL DEFAULT('')
GO
IF OBJECT_id('dbo.AuditTrail') IS NULL
BEGIN
	CREATE TABLE dbo.AuditTrail(ItemID int NOT NULL PRIMARY KEY IDENTITY(1,1), SID varbinary(85) NOT NULL, [User] sysname NOT NULL, RegardingPersonID int NULL, [ID] int NULL, ObjectID int NOT NULL, [Event Mask] int NOT NULL, Event varchar(4000) NOT NULL, Created datetime NOT NULL DEFAULT(GETDATE()), TableID int NOT NULL)
	CREATE INDEX IX_AuditTrail_PersonID ON dbo.AuditTrail(RegardingPersonID)
	CREATE INDEX IX_AuditTrail_ObjectID ON dbo.AuditTrail(ObjectID)
	CREATE INDEX IX_AuditTrail_PersonIDObjectID ON dbo.AuditTrail(RegardingPersonID,ObjectID)
	CREATE INDEX IX_AuditTrail_Created ON dbo.AuditTrail(Created)
END
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name]='TableID' AND [id]=OBJECT_ID('dbo.AuditTrail'))
BEGIN
	-- 1: Person, 4: PersonX, 10001: LeaveUsed, 10002: LeaveUsedItem, 10003: LeaveEarned,, 262144: Timecards, 1073741824: EmployeeComp
	ALTER TABLE dbo.AuditTrail ADD TableID int NOT NULL DEFAULT(0)
	EXEC sp_executesql N'UPDATE dbo.AuditTrail SET TableID=ObjectID'
END
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name]='FieldInvisibleMask' AND [id]=OBJECT_ID('dbo.Constant'))
ALTER TABLE dbo.Constant ADD FieldInvisibleMask bigint NOT NULL DEFAULT 0
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name]='EmployeeTimeZKQImportEnable' AND [id]=OBJECT_ID('dbo.Constant'))
ALTER TABLE dbo.Constant ADD EmployeeTimeZKQImportEnable bit NOT NULL DEFAULT(1)
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [id]=OBJECT_ID('dbo.Constant') AND [name]='Max Shift Seconds')
ALTER TABLE dbo.Constant ADD [Max Shift Seconds] int NOT NULL DEFAULT(54000)
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name] = 'GMT+Hours' AND [id] = OBJECT_id('dbo.EmployeeTime'))
ALTER TABLE dbo.EmployeeTime ADD [GMT+Hours] int NULL
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [id]=OBJECT_ID('dbo.Race') AND [name]='Report Column')
ALTER TABLE dbo.Race ADD [Report Column] int NOT NULL DEFAULT(-1)
GO
IF NOT EXISTS(SELECT * FROM sysindexes WHERE [ID] = OBJECT_id('EmployeeTime') AND [name] = 'IX_EmployeeTime_EmployeeID_In') 
CREATE INDEX IX_EmployeeTime_EmployeeID_In ON dbo.EmployeeTime(EmployeeID,[In]) WITH  FILLFACTOR = 90
GO
UPDATE dbo.Project SET [Note] = '' WHERE [Note] IS NULL
ALTER TABLE dbo.Project ALTER COLUMN [Note] varchar(4000) NOT NULL
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [id]=OBJECT_ID('dbo.Union') AND [name]='BU')
ALTER TABLE dbo.[Union] ADD BU varchar(5) NOT NULL DEFAULT('')

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [id]=OBJECT_ID('dbo.Employee') AND [name]='Terminal Password')
ALTER TABLE dbo.Employee ADD [Terminal Password] varchar(50) NOT NULL DEFAULT('')

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [id]=OBJECT_ID('dbo.Employee') AND [name]='PID Card Number')
ALTER TABLE dbo.Employee ADD [PID Card Number] varchar(50) NOT NULL DEFAULT('')

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [id]=OBJECT_ID('dbo.Employee') AND [name]='TerminalSyncFlags')
BEGIN
	ALTER TABLE dbo.Employee ADD [TerminalSyncFlags] int NOT NULL DEFAULT(0x37)
	EXEC sp_executesql N'UPDATE dbo.Employee SET TerminalSyncFlags=0x39 WHERE [Active Employee]=0'
END
ELSE
BEGIN
	EXEC dbo.spAdminDropDefault 'dbo.Employee', 'TerminalSyncFlags'
	ALTER TABLE dbo.Employee WITH NOCHECK ADD CONSTRAINT DF_Employee_TerminalSyncFlags DEFAULT (0x37) FOR TerminalSyncFlags
END

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [id]=OBJECT_ID('dbo.Employee') AND [name]='TerminalSyncFlags2')
ALTER TABLE dbo.Employee ADD [TerminalSyncFlags2] int NOT NULL DEFAULT(0)

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [id]=OBJECT_ID('dbo.Employee') AND [name]='Terminal Last Sync')
ALTER TABLE dbo.Employee ADD [Terminal Last Sync] datetime NULL

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [id]=OBJECT_ID('dbo.Employee') AND [name]='Enrolled Terminals Mask')
ALTER TABLE dbo.Employee ADD [Enrolled Terminals Mask] int NOT NULL DEFAULT(0)

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [id]=OBJECT_ID('dbo.Employee') AND [name]='Terminal Sync State Mask')
ALTER TABLE dbo.Employee ADD [Terminal Sync State Mask] int NOT NULL DEFAULT(0x2F)

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [id]=OBJECT_ID('dbo.Employee') AND [name]='Fingerprints Stream')
ALTER TABLE dbo.Employee ADD [Fingerprints Stream] image NULL
GO

IF NOT EXISTS(SELECT * FROM Error WHERE ErrorID = 50057)
INSERT dbo.Error(ErrorID,Error) VALUES(50057, 'This terminal cannot be added because the system can only track 31 terminals.')
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [id]=OBJECT_ID('dbo.Project') AND [name]='DefaultTimeTypeID')
ALTER TABLE dbo.Project ADD DefaultTimeTypeID int NULL
GO
IF OBJECT_ID('FK_Project_TimeType') IS NULL
ALTER TABLE dbo.Project ADD CONSTRAINT [FK_Project_TimeType] FOREIGN KEY (DefaultTimeTypeID) REFERENCES dbo.[TimeType] (TypeID)
GO
IF NOT EXISTS(SELECT * FROM sysindexes WHERE [ID] = OBJECT_id('dbo.TempXYZ') AND [name] = 'IX_TempXYZ_BatchID_ID_X')
CREATE INDEX IX_TempXYZ_BatchID_ID_X ON dbo.TempXYZ(BatchID, [ID], X)
GO
IF NOT EXISTS(SELECT * FROM sysindexes WHERE [ID]=OBJECT_ID('dbo.PersonX') AND [name]='IX_PersonX_SSN')
CREATE INDEX IX_PersonX_SSN ON dbo.PersonX(SSN)
GO
IF NOT EXISTS(SELECT * FROM sysindexes WHERE [ID]=OBJECT_ID('dbo.Employee') AND [name]='IX_Employee_EmployeeNumber')
CREATE INDEX IX_Employee_EmployeeNumber ON dbo.Employee([Employee Number])
GO
IF OBJECT_ID('dbo.fnGetLanguageColumnName') IS NOT NULL DROP FUNCTION dbo.fnGetLanguageColumnName
GO
CREATE FUNCTION dbo.fnGetLanguageColumnName(@proficiency_id int)
RETURNS sysname
AS BEGIN RETURN 'LP_' + CAST(@proficiency_id AS sysname) + '_X' END
GO
-- Creates a calculated pivot table to hold languages per proficiency
IF OBJECT_ID('dbo.PersonXLanguageFlat') IS NULL
BEGIN
	CREATE TABLE dbo.PersonXLanguageFlat(LPPersonID int NOT NULL PRIMARY KEY)
	CREATE INDEX IX_PersonXLanguageFlat_PersonID ON dbo.PersonXLanguageFlat(LPPersonID)

	ALTER TABLE dbo.PersonXLanguageFlat ADD 
	CONSTRAINT FK_PersonXLanguageFlat_PersonID FOREIGN KEY (LPPersonID) 
	REFERENCES dbo.PersonX(PersonID) ON DELETE CASCADE

	INSERT dbo.PersonXLanguageFlat(LPPersonID) SELECT PersonID FROM dbo.PersonX
END
GO
IF OBJECT_ID('dbo.PersonXAddFlatTableRowOnInsert') IS NOT NULL DROP TRIGGER dbo.PersonXAddFlatTableRowOnInsert
GO
-- Adds a row to PersonXLanguageFlat when a row is added to PersonX
CREATE TRIGGER dbo.PersonXAddFlatTableRowOnInsert ON dbo.PersonX FOR INSERT AS
INSERT dbo.PersonXLanguageFlat(LPPersonID) SELECT PersonID FROM inserted
GO
IF OBJECT_ID('dbo.LanguageProficiency') IS NULL
BEGIN
	CREATE TABLE dbo.LanguageProficiency(
		ProficiencyID int NOT NULL PRIMARY KEY IDENTITY(1,1),
		Proficiency varchar(50) NOT NULL,
		[Level] int NOT NULL,
		Flags int NOT NULL DEFAULT(0)
	)
END
GO
IF OBJECT_ID('dbo.LanguageProficiencyAddFlatTableColumnOnInsert') IS NOT NULL DROP TRIGGER dbo.LanguageProficiencyAddFlatTableColumnOnInsert
GO




-- Adds a column to PersonXLanguageFlat when a row is added to LanguageProficiency
CREATE TRIGGER dbo.LanguageProficiencyAddFlatTableColumnOnInsert ON dbo.LanguageProficiency FOR INSERT AS
DECLARE @colname sysname, @sql nvarchar(4000), @proficiency_id int

CREATE TABLE #DEPENDENT_VIEWS(ID int, [Order] int NOT NULL identity(1,1))
EXEC dbo.spAdminDependentViews_Identify 'dbo.PersonXLanguageFlat'

DECLARE p_cursor CURSOR LOCAL FORWARD_ONLY STATIC FOR SELECT ProficiencyID FROM inserted
OPEN p_cursor 
FETCH p_cursor INTO @proficiency_id
WHILE @@FETCH_STATUS=0
BEGIN
	SET @colname = dbo.fnGetLanguageColumnName(@proficiency_id)
	SET @sql = 'ALTER TABLE dbo.PersonXLanguageFlat ADD ' + @colname + ' varchar(400) NOT NULL DEFAULT('''') '
	EXEC dbo.spExecSQLAsDBO @sql
	FETCH p_cursor INTO @proficiency_id
END
CLOSE p_cursor DEALLOCATE p_cursor

EXEC dbo.spAdminDependentViews_Refresh
GO
IF OBJECT_ID('dbo.LanguageProficiencyRemoveFlatTableColumnOnDelete') IS NOT NULL DROP TRIGGER dbo.LanguageProficiencyRemoveFlatTableColumnOnDelete
GO
-- Removes a column to PersonXLanguageFlat when a row is removed from LanguageProficiency
CREATE TRIGGER dbo.LanguageProficiencyRemoveFlatTableColumnOnDelete ON dbo.LanguageProficiency FOR DELETE AS
DECLARE @colname sysname, @sql nvarchar(4000), @proficiency_id int

CREATE TABLE #DEPENDENT_VIEWS(ID int, [Order] int NOT NULL identity(1,1))
EXEC dbo.spAdminDependentViews_Identify 'dbo.PersonXLanguageFlat'

DECLARE p_cursor CURSOR LOCAL FORWARD_ONLY STATIC FOR SELECT ProficiencyID FROM deleted
OPEN p_cursor 
FETCH p_cursor INTO @proficiency_id
WHILE @@FETCH_STATUS=0
BEGIN
	SET @colname = dbo.fnGetLanguageColumnName(@proficiency_id)
	EXEC dbo.spAdminDropDefault 'dbo.PersonXLanguageFlat', @colname
	SET @sql = 'ALTER TABLE dbo.PersonXLanguageFlat DROP COLUMN ' + @colname
	EXEC dbo.spExecSQLAsDBO @sql
	FETCH p_cursor INTO @proficiency_id
END
CLOSE p_cursor DEALLOCATE p_cursor

EXEC dbo.spAdminDependentViews_Refresh
GO
-- Fills LanguageProficiency with defaults
IF NOT EXISTS(SELECT * FROM dbo.LanguageProficiency)
BEGIN
	INSERT dbo.LanguageProficiency(Proficiency, [Level], Flags) VALUES ('Native', 4, 1)
	INSERT dbo.LanguageProficiency(Proficiency, [Level], Flags) VALUES ('Fluent', 3, 1)
	INSERT dbo.LanguageProficiency(Proficiency, [Level], Flags) VALUES ('Good', 2, 0)
	INSERT dbo.LanguageProficiency(Proficiency, [Level], Flags) VALUES ('Basic', 1, 0)
END
GO
IF OBJECT_ID('dbo.PersonXLanguage') IS NULL
BEGIN
	CREATE TABLE dbo.PersonXLanguage(
		ItemID int NOT NULL PRIMARY KEY IDENTITY(1,1),
		PersonID int NOT NULL,
		LanguageID int NOT NULL,
		ProficiencyID int NOT NULL,
		Comment varchar(50) NOT NULL
	)

	ALTER TABLE dbo.PersonXLanguage ADD 
	CONSTRAINT FK_PersonXLanguage_PersonID FOREIGN KEY (PersonID) 
	REFERENCES dbo.PersonX (PersonID) ON DELETE CASCADE

	ALTER TABLE dbo.PersonXLanguage ADD 
	CONSTRAINT FK_PersonXLanguage_ProficiencyID FOREIGN KEY (ProficiencyID) 
	REFERENCES dbo.LanguageProficiency (ProficiencyID) ON DELETE CASCADE

	ALTER TABLE dbo.PersonXLanguage ADD 
	CONSTRAINT FK_PersonXLanguage_LanguageID FOREIGN KEY (LanguageID) 
	REFERENCES dbo.Language (LanguageID) ON DELETE CASCADE

	CREATE UNIQUE INDEX IX_PersonXLanguage_PersonIDLanguageID ON dbo.PersonXLanguage(PersonID, LanguageID)
	CREATE INDEX IX_PersonXLanguage_PersonID ON dbo.PersonXLanguage(PersonID) 
	CREATE INDEX IX_PersonXLanguage_LanguageID ON dbo.PersonXLanguage(LanguageID)
	CREATE INDEX IX_PersonXLanguage_ProficiencyID ON dbo.PersonXLanguage(ProficiencyID)
	CREATE INDEX IX_PersonXLanguage_PersonIDProficiencyID ON dbo.PersonXLanguage(PersonID, ProficiencyID)  
	CREATE INDEX IX_PersonXLanguage_LanguageIDProficiencyID ON dbo.PersonXLanguage(LanguageID, ProficiencyID)
END
GO
IF OBJECT_ID('dbo.PersonXLanguageUpdateFlatTableCell') IS NOT NULL DROP TRIGGER dbo.PersonXLanguageUpdateFlatTableCell
GO
-- Updates a cell in PersonXLanguageFlat when a row changes in PersonXLanguage
CREATE TRIGGER dbo.PersonXLanguageUpdateFlatTableCell ON dbo.PersonXLanguage FOR INSERT, UPDATE, DELETE AS
DECLARE @person_id int, @proficiency_id int, @sql nvarchar(4000), @colname sysname, @languages varchar(800), @language varchar(50), @rows int
SET NOCOUNT ON

SET ANSI_WARNINGS OFF -- NULL values will be eliminated in MIN functions
CREATE TABLE #PersonXLanguagePivot(PersonID int NOT NULL, ProficiencyID int NOT NULL, Languages varchar(400) COLLATE SQL_Latin1_General_CP1_CI_AS, LastLanguageID int)
INSERT #PersonXLanguagePivot
SELECT DISTINCT PersonID, ProficiencyID, '', NULL FROM inserted
UNION -- Implied distinct
SELECT DISTINCT PersonID, ProficiencyID, '', NULL FROM deleted

CREATE INDEX T07242009_PersonXLanguagePivot ON #PersonXLanguagePivot(PersonID, ProficiencyID)
CREATE INDEX T07242009_PersonXLanguagePivot2 ON #PersonXLanguagePivot(PersonID, ProficiencyID, LastLanguageID)

UPDATE T SET LastLanguageID = (
	SELECT MIN(LanguageID) FROM dbo.PersonXLanguage PL WHERE PL.PersonID = T.PersonID AND PL.ProficiencyID = T.ProficiencyID
)
FROM #PersonXLanguagePivot T

SET @rows = 1
WHILE @rows > 0
BEGIN
	UPDATE T SET Languages = T.Languages + CASE WHEN T.Languages='' THEN '' ELSE ', ' END + L.Language
	FROM #PersonXLanguagePivot T
	INNER JOIN dbo.[Language] L ON T.LastLanguageID = L.LanguageID
	SET @rows = @@ROWCOUNT

	IF @rows > 0 UPDATE T SET LastLanguageID = (
		SELECT MIN(LanguageID) FROM dbo.PersonXLanguage PL WHERE PL.PersonID = T.PersonID AND PL.ProficiencyID = T.ProficiencyID AND PL.LanguageID > T.LastLanguageID
	)
	FROM #PersonXLanguagePivot T
END

DECLARE l_cursor CURSOR LOCAL FORWARD_ONLY STATIC FOR SELECT PersonID, ProficiencyID FROM #PersonXLanguagePivot
OPEN l_cursor 
FETCH l_cursor INTO @person_id, @proficiency_id

WHILE @@FETCH_STATUS=0
BEGIN
	SELECT @languages = REPLACE([Languages], '''', '''''') FROM #PersonXLanguagePivot WHERE PersonID=@person_id AND ProficiencyID=@proficiency_id

	SET @colname = dbo.fnGetLanguageColumnName(@proficiency_id)
	SET @sql = 'UPDATE dbo.PersonXLanguageFlat SET ' + @colname + '=''' + @languages + ''' WHERE LPPersonID=' + CAST(@person_id AS nvarchar(40))
	EXEC dbo.spExecSQLAsDBO @sql
	FETCH l_cursor INTO @person_id, @proficiency_id
END
CLOSE l_cursor DEALLOCATE l_cursor

DELETE #PersonXLanguagePivot

INSERT #PersonXLanguagePivot
SELECT DISTINCT PersonID, 0, '', NULL FROM inserted
UNION -- Implied distinct
SELECT DISTINCT PersonID, 0, '', NULL FROM deleted

INSERT #PersonXLanguagePivot
SELECT PersonID, 1, '', NULL FROM #PersonXLanguagePivot

UPDATE T SET LastLanguageID = (
	SELECT MIN(LanguageID) FROM dbo.PersonXLanguage PL 
	INNER JOIN dbo.LanguageProficiency P ON PL.PersonID=T.PersonID AND PL.ProficiencyID=P.ProficiencyID AND (P.Flags & 1) = T.ProficiencyID
)
FROM #PersonXLanguagePivot T

SET @rows = 1
WHILE @rows > 0
BEGIN
	UPDATE T SET Languages = T.Languages + CASE WHEN T.Languages='' THEN '' ELSE ', ' END + L.Language
	FROM #PersonXLanguagePivot T
	INNER JOIN dbo.[Language] L ON T.LastLanguageID = L.LanguageID
	SET @rows = @@ROWCOUNT

	IF @rows > 0 UPDATE T SET LastLanguageID = (
		SELECT MIN(LanguageID) FROM dbo.PersonXLanguage PL 
		INNER JOIN dbo.LanguageProficiency P ON PL.PersonID=T.PersonID AND PL.ProficiencyID=P.ProficiencyID AND (P.Flags & 1) = T.ProficiencyID AND PL.LanguageID > T.LastLanguageID
	)
	FROM #PersonXLanguagePivot T
END

UPDATE PX SET PrimaryLanguages2 = T.Languages
FROM dbo.PersonX PX
INNER JOIN #PersonXLanguagePivot T ON T.ProficiencyID=1 AND T.PersonID=PX.PersonID

UPDATE PX SET SecondaryLanguages2 = T.Languages
FROM dbo.PersonX PX
INNER JOIN #PersonXLanguagePivot T ON T.ProficiencyID=0 AND T.PersonID=PX.PersonID
GO
DECLARE @language_id int

DECLARE l_cursor CURSOR LOCAL FORWARD_ONLY STATIC FOR SELECT LanguageID FROM dbo.Language ORDER BY LanguageID
OPEN l_cursor
FETCH l_cursor INTO @language_id
WHILE @@FETCH_STATUS=0
BEGIN
	INSERT dbo.PersonXLanguage(PersonID, LanguageID, ProficiencyID, Comment)
	SELECT PersonID, @language_id, 1, 'Primary' FROM dbo.PersonX WHERE PrimaryLanguageID=@language_id

	INSERT dbo.PersonXLanguage(PersonID, LanguageID, ProficiencyID, Comment)
	SELECT PersonID, @language_id, 4, 'Secondary' FROM dbo.PersonX WHERE (PrimaryLanguageID IS NULL OR PrimaryLanguageID<>@language_id) AND ([Secondary Language Mask] & @language_id) > 0

	FETCH l_cursor INTO @language_id
END
CLOSE l_cursor
DEALLOCATE l_cursor

IF EXISTS(SELECT * FROM dbo.PersonX WHERE PrimaryLanguageID IS NOT NULL OR [Secondary Language Mask] > 0)
BEGIN
	IF OBJECT_ID('dbo._PersonX_LanguageBackup') IS NULL SELECT PersonID, PrimaryLanguageID, [Secondary Language Mask] INTO dbo._PersonX_LanguageBackup FROM dbo.PersonX WHERE PrimaryLanguageID IS NOT NULL OR [Secondary Language Mask] > 0
	UPDATE dbo.PersonX SET PrimaryLanguageID=NULL, [Secondary Language Mask]=0
END
GO
IF NOT EXISTS(SELECT * FROM sysindexes WHERE [ID]=OBJECT_ID('dbo.EmployeeBenefit') AND [name]='IX_EmployeeBenefit_Benefit')
CREATE INDEX IX_EmployeeBenefit_Benefit ON dbo.EmployeeBenefit(BenefitID)
GO
IF NOT EXISTS(SELECT * FROM sysindexes WHERE [ID]=OBJECT_ID('dbo.EmployeeBenefit') AND [name]='IX_EmployeeBenefit_Employee')
CREATE INDEX IX_EmployeeBenefit_Employee ON dbo.EmployeeBenefit(EmployeeID)
GO
IF NOT EXISTS(SELECT * FROM sysindexes WHERE [ID]=OBJECT_ID('dbo.EmployeeBenefit') AND [name]='IX_EmployeeBenefit_EmployeeBenefit')
CREATE INDEX IX_EmployeeBenefit_EmployeeBenefit ON dbo.EmployeeBenefit(EmployeeID, BenefitID)
GO
ALTER TABLE dbo.PersonCustomField ALTER COLUMN [Value] sql_variant NULL
GO
INSERT dbo.PersonCustomField(PersonID, FieldID, [Value])
SELECT P.PersonID, F.FieldID, NULL
FROM dbo.Person P CROSS JOIN dbo.CustomField F WHERE F.TypeID <> 3 AND NOT EXISTS(
	SELECT * FROM dbo.PersonCustomField PF WHERE PF.PersonID=P.PersonID AND PF.FieldID=F.FieldID
)

INSERT dbo.PersonCustomField(PersonID, FieldID, [Value])
SELECT P.PersonID, F.FieldID, CAST(0 AS bit)
FROM dbo.Person P CROSS JOIN dbo.CustomField F WHERE F.TypeID = 3 AND NOT EXISTS(
	SELECT * FROM dbo.PersonCustomField PF WHERE PF.PersonID=P.PersonID AND PF.FieldID=F.FieldID
)

-- Custom fields of type bit should all contain 0/1 values, but some legacy clients may still store NULL for false
IF EXISTS(SELECT * FROM PersonCustomField PCF INNER JOIN CustomField CF ON PCF.FieldID=CF.FieldID AND CF.TypeID=3 AND PCF.Value IS NULL)
BEGIN
	UPDATE PCF SET [Value]=CAST(0 as bit) FROM PersonCustomField PCF
	INNER JOIN CustomField CF ON PCF.FieldID=CF.FieldID AND CF.TypeID=3 AND PCF.Value IS NULL
END
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [id]=OBJECT_id('EmployeeBenefit') AND [name]='Volume')
ALTER TABLE dbo.EmployeeBenefit ADD [Volume] money NULL

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [id]=OBJECT_id('EmployeeBenefit') AND [name]='Wait List Queue')
ALTER TABLE dbo.EmployeeBenefit ADD [Wait List Queue] int NULL

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [id]=OBJECT_id('EmployeeBenefit') AND [name]='Wait List Day past 1900')
ALTER TABLE dbo.EmployeeBenefit ADD [Wait List Day past 1900] int NULL

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [id]=OBJECT_id('EmployeeBenefit') AND [name]='Other Premium')
ALTER TABLE dbo.EmployeeBenefit ADD [Other Premium] money NOT NULL DEFAULT(0)
GO
INSERT dbo.EmployeeBenefit(
	EmployeeID,
	BenefitID,
	[Employee Premium],
	[Employer Premium],
	[Expires Day past 1900],
	[Eligible Day past 1900],
	[Notified Day past 1900],
	[First Enrolled Day past 1900],
	[Last Enrolled Day past 1900],
	[Declined Day past 1900],
	Note,
	[Group Policy Number],
	[Individual Policy Number],
	Coverage,
	[Plan],
	Provider,
	[Wait List Queue],
	[Wait List Day past 1900],
	[Other Premium]
)
SELECT
E.EmployeeID,
B.BenefitID,
0, -- [Employee Premium]
0, -- [Employer Premium]
NULL, -- [Expires Day past 1900]
NULL, -- [Eligible Day past 1900]
NULL, -- [Notified Day past 1900]
NULL, -- [First Enrolled Day past 1900]
NULL, -- [Last Enrolled Day past 1900]
NULL, -- [Declined Day past 1900]
'', -- Note
'', -- [Group Policy Number]
'', -- [Individual Policy Number]
'', -- Coverage
'', -- [Plan]
'', -- Provider
NULL, -- [Wait List Queue]
NULL, -- [Wait List Day past 1900]
0 -- Other premium
FROM dbo.Employee E CROSS JOIN dbo.Benefit B WHERE NOT EXISTS (
	SELECT * FROM dbo.EmployeeBenefit EB WHERE EB.EmployeeID=E.EmployeeID AND EB.BenefitID=B.BenefitID
)
GO
IF OBJECT_Id('CK_LeaveType_TypeIDReservedForTardiness') IS NOT NULL ALTER TABLE LeaveType DROP CONSTRAINT CK_LeaveType_TypeIDReservedForTardiness

IF NOT EXISTS(SELECT * FROM syscolumns WHERE id=OBJECT_id('dbo.EmployeeLeaveUsed') AND [name]='First Certified Day past 1900')
ALTER TABLE dbo.EmployeeLeaveUsed ADD [First Certified Day past 1900] int NULL

IF NOT EXISTS(SELECT * FROM syscolumns WHERE id=OBJECT_id('dbo.EmployeeLeaveUsed') AND [name]='Recertify Day past 1900')
ALTER TABLE dbo.EmployeeLeaveUsed ADD [Recertify Day past 1900] int NULL

IF NOT EXISTS(SELECT * FROM syscolumns WHERE id=OBJECT_id('dbo.EmployeeLeaveUsed') AND [name]='Authorization Expires Day past 1900')
ALTER TABLE dbo.EmployeeLeaveUsed ADD [Authorization Expires Day past 1900] int NULL

--IF NOT EXISTS(SELECT * FROM syscolumns WHERE id=OBJECT_id('dbo.EmployeeLeaveUsed') AND [name]='Intermittent')
--ALTER TABLE dbo.EmployeeLeaveUsed ADD [Intermittent] bit NOT NULL DEFAULT(0)


IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name]='BatchCreateInvoice' AND [id]=OBJECT_id('dbo.Employee'))
ALTER TABLE dbo.Employee ADD BatchCreateInvoice bit NOT NULL DEFAULT(0)

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name]='Advance Pay' AND [id]=OBJECT_id('dbo.Employee'))
ALTER TABLE dbo.Employee ADD [Advance Pay] bit NOT NULL DEFAULT(0)

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name]='NSF' AND [id]=OBJECT_id('dbo.Employee'))
ALTER TABLE dbo.Employee ADD NSF bit NOT NULL DEFAULT(0)


IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name]='FTEM' AND [id]=OBJECT_id('dbo.Period'))
ALTER TABLE dbo.Period ADD FTEM int NOT NULL DEFAULT(1)

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name]='FTEB' AND [id]=OBJECT_id('dbo.Period'))
ALTER TABLE dbo.Period ADD FTEB int NOT NULL DEFAULT(1)

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [ID]=OBJECT_id('dbo.Position') AND [name]='Seconds per Week')
BEGIN
	ALTER TABLE Position ADD [Seconds per Week] int NOT NULL DEFAULT(144000)
	EXEC sp_executesql N'UPDATE Position SET [Seconds per Week] = [Seconds per Week] * FTE'
END




IF NOT EXISTS(SELECT * FROM syscolumns WHERE [id]=OBJECT_id('dbo.TempX') AND [name]='Y')
ALTER TABLE dbo.TempX ADD [Y] int NULL
GO
IF OBJECT_ID('dbo.TimeSchemaSlant') IS NULL
BEGIN
	CREATE TABLE dbo.TimeSchemaSlant (
		SlantID int NOT NULL IDENTITY(1,1) PRIMARY KEY,
		TimeSchemaID int,
		[Range Start Seconds Past Midnight] int NOT NULL,
		[Range Stop Seconds Past Midnight] int NOT NULL,
		[Slant to Seconds Past Midnight] int NOT NULL,
		[Day of Week Mask] int NOT NULL,
		[In Out Mask] int NOT NULL
	)

	ALTER TABLE TimeSchemaSlant ADD CONSTRAINT FK_TimeSchemaSlant_TimeSchema FOREIGN KEY (TimeSchemaID) REFERENCES TimeSchema (TimeSchemaID) ON DELETE CASCADE
	CREATE INDEX IX_TimeSchemaSlant_TimeSchemaID ON TimeSchemaSlant(TimeSchemaID)
END
GO
IF OBJECT_ID('dbo.TimeSchemaShiftDiff') IS NOT NULL AND NOT EXISTS(SELECT * FROM syscolumns WHERE [ID]=OBJECT_ID('dbo.TimeSchemaShiftDiff') AND [name]='PayRateM')
EXEC sp_executesql N'IF NOT EXISTS(SELECT * FROM dbo.TimeSchemaShiftDiff) DROP TABLE dbo.TimeSchemaShiftDiff'
GO
IF OBJECT_ID('dbo.TimeSchemaShiftDiff') IS NULL
BEGIN
	CREATE TABLE dbo.TimeSchemaShiftDiff (
		ItemID int NOT NULL IDENTITY(1,1) PRIMARY KEY,
		TimeSchemaID int NOT NULL,
		[Range Start Seconds Past Midnight] int NOT NULL,
		[Range Stop Seconds Past Midnight] int NOT NULL,
		PayRateM money NOT NULL,
		PayRateB money NOT NULL
	)

	ALTER TABLE TimeSchemaShiftDiff ADD CONSTRAINT FK_TimeSchemaShiftDiff_TimeSchema FOREIGN KEY (TimeSchemaID) REFERENCES TimeSchema (TimeSchemaID) ON DELETE CASCADE
	
	CREATE INDEX IX_TimeSchemaShiftDiff_TimeSchemaID ON TimeSchemaShiftDiff(TimeSchemaID)
END
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [id]=OBJECT_id('dbo.TimeType') AND [name]='Flags')
BEGIN
	ALTER TABLE dbo.TimeType ADD Flags int NOT NULL DEFAULT(0)
	EXEC sp_executesql N'UPDATE dbo.TimeType SET Flags=5 WHERE TypeID=1'
	EXEC sp_executesql N'UPDATE dbo.TimeType SET Flags=2 WHERE TypeID=4'
	EXEC sp_executesql N'IF NOT EXISTS(SELECT * FROM dbo.TimeType WHERE Flags=2) UPDATE dbo.TimeType SET Flags=2 WHERE Type=''Overtime'''
END
GO
IF EXISTS(SELECT * FROM syscolumns WHERE [id]=OBJECT_id('dbo.TimeType') AND [name]='Regular')
BEGIN
	EXEC dbo.spAdminDropDefault 'dbo.TimeType', 'Regular'
	EXEC sp_executesql N'UPDATE dbo.TimeType SET Flags=Flags | 1 WHERE Regular=1'
	EXEC sp_executesql N'ALTER TABLE dbo.TimeType DROP COLUMN Regular'
END
GO
IF EXISTS(SELECT * FROM syscolumns WHERE [id]=OBJECT_id('dbo.TimeType') AND [name]='OT Eligible')
BEGIN
	EXEC dbo.spAdminDropDefault 'dbo.TimeType', 'OT Eligible'
	EXEC sp_executesql N'UPDATE dbo.TimeType SET Flags=Flags | 4 WHERE [OT Eligible]=1'
	EXEC sp_executesql N'ALTER TABLE dbo.TimeType DROP COLUMN [OT Eligible]'
END
GO

IF OBJECT_ID('dbo.EmployeeTimeZKQ') IS NULL
BEGIN
	CREATE TABLE dbo.EmployeeTimeZKQ(
		[ItemID] [int] IDENTITY(1,1) NOT NULL PRIMARY KEY,
		[Badge] [varchar](50) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
		[Terminal] [varchar](50) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
		[Time] datetime NOT NULL,
		[In Out Mode] int NOT NULL DEFAULT(0),
		[Created] datetime NOT NULL DEFAULT (GETDATE()),
		[Imported] datetime NULL,
		[EmployeeID] [int] NULL,
		[Work Code] int NOT NULL DEFAULT(0)
	)
END
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [id]=OBJECT_ID('dbo.EmployeeTimeZKQ') AND [name]='In Out Mode')
ALTER TABLE dbo.EmployeeTimeZKQ ADD [In Out Mode] int NOT NULL DEFAULT(0)
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [id]=OBJECT_ID('dbo.EmployeeTimeZKQ') AND [name]='Work Code')
ALTER TABLE dbo.EmployeeTimeZKQ ADD [Work Code] int NOT NULL DEFAULT(0)
GO
-- New field, EmployeeLeaveUsedItem.[Created Day past 1900]
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name] = 'Created Day past 1900' AND [id] = OBJECT_id('dbo.EmployeeLeaveUsedItem'))
ALTER TABLE dbo.EmployeeLeaveUsedItem ADD [Created Day past 1900] int NOT NULL DEFAULT DATEDIFF(d, 0, GETDATE())

-- New field, EmployeeLeaveUsed.[Created Day past 1900]
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name] = 'Created Day past 1900' AND [id] = OBJECT_id('dbo.EmployeeLeaveUsed'))
ALTER TABLE dbo.EmployeeLeaveUsed ADD [Created Day past 1900] int NOT NULL DEFAULT DATEDIFF(d, 0, GETDATE())

-- New field, EmployeeLeaveEarned.[Created Day past 1900]
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name] = 'Created Day past 1900' AND [id] = OBJECT_id('dbo.EmployeeLeaveEarned'))
ALTER TABLE dbo.EmployeeLeaveEarned ADD [Created Day past 1900] int NOT NULL DEFAULT DATEDIFF(d, 0, GETDATE())

-- New field, EmployeeTime.[Created Day past 1900]
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name] = 'Created Day past 1900' AND [id] = OBJECT_id('dbo.EmployeeTime'))
ALTER TABLE dbo.EmployeeTime ADD [Created Day past 1900] int NOT NULL DEFAULT DATEDIFF(d, 0, GETDATE())
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [ID]=OBJECT_id('dbo.EmployeeTime') AND [name]='PPE Day past 1900')
BEGIN
	ALTER TABLE dbo.EmployeeTime ADD [PPE Day past 1900] int NOT NULL DEFAULT(0)
	EXEC sp_executesql N'UPDATE EmployeeTime SET [PPE Day past 1900] = DATEDIFF(d,0,[In])'
END

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [ID]=OBJECT_id('dbo.EmployeeLeaveEarned') AND [name]='PPE Day past 1900')
BEGIN
	ALTER TABLE dbo.EmployeeLeaveEarned ADD [PPE Day past 1900] int NOT NULL DEFAULT(0)
	EXEC sp_executesql N'UPDATE EmployeeLeaveEarned SET [PPE Day past 1900] = [Day past 1900]'
END

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [ID]=OBJECT_id('dbo.EmployeeLeaveUsedItem') AND [name]='PPE Day past 1900')
BEGIN
	ALTER TABLE dbo.EmployeeLeaveUsedItem ADD [PPE Day past 1900] int NOT NULL DEFAULT(0)
	EXEC sp_executesql N'UPDATE EmployeeLeaveUsedItem SET [PPE Day past 1900] = [Day past 1900]'
END

-- New field, EmployeeLeaveUsed.[PPE Start Day past 1900]
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name] = 'PPE Start Day past 1900' AND [id] = OBJECT_id('dbo.EmployeeLeaveUsed'))
BEGIN
	ALTER TABLE dbo.EmployeeLeaveUsed ADD [PPE Start Day past 1900] int NOT NULL DEFAULT DATEDIFF(d, 0, GETDATE())
	EXEC sp_executesql N'UPDATE U SET [PPE Start Day past 1900] = ISNULL((SELECT MIN(I.[PPE Day past 1900]) FROM EmployeeLeaveUsedItem I WHERE I.LeaveID=U.LeaveID), U.[Start Day past 1900]) FROM EmployeeLeaveUsed U'
END

-- New field, EmployeeLeaveUsed.[PPE Stop Day past 1900]
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name] = 'PPE Stop Day past 1900' AND [id] = OBJECT_id('dbo.EmployeeLeaveUsed'))
BEGIN
	ALTER TABLE dbo.EmployeeLeaveUsed ADD [PPE Stop Day past 1900] int NOT NULL DEFAULT DATEDIFF(d, 0, GETDATE())
	EXEC sp_executesql N'UPDATE U SET [PPE Stop Day past 1900] = ISNULL((SELECT MAX(I.[PPE Day past 1900]) FROM EmployeeLeaveUsedItem I WHERE I.LeaveID=U.LeaveID), U.[Stop Day past 1900]) FROM EmployeeLeaveUsed U'
END

-- New field, EmployeeLeaveUsed.[Created Start Day past 1900]
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name] = 'Created Start Day past 1900' AND [id] = OBJECT_id('dbo.EmployeeLeaveUsed'))
BEGIN
	ALTER TABLE dbo.EmployeeLeaveUsed ADD [Created Start Day past 1900] int NOT NULL DEFAULT DATEDIFF(d, 0, GETDATE())
	EXEC sp_executesql N'UPDATE U SET [Created Start Day past 1900] = ISNULL((SELECT MIN(I.[Created Day past 1900]) FROM EmployeeLeaveUsedItem I WHERE I.LeaveID=U.LeaveID), U.[Created Day past 1900]) FROM EmployeeLeaveUsed U'
END

-- New field, EmployeeLeaveUsed.[Created Stop Day past 1900]
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name] = 'Created Stop Day past 1900' AND [id] = OBJECT_id('dbo.EmployeeLeaveUsed'))
BEGIN
	ALTER TABLE dbo.EmployeeLeaveUsed ADD [Created Stop Day past 1900] int NOT NULL DEFAULT DATEDIFF(d, 0, GETDATE())
	EXEC sp_executesql N'UPDATE U SET [Created Stop Day past 1900] = ISNULL((SELECT MAX(I.[Created Day past 1900]) FROM EmployeeLeaveUsedItem I WHERE I.LeaveID=U.LeaveID), U.[Created Day past 1900]) FROM EmployeeLeaveUsed U'
END
GO
IF OBJECT_id('dbo.EmployeeCompensationEventStart') IS NULL
BEGIN
	CREATE TABLE dbo.EmployeeCompensationEventStart(
		EventID int PRIMARY KEY NOT NULL,
		Event varchar(50) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
		Flags int NOT NULL,
		[Order] int NOT NULL
	)
END
GO
IF NOT EXISTS(SELECT * FROM dbo.EmployeeCompensationEventStart)
BEGIN
	-- Flags: 1 Hired
	INSERT dbo.EmployeeCompensationEventStart(EventID, Event, Flags, [Order]) VALUES(1, 'Hired', 1, 1)
	INSERT dbo.EmployeeCompensationEventStart(EventID, Event, Flags, [Order]) VALUES(2, 'Same position,resumed', 0, 3)
	INSERT dbo.EmployeeCompensationEventStart(EventID, Event, Flags, [Order]) VALUES(4, 'Same position,pay increased', 0, 4)
	INSERT dbo.EmployeeCompensationEventStart(EventID, Event, Flags, [Order]) VALUES(8, 'Same position,pay Decreased', 0, 5)
	INSERT dbo.EmployeeCompensationEventStart(EventID, Event, Flags, [Order]) VALUES(16, 'New position,promoted', 0, 6)
	INSERT dbo.EmployeeCompensationEventStart(EventID, Event, Flags, [Order]) VALUES(32, 'New position,demoted', 0, 7)
	INSERT dbo.EmployeeCompensationEventStart(EventID, Event, Flags, [Order]) VALUES(64, 'Administrative change', 0, 8)
END
GO
IF (OBJECT_id('CK_EmployeeCompensationEventStart_InvalidEventID') IS NOT NULL) ALTER TABLE dbo.EmployeeCompensationEventStart DROP CONSTRAINT CK_EmployeeCompensationEventStart_InvalidEventID
ALTER TABLE dbo.EmployeeCompensationEventStart  WITH NOCHECK ADD CONSTRAINT CK_EmployeeCompensationEventStart_InvalidEventID CHECK  (([EventID] = 0x40000000 or ([EventID] = 0x20000000 or ([EventID] = 0x10000000 or ([EventID] = 0x08000000 or ([EventID] = 0x04000000 or ([EventID] = 0x02000000 or ([EventID] = 0x01000000 or ([EventID] = 0x800000 or ([EventID] = 0x400000 or ([EventID] = 0x200000 or ([EventID] = 0x100000 or ([EventID] = 0x080000 or ([EventID] = 0x040000 or ([EventID] = 0x020000 or ([EventID] = 0x010000 or ([EventID] = 0x8000 or ([EventID] = 0x4000 or ([EventID] = 0x2000 or ([EventID] = 0x1000 or ([EventID] = 0x0800 or ([EventID] = 0x0400 or ([EventID] = 0x0200 or ([EventID] = 0x0100 or ([EventID] = 0x80 or ([EventID] = 0x40 or ([EventID] = 0x20 or ([EventID] = 0x10 or ([EventID] = 8 or ([EventID] = 4 or ([EventID] = 2 or [EventID] = 1)))))))))))))))))))))))))))))))
GO
IF OBJECT_id('dbo.EmployeeCompensationEventStop') IS NULL
BEGIN
	CREATE TABLE dbo.EmployeeCompensationEventStop(
		EventID int PRIMARY KEY NOT NULL,
		Event varchar(50) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
		Flags int NOT NULL,
		[Order] int NOT NULL
	)

	-- Flags: 1 Terminated
	INSERT dbo.EmployeeCompensationEventStop(EventID, Event, Flags, [Order]) VALUES(1, 'Terminated', 1, 1)
	INSERT dbo.EmployeeCompensationEventStop(EventID, Event, Flags, [Order]) VALUES(2, 'Inactivated', 0, 2)
	INSERT dbo.EmployeeCompensationEventStop(EventID, Event, Flags, [Order]) VALUES(4, 'Continued,position/pay changed', 0, 3)
	INSERT dbo.EmployeeCompensationEventStop(EventID, Event, Flags, [Order]) VALUES(8, 'Administrative change', 0, 4)
END
GO
IF OBJECT_id('CK_EmployeeCompensationEventStop_InvalidEventID') IS NOT NULL ALTER TABLE dbo.EmployeeCompensationEventStop DROP CONSTRAINT CK_EmployeeCompensationEventStop_InvalidEventID
ALTER TABLE dbo.EmployeeCompensationEventStop  WITH NOCHECK ADD CONSTRAINT CK_EmployeeCompensationEventStop_InvalidEventID CHECK  (([EventID] = 0x40000000 or ([EventID] = 0x20000000 or ([EventID] = 0x10000000 or ([EventID] = 0x08000000 or ([EventID] = 0x04000000 or ([EventID] = 0x02000000 or ([EventID] = 0x01000000 or ([EventID] = 0x800000 or ([EventID] = 0x400000 or ([EventID] = 0x200000 or ([EventID] = 0x100000 or ([EventID] = 0x080000 or ([EventID] = 0x040000 or ([EventID] = 0x020000 or ([EventID] = 0x010000 or ([EventID] = 0x8000 or ([EventID] = 0x4000 or ([EventID] = 0x2000 or ([EventID] = 0x1000 or ([EventID] = 0x0800 or ([EventID] = 0x0400 or ([EventID] = 0x0200 or ([EventID] = 0x0100 or ([EventID] = 0x80 or ([EventID] = 0x40 or ([EventID] = 0x20 or ([EventID] = 0x10 or ([EventID] = 8 or ([EventID] = 4 or ([EventID] = 2 or [EventID] = 1)))))))))))))))))))))))))))))))
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE ID=OBJECT_id('EmployeeCompensation') AND [name]='StartEventID')
BEGIN
	ALTER TABLE dbo.EmployeeCompensation ADD StartEventID int NULL
	ALTER TABLE dbo.EmployeeCompensation ADD StopEventID int NULL
	EXEC sp_executesql N'UPDATE EmployeeCompensation SET StartEventID=1'
	EXEC sp_executesql N'UPDATE EmployeeCompensation SET StopEventID=1 WHERE [Stop Day past 1900] IS NOT NULL'
	ALTER TABLE dbo.EmployeeCompensation ALTER COLUMN StartEventID int NOT NULL
END
GO
IF OBJECT_id('FK_EmployeeCompensation_StartEventID') IS NULL
ALTER TABLE dbo.EmployeeCompensation ADD CONSTRAINT FK_EmployeeCompensation_StartEventID FOREIGN KEY(StartEventID)
REFERENCES dbo.EmployeeCompensationEventStart(EventID)

IF OBJECT_id('FK_EmployeeCompensation_StopEventID') IS NULL
ALTER TABLE dbo.EmployeeCompensation ADD CONSTRAINT FK_EmployeeCompensation_StopEventID FOREIGN KEY(StopEventID)
REFERENCES dbo.EmployeeCompensationEventStop(EventID)

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [id]=OBJECT_ID('Position') AND [name]='Position Number')
ALTER TABLE Position ADD [Position Number] varchar(50) NOT NULL DEFAULT('')

IF NOT EXISTS(SELECT * FROM dbo.AuditSetting WHERE ObjectID=1073741824) INSERT AuditSetting VALUES(1073741824, 'Employment History\Comp', 14, 0)

IF NOT EXISTS(SELECT * FROM Error WHERE ErrorID=50055)
INSERT Error(ErrorID,Error) SELECT 50055, 'This type of time cannot be added because the system can only track 31 types of time.'

IF NOT EXISTS(SELECT * FROM Error WHERE ErrorID=50059)
INSERT Error(ErrorID, Error)
VALUES(50059, 'You cannot delete the last time schema.')

IF NOT EXISTS(SELECT * FROM Error WHERE ErrorID=50060)
INSERT Error(ErrorID, Error)
VALUES(50060, 'You cannot delete the last position status.')
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [id]=OBJECT_id('EmployeeTime') AND [name]='SourceIn')
ALTER TABLE EmployeeTime ADD SourceIn varchar(50) NOT NULL DEFAULT('')

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [id]=OBJECT_id('EmployeeTime') AND [name]='SourceOut')
ALTER TABLE EmployeeTime ADD SourceOut varchar(50) NOT NULL DEFAULT('')

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [id]=OBJECT_id('PersonX') AND [name]='Driver License Class')
ALTER TABLE PersonX ADD [Driver License Class] varchar(50) NOT NULL DEFAULT('')

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [id]=OBJECT_id('Project') AND [name]='Number')
ALTER TABLE Project ADD [Number] varchar(50) NOT NULL DEFAULT('')

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [id]=OBJECT_id('Project') AND [name]='Order')
ALTER TABLE Project ADD [Order] int NOT NULL DEFAULT(0)

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [id]=OBJECT_id('dbo.ColumnGrid') AND [name]='Role Mask')
ALTER TABLE dbo.ColumnGrid ADD [Role Mask] int NOT NULL CONSTRAINT DF_ColumnGrid_RoleMask DEFAULT(2147483647)

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [id]=OBJECT_id('dbo.ColumnGrid') AND [name]='Group')
ALTER TABLE dbo.ColumnGrid ADD [Group] varchar(50) NOT NULL CONSTRAINT DF_ColumnGrid_Group DEFAULT('')

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [id]=OBJECT_id('Employee') AND [name]='Leave Accrual Multiplier')
ALTER TABLE Employee ADD [Leave Accrual Multiplier] numeric(9,4) NOT NULL CONSTRAINT DF_Employee_LeaveAccrualMultiplier DEFAULT 1

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [id]=OBJECT_id('Employee') AND [name]='Seconds per Day Override')
ALTER TABLE Employee ADD [Seconds per Day Override] int NOT NULL CONSTRAINT DF_Employee_HoursPerDayMultiplier DEFAULT 0
GO
IF OBJECT_id('CK_Employee_LeaveAccrualMultiplier_Not_Between_0_And_100') IS NULL
ALTER TABLE Employee ADD CONSTRAINT CK_Employee_LeaveAccrualMultiplier_Not_Between_0_And_100 CHECK ([Leave Accrual Multiplier] BETWEEN 0 AND 100)


IF OBJECT_id('CK_Employee_SecondsPerDayOverride_Negative') IS NULL
ALTER TABLE Employee ADD CONSTRAINT CK_Employee_SecondsPerDayOverride_Negative CHECK ([Seconds per Day Override] >= 0)


IF NOT EXISTS (SELECT * FROM syscolumns WHERE [id]=OBJECT_id('dbo.Shift') AND [name]='Slant Seconds')
ALTER TABLE dbo.Shift ADD [Slant Seconds] int NOT NULL DEFAULT(1800)

IF NOT EXISTS (SELECT * FROM syscolumns WHERE [id]=OBJECT_id('dbo.Shift') AND [name]='Slant Out Seconds')
ALTER TABLE dbo.Shift ADD [Slant Out Seconds] int NOT NULL DEFAULT(1800)

IF NOT EXISTS (SELECT * FROM syscolumns WHERE [id]=OBJECT_id('dbo.Shift') AND [name]='FTE')
ALTER TABLE dbo.Shift ADD FTE numeric(9,4) NOT NULL DEFAULT(1)

IF NOT EXISTS (SELECT * FROM syscolumns WHERE [id]=OBJECT_id('dbo.Shift') AND [name]='Start Seconds')
ALTER TABLE dbo.Shift ADD [Start Seconds] int NOT NULL DEFAULT(32400)

IF NOT EXISTS (SELECT * FROM syscolumns WHERE [id]=OBJECT_id('dbo.Shift') AND [name]='DaysOn2')
ALTER TABLE dbo.Shift ADD [DaysOn2] int NOT NULL DEFAULT(0)

IF NOT EXISTS (SELECT * FROM syscolumns WHERE [id]=OBJECT_id('dbo.Shift') AND [name]='DaysOff2')
ALTER TABLE dbo.Shift ADD [DaysOff2] int NOT NULL DEFAULT(0)

IF NOT EXISTS (SELECT * FROM syscolumns WHERE [id]=OBJECT_id('dbo.Shift') AND [name]='Stop Seconds')
ALTER TABLE dbo.Shift ADD [Stop Seconds] int NULL -- version compatibility

IF NOT EXISTS (SELECT * FROM syscolumns WHERE [id]=OBJECT_id('dbo.Shift') AND [name]='Grace Seconds')
ALTER TABLE dbo.Shift ADD [Grace Seconds] int NOT NULL DEFAULT(0)

IF NOT EXISTS (SELECT * FROM syscolumns WHERE [id]=OBJECT_id('dbo.Shift') AND [name]='Flags')
ALTER TABLE dbo.Shift ADD Flags int NOT NULL DEFAULT(0)

IF NOT EXISTS (SELECT * FROM syscolumns WHERE [id]=OBJECT_id('dbo.Shift') AND [name]='Lunch Start')
ALTER TABLE dbo.Shift ADD [Lunch Start] int NOT NULL DEFAULT(43200)

IF NOT EXISTS (SELECT * FROM syscolumns WHERE [id]=OBJECT_id('dbo.Shift') AND [name]='Lunch Seconds')
ALTER TABLE dbo.Shift ADD [Lunch Seconds] int NOT NULL DEFAULT(3600)
GO

IF OBJECT_id('CK_Constant_AuditDays') IS NULL
BEGIN
	UPDATE dbo.Constant SET [Audit Purge Days] = 365 WHERE [Audit Purge Days] IS NULL
	UPDATE dbo.Constant SET [Audit Purge Days] = 0 WHERE [Audit Purge Days] < 0

	ALTER TABLE dbo.Constant ADD CONSTRAINT CK_Constant_AuditDays CHECK ([Audit Purge Days] >= 0)
	ALTER TABLE dbo.Constant ALTER COLUMN [Audit Purge Days] int NOT NULL
END
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name]='CC' AND [id]=OBJECT_id('dbo.ReminderType'))
ALTER TABLE dbo.ReminderType ADD CC varchar(50) NOT NULL DEFAULT('')

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name]='Leave Keeper' AND [id]=OBJECT_id('dbo.ReminderType'))
ALTER TABLE dbo.ReminderType ADD [Leave Keeper] bit NOT NULL DEFAULT(0)

IF OBJECT_id('dbo.spCompanyGetDateFirst') IS NOT NULL DROP Proc dbo.spCompanyGetDateFirst

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [ID]=OBJECT_id('dbo.Constant') AND [name]='DateFirst')
ALTER TABLE dbo.Constant ADD [DateFirst] int NULL
GO
-- Adds termination reasonid to Employee table
IF OBJECT_id('dbo.TerminationReason') IS NULL
BEGIN
	CREATE TABLE dbo.TerminationReason
	(
		ReasonID int NOT NULL PRIMARY KEY IDENTITY(1,1),
		Reason varchar(50) NOT NULL
	)

	INSERT TerminationReason(Reason) VALUES('Voluntary')
	INSERT TerminationReason(Reason) VALUES('Performance reasons')
	INSERT TerminationReason(Reason) VALUES('Unexcused absence/tardiness')
	INSERT TerminationReason(Reason) VALUES('Position eliminated')
END

IF OBJECT_id('CK_TerminationReason_BlankReason') IS NULL
ALTER TABLE dbo.TerminationReason ADD CONSTRAINT CK_TerminationReason_BlankReason CHECK (Reason!='')

IF NOT EXISTS(SELECT * FROM syscolumns WHERE id=OBJECT_id('dbo.Employee') AND [name]='TerminationReasonID')
ALTER TABLE dbo.Employee ADD TerminationReasonID int NULL

IF NOT EXISTS (SELECT * FROM dbo.sysobjects WHERE id = OBJECT_id(N'dbo.FK_TerminationReason_Employee') AND type = 'F')
ALTER TABLE dbo.Employee ADD CONSTRAINT FK_TerminationReason_Employee FOREIGN KEY(TerminationReasonID) REFERENCES dbo.TerminationReason(ReasonID)

IF OBJECT_id('CK_Person_WorkEmail') IS NULL
ALTER TABLE dbo.Person WITH NOCHECK ADD CONSTRAINT CK_Person_WorkEmail
CHECK ([Work E-mail]='' OR ([Work E-mail] LIKE '%_@_%._%' AND [Work E-mail] NOT LIKE '% %'))

IF OBJECT_id('CK_Person_HomeEmail') IS NULL
ALTER TABLE dbo.Person WITH NOCHECK ADD CONSTRAINT CK_Person_HomeEmail
CHECK ([Home E-mail]='' OR ([Home E-mail] LIKE '%_@_%._%' AND [Home E-mail] NOT LIKE '% %'))
GO
-- Adds personal fields to employee dependent
BEGIN TRAN

	DECLARE @race_id int, @i9_status_id int, @marital_status_id int
	EXEC dbo.spPersonXInsertPrepare @race_id out, @i9_status_id out, @marital_status_id out

	INSERT PersonX(PersonID, RaceID, I9StatusID, MaritalStatusID)
	SELECT D.PersonID, @race_id, @i9_status_id, @marital_status_id FROM EmployeeDependent D
	LEFT JOIN PersonX X ON D.PersonID=X.PersonID WHERE X.PersonID IS NULL

	IF EXISTS (SELECT * FROM dbo.sysobjects WHERE id = OBJECT_id(N'dbo.[FK_EmployeeDependent_Person]') AND type = 'F')
	ALTER TABLE dbo.[EmployeeDependent] DROP CONSTRAINT [FK_EmployeeDependent_Person]

	IF NOT EXISTS (SELECT * FROM dbo.sysobjects WHERE id = OBJECT_id(N'dbo.[FK_EmployeeDependent_PersonX]') AND type = 'F')
	ALTER TABLE dbo.[EmployeeDependent]  WITH CHECK ADD CONSTRAINT [FK_EmployeeDependent_PersonX] FOREIGN KEY([PersonID])
	REFERENCES dbo.[PersonX] ([PersonID])

COMMIT TRAN
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [id]=OBJECT_id('dbo.EmployeeLeaveUnused') AND [name]='Limit Seconds')
BEGIN
BEGIN TRAN
	ALTER TABLE dbo.EmployeeLeaveUnused ADD [Limit Seconds] int NOT NULL DEFAULT(0)
	EXEC sp_executesql N'UPDATE U SET [Limit Seconds] = ISNULL((
		SELECT 0 - SUM(E.Seconds) FROM EmployeeLeaveEarned E WHERE E.EmployeeID=U.EmployeeID AND E.TypeID=U.TypeID AND E.[Day past 1900]=U.[Day past 1900] AND E.[Auto]=2
	), 0) FROM dbo.EmployeeLeaveUnused U'
COMMIT TRAN
END
GO
IF OBJECT_id('FK_EmployeeReview_ReviewedByEmployee') IS NULL
BEGIN
BEGIN TRAN
	IF ((SELECT COUNT(*) FROM EmployeeReview) > 0 AND (SELECT COUNT(*) FROM Employee) > 0)
	BEGIN
		DECLARE @employee_id int
		SELECT @employee_id = EmployeeID FROM Employee WHERE [SID]=SUSER_SID()
		IF @@ROWCOUNT = 0 SELECT TOP 1 @employee_id=EmployeeID FROM Employee WHERE [Active Employee]=1
		IF @employee_id IS NULL SELECT TOP 1 @employee_id=EmployeeID FROM Employee

		UPDATE EmployeeReview SET ReviewedByEmployeeID=@employee_id WHERE ReviewedByEmployeeID NOT IN (SELECT EmployeeID FROM Employee)
	END

	ALTER TABLE dbo.[EmployeeReview] ADD CONSTRAINT FK_EmployeeReview_ReviewedByEmployee FOREIGN KEY([ReviewedByEmployeeID]) REFERENCES dbo.[Employee] ([EmployeeID])
COMMIT TRAN
END
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [id]=OBJECT_id('dbo.Employee') AND [name]='LastEmployeeReviewID')
BEGIN
BEGIN TRAN
	ALTER TABLE dbo.Employee ADD LastEmployeeReviewID int NULL
	EXEC sp_executesql N'UPDATE Employee SET LastEmployeeReviewID = 
	(
		SELECT TOP 1 ER.[ReviewID] FROM EmployeeReview ER WHERE ER.EmployeeID = Employee.EmployeeID ORDER BY ER.[Day past 1900] DESC
	)'
COMMIT TRAN
END
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [ID] = OBJECT_id('LeaveApprovalType') AND name='Leave Type Mask')
ALTER TABLE dbo.LeaveApprovalType ADD [Leave Type Mask] int NOT NULL DEFAULT 0
GO
IF EXISTS(SELECT * FROM LeaveApprovalType WHERE [Leave Type Mask] = 0x7FFFFFFF)
BEGIN
	UPDATE LeaveApprovalType SET [Leave Type Mask] = 0 WHERE [Leave Type Mask] = 0x7FFFFFFF
	
	DECLARE @leave_id int
	DECLARE l_cursor CURSOR LOCAL FORWARD_ONLY STATIC FOR SELECT LeaveID FROM EmployeeLeaveUsed WHERE [Created Day past 1900] >= 39751

	-- Loops for every user\account\role to which the current user belongs
	OPEN l_cursor
	FETCH NEXT FROM l_cursor INTO @leave_id

	WHILE @@FETCH_STATUS = 0
	BEGIN
		EXEC dbo.spEmployeeLeaveUsedRecalc @leave_id
		FETCH NEXT FROM l_cursor INTO @leave_id
	END

	CLOSE l_cursor
	DEALLOCATE l_cursor
END
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [id]=OBJECT_id('dbo.EmployeeLeaveUnused') AND [name]='Limit Seconds')
BEGIN
BEGIN TRAN
	ALTER TABLE dbo.EmployeeLeaveUnused ADD [Limit Seconds] int NOT NULL DEFAULT(0)

	UPDATE U SET [Limit Seconds] = ISNULL((
		SELECT 0 - SUM(E.Seconds) FROM dbo.EmployeeLeaveEarned E WHERE E.EmployeeID=U.EmployeeID AND E.TypeID=U.TypeID AND E.[Day past 1900]=U.[Day past 1900] AND [Auto]=2
	),0) FROM dbo.EmployeeLeaveUnused U
COMMIT TRAN
END
GO
IF OBJECT_id('dbo.Deduction') IS NULL
CREATE TABLE dbo.Deduction
(
	DeductionID int NOT NULL IDENTITY(1,1),
	Deduction varchar(50) NOT NULL,
	[Deduction Code] varchar(50) NOT NULL
)
GO
IF NOT EXISTS(SELECT * FROM sysindexes WHERE [ID]=OBJECT_id('Deduction') AND [name]='PK_Deduction')
ALTER TABLE dbo.Deduction ADD CONSTRAINT PK_Deduction PRIMARY KEY CLUSTERED(DeductionID) 
GO
IF OBJECT_id('dbo.EmployeeDeduction') IS NULL
CREATE TABLE dbo.EmployeeDeduction(
	ItemID int NOT NULL IDENTITY(1,1),
	EmployeeID int NOT NULL,
	DeductionID int NOT NULL, 
	Amount money NOT NULL, 
	Comment varchar(50) NOT NULL
)
GO
IF NOT EXISTS(SELECT * FROM sysindexes WHERE [ID]=OBJECT_id('EmployeeDeduction') AND [name]='PK_EmployeeDeduction')
ALTER TABLE dbo.EmployeeDeduction ADD CONSTRAINT PK_EmployeeDeduction PRIMARY KEY CLUSTERED(ItemID) 

IF OBJECT_id('FK_EmployeeDeduction_Deduction') IS NULL
ALTER TABLE dbo.EmployeeDeduction  WITH CHECK ADD  CONSTRAINT FK_EmployeeDeduction_Deduction FOREIGN KEY(DeductionID)
REFERENCES dbo.[Deduction] (DeductionID)

IF NOT EXISTS(SELECT * FROM sysindexes WHERE [ID]=OBJECT_id('EmployeeDeduction') AND [name]='IX_EmployeeDeduction_Deduction')
CREATE NONCLUSTERED INDEX IX_EmployeeDeduction_Deduction ON dbo.EmployeeDeduction(DeductionID ASC)

IF OBJECT_id('FK_EmployeeDeduction_Employee') IS NULL
ALTER TABLE dbo.EmployeeDeduction  WITH CHECK ADD  CONSTRAINT FK_EmployeeDeduction_Employee FOREIGN KEY(EmployeeID)
REFERENCES dbo.[Employee] ([EmployeeID]) ON DELETE CASCADE

IF NOT EXISTS(SELECT * FROM sysindexes WHERE [ID]=OBJECT_id('EmployeeDeduction') AND [name]='IX_EmployeeDeduction_Employee')
CREATE NONCLUSTERED INDEX IX_EmployeeDeduction_Employee ON dbo.EmployeeDeduction([EmployeeID] ASC)

IF NOT EXISTS(SELECT * FROM sysindexes WHERE [ID]=OBJECT_id('EmployeeDeduction') AND [name]='IX_EmployeeDeduction_EmployeeDeduction')
CREATE UNIQUE NONCLUSTERED INDEX IX_EmployeeDeduction_EmployeeDeduction ON dbo.EmployeeDeduction 
(
	[EmployeeID] ASC,
	DeductionID ASC
) ON [PRIMARY]
GO
IF OBJECT_id('dbo.Terminal') IS NULL
BEGIN
	CREATE TABLE dbo.Terminal (
		TerminalID int PRIMARY KEY NOT NULL,
		IP binary(4) NOT NULL,
		Port int NOT NULL,
		[Password] int NOT NULL,
		[Last Result] varchar(1000) NOT NULL DEFAULT(''),
		[Last Updated] datetime NULL,
		Flags int NOT NULL DEFAULT(0),
		UniqueBit int NOT NULL DEFAULT(0),
		Source varchar(50) NOT NULL DEFAULT('')
	)

	CREATE UNIQUE NONCLUSTERED INDEX [IX_Terminal_IP] ON dbo.[Terminal] ([IP] ASC, Port ASC) 
END

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name]='Flags' AND [id]=OBJECT_ID('dbo.Terminal'))
ALTER TABLE dbo.Terminal ADD Flags int NOT NULL DEFAULT(0)

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name]='UniqueBit' AND [id]=OBJECT_ID('dbo.Terminal'))
ALTER TABLE dbo.Terminal ADD UniqueBit int NOT NULL DEFAULT(0)

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name]='Source' AND [id]=OBJECT_ID('dbo.Terminal'))
ALTER TABLE dbo.Terminal ADD Source varchar(50) NOT NULL DEFAULT('')

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name]='DDNS' AND [id]=OBJECT_ID('dbo.Terminal'))
ALTER TABLE dbo.Terminal ADD DDNS varchar(50) NOT NULL DEFAULT('')
GO
IF EXISTS(SELECT * FROM dbo.Terminal WHERE UniqueBit = 0)
BEGIN
	DECLARE @r int, @b int
	SELECT @r = 1, @b = 0
	WHILE @r > 0
	BEGIN
		IF @b = 0 SET @b = 1 ELSE SET @b = @b + @b
		UPDATE dbo.Terminal SET UniqueBit=@b WHERE TerminalID = (SELECT TOP 1 TerminalID FROM dbo.Terminal WHERE UniqueBit=0)
		SET @r = @@ROWCOUNT
	END
END
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name]='Terminal Service Last Result' AND [id]=OBJECT_id('dbo.Constant'))
ALTER TABLE dbo.Constant ADD [Terminal Service Last Result] varchar(1000) NOT NULL DEFAULT ('')

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name]='Terminal Service Last Updated' AND [id]=OBJECT_id('dbo.Constant'))
ALTER TABLE dbo.Constant ADD [Terminal Service Last Updated] datetime NULL

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name]='Terminal Service Enable' AND [id]=OBJECT_id('dbo.Constant'))
ALTER TABLE dbo.Constant ADD [Terminal Service Enable] bit NOT NULL DEFAULT (1)

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name]='Terminal Service Verbosity' AND [id]=OBJECT_id('dbo.Constant'))
ALTER TABLE dbo.Constant ADD [Terminal Service Verbosity] int NOT NULL DEFAULT (0x7FFFFFF0)

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name]='Terminal Synch All Fingerprints Seconds' AND [id]=OBJECT_id('dbo.Constant'))
ALTER TABLE dbo.Constant ADD [Terminal Synch All Fingerprints Seconds] int NOT NULL DEFAULT (86400)

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name]='Terminal Synch New Fingerprints Seconds' AND [id]=OBJECT_id('dbo.Constant'))
ALTER TABLE dbo.Constant ADD [Terminal Synch New Fingerprints Seconds] int NOT NULL DEFAULT (18000)

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name]='Terminal Synch Time Seconds' AND [id]=OBJECT_id('dbo.Constant'))
ALTER TABLE dbo.Constant ADD [Terminal Synch Time Seconds] int NOT NULL DEFAULT (86400)

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name]='Terminal Poll Punches Seconds' AND [id]=OBJECT_id('dbo.Constant'))
ALTER TABLE dbo.Constant ADD [Terminal Poll Punches Seconds] int NOT NULL DEFAULT (3600)

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name]='Terminal Synch All Fingerprints Start' AND [id]=OBJECT_id('dbo.Constant'))
ALTER TABLE dbo.Constant ADD [Terminal Synch All Fingerprints Start] datetime NULL DEFAULT ('20080101 03:00')

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name]='Terminal Synch New Fingerprints Start' AND [id]=OBJECT_id('dbo.Constant'))
ALTER TABLE dbo.Constant ADD [Terminal Synch New Fingerprints Start] datetime NULL DEFAULT ('20080101 03:00')

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name]='Terminal Poll Punches Start' AND [id]=OBJECT_id('dbo.Constant'))
ALTER TABLE dbo.Constant ADD [Terminal Poll Punches Start] datetime NULL DEFAULT ('20080101 03:00')

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name]='Terminal Synch Time Start' AND [id]=OBJECT_id('dbo.Constant'))
ALTER TABLE dbo.Constant ADD [Terminal Synch Time Start] datetime NULL DEFAULT ('20080101 02:01')

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name]='Terminal Default Sync Flags' AND [id]=OBJECT_id('dbo.Constant'))
ALTER TABLE dbo.Constant ADD [Terminal Default Sync Flags] int NOT NULL DEFAULT(0x37)

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name]='Terminal Default Enrollment Mask' AND [id]=OBJECT_id('dbo.Constant'))
ALTER TABLE dbo.Constant ADD [Terminal Default Enrollment Mask] int NOT NULL DEFAULT(0)

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name]='Terminal Allow Db PID Card Update' AND [id]=OBJECT_id('dbo.Constant'))
ALTER TABLE dbo.Constant ADD [Terminal Allow Db PID Card Update] bit NOT NULL DEFAULT(1)

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name]='OrgUserField1' AND [id]=OBJECT_id('dbo.Constant'))
ALTER TABLE dbo.Constant ADD OrgUserField1 varchar(50) NOT NULL DEFAULT('')

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name]='Deduction Code' and [ID]=OBJECT_id('Benefit'))
ALTER TABLE dbo.Benefit ADD [Deduction Code] varchar(50) NOT NULL DEFAULT('')

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name]='Deduction Code' and [ID]=OBJECT_id('TDRP'))
ALTER TABLE dbo.TDRP ADD [Deduction Code] varchar(50) NOT NULL DEFAULT('')

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name]='Deduction Code Loan Repay' and [ID]=OBJECT_id('TDRP'))
ALTER TABLE dbo.TDRP ADD [Deduction Code Loan Repay] varchar(50) NOT NULL DEFAULT('')

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name]='Deduction Code Catch Up' and [ID]=OBJECT_id('TDRP'))
ALTER TABLE dbo.TDRP ADD [Deduction Code Catch Up] varchar(50) NOT NULL DEFAULT('')
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name] = 'Pending Timecard Lock' AND [id] = OBJECT_id('Employee'))
ALTER TABLE dbo.Employee ADD [Pending Timecard Lock] int NOT NULL DEFAULT(-2147483648)
GO
IF OBJECT_ID('dbo.MailMerge') IS NOT NULL DROP TABLE dbo.MailMerge
GO
IF OBJECT_ID('dbo.MailMergeEmpty') IS NOT NULL DROP TABLE dbo.MailMergeEmpty
GO
CREATE TABLE dbo.MailMerge(
	[PersonID] [int] NOT NULL,
	[List As] [varchar](153) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
	[Title] [varchar](50) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[First Name] [varchar](50) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[Middle Name] [varchar](50) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[Last Name] [varchar](50) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[Suffix] [varchar](50) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[Credentials] [varchar](50) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[Male] [bit] NULL,
	[Work E-mail] [varchar](50) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[Work Phone] [varchar](50) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[Extension] [varchar](50) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[Work Phone Note] [varchar](50) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[Toll Free Phone] [varchar](50) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[Mobile Phone] [varchar](50) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[Work Fax] [varchar](50) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[Pager] [varchar](50) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[Note] [varchar](4000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[Work Address] [varchar](50) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[Work Address (cont.)] [varchar](50) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[Work City] [varchar](50) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[Work State] [varchar](50) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[Work ZIP] [varchar](50) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[Work Country] [varchar](50) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[Home Office Phone] [varchar](50) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[Extended Work Address] [varchar](256) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[Extended Work Phone] [varchar](102) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[Initials] [varchar](3) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[Formal Name] [varchar](101) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[IsEmployee] [bit] NULL,
	[Full Name] [varchar](152) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[IsApplicant] [bit] NULL,
	[IsRecruiter] [bit] NULL,
	[IsPhysician] [bit] NULL,
	[IsEmergencyContact] [bit] NULL,
	[Home Fax] [varchar](50) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[Home Phone] [varchar](50) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[Home E-mail] [varchar](50) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[Home Address] [varchar](50) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[Home Address (cont.)] [varchar](50) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[Home City] [varchar](50) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[Home State] [varchar](50) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[Home Zip] [varchar](50) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[Home Country] [varchar](50) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[Extended Home Address] [varchar](256) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[Next Performance Review] [datetime] NULL,
	[Last Performance Review] [datetime] NULL,
	[Filing Status] [varchar](50) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[Salaried] [bit] NULL,
	[Payroll Delay] [int] NULL,
	[Direct Deposit Account Number] [varchar](50) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[DefaultTimeTypeID] [int] NULL,
	[OT Pay Multiplier] [numeric](2, 1) NULL,
	[Holiday Pay Multiplier] [numeric](2, 1) NULL,
	[Weekend Pay Multiplier] [numeric](2, 1) NULL,
	[OT Basis] [tinyint] NULL,
	[FIT Exemptions] [int] NULL,
	[ManagerID] [int] NULL,
	[Active Employee] [bit] NULL,
	[Employee Number] [varchar](50) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[EmployeeNumberT] [varchar](50) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[Shift] [varchar](50) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[Manager] [varchar](153) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[Division] [varchar](50) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[Location] [varchar](50) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[Department] [varchar](50) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[Uniuons] [varchar](400) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[Last Position] [varchar](50) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[Seniority Begins] [datetime] NULL,
	[Seniority Begins FirstQuarterAfter6Months] [datetime] NULL,
	[Seniority Begins FirstMonthAfter30Days] [datetime] NULL,
	[Seniority Begins FirstMonthAfter6Months] [datetime] NULL,
	[LeaveBalance_Vacation_Dec31] decimal NULL,
	[LeaveBalance_Sick_Dec31] decimal NULL,
	[LeaveBalance_Personal_Dec31] decimal NULL,
	[LeaveBalance_PTO_Dec31] decimal NULL,
	[LeaveBalance_Vacation_NextDec31] decimal NULL,
	[LeaveBalance_Sick_NextDec31] decimal NULL,
	[LeaveBalance_Personal_NextDec31] decimal NULL,
	[LeaveBalance_PTO_NextDec31] decimal NULL,
	[DOH] [datetime] NULL,
	[SSN] [varchar](50) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[Unions] [varchar](400) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[Country of Citizenship] [varchar](50) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[Visa] [varchar](50) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[Passport] [varchar](50) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[Driver License] [varchar](50) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[Driver License State] [varchar](50) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[Commercial Driver License] [bit] NULL,
	[Dependents] [int] NULL,
	[Disabled] [bit] NULL,
	[Smoker] [bit] NULL,
	[Spouse] [varchar](50) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[Children] [varchar](50) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[Race] [varchar](50) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[I9 Status] [varchar](50) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[Marital Status] [varchar](50) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[DOB] [datetime] NULL,
	[Driver License Expires] [datetime] NULL,
	[Driver Insurance Expires] [datetime] NULL,
	[Renew I9 Status] [datetime] NULL,
	[Visa Expires] [datetime] NULL,
	[Passport Expires] [datetime] NULL,
	[Military Service] [varchar](59) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[Reserves] [bit] NULL,
	[Account] [nvarchar](50) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[Rehire] [bit] NULL,
	[Reason for Termination] [text] COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[Terminated] [datetime] NULL,
	[Annualized Pay] [money] NOT NULL,
	[Daily Pay] [money] NOT NULL,
	[Hourly Pay] [money] NOT NULL,
	[Employment Status] [varchar](50) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
	[Pay Grade] [varchar](15) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
	[Pay Step] [varchar](15) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
	[Job Title] [varchar](50) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
	[Successor Names] [varchar](400) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[Successor Initials] [varchar](400) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[Succeeds Names] [varchar](400) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[Succeeds Initials] [varchar](400) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[LOALeaveID] [int] NULL,
	[LOACoveringEmployeeID] [int] NULL,
	[LOA Advanced Type Mask] [int] NULL,
	[LOA Extended Type Mask] [int] NULL,
	[LOA Status] [tinyint] NULL,
	[LOA Note] [varchar](4000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[LOA Start] [datetime] NULL,
	[LOA Start+84] [datetime] NULL,
	[LOA Start+14] [datetime] NULL,
	[LOA Start+180] [datetime] NULL,
	[LOA Start+365] [datetime] NULL,
	[LOA Stop] [datetime] NULL,
	[LOA Requested] [datetime] NULL,
	[LOA Seconds] [int] NULL,
	[LOA Advanced Days] [int] NULL,
	[LOA Type Mask] [int] NULL,
	[LOA Reason] [varchar](50) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[LOA Authorized] [datetime] NULL,
	[LOA Departing Employee] [varchar](153) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[LOA Departing Employee Full Name] [varchar](152) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[LOA Authorizing Employee] [varchar](153) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[LOA Authorizing Employee Full Name] [varchar](152) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[LOA Denial Reason] [varchar](50) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[LOA Approval Type] [varchar](50) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[LOA Status Text] [varchar](87) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[LOA Preapproved Employee] [varchar](153) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[LOA Preapproved Date] [datetime] NULL,
	[LOA Expected Return] [datetime] NULL,
	[LOA Expected Return-1] [datetime] NULL,
	[LOA Expected Departure] [datetime] NULL,
	[LOA Last MD Note] [datetime] NULL,
	[LOA Pay Began] [datetime] NULL,
	[LOA Pay Ended] [datetime] NULL,
	[LOA Reconciled] [datetime] NULL,
	[InOutStatusID] [int] NULL,
	[InOutStatus] [varchar](50) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[InOutColor] [int] NULL,
	[InOutReturn] [smalldatetime] NULL,
	[InOutComment] [varchar](50) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[InOutLastUpdated] [smalldatetime] NULL,
	InOutLastSource varchar(50) COLLATE SQL_Latin1_General_CP1_CI_AS NULL
)
GO
SELECT TOP 0 * INTO dbo.MailMergeEmpty FROM dbo.MailMerge
GO
GRANT SELECT, DELETE, UPDATE, INSERT ON dbo.MailMerge TO public
GRANT SELECT ON dbo.MailMergeEmpty TO public
GO
IF NOT EXISTS(SELECT * FROM sysindexes WHERE [ID] = OBJECT_id('dbo.PaymentDetail') AND [name] = 'IX_PaymentDetail_InvoiceID')
CREATE INDEX IX_PaymentDetail_InvoiceID ON dbo.PaymentDetail(InvoiceID)
GO
IF NOT EXISTS(SELECT * FROM sysindexes WHERE [ID] = OBJECT_id('dbo.PaymentDetail') AND [name] = 'IX_PaymentDetail_PaymentID')
CREATE INDEX IX_PaymentDetail_PaymentID ON dbo.PaymentDetail(PaymentID)
GO
IF NOT EXISTS(SELECT * FROM sysindexes WHERE [ID] = OBJECT_id('dbo.PaymentRefund') AND [name] = 'IX_PaymentRefund_PaymentID')
CREATE INDEX IX_PaymentRefund_PaymentID ON dbo.PaymentRefund(PaymentID)
GO
IF NOT EXISTS(SELECT * FROM sysindexes WHERE [ID] = OBJECT_id('dbo.InvoiceCredit') AND [name] = 'IX_InvoiceCredit_InvoiceID')
CREATE INDEX IX_InvoiceCredit_InvoiceID ON dbo.InvoiceCredit(InvoiceID)
GO
IF NOT EXISTS(SELECT * FROM sysindexes WHERE [ID] = OBJECT_id('dbo.InvoiceDetail') AND [name] = 'IX_InvoiceDetail_InvoiceID')
CREATE INDEX IX_InvoiceDetail_InvoiceID ON dbo.InvoiceDetail(InvoiceID)
GO
IF OBJECT_ID('dbo.TimeSchemaBreak') IS NULL
BEGIN
	CREATE TABLE dbo.TimeSchemaBreak(
		[ItemID] [int] PRIMARY KEY IDENTITY(1,1) NOT NULL,
		[TimeSchemaID] [int] NOT NULL,
		[Start] [int] NOT NULL,
		[Seconds] [int] NOT NULL,
		[Break Start] [int] NOT NULL,
		[Break Seconds] [int] NOT NULL
	)

	ALTER TABLE dbo.TimeSchemaBreak  WITH CHECK ADD  CONSTRAINT [CK_TimeSchemaBreak_Seconds] CHECK  (([Seconds] > 0 and [Break Seconds] > 0))
	ALTER TABLE dbo.TimeSchemaBreak CHECK CONSTRAINT [CK_TimeSchemaBreak_Seconds]
	ALTER TABLE dbo.TimeSchemaBreak  WITH CHECK ADD  CONSTRAINT [CK_TimeSchemaBreak_Start] CHECK  (([Start] >= 0 and [Start] <= 86400 and ([Break Start] >= 0 and [Break Start] <= 86400)))
	ALTER TABLE dbo.TimeSchemaBreak CHECK CONSTRAINT [CK_TimeSchemaBreak_Start]
	ALTER TABLE dbo.TimeSchemaBreak  WITH CHECK ADD  CONSTRAINT [FK_TimeSchemaBreak_TimeSchema] FOREIGN KEY([TimeSchemaID])
	REFERENCES dbo.TimeSchema ([TimeSchemaID]) ON DELETE CASCADE
END
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [id]=OBJECT_ID('dbo.TimeSchema') AND [name]='Created')
ALTER TABLE dbo.TimeSchema ADD Created datetime NOT NULL DEFAULT GETDATE()

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [id]=OBJECT_ID('dbo.TimeSchema') AND [name]='Creator')
ALTER TABLE dbo.TimeSchema ADD Creator varbinary(85) NOT NULL DEFAULT SUSER_SID()
GO
IF OBJECT_ID('dbo.Break') IS NOT NULL
BEGIN
	IF NOT EXISTS(SELECT * FROM TimeSchemaBreak)
	BEGIN
		INSERT dbo.TimeSchemaBreak(TimeSchemaID, Start, Seconds, [Break Start], [Break Seconds])
		SELECT T.TimeSchemaID, B.Start, B.Seconds, B.[Break Start], B.[Break Seconds]
		FROM dbo.[Break] B CROSS JOIN dbo.TimeSchema T
	END
END
GO
IF NOT EXISTS(SELECT * FROM dbo.PermissionScope WHERE ScopeID=256)
BEGIN
	INSERT dbo.PermissionScope(ScopeID,Scope,Available) SELECT 256,'User Viewing Delegated Subordinate', 1
	INSERT dbo.PermissionScopeAttribute(ScopeID,AttributeID,UID,[Permission Mask],[Deny Mask])
	SELECT 256,AttributeId,UID,[Permission Mask],[Deny Mask] FROM PermissionScopeAttribute WHERE ScopeID=8
END
GO
IF NOT EXISTS(SELECT * FROM dbo.PermissionScope WHERE ScopeID=512)
BEGIN
	INSERT dbo.PermissionScope(ScopeID,Scope,Available) SELECT 512,'User Viewing Manager', 1
END
GO
IF NOT EXISTS(SELECT * FROM dbo.PermissionScope WHERE ScopeID=1024)
BEGIN
	INSERT dbo.PermissionScope(ScopeID,Scope,Available) SELECT 1024,'User Viewing Manager who Delegated Subordinate', 1
	INSERT dbo.PermissionScopeAttribute(ScopeID,AttributeID,UID,[Permission Mask],[Deny Mask])
	SELECT 1024,AttributeId,UID,[Permission Mask],[Deny Mask] FROM PermissionScopeAttribute WHERE ScopeID=4
END
GO
IF NOT EXISTS(SELECT * FROM dbo.PermissionScope WHERE ScopeID=2048)
BEGIN
	INSERT dbo.PermissionScope(ScopeID,Scope,Available) SELECT 2048,'User Viewing Manager''s Subordinates', 1
END
GO
IF NOT EXISTS(SELECT * FROM dbo.PermissionScope WHERE ScopeID=4096)
BEGIN
	INSERT dbo.PermissionScope(ScopeID,Scope,Available) SELECT 4096,'User Viewing an Employee in User''s Custom Org Grp', 1
END
GO
IF NOT EXISTS(SELECT * FROM dbo.PermissionScope WHERE ScopeID=8192)
BEGIN
	INSERT dbo.PermissionScope(ScopeID,Scope,Available) SELECT 8192,'User Viewing Inactive Employees', 1
END
GO
IF NOT EXISTS(SELECT * FROM dbo.PermissionScope WHERE ScopeID=16384)
BEGIN
	INSERT dbo.PermissionScope(ScopeID,Scope,Available) SELECT 16384,'User Viewing an Employee as a Leave Keeper', 1
END
GO
UPDATE dbo.PermissionAttribute set [Scope Possible Mask] = [Scope Possible Mask] | 14336
GO
UPDATE dbo.PermissionAttribute set [Scope Possible Mask] = [Scope Possible Mask] | 16384 WHERE ([Scope Possible Mask] & 24576) = 8192
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [name]='DelegatedManagerID' AND [id]=OBJECT_ID('dbo.Employee'))
BEGIN
	ALTER TABLE dbo.Employee ADD DelegatedManagerID int NULL
	ALTER TABLE dbo.Employee ADD CONSTRAINT FK_EmployeeManagerDelegate_Employee FOREIGN KEY (DelegatedManagerID) REFERENCES dbo.Employee (EmployeeID)
END
GO
IF NOT EXISTS(SELECT * FROM syscolumns WHERE [ID]=OBJECT_id('EmployeeProject') AND [name]='Flags')
ALTER TABLE dbo.EmployeeProject ADD Flags int NOT NULL DEFAULT(0)
GO
IF OBJECT_ID('FK_EmployeeProject_Employee') IS NOT NULL
BEGIN
	ALTER TABLE dbo.EmployeeProject DROP CONSTRAINT FK_EmployeeProject_Employee

	ALTER TABLE dbo.EmployeeProject ADD 
	CONSTRAINT [FK_EmployeeProject_Employee] FOREIGN KEY 
	(
		[EmployeeID]
	) REFERENCES dbo.[Employee] (
		[EmployeeID]
	) ON DELETE CASCADE
END
GO
IF NOT EXISTS(SELECT * FROM ColumnGrid WHERE FieldID = 1062)
BEGIN
	INSERT ColumnGrid(FieldID, [Table], [Key], colid, AttributeID, Field, Label, Importable, Reportable, [Order])
	SELECT 1062, 'Employee', 'EmployeeID', colid, 8, [name], 'Holiday Plan', 1, 1, 10003 FROM syscolumns WHERE [ID] = OBJECT_id('dbo.Employee') AND [name] = 'HolidayPlanID'
END
GO
DELETE H FROM Holiday H WHERE EXISTS
(
	SELECT * FROM Holiday H2 WHERE H.PlanID=H2.PlanID AND H2.[Month]=H.[Month] AND H2.[Day]=H.[Day] AND H2.[Year] IS NOT NULL
) AND H.[Year] IS NULL

DELETE H FROM Holiday H WHERE EXISTS
(
	SELECT * FROM Holiday H2 WHERE H.PlanID=H2.PlanID AND H2.HolidayID < H.HolidayID AND H2.[Month]=H.[Month] AND H2.[Day]=H.[Day] AND H2.[Year] IS NULL
) AND H.[Year] IS NULL

DELETE H FROM Holiday H WHERE EXISTS
(
	SELECT * FROM Holiday H2 WHERE H.PlanID=H2.PlanID AND H2.HolidayID < H.HolidayID AND H2.[Month]=H.[Month] AND H2.[Day]=H.[Day] AND H2.[Year]=H.[Year]
) AND H.[Year] IS NOT NULL


IF EXISTS(SELECT * FROM sysindexes WHERE [name]='IX_Holiday_MDY') DROP INDEX Holiday.IX_Holiday_MDY

IF NOT EXISTS(SELECT * FROM sysindexes WHERE [name]='IX_Holiday_PlanIDMDY')
CREATE UNIQUE INDEX IX_Holiday_MDY ON dbo.Holiday(PlanID, [Month], [Day], [Year])
GO
/* TABLE CHANGES END *********************************************************** */

/* PERMISSION ATTRIBUTE CHANGES BEGIN ****************************************** */
-- New permission attributes
IF NOT EXISTS (SELECT * FROM PermissionAttribute WHERE AttributeID = 10008)
INSERT PermissionAttribute
SELECT 10008, 'Timecard Schema', 127, 2

IF NOT EXISTS(SELECT * FROM PermissionAttribute WHERE AttributeID=10007)
INSERT PermissionAttribute(AttributeID, Attribute, [Scope Possible Mask], [Permission Possible Mask])
VALUES(10007, 'Languages Known', 255, 3)

/*IF NOT EXISTS(SELECT * FROM PermissionAttribute WHERE AttributeID=129)
INSERT PermissionAttribute(AttributeID, Attribute, [Scope Possible Mask], [Permission Possible Mask])
VALUES(129, 'LDAP', 255, 2)*/

IF NOT EXISTS (SELECT * FROM PermissionAttribute WHERE AttributeID = 262145)
BEGIN
	INSERT PermissionAttribute
	SELECT 262145, 'Time Approved', 127, 14

	UPDATE PermissionAttribute SET [Attribute] = 'Time Pending and Project Assignments' WHERE AttributeID = 262144

	INSERT PermissionScopeAttribute(ScopeID, AttributeID, UID, [Permission Mask])
	SELECT  ScopeID, 262145, UID, [Permission Mask] FROM PermissionScopeAttribute WHERE AttributeID = 262144
END





IF NOT EXISTS(SELECT * FROM PermissionAttribute WHERE AttributeID = 262145)
	BEGIN
		INSERT PermissionAttribute(AttributeID, Attribute, [Scope Possible Mask], [Permission Possible Mask])
		SELECT 262145, 'Timecard Approved Entries', 127, 14
	
		INSERT PermissionScopeAttribute(ScopeID, AttributeID, UID, [Permission Mask])
		SELECT ScopeID, 262145, UID, [Permission Mask] & 14 FROM PermissionScopeAttribute WHERE AttributeID = 262144
	END
UPDATE PermissionAttribute SET [Permission Possible Mask] = 14 WHERE Attributeid=262145

IF NOT EXISTS (SELECT * FROM PermissionAttribute WHERE AttributeID=47) 
INSERT PermissionAttribute(AttributeID,Attribute,[Scope Possible Mask],[Permission Possible Mask])
SELECT 47, 'Notes, Creator <3 days old', 127, 12
GO
IF NOT EXISTS (SELECT * FROM PermissionAttribute WHERE AttributeID=48)
BEGIN
BEGIN TRAN
	INSERT PermissionAttribute(AttributeID,Attribute,[Scope Possible Mask],[Permission Possible Mask])
	SELECT 48, 'Notes, Creator >2 days old', 127, 15

	UPDATE PermissionAttribute
	SET [Attribute] = 'Notes, Others', [Scope Possible Mask]=127, [Permission Possible Mask]=15 WHERE AttributeID=131072

	INSERT PermissionScopeAttribute(AttributeID, ScopeID, UID, [Permission Mask])
	SELECT 47, ScopeID, UID, [Permission Mask] & 13 FROM PermissionScopeAttribute WHERE AttributeID=131072

	INSERT PermissionScopeAttribute(AttributeID, ScopeID, UID, [Permission Mask])
	SELECT 48, ScopeID, UID, [Permission Mask] FROM PermissionScopeAttribute WHERE AttributeID=131072
COMMIT TRAN
END
GO

UPDATE PermissionAttribute SET Attribute='Dependents & Emrgncy Contcts' WHERE AttributeID=134217728

UPDATE PermissionAttribute SET [Permission Possible Mask]=14 WHERE AttributeID=48 
UPDATE PermissionAttribute SET [Permission Possible Mask]=14 WHERE AttributeID=47
GO
IF NOT EXISTS(SELECT * FROM PermissionAttribute WHERE AttributeID=50)
BEGIN
BEGIN TRAN
	INSERT PermissionAttribute(AttributeID,Attribute,[Scope Possible Mask], [Permission Possible Mask]) SELECT 50,'Time In/Out Status', 127, 15
	INSERT PermissionScopeAttribute(ScopeID,AttributeID,UID,[Permission Mask]) SELECT 2,50,0,15
COMMIT TRAN
END
GO

UPDATE Error SET Error='An employee can only have one accrual plan that does not specify a stop date. Enter a stop date for the first plan and try again.' WHERE ErrorID=50022
UPDATE PermissionAttribute SET [Permission Possible Mask]=14 WHERE AttributeID=48 
UPDATE PermissionAttribute SET [Permission Possible Mask]=14 WHERE AttributeID=47



IF NOT EXISTS(SELECT * FROM PermissionAttribute WHERE AttributeID=10010)
INSERT PermissionAttribute VALUES(10010,'Expenses Pending',127,15)

IF NOT EXISTS(SELECT * FROM PermissionAttribute WHERE AttributeID=10011)
INSERT PermissionAttribute VALUES(10011,'Expenses Approved',127,14)


IF NOT EXISTS(SELECT * FROM PermissionAttribute WHERE AttributeID=10012)
INSERT PermissionAttribute VALUES(10012,'Occurrences',127,15)
GO
IF NOT EXISTS(SELECT * FROM PermissionAttribute WHERE AttributeID=262143)
BEGIN
		INSERT dbo.PermissionAttribute(AttributeID,Attribute,[Scope Possible Mask],[Permission Possible Mask])
		SELECT 262143,'Timecard Punch',127,2

		INSERT dbo.PermissionScopeAttribute(ScopeID,AttributeID,UID,[Permission Mask],[Deny Mask])
		SELECT PEND.ScopeID,262143,PEND.UID,
		[Permission Mask] = CASE WHEN (APPROVED.[Permission Mask] | PEND.[Permission Mask]) & 10 > 0 THEN 2 ELSE 0 END,
		[Deny Mask] = CASE WHEN APPROVED.[Deny Mask] & PEND.[Deny Mask] & 2 = 2 THEN 2 ELSE 0 END
		FROM dbo.PermissionScopeAttribute PEND
		INNER JOIN dbo.PermissionScopeAttribute APPROVED ON PEND.ScopeID=4 AND PEND.ScopeID=APPROVED.ScopeID AND PEND.UID=APPROVED.UID AND PEND.AttributeID=262144 AND APPROVED.AttributeID=262145
		UNION
		SELECT PEND.ScopeID,262143,PEND.UID,
		[Permission Mask] = CASE WHEN PEND.[Permission Mask] & 10 = 10 THEN 2 ELSE 0 END,
		[Deny Mask] = CASE WHEN PEND.[Deny Mask] & 2 = 2 THEN 2 ELSE 0 END
		FROM dbo.PermissionScopeAttribute PEND
		LEFT JOIN dbo.PermissionScopeAttribute APPROVED ON PEND.ScopeID=APPROVED.ScopeID AND PEND.UID=APPROVED.UID AND APPROVED.AttributeID=262145
		WHERE PEND.ScopeID=4 AND PEND.AttributeID=262144 AND APPROVED.PermissionID IS NULL
		UNION
		SELECT APPROVED.ScopeID,262143,APPROVED.UID,
		[Permission Mask] = CASE WHEN APPROVED.[Permission Mask] & 10 = 10 THEN 2 ELSE 0 END,
		[Deny Mask] = CASE WHEN APPROVED.[Deny Mask] & 2 = 2 THEN 2 ELSE 0 END
		FROM dbo.PermissionScopeAttribute APPROVED
		LEFT JOIN dbo.PermissionScopeAttribute PEND ON PEND.ScopeID=APPROVED.ScopeID AND PEND.UID=APPROVED.UID AND PEND.AttributeID=262144
		WHERE APPROVED.ScopeID=4 AND APPROVED.AttributeID=262145 AND PEND.PermissionID IS NULL
END

UPDATE dbo.PermissionAttribute SET [Attribute]='Timecard Approved' WHERE AttributeID=262145
GO

IF (SELECT [Permission Possible Mask] FROM dbo.PermissionAttribute WHERE AttributeID=10007) != 15
BEGIN
	UPDATE dbo.PermissionAttribute SET [Permission Possible Mask] = 15 WHERE AttributeID=10007
	UPDATE dbo.PermissionScopeAttribute SET [Permission Mask] = 15 WHERE AttributeID=10007 AND [Permission Mask] = 3
END
GO
IF NOT EXISTS(SELECT * FROM dbo.PermissionAttribute WHERE AttributeID=10)
INSERT dbo.PermissionAttribute(AttributeID, Attribute, [Scope Possible Mask], [Permission Possible Mask])
VALUES(10, 'Terminal Sync Settings', 255, 3)
GO
IF NOT EXISTS(SELECT * FROM dbo.PermissionAttribute WHERE AttributeID=9)
BEGIN
	INSERT dbo.PermissionAttribute(AttributeID, Attribute, [Scope Possible Mask], [Permission Possible Mask])
	VALUES(9, 'Manager Delegation', 255, 3)

	-- Grants managers permission to delegate their subordinating managers' approval to someone else
	INSERT PermissionScopeAttribute(ScopeID,AttributeID,UID,[Permission Mask],[Deny Mask])
	SELECT 8,9,0,3,0

	-- Grants everyone permission to delegate their own approval to someone else
	INSERT PermissionScopeAttribute(ScopeID, AttributeID, [UID], [Permission Mask], [Deny Mask])
	SELECT 4,9,0,3,0
END
GO
-- Grants everyone permission to delegate their own approval to someone else
IF NOT EXISTS (SELECT * FROM dbo.PermissionScopeAttribute WHERE ScopeID=4 AND AttributeID=9 AND [UID]=0)
INSERT PermissionScopeAttribute(ScopeID, AttributeID, [UID], [Permission Mask], [Deny Mask])
SELECT 4,9,0,3,0

UPDATE dbo.PermissionAttribute SET [Scope Possible Mask] = [Scope Possible Mask] | 256 WHERE ([Scope Possible Mask] & 258)=2
UPDATE dbo.PermissionAttribute SET [Scope Possible Mask] = [Scope Possible Mask] | 512 WHERE ([Scope Possible Mask] & 514)=2
UPDATE dbo.PermissionAttribute SET [Scope Possible Mask] = [Scope Possible Mask] | 1024 WHERE ([Scope Possible Mask] & 1026)=2
GO
UPDATE dbo.PermissionAttribute SET Attribute = 'Leave Pending Entries' WHERE AttributeID=10001


IF NOT EXISTS(SELECT * FROM PermissionAttribute WHERE AttributeID=10013)
BEGIN
		INSERT dbo.PermissionAttribute(AttributeID,Attribute,[Scope Possible Mask],[Permission Possible Mask])
		SELECT 10013,'Leave Approved Entries',127,14

		/* Pending R--- --> ----
		Pending R-CD --> ---D
		Pending R-C- --> ----
		Pending RWC- --> -WC-
		Pending RWCD --> -WCD */
		INSERT dbo.PermissionScopeAttribute(ScopeID,AttributeID,UID,[Permission Mask],[Deny Mask])
		SELECT ScopeID,10013,UID, [Permission Mask] & CASE WHEN [Permission Mask] & 2 = 0 THEN 8 ELSE 14 END, [Deny Mask] & 14 
		FROM dbo.PermissionScopeAttribute WHERE AttributeID=10001
END
GO
IF NOT EXISTS(SELECT * FROM PermissionAttribute WHERE AttributeID=536870913)
INSERT PermissionAttribute(AttributeID, Attribute, [Scope Possible Mask], [Permission Possible Mask])
SELECT 536870913, 'Benefit Invoices', 127, 15


IF NOT EXISTS(SELECT * FROM PermissionAttribute WHERE AttributeID=536870914)
INSERT PermissionAttribute(AttributeID, Attribute, [Scope Possible Mask], [Permission Possible Mask])
SELECT 536870914, 'Benefit Payments', 127, 15

	UPDATE PermissionAttribute SET Attribute = 'Timecard Pending Entries' WHERE AttributeID = 262144
/* PERMISSION ATTRIBUTE CHANGES END ******************************************** */

/* FUNCTION CHANGES BEGIN ****************************************************** */
GO
EXEC dbo.spAdminCreateFunctionifNonexistent 'fnFormatCurrencyAsString'
GO
ALTER FUNCTION dbo.fnFormatCurrencyAsString(@c money) RETURNS varchar(50)
AS
BEGIN
RETURN CAST(CAST(@c AS numeric(9,2)) AS varchar(50))
END
GO
EXEC dbo.spAdminCreateFunctionifNonexistent 'fnCountBits'
GO
ALTER FUNCTION dbo.fnCountBits(@mask int) RETURNS int
AS
BEGIN
RETURN CASE WHEN @mask & 1 = 0 THEN 0 ELSE 1 END +
CASE WHEN @mask & 2 = 0 THEN 0 ELSE 1 END +
CASE WHEN @mask & 4 = 0 THEN 0 ELSE 1 END +
CASE WHEN @mask & 8 = 0 THEN 0 ELSE 1 END +
CASE WHEN @mask & 16 = 0 THEN 0 ELSE 1 END +
CASE WHEN @mask & 32= 0 THEN 0 ELSE 1 END +
CASE WHEN @mask & 64 = 0 THEN 0 ELSE 1 END +
CASE WHEN @mask & 128 = 0 THEN 0 ELSE 1 END +
CASE WHEN @mask & 256 = 0 THEN 0 ELSE 1 END +
CASE WHEN @mask & 512 = 0 THEN 0 ELSE 1 END +
CASE WHEN @mask & 1024 = 0 THEN 0 ELSE 1 END +
CASE WHEN @mask & 2048 = 0 THEN 0 ELSE 1 END +
CASE WHEN @mask & 4096 = 0 THEN 0 ELSE 1 END +
CASE WHEN @mask & 8192 = 0 THEN 0 ELSE 1 END +
CASE WHEN @mask & 16384 = 0 THEN 0 ELSE 1 END +
CASE WHEN @mask & 32768 = 0 THEN 0 ELSE 1 END +
CASE WHEN @mask & 65536 = 0 THEN 0 ELSE 1 END +
CASE WHEN @mask & 131072 = 0 THEN 0 ELSE 1 END +
CASE WHEN @mask & 262144 = 0 THEN 0 ELSE 1 END +
CASE WHEN @mask & 524288 = 0 THEN 0 ELSE 1 END +
CASE WHEN @mask & 1048576 = 0 THEN 0 ELSE 1 END +
CASE WHEN @mask & 2097152 = 0 THEN 0 ELSE 1 END +
CASE WHEN @mask & 4194304 = 0 THEN 0 ELSE 1 END +
CASE WHEN @mask & 0x800000 = 0 THEN 0 ELSE 1 END +
CASE WHEN @mask & 0x1000000 = 0 THEN 0 ELSE 1 END +
CASE WHEN @mask & 0x2000000 = 0 THEN 0 ELSE 1 END +
CASE WHEN @mask & 0x4000000 = 0 THEN 0 ELSE 1 END +
CASE WHEN @mask & 0x8000000 = 0 THEN 0 ELSE 1 END +
CASE WHEN @mask & 0x10000000 = 0 THEN 0 ELSE 1 END +
CASE WHEN @mask & 0x20000000 = 0 THEN 0 ELSE 1 END +
CASE WHEN @mask & 0x40000000 = 0 THEN 0 ELSE 1 END
END
GO
EXEC dbo.spAdminCreateFunctionifNonexistent 'fnConvertPay2'
GO
ALTER FUNCTION dbo.fnConvertPay2(@source_pay money, @position_fte40 numeric(9,4), @employe_seconds_per_week int, @Ms int, @Bs int, @Ss int, @Mt int, @Bt int, @St int) RETURNS money
AS
BEGIN
	DECLARE @a numeric(28,13), @b numeric(28,13), @fte40 numeric(9,4)

	SELECT @fte40 = CASE WHEN @employe_seconds_per_week IS NULL THEN @position_fte40 ELSE @employe_seconds_per_week / 144000.0 END
	SELECT @a = @St * (@fte40 * @Mt + @Bt), @b = @Ss * (@fte40 * @Ms + @Bs)
	
	RETURN CASE
		WHEN @a=0 OR @b=0 THEN 0
		ELSE (@a / @b) * @source_pay
	END
END
GO
EXEC dbo.spAdminCreateFunctionifNonexistent 'fnGetAnnualizedPayRange2'
GO
ALTER FUNCTION dbo.fnGetAnnualizedPayRange2(@min_rate money, @max_rate money, @pos_seconds_per_week int, @employe_seconds_per_week int) RETURNS varchar(50)
AS
BEGIN
	DECLARE @seconds_per_week int
	SET @seconds_per_week = CASE WHEN @employe_seconds_per_week IS NULL THEN @pos_seconds_per_week ELSE @employe_seconds_per_week END
	RETURN CONVERT(varchar(50), dbo.fnMultiplyMoney(@min_rate, 2080.0 * @seconds_per_week / 144000.0), 1) +
	CASE WHEN @min_rate = @max_rate THEN '' ELSE
	+ ' to ' +
	CONVERT(varchar(50), dbo.fnMultiplyMoney(@max_rate, 2080.0 * @seconds_per_week / 144000.0), 1)
	END
END
GO
EXEC dbo.spAdminCreateFunctionifNonexistent 'fnRoundUp'
GO
ALTER FUNCTION dbo.fnRoundUp(@seconds int, @round int) RETURNS int WITH SCHEMABINDING AS
BEGIN
	RETURN CASE 
	WHEN @round <= 1 THEN @seconds
	ELSE ((@seconds + @round - 1) / @round) * @round END
END
GO
EXEC dbo.spAdminCreateFunctionifNonexistent 'fnIsBenefitActive'
GO
ALTER FUNCTION dbo.fnIsBenefitActive(@declined_day int, @expires_day int, @first_enrolled_day int, @last_enrolled_day int) RETURNS bit WITH SCHEMABINDING AS
BEGIN
	RETURN CASE 
	WHEN @declined_day IS NULL AND (@expires_day IS NOT NULL OR @first_enrolled_day IS NOT NULL OR @last_enrolled_day  IS NOT NULL) THEN 1
	ELSE 0 END
END
GO
EXEC dbo.spAdminCreateFunctionifNonexistent 'fnGetCustomFieldText'
GO
ALTER FUNCTION dbo.fnGetCustomFieldText(@field_id int, @value sql_variant) RETURNS varchar(MAX) AS
BEGIN
DECLARE @r varchar(MAX)
SELECT @r = CASE
	WHEN C.TypeID = 1 AND (C.Attributes & 0xFF) = 2 THEN SUBSTRING(
		ISNULL((SELECT ','+C1.[Text] FROM CustomFieldItem C1 WHERE (CAST(@value AS int) & 1)=1 AND ISNULL(C.CopyItemsFromFieldID, C.FieldID)=C1.FieldID AND C1.[Value]=1), '') +
		ISNULL((SELECT ','+C2.[Text] FROM CustomFieldItem C2 WHERE (CAST(@value AS int) & 2)=2 AND ISNULL(C.CopyItemsFromFieldID, C.FieldID)=C2.FieldID AND C2.[Value]=2), '') +
		ISNULL((SELECT ','+C4.[Text] FROM CustomFieldItem C4 WHERE (CAST(@value AS int) & 4)=4 AND ISNULL(C.CopyItemsFromFieldID, C.FieldID)=C4.FieldID AND C4.[Value]=4), '') +
		ISNULL((SELECT ','+C8.[Text] FROM CustomFieldItem C8 WHERE (CAST(@value AS int) & 8)=8 AND ISNULL(C.CopyItemsFromFieldID, C.FieldID)=C8.FieldID AND C8.[Value]=8), '') +

		ISNULL((SELECT ','+C10.[Text] FROM CustomFieldItem C10 WHERE (CAST(@value AS int) & 0x10)=0x10 AND ISNULL(C.CopyItemsFromFieldID, C.FieldID)=C10.FieldID AND C10.[Value]=0x10), '') +
		ISNULL((SELECT ','+C20.[Text] FROM CustomFieldItem C20 WHERE (CAST(@value AS int) & 0x20)=0x20 AND ISNULL(C.CopyItemsFromFieldID, C.FieldID)=C20.FieldID AND C20.[Value]=0x20), '') +
		ISNULL((SELECT ','+C40.[Text] FROM CustomFieldItem C40 WHERE (CAST(@value AS int) & 0x40)=0x40 AND ISNULL(C.CopyItemsFromFieldID, C.FieldID)=C40.FieldID AND C40.[Value]=0x40), '') +
		ISNULL((SELECT ','+C80.[Text] FROM CustomFieldItem C80 WHERE (CAST(@value AS int) & 0x80)=0x80 AND ISNULL(C.CopyItemsFromFieldID, C.FieldID)=C80.FieldID AND C80.[Value]=0x80), '') +

		ISNULL((SELECT ','+C100.[Text] FROM CustomFieldItem C100 WHERE (CAST(@value AS int) & 0x100)=0x100 AND ISNULL(C.CopyItemsFromFieldID, C.FieldID)=C100.FieldID AND C100.[Value]=0x100), '') +
		ISNULL((SELECT ','+C200.[Text] FROM CustomFieldItem C200 WHERE (CAST(@value AS int) & 0x200)=0x200 AND ISNULL(C.CopyItemsFromFieldID, C.FieldID)=C200.FieldID AND C200.[Value]=0x200), '') +
		ISNULL((SELECT ','+C400.[Text] FROM CustomFieldItem C400 WHERE (CAST(@value AS int) & 0x400)=0x400 AND ISNULL(C.CopyItemsFromFieldID, C.FieldID)=C400.FieldID AND C400.[Value]=0x400), '') +
		ISNULL((SELECT ','+C800.[Text] FROM CustomFieldItem C800 WHERE (CAST(@value AS int) & 0x800)=0x800 AND ISNULL(C.CopyItemsFromFieldID, C.FieldID)=C800.FieldID AND C800.[Value]=0x800), '') +

		ISNULL((SELECT ','+C1000.[Text] FROM CustomFieldItem C1000 WHERE (CAST(@value AS int) & 0x1000)=0x1000 AND ISNULL(C.CopyItemsFromFieldID, C.FieldID)=C1000.FieldID AND C1000.[Value]=0x1000), '') +
		ISNULL((SELECT ','+C2000.[Text] FROM CustomFieldItem C2000 WHERE (CAST(@value AS int) & 0x2000)=0x2000 AND ISNULL(C.CopyItemsFromFieldID, C.FieldID)=C2000.FieldID AND C2000.[Value]=0x2000), '') +
		ISNULL((SELECT ','+C4000.[Text] FROM CustomFieldItem C4000 WHERE (CAST(@value AS int) & 0x4000)=0x4000 AND ISNULL(C.CopyItemsFromFieldID, C.FieldID)=C4000.FieldID AND C4000.[Value]=0x4000), '') +
		ISNULL((SELECT ','+C8000.[Text] FROM CustomFieldItem C8000 WHERE (CAST(@value AS int) & 0x8000)=0x8000 AND ISNULL(C.CopyItemsFromFieldID, C.FieldID)=C8000.FieldID AND C8000.[Value]=0x8000), '') +

		ISNULL((SELECT ','+C10000.[Text] FROM CustomFieldItem C10000 WHERE (CAST(@value AS int) & 0x10000)=0x10000 AND ISNULL(C.CopyItemsFromFieldID, C.FieldID)=C10000.FieldID AND C10000.[Value]=0x10000), '') +
		ISNULL((SELECT ','+C20000.[Text] FROM CustomFieldItem C20000 WHERE (CAST(@value AS int) & 0x20000)=0x20000 AND ISNULL(C.CopyItemsFromFieldID, C.FieldID)=C20000.FieldID AND C20000.[Value]=0x20000), '') +
		ISNULL((SELECT ','+C40000.[Text] FROM CustomFieldItem C40000 WHERE (CAST(@value AS int) & 0x40000)=0x40000 AND ISNULL(C.CopyItemsFromFieldID, C.FieldID)=C40000.FieldID AND C40000.[Value]=0x40000), '') +
		ISNULL((SELECT ','+C80000.[Text] FROM CustomFieldItem C80000 WHERE (CAST(@value AS int) & 0x80000)=0x80000 AND ISNULL(C.CopyItemsFromFieldID, C.FieldID)=C80000.FieldID AND C80000.[Value]=0x80000), '') +

		ISNULL((SELECT ','+C100000.[Text] FROM CustomFieldItem C100000 WHERE (CAST(@value AS int) & 0x100000)=0x100000 AND ISNULL(C.CopyItemsFromFieldID, C.FieldID)=C100000.FieldID AND C100000.[Value]=0x100000), '') +
		ISNULL((SELECT ','+C200000.[Text] FROM CustomFieldItem C200000 WHERE (CAST(@value AS int) & 0x200000)=0x200000 AND ISNULL(C.CopyItemsFromFieldID, C.FieldID)=C200000.FieldID AND C200000.[Value]=0x200000), '') +
		ISNULL((SELECT ','+C400000.[Text] FROM CustomFieldItem C400000 WHERE (CAST(@value AS int) & 0x400000)=0x400000 AND ISNULL(C.CopyItemsFromFieldID, C.FieldID)=C400000.FieldID AND C400000.[Value]=0x400000), '') +
		ISNULL((SELECT ','+C800000.[Text] FROM CustomFieldItem C800000 WHERE (CAST(@value AS int) & 0x800000)=0x800000 AND ISNULL(C.CopyItemsFromFieldID, C.FieldID)=C800000.FieldID AND C800000.[Value]=0x800000), '') +

		ISNULL((SELECT ','+C1000000.[Text] FROM CustomFieldItem C1000000 WHERE (CAST(@value AS int) & 0x1000000)=0x1000000 AND ISNULL(C.CopyItemsFromFieldID, C.FieldID)=C1000000.FieldID AND C1000000.[Value]=0x1000000), '') +
		ISNULL((SELECT ','+C2000000.[Text] FROM CustomFieldItem C2000000 WHERE (CAST(@value AS int) & 0x2000000)=0x2000000 AND ISNULL(C.CopyItemsFromFieldID, C.FieldID)=C2000000.FieldID AND C2000000.[Value]=0x2000000), '') +
		ISNULL((SELECT ','+C4000000.[Text] FROM CustomFieldItem C4000000 WHERE (CAST(@value AS int) & 0x4000000)=0x4000000 AND ISNULL(C.CopyItemsFromFieldID, C.FieldID)=C4000000.FieldID AND C4000000.[Value]=0x4000000), '') +
		ISNULL((SELECT ','+C8000000.[Text] FROM CustomFieldItem C8000000 WHERE (CAST(@value AS int) & 0x8000000)=0x8000000 AND ISNULL(C.CopyItemsFromFieldID, C.FieldID)=C8000000.FieldID AND C8000000.[Value]=0x8000000), '') +

		ISNULL((SELECT ','+C10000000.[Text] FROM CustomFieldItem C10000000 WHERE (CAST(@value AS int) & 0x10000000)=0x10000000 AND ISNULL(C.CopyItemsFromFieldID, C.FieldID)=C10000000.FieldID AND C10000000.[Value]=0x10000000), '') +
		ISNULL((SELECT ','+C20000000.[Text] FROM CustomFieldItem C20000000 WHERE (CAST(@value AS int) & 0x20000000)=0x20000000 AND ISNULL(C.CopyItemsFromFieldID, C.FieldID)=C20000000.FieldID AND C20000000.[Value]=0x20000000), '') +
		ISNULL((SELECT ','+C40000000.[Text] FROM CustomFieldItem C40000000 WHERE (CAST(@value AS int) & 0x40000000)=0x40000000 AND ISNULL(C.CopyItemsFromFieldID, C.FieldID)=C40000000.FieldID AND C40000000.[Value]=0x40000000), '')
		,2,50)
	WHEN L.[Text] IS NOT NULL THEN L.[Text]
	WHEN Department.Department IS NOT NULL THEN Department.Department
	WHEN Division.Division IS NOT NULL THEN Division.Division
	WHEN Location.[List As] IS NOT NULL THEN Location.[List As]
	WHEN dbo.fnGetListAs(E.[First Name], E.[Middle Name], E.[Last Name], E.Suffix) IS NOT NULL THEN dbo.fnGetListAs(E.[First Name], E.[Middle Name], E.[Last Name], E.Suffix)
	WHEN C.[TypeID]=3 AND @value IS NULL THEN '0'
	WHEN @value IS NULL THEN ''
	ELSE CAST(@value AS varchar(50))
END
FROM CustomField C
LEFT JOIN CustomFieldItem L ON C.FieldID=@field_id AND C.TypeID=1 AND (C.Attributes & 0xFF) IN (1, 3) AND L.FieldID=ISNULL(C.CopyItemsFromFieldID, C.FieldID) AND @value=L.Value
LEFT JOIN Department ON C.TypeID=1 AND (C.Attributes & 0xFF)=4 AND @value=Department.DepartmentID
LEFT JOIN Division ON C.TypeID=1 AND (C.Attributes & 0xFF)=5 AND @value=Division.DivisionID
LEFT JOIN Location ON C.TypeID=1 AND (C.Attributes & 0xFF)=6 AND @value=Location.LocationID
LEFT JOIN Person E ON C.TypeID=1 AND (C.Attributes & 0xFF)=7 AND @value=E.PersonID
WHERE C.FieldID=@field_id

RETURN @r
END
GO
EXEC dbo.spAdminCreateFunctionifNonexistent 'fnGetHHMMfromSeconds'
GO
ALTER FUNCTION dbo.fnGetHHMMfromSeconds(@seconds int) RETURNS varchar(5)
BEGIN
	RETURN CASE 
		WHEN @seconds >= 360000 THEN '99' 
		WHEN @seconds >= 36000 THEN CAST(@seconds / 3600 AS char(2))
		ELSE '0' + CAST(@seconds / 3600 AS char(1))
	END + ':' + CASE 
		WHEN @seconds % 3600 >= 600 THEN CAST((@seconds % 3600) / 60 AS char(2))
		ELSE '0' + CAST((@seconds % 3600) / 60 AS char(1))
	END
END
GO
EXEC dbo.spAdminCreateFunctionifNonexistent 'fnGetBeginningOfSemiMonthlyPeriod'
GO
ALTER FUNCTION dbo.fnGetBeginningOfSemiMonthlyPeriod(@d datetime, @offset int, @d1 int, @d2 int) RETURNS varchar(50)
BEGIN
	DECLARE @day int, @month int, @year int

	IF @offset <> 0 SET @d = DATEADD(d,@offset,@d)
	SELECT @day = DAY(@d), @month = MONTH(@d), @year = YEAR(@d)

	-- Get end of last period
	IF @day > @d2 SET @day = @d2
	ELSE IF @day > @d1 SET @day = @d1
	ELSE SELECT @day = @d2, @month = @month - 1

	-- Add one day to get beginning of this period
	RETURN DATEADD(d,1,dbo.AddMonthsToDY(@month, @day, @year))
END
GO
EXEC dbo.spAdminCreateFunctionifNonexistent 'fnGetEndOfSemiMonthlyPeriod'
GO
ALTER FUNCTION dbo.fnGetEndOfSemiMonthlyPeriod(@d datetime, @offset int, @d1 int, @d2 int) RETURNS datetime
BEGIN
	DECLARE @day int, @month int, @year int

	IF @offset <> 0 SET @d = DATEADD(d,@offset,@d)
	SELECT @day = DAY(@d), @month = MONTH(@d), @year = YEAR(@d)

	IF @day <= @d1 SET @day = @d1
	ELSE IF @day <= @d2 SET @day = @d2
	ELSE SELECT @day = @d1, @month = @month + 1

	RETURN dbo.AddMonthsToDY(@month, @day, @year)	
END
GO
EXEC dbo.spAdminCreateFunctionifNonexistent 'fnIsMissedPunch'
GO
ALTER FUNCTION dbo.fnIsMissedPunch
(
	@in datetime,
	@out datetime,
	@seconds int,
	@max_seconds int
)
RETURNS bit
BEGIN
IF @seconds IS NULL SET @seconds = DATEDIFF(second,@in,@out)
ELSE IF @out IS NULL SET @out = DATEADD(second,@seconds,@in)
RETURN
	CASE 
		WHEN @max_seconds > 0 AND @seconds > @max_seconds THEN 1
		WHEN @max_seconds = 0 AND DATEDIFF(d,0,@in) <> DATEDIFF(d,0,@out) THEN 1
		ELSE 0
	END
END
GO
EXEC dbo.spAdminCreateFunctionifNonexistent 'fnIsMissedPunch2'
GO
ALTER FUNCTION dbo.fnIsMissedPunch2
(
	@in datetime,
	@out datetime,
	@seconds int,
	@max_seconds int,
	@shift_start int,
	@shift_stop int
)
RETURNS bit
BEGIN
IF OBJECT_ID('dbo.fnCustom_IsMissedPunch2') IS NOT NULL RETURN dbo.fnCustom_IsMissedPunch2(@in, @out, @seconds, @max_seconds, @shift_start, @shift_stop)

DECLARE @dayi int, @dayo int, @si int, @so int
SELECT @dayi = DATEDIFF(d,0,@in), @dayo = DATEDIFF(d,0,@out), @shift_start = @shift_start % 86400, @shift_stop = @shift_stop % 86400
SELECT @si = DATEDIFF(second,@dayi,@in) % 86400, @so = DATEDIFF(second,@dayo,@out) % 86400

IF @seconds IS NULL SET @seconds = DATEDIFF(second,@in,@out)
ELSE IF @out IS NULL SET @out = DATEADD(second,@seconds,@in)
RETURN
	CASE 
		WHEN @max_seconds > 0 AND @seconds > @max_seconds THEN 1
		WHEN @max_seconds = 0 AND @dayi <> @dayo THEN 1
		WHEN @shift_start > 0 AND @shift_stop > 0 AND (ABS(@shift_stop - @si) < ABS(@shift_start - @si)) AND (ABS(@shift_start - @so) < ABS(@shift_stop - @so)) THEN 1 -- in closer to shfit stop and out closer to shift start
		ELSE 0
	END
END
GO
EXEC dbo.spAdminCreateFunctionifNonexistent 'fnPermissionGetOnPersonForCurrentUser'
GO
ALTER FUNCTION dbo.fnPermissionGetOnPersonForCurrentUser
(
	@person_id int,
	@attribute_id int
)
RETURNS int
BEGIN
	-- Returns the permission on a given attribute 
	-- on a given person (employee\applicant...) for the current user
	DECLARE @permission int
	DECLARE @user_employee_id int
	DECLARE @user_department_id int, @employee_department_id int
	DECLARE @user_division_id int, @employee_division_id int
	DECLARE @user_location_id int, @employee_location_id int
	DECLARE @user_manager_id int, @employee_delegated_manager_id int
	DECLARE @user_org_user_field_1 int, @employee_org_user_field_1 int
	DECLARE @user_sid varbinary(85), @employee_active bit
	DECLARE @employee_dept_lkid int, @employee_div_lkid int

	IF IS_MEMBER('db_owner') = 1
		SELECT @permission = 0x7FFFFFFF
	ELSE
	BEGIN
		DECLARE @deny int, @permission_cache_expires datetime
		SELECT @deny = 0, @permission = 0, @user_sid = SUSER_SID(), @permission_cache_expires = DATEADD(hour, -1, GETDATE())

		SELECT @permission = [Permission Mask] FROM dbo.PermissionCached WHERE [SID] = @user_sid AND PersonID = @person_id AND AttributeID = @attribute_id AND Created > @permission_cache_expires
		IF @@ROWCOUNT = 1 RETURN @permission

		SELECT @user_org_user_field_1 = OrgUserField1, @user_manager_id = ManagerID, @user_employee_id = EmployeeID, @user_division_id = DivisionID, @user_department_id = DepartmentID, @user_location_id = LocationID FROM dbo.Employee WHERE [SID] = @user_sid
		SELECT @employee_active = [Active Employee], @employee_org_user_field_1 = OrgUserField1, @employee_delegated_manager_id = DelegatedManagerID, @employee_department_id = DepartmentID, @employee_division_id = DivisionID, @employee_location_id = LocationID FROM dbo.Employee WHERE EmployeeID = @person_id
		SELECT @employee_dept_lkid = LeaveKeeperID FROM dbo.Department WHERE DepartmentID = @employee_department_id
		SELECT @employee_div_lkid = LeaveKeeperID FROM dbo.Division WHERE DivisionID = @employee_division_id

		-- Select permissions for people
		SELECT @permission = @permission | P.[Permission Mask], @deny = @deny | P.[Deny Mask]
		FROM dbo.PermissionScopeAttribute P
		INNER JOIN dbo.sysusers U ON P.ScopeID = 1 AND P.AttributeID = @attribute_id AND P.UID = U.uid AND (U.SID = @user_sid OR IS_MEMBER(U.[name]) = 1)

		-- Select permissions for applicant
		SELECT @permission = @permission | P.[Permission Mask], @deny = @deny | P.[Deny Mask]
		FROM dbo.PermissionScopeAttribute P
		INNER JOIN dbo.Applicant ON Applicant.ApplicantID = @person_id AND P.ScopeID = 128 AND P.AttributeID = @attribute_id

		-- Select employee-level permissions
		SELECT @permission = @permission | P.[Permission Mask], @deny = @deny | P.[Deny Mask]
		FROM dbo.PermissionScopeAttribute P 
		INNER JOIN dbo.sysusers U ON  P.AttributeID = @attribute_id AND P.UID = U.uid AND (U.SID = @user_sid OR IS_MEMBER(U.[name]) = 1)
			AND (
				(P.ScopeID = 2) OR					-- All employees								
				(P.ScopeID = 4 AND @user_employee_id = @person_id) OR			-- Self
				(P.ScopeID = 16 AND @employee_division_id = @user_division_id) OR	-- Employees in same division
				(P.ScopeID = 32 AND @employee_department_id = @user_department_id) OR	-- Employees in same department
				(P.ScopeID = 64 AND @employee_location_id = @user_location_id) OR	-- Employees in same location
				(P.ScopeID = 8 AND EXISTS(				-- Subordinates
					SELECT * FROM dbo.EmployeeSuperior S WHERE S.EmployeeID = @person_id AND S.SuperiorID = @user_employee_id
				)) OR
				(P.ScopeID = 256 AND EXISTS(		-- Delegated subordinates
					SELECT * FROM dbo.EmployeeSuperior S INNER JOIN dbo.Employee DM ON S.EmployeeID = @person_id AND S.SuperiorID = DM.EmployeeID AND DM.DelegatedManagerID = @user_employee_id
				)) OR
				(P.ScopeID = 512 AND @person_id = @user_manager_id) OR -- Manager
				(P.ScopeID = 1024 AND @employee_delegated_manager_id = @user_employee_id) OR -- Delegated self
				(P.ScopeID = 2048 AND EXISTS(				-- Manager's subordinates
					SELECT * FROM dbo.EmployeeSuperior S WHERE S.EmployeeID = @person_id AND S.SuperiorID = @user_manager_id
				)) OR
				(P.ScopeID = 4096 AND (
					(@user_org_user_field_1 IS NOT NULL AND @employee_org_user_field_1 = @user_org_user_field_1) OR 
					EXISTS(SELECT * FROM EmployeeUserFieldItem WHERE EmployeeID=@user_employee_id AND ItemID=@employee_org_user_field_1)
				)) OR -- Employees in same user org
				(P.ScopeID = 8192 AND @employee_active = 0) OR										-- Inactive employees
				(P.ScopeID = 16384 AND @user_employee_id IN (@employee_div_lkid, @employee_dept_lkid))	-- Leave keeper
			)
		-- Any deny overrides every grant
		SELECT @permission = @permission & (0x7FFFFFFF ^ @deny)
	END

	RETURN @permission
END
GO
EXEC dbo.spAdminCreateFunctionifNonexistent 'fnTimeRoundIn'
GO
ALTER FUNCTION dbo.fnTimeRoundIn(@flags int, @rounding_seconds int, @in datetime) RETURNS datetime AS
BEGIN
	IF (@flags & 12) = 0 OR @rounding_seconds=1 RETURN @in
	
	DECLARE @d datetime, @in_seconds int
	SET @d = DATEADD(d,0,DATEDIFF(d,0,@in))
	SET @in_seconds = DATEDIFF(second,@d,@in)
	
	RETURN DATEADD(second, (CASE
		-- round down
		WHEN (@flags & 12) = 12 THEN @in_seconds
		-- round
		WHEN (@flags & 4) = 4 THEN @in_seconds + @rounding_seconds / 2
		-- round up
		WHEN (@flags & 8) = 8 THEN @in_seconds + @rounding_seconds - 1
		ELSE @in_seconds
	END / @rounding_seconds) * @rounding_seconds, @d)
END
GO
EXEC dbo.spAdminCreateFunctionifNonexistent 'fnTimeRoundOut'
GO
ALTER FUNCTION dbo.fnTimeRoundOut(@flags int, @rounding_seconds int, @in datetime, @seconds int) RETURNS datetime AS
BEGIN
	DECLARE @out datetime
	SET @out = DATEADD(second, @seconds, @in)
	
	-- 0 = shift hours, but that's not supported by this function

	DECLARE @d datetime, @out_seconds numeric(19,5)
	SET @d = DATEADD(d,0,DATEDIFF(d,0,@out))
	SET @out_seconds = DATEDIFF(second,@d,@out)
	
	RETURN CASE (@flags & 0x70)
		-- round down
		WHEN 0x30 THEN DATEADD(second, FLOOR(@out_seconds / @rounding_seconds) * @rounding_seconds, @d)
		-- round up
		WHEN 0x20 THEN DATEADD(second, CEILING(@out_seconds / @rounding_seconds) * @rounding_seconds, @d)
		-- round
		WHEN 0x40 THEN DATEADD(second, ROUND(@out_seconds / @rounding_seconds, 0) * @rounding_seconds, @d)
		-- round in\out up
		WHEN 0x60 THEN DATEADD(second, CEILING(@seconds / @rounding_seconds) * @rounding_seconds, @in)
		ELSE DATEADD(second,@out_seconds,@d)
	END 

END
GO
IF OBJECT_ID('dbo.fnPrefixSuffixIfNotEmpty') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE FUNCTION dbo.fnPrefixSuffixIfNotEmpty() RETURNS varchar(50) AS BEGIN RETURN NULL END'
	GRANT EXEC ON dbo.fnPrefixSuffixIfNotEmpty TO public 
END
GO
ALTER FUNCTION dbo.fnPrefixSuffixIfNotEmpty(@prefix varchar(50), @val varchar(50), @suffix varchar(50), @empty varchar(50)) RETURNS varchar(50)
AS
BEGIN
RETURN CASE WHEN @val IS NULL OR @val='' THEN @empty
ELSE @prefix + @val + @suffix END
END
GO
IF OBJECT_ID('dbo.fnGetUnusedBalanceForTypeOnDate') IS NULL
EXEC sp_executesql N'CREATE FUNCTION dbo.fnGetUnusedBalanceForTypeOnDate(@employee_id int, @type varchar(50), @date datetime) RETURNS decimal(19,4) AS BEGIN RETURN NULL END'
GRANT EXEC ON dbo.fnGetUnusedBalanceForTypeOnDate TO public 
GO
ALTER FUNCTION dbo.fnGetUnusedBalanceForTypeOnDate(@employee_id int, @type varchar(50), @date datetime) RETURNS decimal(19,4)
AS
BEGIN
DECLARE @type_id int, @pattern varchar(50), @d int, @unused decimal(19,4)
SELECT @pattern = @type + '%', @d = DATEDIFF(d,0,@date)
SELECT @type_id = TypeID FROM dbo.LeaveType WHERE [Type]=@type
IF @type_id IS NULL SELECT @type_id = TypeID FROM dbo.LeaveType WHERE Abbreviation=@type
IF @type_id IS NULL SELECT @type_id = TypeID FROM dbo.LeaveType WHERE [Type] LIKE @pattern
IF @type_id IS NULL SELECT @type_id = TypeID FROM dbo.LeaveType WHERE Abbreviation LIKE @pattern
IF @type_id IS NULL RETURN NULL

SELECT @unused = Unused / 3600.00 FROM dbo.EmployeeLeaveUnused WHERE EmployeeID=@employee_id AND TypeID=@type_id AND [Day past 1900]=@d AND [Limit Adjustment]=0
IF @unused IS NULL SELECT TOP 1 @unused = ISNULL(Unused / 3600.00, 0) FROM dbo.EmployeeLeaveUnused WHERE EmployeeID=@employee_id AND TypeID=@type_id AND [Day past 1900] < @d AND [Limit Adjustment]=0 ORDER BY [Day past 1900] DESC

RETURN @unused
END
GO
IF OBJECT_ID('dbo.fnGetFirstQuarterAfter6Months') IS NULL
EXEC sp_executesql N'CREATE FUNCTION dbo.fnGetFirstQuarterAfter6Months(@date datetime) RETURNS datetime AS BEGIN RETURN ''20000101'' END'
GRANT EXEC ON dbo.fnGetFirstQuarterAfter6Months TO public
GO
ALTER FUNCTION dbo.fnGetFirstQuarterAfter6Months(@date datetime) RETURNS datetime
AS
BEGIN
SET @date = DATEADD(month, 6, @date)
DECLARE @m int, @y int, @d int
SELECT @m = DATEPART(month, @date), @y = DATEPART(year, @date), @d = DATEPARt(day, @date)
SELECT @m = CASE
	WHEN @m = 1 AND @d = 1 THEN 1
	WHEN @m < 4 OR @m = 4 AND @d = 1 THEN 4
	WHEN @m < 7 OR @m = 7 AND @d = 1 THEN 7	
	WHEN @m < 10 OR @m = 10 AND @d = 1 THEN 10
	ELSE 13
END
RETURN dbo.GetDateFromMDY(@m,1,@y)
END
GO
IF OBJECT_ID('dbo.fnGetFirstMonthAfter30Days') IS NULL
EXEC sp_executesql N'CREATE FUNCTION dbo.fnGetFirstMonthAfter30Days(@date datetime) RETURNS datetime AS BEGIN RETURN ''20000101'' END'
GRANT EXEC ON dbo.fnGetFirstMonthAfter30Days TO public
GO
ALTER FUNCTION dbo.fnGetFirstMonthAfter30Days(@date datetime) RETURNS datetime
AS
BEGIN
SET @date = DATEADD(day, 30, @date)
DECLARE @m int, @y int, @d int
SELECT @m = DATEPART(month, @date) + 1, @y = DATEPART(year, @date)
RETURN dbo.GetDateFromMDY(@m,1,@y)
END
GO
IF OBJECT_ID('dbo.fnGetFirstMonthAfter6Months') IS NULL
EXEC sp_executesql N'CREATE FUNCTION dbo.fnGetFirstMonthAfter6Months(@date datetime) RETURNS datetime AS BEGIN RETURN ''20000101'' END'
GRANT EXEC ON dbo.fnGetFirstMonthAfter6Months TO public
GO
ALTER FUNCTION dbo.fnGetFirstMonthAfter6Months(@date datetime) RETURNS datetime
AS
BEGIN
SET @date = DATEADD(month, 6, @date)
DECLARE @m int, @y int, @d int
SELECT @m = DATEPART(month, @date) + 1, @y = DATEPART(year, @date)
RETURN dbo.GetDateFromMDY(@m,1,@y)
END
GO
IF OBJECT_ID('dbo.AddMonthsToDY') IS NULL EXEC sp_executesql N'CREATE FUNCTION dbo.AddMonthsToDY() RETURNS datetime AS BEGIN RETURN 0 END'
GO
ALTER FUNCTION dbo.AddMonthsToDY(@m int, @d int, @y int)
RETURNS datetime
AS
BEGIN 
DECLARE @maxd int

IF @m < 1 SELECT @y = @y - 1 - @m / 12, @m = @m % 12 + 12
ELSE IF @m > 12 SELECT @y = @y + (@m - 1) / 12, @m = (@m - 1) % 12 + 1

SET @maxd = dbo.GetLastDayOfMonth(@m, @y)

IF @d > @maxd SET @d = @maxd

RETURN dbo.GetDateFromMDY(@m, @d, @y)
END
GO
EXEC dbo.spAdminCreateFunctionifNonexistent 'fnTrimLeadingZeros'
GO
ALTER FUNCTION dbo.fnTrimLeadingZeros(@s varchar(50)) RETURNS varchar(50)
AS
BEGIN
	RETURN CASE
		WHEN @s IS NULL THEN ''
		WHEN ISNUMERIC(@s) = 1 THEN CAST(CAST(@s AS float) AS varchar(50))
		ELSE @s
	END
END
GO
EXEC dbo.spAdminCreateFunctionifNonexistent 'fnSelectEmployeeDefaults'
GO
EXEC dbo.spAdminCreateFunctionifNonexistent 'fnNormalizeTerminalEnrollNumber'
GO
ALTER FUNCTION dbo.fnNormalizeTerminalEnrollNumber(@employee_number varchar(50), @employee_id int) RETURNS varchar(50)
AS
BEGIN
	DECLARE @n varchar(50)
	SET @n = dbo.fnTrimLeadingZeros(@employee_number)
	IF OBJECT_ID('dbo.fnCustom_NormalizeTerminalEnrollNumber') IS NOT NULL SET @n=ISNULL(dbo.fnCustom_NormalizeTerminalEnrollNumber(@employee_number, @employee_id), '')

	RETURN @n
END
GO
EXEC dbo.spAdminCreateFunctionifNonexistent 'fnGetShiftDay'
GO
ALTER FUNCTION dbo.fnGetShiftDay(@day int, @shift_id int, @start_day int, @dayson int, @daysoff int, @dayson2 int, @daysoff2 int) RETURNS int
AS
BEGIN
	IF OBJECT_ID('dbo.fnCustom_GetShiftDay') IS NOT NULL -- EXEC sp_executesql N'SELECT @r=fnCustom_IsShiftOnDay(@day, @shift_id, @start_day, @dayson, @daysoff, @dayson2, @daysoff2)', '@day int, @shift_id int, @start_day int, @dayson int, @daysoff int, @dayson2 int, @daysoff2 int, @r bit out', @day, @shift_id, @start_day, @dayson, @daysoff, @dayson2, @daysoff2, @r out
	RETURN dbo.fnCustom_GetShiftDay(@day, @shift_id, @start_day, @dayson, @daysoff, @dayson2, @daysoff2)

	RETURN (@day-@start_day)%(@dayson+@daysoff+@dayson2+@daysoff2) 
END
GO
IF OBJECT_ID('dbo.fnIsShiftOnDay') IS NULL EXEC sp_executesql N'CREATE FUNCTION dbo.fnIsShiftOnDay() RETURNS bit AS BEGIN RETURN 0 END'
GO
GRANT EXEC ON dbo.fnIsShiftOnDay TO public
GO
ALTER FUNCTION dbo.fnIsShiftOnDay(@day int, @shift_id int, @start_day int, @dayson int, @daysoff int, @dayson2 int, @daysoff2 int) RETURNS bit
AS
BEGIN
	IF OBJECT_ID('dbo.fnCustom_IsShiftOnDay') IS NOT NULL -- EXEC sp_executesql N'SELECT @r=fnCustom_IsShiftOnDay(@day, @shift_id, @start_day, @dayson, @daysoff, @dayson2, @daysoff2)', '@day int, @shift_id int, @start_day int, @dayson int, @daysoff int, @dayson2 int, @daysoff2 int, @r bit out', @day, @shift_id, @start_day, @dayson, @daysoff, @dayson2, @daysoff2, @r out
	RETURN dbo.fnCustom_IsShiftOnDay(@day, @shift_id, @start_day, @dayson, @daysoff, @dayson2, @daysoff2)

	RETURN
	/* CASE WHEN ((@day-@start_day)%(@dayson+@daysoff+@dayson2+@daysoff2) BETWEEN @dayson AND @dayson + @daysoff - 1) OR
			((@day-@start_day)%(@dayson+@daysoff+@dayson2+@daysoff2) >= @dayson + @daysoff + @dayson2) THEN 0
	ELSE 1 */
	CASE WHEN ISNULL((SELECT TOP 1 [Length Seconds] FROM dbo.ShiftSchedule WHERE ShiftID=@shift_id AND [Day of Shift] = (@day-@start_day)%(@dayson+@daysoff+@dayson2+@daysoff2)), 0) <> 0 THEN 1
	ELSE 0

	END		
END
GO
EXEC dbo.spAdminCreateFunctionifNonexistent 'fnGetShiftLengthSecondsForDay'
GO
ALTER FUNCTION dbo.fnGetShiftLengthSecondsForDay(@day int, @shift_id int, @start_day int, @dayson int, @daysoff int, @dayson2 int, @daysoff2 int) RETURNS int
AS
BEGIN
	RETURN ISNULL((SELECT TOP 1 [Length Seconds] FROM dbo.ShiftSchedule WHERE ShiftID=@shift_id AND [Day of Shift] = (@day-@start_day)%(@dayson+@daysoff+@dayson2+@daysoff2)), 0)
END
GO
IF OBJECT_ID('dbo.fnRightAlignText') IS NULL EXEC sp_executesql N'CREATE FUNCTION dbo.fnRightAlignText() RETURNS varchar(400) AS BEGIN RETURN '''' END'
GO
ALTER FUNCTION dbo.fnRightAlignText(@val varchar(400), @fieldLength int) RETURNS varchar(400) AS
BEGIN
	IF @val IS NULL OR @val = '' RETURN SPACE(@fieldLength)
	IF LEN(@val) >= @fieldLength RETURN SUBSTRING(@val, 1, @fieldLength)
	RETURN SPACE(@fieldLength - LEN(@val)) + @val
END
GO
IF OBJECT_id('dbo.GetYearStart') IS NULL EXEC sp_executesql N'CREATE FUNCTION dbo.GetYearStart(@year int) RETURNS datetime AS BEGIN RETURN dbo.GetDateFromMDY(1, 1, @year) END'
GO
GRANT EXEC ON dbo.GetYearStart TO public
GO
IF OBJECT_ID('dbo.fnBoundIntAddition') IS NULL EXEC sp_executesql N'CREATE FUNCTION dbo.fnBoundIntAddition() RETURNS int AS BEGIN RETURN 0 END'
GO
ALTER FUNCTION dbo.fnBoundIntAddition(@a int, @b int)
RETURNS int
AS
BEGIN
	IF (@a > 0 AND @b > 0) 
	BEGIN
		IF (@a > 2147483647 - @b OR @b > 2147483647 - @a) RETURN 2147483647
	END
	ELSE IF (@a < 0 AND @b < 0)
	BEGIN
		IF (@a < -2147483648 - @b OR @b < -2147483648 - @a) RETURN -2147483648
	END
	RETURN @a + @b
END
GO
IF OBJECT_id('dbo.fnProrateTime') IS NULL EXEC sp_executesql N'CREATE FUNCTION dbo.fnProrateTime() RETURNS int AS BEGIN RETURN 0 END'
GO
ALTER FUNCTION dbo.fnProrateTime(@seconds int, @divisor int, @start datetime, @stop datetime)
RETURNS int
AS
BEGIN
	IF @seconds = 0 OR @divisor = 0 OR DATEDIFF(d, @start, @stop) > 400 RETURN 0

	DECLARE @prorated_seconds int

	SET @prorated_seconds = 0
	WHILE @start <= @stop
	BEGIN
		IF (DATEPART(dw,@start) + @@DATEFIRST) % 7 IN (2, 3, 4, 5, 6) SET @prorated_seconds = @prorated_seconds + @seconds
		SET @start = DATEADD(d,1,@start)
	END

	RETURN @prorated_seconds / @divisor
END
GO
IF OBJECT_id('dbo.fnLOAStartStopInt') IS NULL EXEC sp_executesql N'CREATE FUNCTION dbo.fnLOAStartStopInt() RETURNS int AS BEGIN RETURN 0 END'
GO
-- Functions in SQL 2000 cannot contain GETDATE()
ALTER FUNCTION dbo.fnLOAStartStopInt(
	@start int,
	@stop int,
	@x int,
	@d datetime
)
RETURNS int
AS
BEGIN
	RETURN CASE WHEN @start = -2147483648 AND @stop = -2147483648 THEN DATEDIFF(d,0,@d) ELSE @x END
END
GO
IF OBJECT_id('dbo.fnLOAStartStopDate') IS NULL EXEC sp_executesql N'CREATE FUNCTION dbo.fnLOAStartStopDate() RETURNS datetime AS BEGIN RETURN NULL END'
GO
-- Functions in SQL 2000 cannot contain GETDATE()
ALTER FUNCTION dbo.fnLOAStartStopDate(
	@start int,
	@stop int,
	@x int,
	@d datetime
)
RETURNS datetime
AS
BEGIN
	RETURN CASE WHEN @start = -2147483648 AND @stop = -2147483648 THEN @d ELSE dbo.GetDateFromDaysPast1900(@x) END
END
GO
IF OBJECT_id('dbo.fnGetStatusText') IS NULL EXEC sp_executesql N'CREATE FUNCTION dbo.fnGetStatusText() RETURNS varchar(400) AS BEGIN RETURN '''' END'
GO
ALTER FUNCTION dbo.fnGetStatusText(
	@status int,
	@authorizing_first varchar(50),
	@authorizing_middle varchar(50),
	@authorizing_last varchar(50),
	@authorizing_day int,
	@approval_type varchar(50),
	@denial_reason varchar(50)
)
RETURNS varchar(400)
AS
BEGIN 
	DECLARE @authorizing_initials varchar(3)
	SET @authorizing_initials = dbo.fnGetInitials(@authorizing_first, @authorizing_middle, @authorizing_last)
	RETURN CASE @status
		WHEN 2 THEN 'Approved' +
			CASE WHEN @authorizing_initials IS NULL THEN '' ELSE ' by ' + @authorizing_initials END +
			CASE WHEN @authorizing_day IS NULL THEN '' ELSE ' on ' + CAST(dbo.GetDateFromDaysPast1900(@authorizing_day) AS varchar(11)) END +
			' for ' + @approval_type
		WHEN 4 THEN 'Denied' +
			CASE WHEN @authorizing_initials IS NULL THEN '' ELSE ' by ' + @authorizing_initials END +
			CASE WHEN @authorizing_day IS NULL THEN '' ELSE ' on ' + CAST(dbo.GetDateFromDaysPast1900(@authorizing_day) AS varchar(11)) END +
			CASE WHEN @denial_reason IS NULL THEN '' ELSE ' because ' + @denial_reason END
		ELSE 'Pending'
	END
END
GO
IF OBJECT_ID('dbo.fnConvertPay') IS NOT NULL DROP FUNCTION dbo.fnConvertPay
GO
CREATE FUNCTION dbo.fnConvertPay(@source_pay money, @fte40 numeric(9,4), @Ms int, @Bs int, @Ss int, @Mt int, @Bt int, @St int) RETURNS money
AS
BEGIN
	DECLARE @a numeric(28,13), @b numeric(28,13)

	SELECT @a = @St * (@fte40 * @Mt + @Bt), @b = @Ss * (@fte40 * @Ms + @Bs)
	
	RETURN CASE
		WHEN @a=0 OR @b=0 THEN 0
		ELSE (@a / @b) * @source_pay
	END
END
GO
IF OBJECT_ID('dbo.fnGetAnnualizedPayRange') IS NOT NULL DROP FUNCTION dbo.fnGetAnnualizedPayRange
GO
CREATE FUNCTION dbo.fnGetAnnualizedPayRange(@min_rate money, @max_rate money, @seconds_per_week int) RETURNS varchar(50)
AS
BEGIN
	RETURN CONVERT(varchar(50), dbo.fnMultiplyMoney(@min_rate, 2080.0 * @seconds_per_week / 144000.0), 1) +
	CASE WHEN @min_rate = @max_rate THEN '' ELSE
	+ ' to ' +
	CONVERT(varchar(50), dbo.fnMultiplyMoney(@max_rate, 2080.0 * @seconds_per_week / 144000.0), 1)
	END
END
GO
IF OBJECT_ID('dbo.fnMultiplyMoney') IS NOT NULL DROP FUNCTION dbo.fnMultiplyMoney
GO
CREATE FUNCTION dbo.fnMultiplyMoney(@amount money, @multiplier numeric(28,13)) RETURNS money
AS
BEGIN
	IF @multiplier = 1 RETURN @amount
	IF (@multiplier > 1 OR @multiplier < -1) AND @amount > 922337203685477 / @multiplier RETURN 922337203685477
	IF (@multiplier > 1 OR @multiplier < -1) AND @amount < -922337203685477 / @multiplier RETURN -922337203685477
	RETURN @amount * @multiplier
END
GO
IF OBJECT_ID('dbo.fnNullCompare') IS NOT NULL DROP FUNCTION dbo.fnNullCompare
GO
CREATE FUNCTION dbo.fnNullCompare(@a int, @b int) RETURNS bit
AS
BEGIN
	DECLARE @r bit
	SELECT @r=CASE
		WHEN @a IS NULL AND @b IS NULL THEN 1
		WHEN @a IS NULL AND @b IS NOT NULL THEN 0
		WHEN @a IS NOT NULL AND @b IS NULL THEN 0
		WHEN @a=@b THEN 1
		ELSE 0
	END

	RETURN @r
END
GO
IF OBJECT_ID('dbo.fnGetTerminalSyncStatus') IS NOT NULL DROP FUNCTION dbo.fnGetTerminalSyncStatus
GO
CREATE FUNCTION dbo.fnGetTerminalSyncStatus(@last_sync datetime, @state_mask int)
RETURNS varchar(50)
AS
BEGIN
RETURN CASE
	WHEN @state_mask IS NULL THEN ''
	WHEN @last_sync IS NULL THEN 'Never synced'
	ELSE
		CASE WHEN @state_mask != 0 THEN 'Out-of-sync. ' ELSE '' END +
		'Last Synced ' + CONVERT(char(8), @last_sync, 112)
END + ' (' + CAST(@state_mask AS varchar(50)) + ')'
END
GO
GRANT EXEC ON dbo.fnGetTerminalSyncStatus TO public
GO
IF OBJECT_id('dbo.GetDateFromMDY2') IS NULL EXEC sp_executesql N'CREATE FUNCTION dbo.GetDateFromMDY2() RETURNS int AS BEGIN RETURN 0 END'
GO
-- Contructs a date from m/d/y
-- Can change m and y by 1 to make invalid dates valid
-- For example, changes 13/1/2004 to 1/1/2005, 2/29/2005 to 3/1/2005, 1/0/2005 to 12/31/2004
-- @options: 1 -- clip days (turns 2/29/2011 to 2/28/2011 instead of 3/1/2011)
ALTER FUNCTION dbo.GetDateFromMDY2(@m int, @d int, @y int, @options int = 0)
RETURNS datetime
AS
BEGIN 
DECLARE @m2 char(2)
DECLARE @d2 char(2)
DECLARE @y4 char(4)
DECLARE @clip_days bit

SET @clip_days = CASE WHEN @options & 1 = 1 THEN 1 ELSE 0 END

IF @m < 1
BEGIN
	SET @y = @y - 1 - (@m - 1) / 12
	SET @m = @m % 12 + 12
END
ELSE IF @m > 12
BEGIN
	SET @y = @y + @m / 12
	SET @m = @m % 12
END

IF @clip_days = 1
BEGIN
	IF @d < 1 SET @d = 1
	ELSE IF @m IN (1, 3, 5, 7, 8, 10, 12) AND @d > 31 SELECT @d = 31
	ELSE IF @m IN (4, 6, 9, 11) AND @d > 30 SELECT @d = 30
	ELSE IF @m = 2 AND (@y % 4) = 0 AND @d > 29 SELECT @d = 29
	ELSE IF @m = 2 AND @d > 28 SELECT @d = 28
END

-- If @d = BETWEEN -27 AND 0 subtract one month
ELSE IF @d BETWEEN -27 AND 0
BEGIN
	IF @m = 1 SELECT @m = 12, @d = @d + 31, @y = @y - 1
	ELSE IF @m IN (5, 7, 8, 10, 12) SELECT @m = @m - 1, @d = @d + 30
	ELSE IF @m IN (2, 4, 6, 9, 11) SELECT @m = @m - 1, @d = @d + 31
	ELSE IF (@y % 4) = 0 SELECT @m = 2, @d = @d + 29 -- Leap year
	ELSE SELECT @m = 2, @d = @d + 28
END
ELSE IF @d BETWEEN 32 AND 50 AND @m IN (1, 3, 5, 7, 8, 10, 0) SELECT @m = @m + 1, @d = @d - 31
ELSE IF @d BETWEEN 32 AND 50 AND @m = 12 SELECT @m = 1, @d = @d - 31, @y = @y + 1
ELSE IF @d BETWEEN 31 AND 50 AND @m IN (4, 6, 9, 11) SELECT @m = @m + 1, @d = @d - 30
ELSE IF @d BETWEEN 30 AND 50 AND @m = 2 AND @y % 4 = 0 SELECT @m = @m + 1, @d = @d - 29
ELSE IF @d BETWEEN 29 AND 50 AND @m = 2 AND @y % 4 <> 0 SELECT @m = @m + 1, @d = @d - 28

IF @m < 1
BEGIN
	SET @y = @y - 1 - (@m - 1) / 12
	SET @m = @m % 12 + 12
END
ELSE IF @m > 12
BEGIN
	SET @y = @y + @m / 12
	SET @m = @m % 12
END

IF @m < 10 SELECT @m2  =  '0' + CAST(@m as char(1)) ELSE SELECT @m2 = @m
IF @d < 10 SELECT @d2 = '0' + CAST(@d as char(1)) ELSE SELECT @d2 = @d

IF @y < 10 SELECT @y4 = '000' + CAST(@y as char(1))
ELSE If @y < 100 SELECT @y4 = '00' + CAST(@y as char(2))
ELSE if @y < 1000 SELECT @y4 = '0' + CAST(@y as char(3))
ELSE SELECT @y4 = @y

DECLARE @zz varchar(100)
SET @zz = @y4 + @m2 + @d2

RETURN CONVERT(datetime, @y4 + @m2 + @d2, 112)
END
GO
IF OBJECT_id('dbo.GetDateFromMDY') IS NULL EXEC sp_executesql N'CREATE FUNCTION dbo.GetDateFromMDY() RETURNS int AS BEGIN RETURN 0 END'
GO
ALTER FUNCTION dbo.GetDateFromMDY(@m int, @d int, @y int) RETURNS datetime
AS BEGIN RETURN dbo.GetDateFromMDY2(@m, @d, @y, 0) END
GO
IF OBJECT_ID('dbo.fnGetDateStringFromDaysPast1900') IS NOT NULL DROP FUNCTION dbo.fnGetDateStringFromDaysPast1900
GO
CREATE FUNCTION dbo.fnGetDateStringFromDaysPast1900 (@days int) 
RETURNS char(10) WITH SCHEMABINDING
AS
BEGIN
	RETURN
		CASE WHEN @days IS NULL THEN NULL
		WHEN @days <= -53690 THEN '1753-01-01'
		WHEN @days >= 2958463 THEN '9999-12-13'
		ELSE CONVERT(char(10), DATEADD(day, 0, @days), 120)
	END
END
GO
GRANT EXEC ON dbo.fnGetDateStringFromDaysPast1900 TO public
GO
IF OBJECT_ID('dbo.GetGroupFromColumnName') IS NOT NULL DROP FUNCTION dbo.GetGroupFromColumnName
IF OBJECT_ID('dbo.GetExampleForColumnName') IS NOT NULL DROP FUNCTION dbo.GetExampleForColumnName
IF OBJECT_ID('dbo.GetCaptionForColumnName') IS NOT NULL DROP FUNCTION dbo.GetCaptionForColumnName
IF OBJECT_ID('dbo.IsColumnVisibleOnReport') IS NOT NULL DROP FUNCTION dbo.IsColumnVisibleOnReport
GO
GRANT EXEC ON dbo.GetDateFromDaysPast1900 TO public
GO
CREATE FUNCTION dbo.fnGetEnrolled(@first int, @last int)
RETURNS datetime WITH SCHEMABINDING
AS
BEGIN
	RETURN dbo.GetDateFromDaysPast1900(CASE
	WHEN @last IS NULL THEN @first
	WHEN @first IS NULL THEN @last
	WHEN @last > @first THEN @last
	ELSE @first END)
END
GO

CREATE FUNCTION dbo.fnGetEnrolledDayPast1900(@first int, @last int)
RETURNS int WITH SCHEMABINDING
AS
BEGIN
	RETURN CASE
	WHEN @last IS NULL THEN @first
	WHEN @first IS NULL THEN @last
	WHEN @last > @first THEN @last
	ELSE @first END
END
GO
GRANT EXEC ON dbo.fnGetEnrolled TO public
GRANT EXEC ON dbo.fnGetEnrolledDayPast1900 TO public
GO
CREATE FUNCTION dbo.IsColumnVisibleOnReport(@column sysname) RETURNS bit
AS
BEGIN
	RETURN CASE WHEN @column IN ('InvoiceID', 'PaymentID') THEN 1
	WHEN
		@column LIKE '%ID' OR
		@column LIKE '%Mask' OR
		@column LIKE '%Day past 1900' OR
		@column IN (
			'IsApplicant', 'IsEmployee', 'IsEmergencyContact', 'IsRecruiter', 'IsPhysician', -- vwReportTabular
			'Employee Full Name', -- vwEmployeeBenefitSecure
			'Status', 'Start Event Flags', 'Stop Event Flags', 'FTE40', 'Seconds per Week', 'Report Row' -- vwEmployeeCompensationSecure
		)
	THEN 0
	ELSE 1 END
END
GO
CREATE FUNCTION dbo.GetCaptionForColumnName(@column sysname) RETURNS varchar(50)
AS
BEGIN
	DECLARE @stop int, @caption varchar(50)

	IF @column = 'Primary Language' SET @caption = 'Primary Languages'
	ELSE IF @column IN ('Person List As') SET @caption = 'List As'
	ELSE IF @column LIKE '%Declined' SET @caption = SUBSTRING(@column, 1, LEN(@column) - 8) + 'Terminated'
	ELSE IF @column LIKE 'EB_%_X%'
	BEGIN
		DECLARE @benefit_id int, @benefit varchar(50)
		SET @stop = CHARINDEX('_', @column, 4)
		SELECT @benefit_id = CAST(SUBSTRING(@column, 4, @stop-4) AS int)
		SELECT @benefit = Benefit FROM Benefit WHERE BenefitID = @benefit_id
		SET @caption = SUBSTRING(@column, @stop + 2, 999)
		SET @caption = @benefit + ' ' + CASE @caption
			WHEN 'EmployeePremium' THEN 'Employee Premium'
			WHEN 'TotalPremium' THEN 'Total Premium'
			WHEN 'EmployerPremium' THEN 'Employer Premium'
			WHEN 'WaitListQueue' THEN 'Wait List Queue'
			WHEN 'StatusCode' THEN 'Status Code'
			WHEN 'AnnualEmployerPremium' THEN 'Annual Employer Premium'
			WHEN 'AnnualEmployeePremium' THEN 'Annual Employee Premium'
			WHEN 'AnnualPremium' THEN 'Annual Premium'
			when 'OtherPremium' THEN 'Other Premium'
			ELSE @caption
		END
	END
	ELSE IF @column LIKE 'ED_%_X%'
	BEGIN
		DECLARE @deduction_id int, @deduction varchar(50), @code varchar(50)
		SET @stop = CHARINDEX('_', @column, 4)
		SELECT @deduction_id = CAST(SUBSTRING(@column, 4, @stop-4) AS int)
		SELECT @deduction = Deduction, @code = [Deduction Code] FROM Deduction WHERE DeductionID = @deduction_id
		SET @caption = SUBSTRING(@column, @stop + 2, 999)
		SET @caption = CASE
			WHEN @caption='Amount' THEN @deduction
			WHEN @caption='Amount2' AND @code<>'' THEN @code
			WHEN @caption='Amount2' AND @code='' THEN @deduction + ' Amount'
			WHEN @caption='Comment' THEN @deduction + ' Comment'
			ELSE @caption
		END
	END
	ELSE IF @column LIKE 'PS_%_X%'
	BEGIN
		DECLARE @skill_id int, @skill varchar(50)
		SET @stop = CHARINDEX('_', @column, 4)
		SELECT @skill_id = CAST(SUBSTRING(@column, 4, @stop-4) AS int)
		SELECT @skill = Skill FROM Skill WHERE SkillID = @skill_id
		SET @caption = SUBSTRING(@column, @stop + 2, 999)
		SET @caption = CASE
			WHEN @caption='Level' THEN @skill
			ELSE @caption
		END
	END
	ELSE IF @column LIKE 'CF_%_X%'
	BEGIN
		DECLARE @field_id int, @field varchar(50)
		SET @stop = CHARINDEX('_', @column, 4)
		SELECT @field_id = CAST(SUBSTRING(@column, 4, @stop-4) AS int)
		SELECT @field = Field FROM dbo.CustomField WHERE FieldID = @field_id
		IF @field IS NULL
		BEGIN
			SET @caption = 'CF' + CAST(@field_id AS varchar(50)) + ' not found. ' + @column
		END
		ELSE
		BEGIN
			IF SUBSTRING(@column, @stop + 2, 999) = 'Text' SET @caption = @field
			ELSE SET @caption = @field + ' ' + SUBSTRING(@column, @stop + 2, 999)
		END
	END
	ELSE IF @column LIKE 'LP_%_X%'
	BEGIN
		DECLARE @proficiency_id int
		SET @stop = CHARINDEX('_', @column, 4)
		SELECT @proficiency_id = CAST(SUBSTRING(@column, 4, @stop-4) AS int)
		SELECT @caption = Proficiency FROM LanguageProficiency WHERE ProficiencyID = @proficiency_id
	END
	ELSE SET @caption = @column

	RETURN ISNULL(@caption, '')
END
GO
CREATE FUNCTION dbo.GetExampleForColumnName(@column sysname, @default sysname) RETURNS sysname
AS
BEGIN
	RETURN 
	CASE @column
		WHEN 'List As' THEN 'Doe, John'
		WHEN 'Person List As' THEN 'Doe, John'
		WHEN 'Employee' THEN 'Doe, John'
		WHEN 'Other Compensation' THEN 'Bonus explanation'
		WHEN 'Note' THEN 'Long note field'
		WHEN 'Stop Event' THEN 'Promoted, Same Position'
		WHEN 'SSN' THEN '999-99-9999'
		WHEN 'Work ZIP' THEN '99423'
		WHEN 'Home ZIP' THEN '99111'
		WHEN 'Work Country' THEN 'United States'
		WHEN 'Home Country' THEN 'Spain'
		WHEN 'Extension' THEN '234'
		WHEN 'Extended Work Phone' THEN '(999) 923-4321 x234'
		WHEN 'Work Address' THEN '1710 Plaza North'
		WHEN 'Work Address (cont.)' THEN 'STE 120'
		WHEN 'Work City' THEN 'New York'
		WHEN 'Work State' THEN 'NY'
		WHEN 'Extended Work Address' THEN '1710 Plaza North  New York, NY 99423'
		WHEN 'Home Address' THEN '14410 Curry Ct'
		WHEN 'Home City' THEN 'Los Angeles'
		WHEN 'Home State' THEN 'CA'
		WHEN 'Extended Home Address' THEN '14410 Curry Ct  Los Angeles, CA 99423'
		WHEN 'Credentials' THEN 'CPA'
		WHEN 'Gender' THEN 'Female'
		WHEN 'DOB' THEN 'Dec 11 2004'
		WHEN 'I9 Status' THEN 'N - Natural'
		WHEN 'Title' THEN 'Dr.'
		WHEN 'Suffix' THEN 'Jr.'
		WHEN 'Initials' THEN 'JFK'
		WHEN 'Marital Status' THEN 'Married'
		WHEN 'Receptionist is Judy' THEN 'Work Phone Note'
		WHEN 'Race' THEN 'Hispanic'
		WHEN 'Manager' THEN 'Smith, John'
		WHEN 'DOH' THEN 'Apr 4 2000'
		WHEN 'Seniority Begins' THEN 'Feb 1 2000'
		WHEN 'Annualized Pay' THEN '69999.99'
		WHEN 'Daily Pay' THEN '699.99'
		WHEN 'Hourly Pay' THEN '99.99'
		WHEN 'FTE' THEN '0.750'
		ELSE CASE
			WHEN @column LIKE '%Is Enrolled' THEN 'Yes'
			WHEN @column LIKE '%Enrolled' THEN 'Apr 1 2000'
			WHEN @column LIKE '%Enrollment' THEN 'Eligible, Enrolled, Declined\Discontinued'
			WHEN @column IN ('Work Fax', 'Work Phone', 'Home Phone', 'Home Office Phone', 'Pager', 'Toll Free Phone') THEN '(999) 923-4321'
			ELSE @default
		END
	END
END
GO
CREATE FUNCTION dbo.GetGroupFromColumnName(@column sysname, @default sysname) RETURNS sysname
AS
BEGIN
	RETURN 
	CASE
		WHEN @column IN ('Primary Language', 'Secondary Languages') THEN 'Languages'
		WHEN @column LIKE '%COBRA%' THEN 'Benefits'
		WHEN @column LIKE 'InOut%' THEN 'Time'
		WHEN @column IN ('Employee', 'Employee Full Name', 'Person List As', 'List As', 'Person', 'Full Name') THEN 'Name'
		WHEN @column IN (SELECT NColumns.[name] FROM syscolumns NColumns WHERE NColumns.[ID]=OBJECT_ID('vwPersonCalculated')) THEN 'Name'
		WHEN @column IN ('Unions', 'Days Employed', 'Start', 'Stop', 'Employment Status', 'Start Event', 'Stop Event', 'Budgeted', 'Job Title', 'Category', 'FLSA Status', 'FLSA Exempt', 'Status', 'FTE', 'Employee Number', 'Position Number', 'DOH', 'Seniority Begins') THEN 'Employment'
		WHEN @column IN (SELECT OColumns.[name] FROM syscolumns OColumns WHERE OColumns.[ID]=OBJECT_ID('vwEmployeeOrg')) THEN 'Employment'
		WHEN @column IN (SELECT OColumns.[name] FROM syscolumns OColumns WHERE OColumns.[ID]=OBJECT_ID('vwEmployeeDelegatedManager')) THEN 'Employment'
		WHEN @column='Gender' OR @column IN (SELECT WColumns.[name] FROM syscolumns WColumns WHERE WColumns.[ID]=OBJECT_ID('vwPersonX')) THEN 'Personal'
		WHEN @column IN (SELECT WColumns.[name] FROM syscolumns WColumns WHERE WColumns.[ID]=OBJECT_ID('vwPersonXLanguages')) THEN 'Personal'
		WHEN @column IN (SELECT WColumns.[name] FROM syscolumns WColumns WHERE WColumns.[ID]=OBJECT_ID('vwPersonWork')) THEN 'Work Contact'
		WHEN @column IN (SELECT HColumns.[name] FROM syscolumns HColumns WHERE HColumns.[ID]=OBJECT_ID('vwPersonHome')) THEN 'Home Contact'
		WHEN @column IN ('ZIP') THEN 'Home Contact'
		WHEN @column IN (SELECT BColumns.[name] FROM syscolumns BColumns WHERE BColumns.[ID]=OBJECT_ID('vwPersonXSkillFlat')) THEN 'Skills'
		WHEN @column IN (SELECT BColumns.[name] FROM syscolumns BColumns WHERE BColumns.[ID]=OBJECT_ID('vwEmployeeDeductionFlat')) THEN 'Deductions'
		WHEN @column IN (SELECT BColumns.[name] FROM syscolumns BColumns WHERE BColumns.[ID]=OBJECT_ID('vwEmployeeBenefitFlat')) THEN 'Benefits'
		WHEN @column IN (SELECT BColumns.[name] FROM syscolumns BColumns WHERE BColumns.[ID]=OBJECT_ID('vwEmployeeBINV')) THEN 'Benefits'
		WHEN @column IN (SELECT BColumns.[name] FROM syscolumns BColumns WHERE BColumns.[ID]=OBJECT_ID('vwEmployeeBPMT')) THEN 'Benefits'
		WHEN @column IN (SELECT BColumns.[name] FROM syscolumns BColumns WHERE BColumns.[ID]=OBJECT_ID('vwEmployeeUpdateInOutStatus')) THEN 'Time'
		WHEN @column IN (SELECT BColumns.[name] FROM syscolumns BColumns WHERE BColumns.[ID]=OBJECT_ID('vwEmployeeTime')) THEN 'Time'
		WHEN @column IN (SELECT BColumns.[name] FROM syscolumns BColumns WHERE BColumns.[ID]=OBJECT_ID('PersonCustomFieldFlat')) THEN 'Custom'
		WHEN @column IN (SELECT BColumns.[name] FROM syscolumns BColumns WHERE BColumns.[ID]=OBJECT_ID('vwEmployeeSucceedsNames')) THEN 'Succession'
		WHEN @column IN (SELECT BColumns.[name] FROM syscolumns BColumns WHERE BColumns.[ID]=OBJECT_ID('vwEmployeeSuccessorNames')) THEN 'Succession'
		WHEN @column IN (SELECT BColumns.[name] FROM syscolumns BColumns WHERE BColumns.[ID]=OBJECT_ID('vwEmployeeCompensation')) THEN 'Compensation'
		WHEN @column IN ('Current Daily Pay', 'Current Annualized Pay', 'Current Employment Status', 'Current Hourly Pay', 'Current FTE', 'Current Job Title', 'Current Pay Grade', 'Current Pay Step', 'Current Position Status') THEN 'Compensation'
		WHEN @column IN (SELECT BColumns.[name] FROM syscolumns BColumns WHERE BColumns.[ID]=OBJECT_ID('vwEmployeeTermination')) THEN 'Employment'
		WHEN @column IN (SELECT BColumns.[name] FROM syscolumns BColumns WHERE BColumns.[ID]=OBJECT_ID('vwEmployeeAccount')) THEN 'Security'
		WHEN @column IN (SELECT BColumns.[name] FROM syscolumns BColumns WHERE BColumns.[ID]=OBJECT_ID('vwEmployeeReview')) THEN 'Review'
		WHEN @column IN (SELECT BColumns.[name] FROM syscolumns BColumns WHERE BColumns.[ID]=OBJECT_ID('vwEmployeePayStep')) THEN 'Compensation'
		WHEN @column IN (SELECT BColumns.[name] FROM syscolumns BColumns WHERE BColumns.[ID]=OBJECT_ID('vwEmployeeTerminal')) THEN 'Terminal Sync'
		WHEN @column IN (SELECT BColumns.[name] FROM syscolumns BColumns WHERE BColumns.[ID]=OBJECT_ID('dbo.PersonXLanguageFlat')) THEN 'Languages'
		WHEN @column LIKE '%Languages%' THEN 'Languages'
	ELSE @default
	END
END
GO
GRANT EXEC ON dbo.IsColumnVisibleOnReport TO public
GRANT EXEC ON dbo.GetGroupFromColumnName TO public
GRANT EXEC ON dbo.GetExampleForColumnName TO public
GRANT EXEC ON dbo.GetCaptionForColumnName TO public
GO
IF OBJECT_id('dbo.GetWeekStart') IS NOT NULL DROP FUNCTION dbo.GetWeekStart
IF OBJECT_id('dbo.GetWeekStart2') IS NOT NULL DROP FUNCTION dbo.GetWeekStart2
GO
CREATE FUNCTION dbo.GetWeekStart (@dw int, @day int) RETURNS datetime
AS
BEGIN
	DECLARE @r int
	SET @r = @dw - DATEPART(dw, @day)
	IF @r > 0 SET @r = @r - 7
	RETURN DATEADD(d, @r, @day)
END
GO
CREATE FUNCTION dbo.GetWeekStart2 (@dw int, @date datetime) RETURNS datetime
AS
BEGIN
	DECLARE @r int
	SET @r = @dw - DATEPART(dw, @date)
	IF @r > 0 SET @r = @r - 7
	RETURN DATEADD(d, @r, @date)
END
GO
CREATE FUNCTION dbo.fnGetEnrollment
(
	@today datetime,
	@wl_day int,
	@wl_queue int,
	@declined int,
	@first_enrolled int,
	@last_enrolled int,
	@expires int,
	@eligible int
)
RETURNS varchar(50) AS
BEGIN
	DECLARE @expires_date datetime
	SELECT @expires_date = dbo.GetDateFromDaysPast1900(@expires)

	RETURN CASE
	WHEN @wl_day IS NOT NULL OR @wl_queue IS NOT NULL THEN 'W/L ' + 
		CASE WHEN @wl_queue IS NULL THEN '' ELSE CAST(@wl_queue AS varchar(11)) + ' ' END + 
		CASE WHEN @wl_day IS NULL THEN '' ELSE dbo.fnGetDateStringFromDaysPast1900(@wl_day) END
	WHEN @declined IS NOT NULL THEN
		CASE WHEN @first_enrolled IS NULL THEN 'Declined ' ELSE 'Discontinued ' END + dbo.fnGetDateStringFromDaysPast1900(@declined)
	WHEN @expires IS NOT NULL AND @expires_date <= @today THEN 'Expired ' + dbo.fnGetDateStringFromDaysPast1900(@expires)
	WHEN @expires IS NOT NULL AND @expires_date > @today AND (@first_enrolled IS NOT NULL OR @last_enrolled IS NOT NULL) THEN 'Enrolled. Expires ' + dbo.fnGetDateStringFromDaysPast1900(@expires)
	WHEN @expires IS NOT NULL AND @expires_date > @today THEN '' -- Expiration date with no enrollment
	WHEN @last_enrolled IS NOT NULL THEN 'Enrolled ' + dbo.fnGetDateStringFromDaysPast1900(@last_enrolled)
	WHEN @first_enrolled IS NOT NULL THEN 'Enrolled ' + dbo.fnGetDateStringFromDaysPast1900(@first_enrolled)
	WHEN @eligible IS NOT NULL THEN 'Eligible ' + dbo.fnGetDateStringFromDaysPast1900(@eligible)
	ELSE '' END
END
GO
CREATE FUNCTION dbo.fnGetEBStatusCode
(
	@wl_day int,
	@wl_queue int,
	@declined int,
	@first_enrolled int,
	@last_enrolled int,
	@expires int,
	@eligible int,
	@cobra_declined int,
	@cobra_first_enrolled int,
	@cobra_last_enrolled int
)
RETURNS char(1) WITH SCHEMABINDING AS
BEGIN
	RETURN CASE
	WHEN @declined IS NOT NULL THEN 'T'
	WHEN (@first_enrolled IS NOT NULL OR @last_enrolled IS NOT NULL) AND @cobra_declined IS NULL AND (@cobra_first_enrolled IS NOT NULL OR @cobra_last_enrolled IS NOT NULL) THEN 'C'
	WHEN @first_enrolled IS NOT NULL OR @last_enrolled IS NOT NULL THEN 'E'
	ELSE '' END
END
GO
/* FUNCTION CHANGES END ***************************************************************************** */
GO
IF EXISTS(SELECT * FROM dbo.Constant WHERE [Version Update Flags] & 1 = 0)
BEGIN
	UPDATE dbo.TimeType SET [Flags] = [Flags] | 16 WHERE [Type] = 'Holiday'
	UPDATE dbo.Constant SET [Version Update Flags] = [Version Update Flags] | 1
END
GO
/* VIEW CHANGES BEGIN ******************************************************************************* */
GO
EXEC dbo.spAdminCreateViewIfNonexistent 'vwCalendarRemark'
GO
ALTER VIEW dbo.vwCalendarRemark AS SELECT RemarkID, Remark, [Day past 1900], [Created Day past 1900], [Created By], [Date] = DATEADD(d, [Day past 1900], 0) FROM dbo.CalendarRemark
GO
IF OBJECT_id('dbo.vwPersonCustomField') IS NULL EXEC sp_executesql N'CREATE VIEW dbo.vwPersonCustomField AS SELECT A=0'
GO
ALTER VIEW dbo.vwPersonCustomField
AS
SELECT C.Attributes, C.LocationID, C.TypeID, C.FieldID, C.Field,C.PermissionAttributeID,
Textarea = CAST(CASE WHEN (Attributes&1)=1 THEN 1 ELSE 0 END AS bit),
[Text] = dbo.fnGetCustomFieldText(P.FieldID, P.[Value]),
C.[Role Mask], P.PersonID,
[Person Name] = dbo.fnGetListAs(Person.[First Name], Person.[Middle Name], Person.[Last Name], Person.Suffix), 
P.ItemID, C.[Order], CopyItemsFromFieldID,
[Value] = CAST(P.[Value] AS varchar(4000)),
Value2 = P.[Value]
FROM dbo.PersonCustomField P
INNER JOIN dbo.Person ON P.PersonID = Person.PersonID
INNER JOIN dbo.CustomField C ON P.FieldID = C.FieldID
GO
EXEC dbo.spAdminCreateViewIfNonexistent 'vwInOutStatus'
GO
ALTER VIEW dbo.vwInOutStatus AS SELECT * FROM InOutStatus
GO
IF OBJECT_id('dbo.vwPerson') IS NULL EXEC sp_executesql N'CREATE VIEW dbo.vwPerson AS SELECT A=0'
GO
ALTER VIEW dbo.vwPerson
AS
SELECT P.*,
V.[List As],
V.Initials,
V.[Full Name],
V.[Formal Name],
V.[IsEmployee],
V.[IsApplicant],
V.[IsRecruiter],
V.[IsPhysician],
V.[IsEmergencyContact]
FROM dbo.Person P INNER JOIN dbo.vwPersonCalculated V ON P.PersonID = V.PersonID
GO
IF OBJECT_id('dbo.vwShift') IS NULL EXEC sp_executesql N'CREATE VIEW dbo.vwShift AS SELECT A=0'
GO
ALTER VIEW dbo.vwShift AS
SELECT
ShiftID,
Shift,
Start = dbo.GetDateFromDaysPast1900([Start Day past 1900]),
[Start Time] = 
CASE WHEN [Start Seconds] < 36000 THEN '0' ELSE '' END +
CAST([Start Seconds] / 3600 AS varchar(50)) + ':' +
CASE WHEN ([Start Seconds] % 3600) < 600 THEN '0' ELSE '' END +
CAST(([Start Seconds] % 3600) / 60 AS varchar(50)) + ':' +
CASE WHEN [Start Seconds] % 60 < 10 THEN '0' ELSE '' END +
CAST([Start Seconds] % 60 AS varchar(50)),
[Stop Time] = 
CASE WHEN [Stop Seconds] < 36000 THEN '0' ELSE '' END +
CAST([Stop Seconds] / 3600 AS varchar(50)) + ':' +
CASE WHEN ([Stop Seconds] % 3600) < 600 THEN '0' ELSE '' END +
CAST(([Stop Seconds] % 3600) / 60 AS varchar(50)) + ':' +
CASE WHEN [Stop Seconds] % 60 < 10 THEN '0' ELSE '' END +
CAST([Stop Seconds] % 60 AS varchar(50)),
[Lunch Punch] = CAST(Flags & 16 AS bit),
[Lunch] = 
CASE WHEN (Flags & 0x10) = 0 THEN '' ELSE
CASE WHEN [Lunch Start] < 36000 THEN '0' ELSE '' END +
CAST([Lunch Start] / 3600 AS varchar(50)) + ':' +
CASE WHEN ([Lunch Start] % 3600) < 600 THEN '0' ELSE '' END +
CAST(([Lunch Start] % 3600) / 60 AS varchar(50)) + ':' +
CASE WHEN [Lunch Start] % 60 < 10 THEN '0' ELSE '' END +
CAST([Lunch Start] % 60 AS varchar(50)) END,
[Lunch Minutes] = CASE WHEN (Flags & 0x10) = 0 THEN NULL ELSE [Lunch Seconds] / 60 END,
[Slant In] = CAST(Flags & 4 AS bit),
[Slant Out] = CAST(Flags & 8 AS bit),
[Grace Minutes] = [Grace Seconds] / 60,
[Shift Hours] = CASE WHEN [Seconds per Day] < 36000 THEN '0' ELSE '' END +
CAST([Seconds per Day] / 3600 AS varchar(50)) + ':' +
CASE WHEN ([Seconds per Day] % 3600) < 600 THEN '0' ELSE '' END +
CAST(([Seconds per Day] % 3600) / 60 AS varchar(50)) + ':' +
CASE WHEN [Seconds per Day] % 60 < 10 THEN '0' ELSE '' END +
CAST([Seconds per Day] % 60 AS varchar(50)),
FTE,
[Days On],
[Days Off],
DaysOn2,
DaysOff2,
[Start Seconds],
[Stop Seconds],
[Grace Seconds],
[Lunch Start],
[Lunch Seconds],
[Start Day past 1900],
[Seconds per Day],
Flags
FROM dbo.Shift
GO
IF OBJECT_ID('dbo.vwLedger') IS NOT NULL DROP VIEW dbo.vwLedger
IF OBJECT_ID('dbo.vwEmployeeEEO') IS NOT NULL DROP VIEW dbo.vwEmployeeEEO
IF OBJECT_ID('dbo.vwEmployeeCommunication') IS NOT NULL DROP VIEW dbo.vwEmployeeCommunication
GO
IF OBJECT_id('dbo.vwEquipment') IS NULL EXEC sp_executesql N'CREATE VIEW dbo.vwEquipment AS SELECT A=0'
GO
ALTER VIEW dbo.vwEquipment
AS
SELECT E.EquipmentID,
E.[Description],
T.[Type],
Employee = CASE WHEN P.PersonID IS NULL THEN '' ELSE dbo.fnGetListAs(P.[First Name], P.[Middle Name], P.[Last Name], P.Suffix) END,
E.EmployeeID,
E.[Manufacturer],
E.[Serial Number],
E.Model,
E.Make,
E.[Service Tag],
[Last Serviced Date] = dbo.GetDateFromDaysPast1900(E.[Last Serviced Day past 1900]),
E.[Last Serviced Day past 1900],
E.[Purchase Day past 1900],
[Purchase Date] = dbo.GetDateFromDaysPast1900(E.[Purchase Day past 1900]),
E.[Purchase Price],
E.[Checked Out Day past 1900],
[Checked Out Date] = dbo.GetDateFromDaysPast1900(E.[Checked Out Day past 1900]),
E.[Due Day past 1900],
E.ReturnedByEmployeeID,
[Checked Out By] = CASE WHEN P3.PersonID IS NULL THEN '' ELSE dbo.fnGetListAs(P3.[First Name], P3.[Middle Name], P3.[Last Name], P3.Suffix) END,
E.CheckedOutByEmployeeID,
[Returned By] = CASE WHEN P2.PersonID IS NULL THEN '' ELSE dbo.fnGetListAs(P2.[First Name], P2.[Middle Name], P2.[Last Name], P2.Suffix) END,
E.[Returned Day past 1900],
[Returned Date] = dbo.GetDateFromDaysPast1900(E.[Returned Day past 1900]),
E.[Last Price],
E.[Last Price Day past 1900],
[Last Price Date] = dbo.GetDateFromDaysPast1900(E.[Last Price Day past 1900]),
E.Pin,
E.SIMM,
E.IMEI,
E.Accessories,
E.[Service Start Day past 1900],
E.[Expiration Day past 1900],
E.[Service],
[Service Start] = dbo.GetDateFromDaysPast1900(E.[Service Start Day past 1900]),
[Expiration] = dbo.GetDateFromDaysPast1900(E.[Expiration Day past 1900]),
E.Issuer,
E.Number,
E.CVV,
E.[Name on Card],
E.[Purchase Limit],
E.[Daily Limit],
E.[Total Limit],
E.[Billing Address],
E.[Billing Address (cont.)],
E.[Billing City],
E.[Billing State / Region],
E.[Billing ZIP / Postal Code],
[Due Date] = dbo.GetDateFromDaysPast1900(E.[Due Day past 1900]),
E.Note,
E.TypeID,
E.VIN,
E.[Year],
IP,
--Applications,
OS,
CPU,
RAM,
HD,
HD2,
[Role],
[Service Pack],
Location,
[Serial Number (2)],
UICC,
Provider,
[Product Key],
User1,
User2,
User3,
User4,
User5,
User6,
User7,
User8,
User9,
[Type Flags] = T.Flags,
T.[Column Mask]
FROM dbo.Equipment E
INNER JOIN dbo.EquipmentType T ON E.TypeID = T.TypeID
LEFT JOIN dbo.Person P ON P.PersonID = E.EmployeeID
LEFT JOIN dbo.Person P2 ON P2.PersonID = E.ReturnedByEmployeeID
LEFT JOIN dbo.Person P3 ON P3.PersonID = E.CheckedOutByEmployeeID
GO
IF OBJECT_id('dbo.vwBenefitPremium') IS NULL EXEC sp_executesql N'CREATE VIEW dbo.vwBenefitPremium AS SELECT A=0'
GO
ALTER VIEW dbo.vwBenefitPremium AS SELECT * FROM BenefitPremium
GO
IF OBJECT_ID('dbo.vwEmployeeCompensationAdjustment') IS NULL EXEC sp_executesql N'CREATE VIEW dbo.vwEmployeeCompensationAdjustment AS SELECT A=0'
GO
ALTER VIEW dbo.vwEmployeeCompensationAdjustment
AS
SELECT ItemID=0,
AdjustmentID=0,
CompensationID=0,
[Minimum Adjustment]=CAST(0 AS money),
[Maximum Adjustment]=CAST(0 AS money),
Adjustment='',
[List As]='',
Initials='',
[Full Name]='',
EmployeeID=0,
[Start Day past 1900]=0,
[Stop Day past 1900]=0,
PeriodID=0,
Period = '',
Seconds=0,
[Annualized Minimum Adjustment] = CAST(0 AS money),
[Annualized Maximum Adjustment] = CAST(0 AS money)
GO
IF OBJECT_id('dbo.vwEmployeeLeavePlan') IS NULL EXEC sp_executesql N'CREATE VIEW dbo.vwEmployeeLeavePlan AS SELECT A=0'
GO
ALTER VIEW dbo.vwEmployeeLeavePlan
AS
SELECT EP.ItemID, EP.EmployeeID, EP.PlanID, EP.[Start Day past 1900], EP.[Stop Day past 1900], EP.FTE,
P.[Plan],
[Start] = dbo.GetDateFromDaysPast1900([Start Day past 1900]),[Stop] = dbo.GetDateFromDaysPast1900([Stop Day past 1900])
FROM EmployeeLeavePlan EP 
INNER JOIN LeavePlan P
ON EP.PlanID = P.PlanID
GO
IF OBJECT_id('dbo.vwLeaveLimit') IS NULL EXEC sp_executesql N'CREATE VIEW dbo.vwLeaveLimit AS SELECT A=0'
GO
ALTER VIEW dbo.vwLeaveLimit
AS
SELECT L.LimitID, L.PlanID, L.TypeID, L.PeriodID, L.[Month], L.[Day], L.[Max Seconds], L.[Enable After Months],
T.[Type], [Description] = CASE WHEN L.[Max Seconds] IS NULL THEN 'Unlimited' ELSE
	CAST(CAST(L.[Max Seconds] / 3600 AS numeric(9,2)) AS varchar(100)) + ' Hrs' + CASE L.PeriodID
		WHEN 1 THEN ' Applied Every ' + 
			DATENAME(m, CONVERT(DATETIME,'00'+
				(CASE WHEN L.[Month]  < 10 THEN '0' ELSE '' END) + CAST(L.[Month] AS varchar(100))
			+'01',12)) + ' ' + CAST(L.[Day] AS varchar(100))
		WHEN 2 THEN ' Applied on Each Seniority Anniversary'
		WHEN 3 THEN ' Applied on the Eve of Each Seniority Anniversary'
		WHEN 4 THEN ' Applied Day ' + CAST(L.[Day] AS varchar(100)) + ' of Each Month'
		ELSE ''
	END
END, L.Flags
FROM LeaveLimit L
INNER JOIN LeaveType T ON L.TypeID = T.TypeID
GO
IF OBJECT_id('dbo.vwDateFirst') IS NULL EXEC sp_executesql N'CREATE VIEW dbo.vwDateFirst AS SELECT [DateFirst]=0, DatePartDW=0'
GO
-- DateFirst Monday=1:Sunday=7, DatePartDW Sunday=1:Saturday=7
ALTER VIEW dbo.vwDateFirst
AS
SELECT 
	[DateFirst]=CASE 
		WHEN C.DateFirst IS NOT NULL THEN C.DateFirst
		WHEN P.Weekday=0 THEN @@DATEFIRST
		ELSE P.Weekday
	END,
	DatePartDW=CASE 
		WHEN C.DateFirst IS NOT NULL AND C.DateFirst=7 THEN 1
		WHEN C.DateFirst IS NOT NULL THEN C.DateFirst+1
		WHEN P.Weekday=0 AND @@DATEFIRST=7 THEN 1
		WHEN P.Weekday=0 THEN @@DATEFIRST+1
		WHEN P.Weekday=7 THEN 1
		ELSE P.Weekday+1
	END
FROM dbo.Constant C INNER JOIN LeaveRatePeriod P ON P.PeriodID=C.CurrentPayrollPeriodID
GO
IF OBJECT_id('dbo.vwEmployeeLeaveInfo') IS NULL EXEC sp_executesql N'CREATE VIEW dbo.vwEmployeeLeaveInfo AS SELECT A=0'
GO
ALTER VIEW dbo.vwEmployeeLeaveInfo
AS
SELECT E.EmployeeID, E.[Leave Note], E.[Ongoing Condition], E.[Recertify Condition Day past 1900], [Recertify Condition] = dbo.GetDateFromDaysPast1900(E.[Recertify Condition Day past 1900]), E.HolidayPlanID, [Holiday Plan] = H.[Plan]
FROM dbo.Employee E INNER JOIN dbo.HolidayPlan H ON E.HolidayPlanID = H.PlanID
GO
IF OBJECT_id('dbo.vwEmployeeLeaveUsed') IS NULL EXEC sp_executesql N'CREATE VIEW dbo.vwEmployeeLeaveUsed AS SELECT A=0'
GO
ALTER VIEW dbo.vwEmployeeLeaveUsed AS
SELECT
[LOALeaveID] = U.LeaveID,
[LOAEmployeeID] = U.EmployeeID,
[LOAReasonID] = U.ReasonID,
[LOACoveringEmployeeID] = U.CoveringEmployeeID,
[LOADenialReasonID] = U.DenialReasonID,
[LOAAuthorizingEmployeeID] = U.AuthorizingEmployeeID,
[LOAApprovalTypeID] = U.ApprovalTypeID,
[LOA Advanced Type Mask] = U.[Advanced Type Mask],
[LOA Extended Type Mask] = U.[Type Mask] | U.[Advanced Type Mask],
[LOA Status] = U.Status,
[LOA Note] = U.Note,

[LOA Start Day past 1900] = dbo.fnLOAStartStopInt(U.[Start Day past 1900],U.[Stop Day past 1900],U.[Start Day past 1900], GETDATE()),
[LOA Start] = dbo.fnLOAStartStopDate(U.[Start Day past 1900],U.[Stop Day past 1900],U.[Start Day past 1900], GETDATE()),

[LOA Stop Day past 1900] = dbo.fnLOAStartStopInt(U.[Start Day past 1900],U.[Stop Day past 1900],U.[Stop Day past 1900], GETDATE()),
[LOA Stop] = dbo.fnLOAStartStopDate(U.[Start Day past 1900],U.[Stop Day past 1900],U.[Stop Day past 1900], GETDATE()),

[LOA Requested Day past 1900] = U.[Requested Day past 1900],
[LOA Requested] = dbo.GetDateFromDaysPast1900(U.[Requested Day past 1900]),

[LOA Seconds] = U.Seconds,
[LOA Advanced Days] = U.[Advanced Seconds] / S.[Seconds per Day],
[LOA Type Mask] = U.[Type Mask],
[LOA Authorized Day past 1900] = U.[Authorized Day past 1900],

[LOA Reason] = ISNULL(R.Reason, ''),

[LOA Authorized] = dbo.GetDateFromDaysPast1900(U.[Authorized Day past 1900]),
[LOA Departing Employee] = dbo.fnGetListAs(E.[First Name], E.[Middle Name], E.[Last Name], E.Suffix),
[LOA Departing Employee Full Name] = dbo.fnGetFullName(E.[First Name], E.[Middle Name], E.[Last Name], E.Suffix),
[LOA Authorizing Employee] = CASE WHEN A.PersonID IS NULL THEN '' ELSE dbo.fnGetListAs(A.[First Name], A.[Middle Name], A.[Last Name], A.Suffix) END,
[LOA Authorizing Employee Full Name] = CASE WHEN A.PersonID IS NULL THEN '' ELSE dbo.fnGetFullName(A.[First Name], A.[Middle Name], A.[Last Name], A.Suffix) END,
[LOA Denial Reason] = ISNULL(D.[Reason], ''),
[LOA Approval Type] = ISNULL(LAT.[Type], ''),
[LOA Status Text] = dbo.fnGetStatusText(U.Status, A.[First Name], A.[Middle Name], A.[Last Name], U.[Authorized Day past 1900], LAT.[Type], D.Reason),
[LOAPreapprovedEmployeeID] = U.PreapprovedEmployeeID,
[LOA Preapproved Day past 1900] = U.[Preapproved Day past 1900],
[LOA Preapproved Employee] = CASE WHEN PRE.PersonID IS NULL THEN '' ELSE dbo.fnGetListAs(PRE.[First Name], PRE.[Middle Name], PRE.[Last Name], PRE.Suffix) END,
[LOA Preapproved Date] = dbo.GetDateFromDaysPast1900(U.[Preapproved Day past 1900]),

[LOA Expected Return Day past 1900] = U.[Expected Return Day past 1900],
[LOA Expected Departure Day past 1900] = U.[Expected Departure Day past 1900],
[LOA Last MD Note Day past 1900] = U.[Last MD Note Day past 1900],
[LOA Pay Began Day past 1900] = U.[Pay Began Day past 1900],
[LOA Pay Ended Day past 1900] = U.[Pay Ended Day past 1900],
[LOA Reconciled Day past 1900] = U.[Reconciled Day past 1900],

[LOA Expected Return] = dbo.GetDateFromDaysPast1900(U.[Expected Return Day past 1900]),
[LOA Expected Departure] = dbo.GetDateFromDaysPast1900(U.[Expected Departure Day past 1900]),
[LOA Last MD Note] = dbo.GetDateFromDaysPast1900(U.[Last MD Note Day past 1900]),
[LOA Pay Began] = dbo.GetDateFromDaysPast1900(U.[Pay Began Day past 1900]),
[LOA Pay Ended] = dbo.GetDateFromDaysPast1900(U.[Pay Ended Day past 1900]),
[LOA Reconciled] = dbo.GetDateFromDaysPast1900(U.[Reconciled Day past 1900]),

[LOA First Certified Day past 1900] = U.[First Certified Day past 1900],
[LOA First Certified] = dbo.GetDateFromDaysPast1900(U.[First Certified Day past 1900]),

[LOA Recertify Day past 1900] = U.[Recertify Day past 1900],
[LOA Recertify] = DATEADD(d, 0, U.[Recertify Day past 1900]),
[LOA Departing Employee Initials] = dbo.fnGetInitials(E.[First Name], E.[Middle Name], E.[Last Name]),
[LOA Authorization Expires Day past 1900] = U.[Authorization Expires Day past 1900],
[LOA Authorization Expires] = DATEADD(d, 0, U.[Authorization Expires Day past 1900]),
[LOA Expected Return-1] = DATEADD(d,-1,U.[Expected Return Day past 1900]),
[LOA Start+84] = CASE WHEN U.[Start Day past 1900] = -2147483648 AND U.[Stop Day past 1900] = -2147483648 THEN DATEADD(d,84,GETDATE()) ELSE dbo.GetDateFromDaysPast1900(U.[Start Day past 1900] + 84) END,
[LOA Start+14] = CASE WHEN U.[Start Day past 1900] = -2147483648 AND U.[Stop Day past 1900] = -2147483648 THEN DATEADD(d,14,GETDATE()) ELSE dbo.GetDateFromDaysPast1900(U.[Start Day past 1900] + 14) END,
[LOA Start+180] = CASE WHEN U.[Start Day past 1900] = -2147483648 AND U.[Stop Day past 1900] = -2147483648 THEN DATEADD(d,180,GETDATE()) ELSE dbo.GetDateFromDaysPast1900(U.[Start Day past 1900] + 180) END,
[LOA Start+365] = CASE WHEN U.[Start Day past 1900] = -2147483648 AND U.[Stop Day past 1900] = -2147483648 THEN DATEADD(d,365,GETDATE()) ELSE dbo.GetDateFromDaysPast1900(U.[Start Day past 1900] + 365) END,
[LOA PPE Start Day past 1900] = U.[PPE Start Day past 1900],
[LOA PPE Stop Day past 1900] = U.[PPE Stop Day past 1900],
[LOA Created Day past 1900] = U.[Created Day past 1900],
[LOA Created Start Day past 1900] = U.[Created Start Day past 1900],
[LOA Created Stop Day past 1900] = U.[Created Stop Day past 1900],
[LOA First Day Used past 1900] = U.[First Day Used],
[LOA Last Day Used past 1900] = U.[Last Day Used],
[LOA First Date Used] = DATEADD(d, 0, U.[First Day Used]),
[LOA Last Date Used] = DATEADD(d, 0, U.[Last Day Used]),
U.[Calendar Comment],
[LOA RTW] = DATEADD(d, 0, U.[RTW Day past 1900]),
[LOA RTW Day past 1900] = U.[RTW Day past 1900],
[LOA RTW Mask] = U.[RTW Mask]
FROM dbo.EmployeeLeaveUsed U
INNER JOIN dbo.Person E ON U.EmployeeID = E.PersonID
INNER JOIN dbo.Employee EMP ON U.EmployeeID = EMP.EmployeeID
INNER JOIN dbo.Shift S ON EMP.ShiftID = S.ShiftID
LEFT JOIN dbo.Person A ON U.AuthorizingEmployeeID = A.PersonID
LEFT JOIN dbo.DenialReason D ON U.DenialReasonID = D.DenialReasonID
LEFT JOIN dbo.Reason R ON U.ReasonID = R.ReasonID
LEFT JOIN dbo.LeaveApprovalType LAT ON U.ApprovalTypeID = LAT.TypeID
LEFT JOIN dbo.Person PRE ON U.PreapprovedEmployeeID=PRE.PersonID
GO
IF OBJECT_id('dbo.vwEmployeeExpense2') IS NULL EXEC sp_executesql N'CREATE VIEW dbo.vwEmployeeExpense2 AS SELECT A=0'
GO
ALTER VIEW dbo.vwEmployeeExpense2
AS
SELECT H.ItemID, H.AccountID, H.StatusID, H.ProjectID, H.EmployeeID, H.[Day past 1900], H.Amount,
H.[Day Reimbursed], H.[Employee Comment], H.[Manager Comment], H.[Reimbursed Check Number],
H.[Created Day past 1900], H.GLAccountID, H.Miles, H.[Attachment Name],
S.Status, Employee=P.[List As], Project=ISNULL(Project.Project,''),
[Date]=dbo.GetDateFromDaysPast1900(H.[Day past 1900]),
[Reimbursed Date]=dbo.GetDateFromDaysPast1900(H.[Day Reimbursed]),
[To Be Reimbursed]=CAST(CASE
	WHEN T.Reimbursable=1 AND H.[Amount]<0 THEN 1
	ELSE 0
END as bit),
Reimbursed=CAST(CASE
	WHEN T.Reimbursable=1 AND H.[Day Reimbursed] IS NOT NULL THEN 1
	ELSE 0
END AS bit),
T.[Reimbursable], T.[Accumulated], T.[Project Tracking], T.[Requires Approval],
T.[Account], T.[Note], T.[Flags], T.ExpenseGLAccount, T.LiabilityGLAccount,
[Has Attachment] = CAST(CASE WHEN H.Attachment IS NULL THEN 0 ELSE 1 END AS bit),
Credit = CASE WHEN H.Amount > 0 THEN H.Amount ELSE 0 END,
Debit = CASE WHEN H.Amount < 0 THEN 0 - H.Amount ELSE 0 END
FROM dbo.EmployeeExpense H
INNER JOIN dbo.vwPersonListAs P ON H.EmployeeID=P.PersonID
INNER JOIN dbo.vwExpenseAccount T ON H.AccountID=T.AccountID
INNER JOIN dbo.ExpenseStatus S ON H.StatusID=S.StatusID
LEFT JOIN dbo.Project ON H.ProjectID=Project.ProjectID
GO
IF OBJECT_id('dbo.vwEmployeeExpense') IS NULL EXEC sp_executesql N'CREATE VIEW dbo.vwEmployeeExpense AS SELECT A=0'
GO
ALTER  VIEW dbo.vwEmployeeExpense
AS
SELECT H.*,
[Unreimbursed]=CASE WHEN H.Reimbursable=0 THEN 0.0000
	ELSE ISNULL((
		SELECT 0 - SUM(Amount) FROM vwEmployeeExpense2 X WHERE 
		X.EmployeeID=H.EmployeeID AND X.AccountID=H.AccountID AND (X.StatusID & 1)=1 AND X.[To Be Reimbursed]=1 AND X.Reimbursed=0 AND (
			X.[Day past 1900]<H.[Day past 1900] OR (X.[Day past 1900]=H.[Day past 1900] AND X.ItemID<=H.ItemID)
		)
	),0.0000)
	END,
[Sum]=CASE WHEN H.Accumulated=0 THEN 0.0000
	ELSE ISNULL((
		SELECT SUM(Amount) FROM EmployeeExpense X WHERE 
		X.EmployeeID=H.EmployeeID AND X.AccountID=H.AccountID AND (X.StatusID & 1)=1 AND (
			X.[Day past 1900]<H.[Day past 1900] OR (X.[Day past 1900]=H.[Day past 1900] AND X.ItemID<=H.ItemID)
		)
	),0.0000)
	END
FROM dbo.vwEmployeeExpense2 H
GO
IF OBJECT_ID('dbo.vwLeaveRate') IS NULL EXEC sp_executesql N'CREATE VIEW dbo.vwLeaveRate AS SELECT A=0'
GO
ALTER VIEW dbo.vwLeaveRate
AS
SELECT R.RateID, R.PlanID, R.TypeID, R.[Start Month], R.[Stop Month], R.Seconds, R.PeriodID, R.[Ineligible Months], R.Flags,
T.[Type], T.Paid, P.Period, GroupID = G.PeriodID, [Group] = G.Period, [Seconds in Period] = G.Seconds,
LimitPeriodID,
[Limit Month],
[Limit Day],
[Limit Max Seconds],
R.ExcludeMonthMask
FROM LeaveRate R
INNER JOIN LeaveRatePeriod P ON R.PeriodID = P.PeriodID
INNER JOIN Period G ON P.GroupID = G.PeriodID
INNER JOIN LeaveType T ON R.TypeID = T.TypeID
GO
IF OBJECT_ID('dbo.vwEmployeeLeaveApproved') IS NULL EXEC sp_executesql N'CREATE VIEW dbo.vwEmployeeLeaveApproved AS SELECT A=0'
GO
ALTER VIEW dbo.vwEmployeeLeaveApproved
AS
SELECT [Limit Adjustment] = CAST(CASE WHEN E.[Auto] = 2 THEN 1 ELSE 0 END AS bit), E.[Day past 1900], E.Seconds, 
[Date] = dbo.GetDateFromDaysPast1900(E.[Day past 1900]), [Extended Type Mask] = E.TypeID, E.TypeID, E.EmployeeID, 
T.Type, T.Abbreviation, T.Paid, T.[Order], T.Bank, T.[OT Eligible], EMP.[Payroll Delay], T.[Advanced], [Table]=1
FROM dbo.EmployeeLeaveEarned E
INNER JOIN dbo.LeaveType T ON E.TypeID = T.TypeID
INNER JOIN dbo.Employee EMP ON EMP.EmployeeID = E.EmployeeID

UNION ALL

SELECT 0, I.[Day past 1900], -I.Seconds,
[Date] = dbo.GetDateFromDaysPast1900(I.[Day past 1900]), 
[Extended Type Mask] = L.TypeID,
L.TypeID, L.EmployeeID, 
T.[Type], T.Abbreviation, T.Paid, T.[Order], T.Bank, T.[OT Eligible], EMP.[Payroll Delay], T.Advanced, [Table]=2
FROM dbo.EmployeeLeaveUsedLink L 
INNER JOIN dbo.EmployeeLeaveUsed U ON U.LeaveID = L.LeaveID AND U.[Status] = 2
INNER JOIN dbo.EmployeeLeaveUsedItem I ON U.LeaveID=I.LeaveID AND ((I.TypeID | I.[Advanced Type Mask]) & L.TypeID) > 0
INNER JOIN dbo.Employee EMP ON EMP.EmployeeID = L.EmployeeID
INNER JOIN dbo.LeaveType T ON  L.TypeID = T.TypeID

UNION ALL

SELECT CAST(0 AS bit), I.[Day past 1900], -I.Seconds,
[Date] = dbo.GetDateFromDaysPast1900([Day past 1900]), [Extended Type Mask] = I.TypeID | I.[Advanced Type Mask], I.TypeID, U.EmployeeID, 
T.Type, T.Abbreviation, T.Paid, T.[Order], T.Bank, T.[OT Eligible], EMP.[Payroll Delay], T.Advanced, [Table]=3
FROM dbo.EmployeeLeaveUsedItem I
INNER JOIN dbo.EmployeeLeaveUsed U ON U.LeaveID=I.LeaveID
INNER JOIN dbo.LeaveType T ON U.[Status] = 2 AND I.TypeID = T.TypeID
INNER JOIN dbo.Employee EMP ON EMP.EmployeeID = U.EmployeeID

UNION ALL

SELECT 0, DATEDIFF(d,0,T.[In]), 
dbo.fnRoundUp(
	CAST(TT.[Comp Rate] AS numeric(19,4)) * 
	DATEDIFF(second,
		dbo.fnTimeRoundIn(C.[Timecard Flags], C.[Timecard Rounding], T.[In]),
		dbo.fnTimeRoundOut(C.[Timecard Flags], C.[Timecard Rounding], T.[In], T.Seconds)
	),
	C.[Comp Rate Round Seconds]
)
,
[Date] = CAST(T.[In] AS varchar(11)), [Extended Type Mask] = TT.CompLeaveTypeID, TT.CompLeaveTypeID, T.EmployeeID,
LT.[Type], LT.Abbreviation, LT.Paid, LT.[Order], LT.Bank, LT.[OT Eligible], EMP.[Payroll Delay], LT.Advanced, [Table]=4
FROM dbo.EmployeeTime T
INNER JOIN dbo.TimeType TT ON T.TypeID=TT.TypeID AND (T.StatusID & 1) = 1
INNER JOIN dbo.LeaveType LT ON TT.CompLeaveTypeID = LT.TypeID
INNER JOIN dbo.Employee EMP ON EMP.EmployeeID = T.EmployeeID
CROSS JOIN dbo.Constant C
GO
IF OBJECT_ID('dbo.vwPayer') IS NOT NULL DROP VIEW dbo.vwPayer
GO
IF OBJECT_id('dbo.vwOccurrence2') IS NOT NULL DROP VIEW dbo.vwOccurrence2
GO
CREATE VIEW dbo.vwOccurrence2 AS SELECT O.*, T.Type,
[Date] = dbo.GetDateFromDaysPast1900([Day past 1900]),
Expires = dbo.GetDateFromDaysPast1900([Expires Day past 1900]),
Employee = P.[List As],
[Employee Full Name] = P.[Full Name]
FROM Occurrence O INNER JOIN OccurrenceType T ON O.TypeID=T.TypeID
INNER JOIN vwPersonCalculated P ON O.EmployeeID=P.PersonID
GO
IF OBJECT_id('dbo.vwOccurrence') IS NOT NULL DROP VIEW dbo.vwOccurrence
GO
CREATE VIEW dbo.vwOccurrence AS
SELECT O.*,
Balance = ISNULL((
	SELECT SUM(R.[Weight]) FROM Occurrence R WHERE O.EmployeeID=R.EmployeeID AND (O.TypeID=R.TypeID OR (C.[Occurrence Flags] & 1) = 1) AND
	(R.[Expires Day past 1900] IS NULL OR R.[Expires Day past 1900] > O.[Day past 1900]) AND
	((R.[Day past 1900]<O.[Day past 1900]) OR (R.[Day past 1900]=O.[Day past 1900] AND R.OccurrenceID<=O.OccurrenceID))
), 0.0000),
Balance2 = ISNULL((
	SELECT SUM(R.[Weight]) FROM Occurrence R WHERE O.EmployeeID=R.EmployeeID AND (O.TypeID=R.TypeID OR (C.[Occurrence Flags] & 1) = 1) AND
	R.[Day past 1900] < ISNULL(O.[Expires Day past 1900], 2147483647) AND
	ISNULL(R.[Expires Day past 1900], 2147483647) > ISNULL(O.[Expires Day past 1900], 2147483646)
), 0.0000),
Balance3 = ISNULL((
	SELECT SUM(R.[Weight]) FROM Occurrence R WHERE O.EmployeeID=R.EmployeeID AND (O.TypeID=R.TypeID OR (C.[Occurrence Flags] & 1) = 1) AND
	(R.[Expires Day past 1900] IS NULL OR R.[Expires Day past 1900] > DATEDIFF(d,0,GETDATE()))
), 0.0000)
FROM dbo.vwOccurrence2 O
CROSS JOIN dbo.Constant C
GO
IF OBJECT_ID('dbo.vwLanguageProficiency') IS NOT NULL DROP VIEW dbo.vwLanguageProficiency
GO
CREATE VIEW dbo.vwLanguageProficiency
AS
SELECT P.Proficiency, P.ProficiencyID, P.Level, P.Flags,
AreLanguagesPrimary = CAST((P.Flags & 1) AS bit)
FROM dbo.LanguageProficiency P
GO
IF OBJECT_ID('dbo.vwPersonXLanguage2') IS NOT NULL DROP VIEW dbo.vwPersonXLanguage2
GO
CREATE VIEW dbo.vwPersonXLanguage2 AS
SELECT PL.ItemID, PL.PersonID, PL.LanguageID, PL.ProficiencyID, PL.Comment, 
L.Language,
P.[Level], P.Proficiency, P.Flags,
[Primary] = CAST (CASE WHEN (P.Flags & 1) = 1 THEN 1 ELSE 0 END AS bit),
[Person] = dbo.fnGetListAs(Person.[First Name], Person.[Middle Name], Person.[Last Name], Person.Suffix)
FROM dbo.PersonXLanguage PL
INNER JOIN dbo.Language L ON PL.LanguageID = L.LanguageID
INNER JOIN dbo.PersonX PX ON PL.PersonID = PX.PersonID
INNER JOIN dbo.LanguageProficiency P ON PL.ProficiencyID = P.ProficiencyID
INNER JOIN dbo.Person ON PL.PersonID = Person.PersonID
GO
IF OBJECT_id('dbo.vwAuditTrail') IS NOT NULL DROP VIEW dbo.vwAuditTrail
GO
CREATE VIEW dbo.vwAuditTrail AS
SELECT A.ItemID, A.SID, A.Event, A.[User], A.RegardingPersonID, A.[ID], A.ObjectID, A.[Event Mask], A.Created, A.TableID,
[Regarding Person] = ISNULL(P.[List As], ''), [Object]=ISNULL(S.[Object],'Unknown'),
[Action] = CASE [Event Mask]
	WHEN 1 THEN 'Read'
	WHEN 2 THEN 'Write'
	WHEN 4 THEN 'Create'
	WHEN 8 THEN 'Delete'
	WHEN 16 THEN 'Unauthorized Read'
	WHEN 32 THEN 'Unauthorized Write'
	WHEN 64 THEN 'Unauthorized Create'
	WHEN 128 THEN 'Unauthorized Delete'
	ELSE 'Multiple'
END
FROM dbo.AuditTrail A
LEFT JOIN dbo.AuditSetting S ON A.ObjectID=S.ObjectID
LEFT JOIN dbo.vwPersonListAs P ON A.RegardingPersonID=P.PersonID
GO
IF OBJECT_id('dbo.vwRace') IS NOT NULL DROP VIEW dbo.vwRace
GO
CREATE VIEW dbo.vwRace AS SELECT * FROM Race
GO
ALTER VIEW dbo.vwLocationRaceEEO
AS
SELECT Male = CAST(Male.Male AS bit), L.LocationID, RaceID=Columns.[Column], Location = L.[List As], Race='', [Previous Count] =
ISNULL ((
	SELECT LR.[Previous Count] FROM LocationRaceEEO LR
	INNER JOIN Race R ON R.[Report Column]=Columns.[Column] AND LR.RaceID=R.[Report Column] AND LR.LocationID = L.LocationID AND LR.Male = Male.Male
) ,0)
FROM Location L
CROSS JOIN
(
	SELECT [Column]=0 UNION
	SELECT 1 UNION SELECT 2 UNION SELECT 3 UNION SELECT 4 UNION
	SELECT 5 UNION SELECT 6 UNION SELECT 7 UNION SELECT 8 UNION
	SELECT 9 UNION SELECT 10
) Columns
CROSS JOIN
(
	SELECT [Male]=0 UNION SELECT 1
) Male

UNION ALL

SELECT Male = CAST(Male.Male AS bit), NULL, RaceID=Columns.[Column], '', Race='', [Previous Count] =
ISNULL ((
	SELECT LR.[Previous Count] FROM LocationRaceEEO LR
	INNER JOIN Race R ON R.[Report Column]=Columns.[Column] AND LR.RaceID=R.[Report Column] AND LR.Male = Male.Male
) ,0)
FROM
(
	SELECT [Column]=0 UNION
	SELECT 1 UNION SELECT 2 UNION SELECT 3 UNION SELECT 4 UNION
	SELECT 5 UNION SELECT 6 UNION SELECT 7 UNION SELECT 8 UNION
	SELECT 9 UNION SELECT 10
) Columns
CROSS JOIN
(
	SELECT [Male]=0 UNION SELECT 1
) Male
GO
IF OBJECT_ID('dbo.vwEmployeeTerminal') IS NULL EXEC sp_executesql N'CREATE VIEW dbo.vwEmployeeTerminal AS SELECT A=0'
GO
ALTER VIEW dbo.vwEmployeeTerminal AS
SELECT E.[Terminal Password],
E.[PID Card Number],
E.TerminalSyncFlags,
E.TerminalSyncFlags2,
E.[Enrolled Terminals Mask],
E.[Terminal Sync State Mask],
E.EmployeeID,
E.[Fingerprints Stream],
E.[Terminal Last Sync],
E.[Employee Number],
[Full Name] = dbo.fnGetFullName(P.[First Name], P.[Middle Name], P.[Last Name], P.Suffix),
[Terminal Sync Status] = dbo.fnGetTerminalSyncStatus(E.[Terminal Last Sync], E.[Terminal Sync State Mask]),
E.[Active Employee],
EmployeeNumberT = dbo.fnNormalizeTerminalEnrollNumber(E.[Employee Number], E.EmployeeID)
FROM dbo.Employee E
INNER JOIN dbo.Person P ON E.EmployeeID= P.PersonID
GO
IF OBJECT_ID('dbo.vwTerminal') IS NOT NULL DROP VIEW dbo.vwTerminal
GO
CREATE VIEW dbo.vwTerminal AS 
SELECT TerminalID, IP, [Port], [Password], [Last Result], [Last Updated], Flags, [Master] = CAST(CASE WHEN (Flags & 1) = 1 THEN 1 ELSE 0 END AS bit), UniqueBit, Source, DDNS
FROM dbo.Terminal
GO
ALTER VIEW dbo.vwEmployeeCOBRA
AS
SELECT
E.EmployeeID,
Employee = dbo.fnGetListAs(P.[First Name], P.[Middle Name], P.[Last Name], P.Suffix),
E.[Track COBRA],
E.[First Payment Due Day past 1900] , [First Payment Due] = dbo.GetDateFromDaysPast1900(E.[First Payment Due Day past 1900]),
E.[Next Payment Due Day past 1900], [Next Payment Due] = dbo.GetDateFromDaysPast1900(E.[Next Payment Due Day past 1900]),
[Payment Due Day past 1900] = ISNULL(E.[First Payment Due Day past 1900], [Next Payment Due Day past 1900]),
[Payment Due] = dbo.GetDateFromDaysPast1900(ISNULL(E.[First Payment Due Day past 1900], [Next Payment Due Day past 1900])),
E.[COBRA Eligible Day past 1900], [COBRA Eligible] = dbo.GetDateFromDaysPast1900(E.[COBRA Eligible Day past 1900]),
E.[COBRA Notified Day past 1900], [COBRA Notified] = dbo.GetDateFromDaysPast1900(E.[COBRA Notified Day past 1900]),
E.[COBRA First Enrolled Day past 1900], [COBRA First Enrolled] = dbo.GetDateFromDaysPast1900(E.[COBRA First Enrolled Day past 1900]),
E.[COBRA Last Enrolled Day past 1900], [COBRA Last Enrolled] = dbo.GetDateFromDaysPast1900(E.[COBRA Last Enrolled Day past 1900]),
[COBRA Enrolled Day past 1900] = dbo.fnGetEnrolledDayPast1900(E.[COBRA First Enrolled Day past 1900], E.[COBRA Last Enrolled Day past 1900]),
[COBRA Enrolled] = dbo.fnGetEnrolled(E.[COBRA First Enrolled Day past 1900], E.[COBRA Last Enrolled Day past 1900]),
E.[COBRA Declined Day past 1900], [COBRA Declined] = dbo.GetDateFromDaysPast1900(E.[COBRA Declined Day past 1900]),
E.[COBRA Expires Day past 1900], [COBRA Expires] = dbo.GetDateFromDaysPast1900(E.[COBRA Expires Day past 1900]), E.[Benefit Note],
E.COBRAFirstQualifyingEventID, E.COBRALastQualifyingEventID, E.[COBRA First Qualifying Event Day past 1900], E.[COBRA Last Qualifying Event Day past 1900],
[COBRA First Qualifying Event Date] = dbo.GetDateFromDaysPast1900(E.[COBRA First Qualifying Event Day past 1900]), [COBRA First Qualifying Event] = ISNULL(QE1.Event, ''),
[COBRA Last Qualifying Event Date] = dbo.GetDateFromDaysPast1900(E.[COBRA Last Qualifying Event Day past 1900]), [COBRA Last Qualifying Event] = ISNULL(QE2.Event, ''),
Enrollment = CASE
	WHEN E.[Track COBRA] = 0 THEN ''
	ELSE dbo.fnGetEnrollment(GETDATE(), NULL, NULL, E.[COBRA Declined Day past 1900], E.[COBRA First Enrolled Day past 1900], E.[COBRA Last Enrolled Day past 1900], E.[COBRA Expires Day past 1900], E.[COBRA Eligible Day past 1900])
END,
EnrollmentID = CASE 
	WHEN E.[Track COBRA] = 0 THEN 0
	ELSE dbo.fnGetEnrollmentID(GETDATE(), E.[COBRA Declined Day past 1900],E.[COBRA Expires Day past 1900],E.[COBRA First Enrolled Day past 1900],E.[COBRA Last Enrolled Day past 1900],E.[COBRA Eligible Day past 1900],E.[COBRA Notified Day past 1900])
END
FROM dbo.Employee E
INNER JOIN dbo.Person P ON E.EmployeeID = P.PersonID
LEFT JOIN dbo.COBRAQE QE1 ON E.COBRAFirstQualifyingEventID = QE1.EventID
LEFT JOIN dbo.COBRAQE QE2 ON E.COBRAFirstQualifyingEventID = QE2.EventID
GO
CREATE VIEW dbo.vwEmployeeTermination AS
SELECT E.EmployeeID, E.Rehire, E.[Reason for Termination], E.[Terminated Day past 1900], Terminated = dbo.GetDateFromDaysPast1900(E.[Terminated Day past 1900]),
TerminationReasonID, Reason=ISNULL(TR.Reason,''), E.[Exit Interview Day past 1900], [Exit Interview] = dbo.GetDateFromDaysPast1900(E.[Exit Interview Day past 1900]),
E.ExitInterviewByEmployeeID, [Exit Interview by] = ISNULL(P.[List As],'')
FROM dbo.Employee E LEFT JOIN dbo.TerminationReason TR ON E.TerminationReasonID = TR.ReasonID
LEFT JOIN dbo.vwPersonListAs P ON E.ExitInterviewByEmployeeID = P.PersonID
GO
-- Can't because of note column. CREATE UNIQUE CLUSTERED INDEX IX_vwEmployeeTermination_EmployeeID ON vwEmployeeTermination(EmployeeID) 
GO
CREATE VIEW dbo.vwEmployeePayStep WITH SCHEMABINDING AS
SELECT E.EmployeeID, 
E.FilingStatusID,
[Filing Status] = FS.Status,
E.Salaried,
E.[OT Basis],
E.[FIT Exemptions],

E.DefaultTimeTypeID,
E.[Direct Deposit Account Number],
E.[Payroll Delay],

[OT Pay Multiplier] = 1.5, -- legacy
[Holiday Pay Multiplier] = 1.0, -- legacy
[Weekend Pay Multiplier] = 1.0 -- legacy

FROM dbo.Employee E 
INNER JOIN dbo.FilingStatus FS ON E.FilingStatusID = FS.StatusID
GO
CREATE UNIQUE CLUSTERED INDEX IX_vwEmployeePayStep_EmployeeID ON vwEmployeePayStep(EmployeeID)
GO
CREATE VIEW dbo.vwEmployeeUpdateInOutStatus WITH SCHEMABINDING AS
SELECT E.EmployeeID, [List As] = dbo.fnGetListAs(P.[First Name], P.[Middle Name], P.[Last Name], P.Suffix), S.[Status], E.InOutStatusID, E.InOutReturn, S.[In], [Color] = S.Color & 0xFFFFFF, E.InOutComment, E.InOutLastUpdated, E.InOutLastSource, E.SyncID
FROM dbo.Employee E INNER JOIN dbo.Person P ON E.EmployeeID=P.PersonID INNER JOIN dbo.InOutStatus S ON E.InOutStatusID = S.StatusID
GO
CREATE UNIQUE CLUSTERED INDEX IX_vwEmployeeUpdateInOutStatus_EmployeeID ON dbo.vwEmployeeUpdateInOutStatus(EmployeeID)
GO
CREATE VIEW dbo.vwPersonXLanguages AS
SELECT X.PersonID, 
[Primary Language] = X.PrimaryLanguages2,
PrimaryLanguageID = (
	SELECT TOP 1 LanguageID FROM dbo.PersonXLanguage PL
	INNER JOIN dbo.LanguageProficiency PROFICIENCY ON X.PersonID = PL.PersonID AND PL.ProficiencyID=PROFICIENCY.ProficiencyID AND (PROFICIENCY.Flags & 1) = 1
),
[Secondary Language Mask] = ISNULL((
	SELECT SUM(LanguageID) FROM dbo.PersonXLanguage PL
	INNER JOIN dbo.LanguageProficiency PROFICIENCY ON X.PersonID = PL.PersonID AND PL.ProficiencyID=PROFICIENCY.ProficiencyID AND (PROFICIENCY.Flags & 1) = 0
), 0),
[Language Mask] = ISNULL((
	SELECT SUM(LanguageID) FROM dbo.PersonXLanguage PL WHERE PL.PersonID=X.PersonID
), 0),
[Secondary Languages] = X.SecondaryLanguages2
FROM dbo.PersonX X LEFT JOIN dbo.Language L ON X.PrimaryLanguageID = L.LanguageID
GO
ALTER VIEW dbo.vwPersonHome WITH SCHEMABINDING
AS
SELECT 
PersonID, [Home Fax], [Home Phone], [Home E-mail], [Home Address], [Home Address (cont.)], [Home City], [Home State], [Home Zip], [Home Country],
[Extended Home Address] = dbo.fnGetExtendedHomeAddress([Home Address], [Home Address (cont.)], [Home City], [Home State], [Home Zip]) FROM dbo.Person
GO
CREATE UNIQUE CLUSTERED INDEX IX_vwPersonHome_PersonID ON dbo.vwPersonHome(PersonID)
GO
ALTER VIEW dbo.vwPersonWork WITH SCHEMABINDING
AS
SELECT
P.Title, P.[First Name], P.[Middle Name], P.[Last Name], P.Suffix, P.[Credentials], P.Male,
P.[Work E-mail], P.[Work Phone], P.Extension, P.[Work Phone Note],
P.[Toll Free Phone], P.[Mobile Phone], P.[Work Fax], P.Pager, P.Note,
P.[Work Address], P.[Work Address (cont.)], P.[Work City], P.[Work State], P.[Work ZIP], P.[Work Country],
P.PersonID, P.[Role Mask], P.[Home Office Phone],

[Extended Work Address] =  CASE WHEN LEN(P.[Work Address]) = 0 THEN '' ELSE P.[Work Address] + CHAR(10) END +
CASE LEN(P.[Work Address (cont.)]) WHEN 0 THEN '' ELSE P.[Work Address (cont.)] + CHAR(10)  END +
CASE LEN(P.[Work City]) WHEN 0 THEN '' ELSE P.[Work City] + ', ' END +
CASE LEN(P.[Work State]) WHEN 0 THEN '' ELSE P.[Work State] + '  ' END +
P.[Work ZIP],

[Extended Work Phone] = P.[Work Phone]  + CASE WHEN LEN(P.[Work Phone]) > 0 AND LEN(P.[Extension]) > 0 THEN ' x' ELSE '' END + P.Extension,

[List As] = dbo.fnGetListAs(P.[First Name], P.[Middle Name], P.[Last Name], P.Suffix),
Initials = dbo.fnGetInitials(P.[First Name], P.[Middle Name], P.[Last Name]),
[Formal Name] = dbo.fnGetFormalName(P.Male, P.[Title], P.[Last Name]),
[Full Name] = dbo.fnGetFullName(P.[First Name], P.[Middle Name], P.[Last Name], P.Suffix),
[IsEmployee] = CAST(([Role Mask] & 1) AS bit),
[IsApplicant] = CAST(([Role Mask] & 2) AS bit),
[IsRecruiter] = CAST(([Role Mask] & 4) AS bit),
[IsPhysician] = CAST(([Role Mask] & 8) AS bit),
[IsEmergencyContact] = CAST(([Role Mask] & 16) AS bit),

P.PFlags

FROM dbo.Person P
GO
CREATE UNIQUE CLUSTERED INDEX IX_vwPersonWork_PersonID ON dbo.vwPersonWork(PersonID)
GO
ALTER VIEW dbo.vwCustomField WITH SCHEMABINDING
AS
SELECT FieldID, Field, [Role Mask], [TypeID], CopyItemsFromFieldID, LocationID, [Order], Attributes, 
Textarea=CAST(CASE WHEN (Attributes&1)=1 THEN 1 ELSE 0 END AS bit),LookUpFieldID=ISNULL(CopyItemsFromFieldID, FieldID),PermissionAttributeID
FROM dbo.CustomField
GO
CREATE UNIQUE CLUSTERED INDEX IX_vwCustomField_FieldID ON dbo.vwCustomField(FieldID)
GO
IF OBJECT_ID('dbo.vwEmployeeDelegatedManager') IS NULL EXEC sp_executesql N'CREATE VIEW dbo.vwEmployeeDelegatedManager AS SELECT A=0'
GO
ALTER VIEW dbo.vwEmployeeDelegatedManager
AS
SELECT E.EmployeeID, E.DelegatedManagerID,
[Delegated Manager] = ISNULL(dbo.fnGetListAs(DMPerson.[First Name], DMPerson.[Middle Name], DMPerson.[Last Name], DMPerson.Suffix), ''),
EffectiveManagerID = CASE 
	WHEN Manager.DelegatedManagerID IS NULL OR Manager.DelegatedManagerID=E.EmployeeID THEN E.ManagerID 
	ELSE Manager.DelegatedManagerID 
END,
[Effective Manager] = CASE 
	WHEN Manager.DelegatedManagerID IS NOT NULL AND Manager.DelegatedManagerID<>E.EmployeeID THEN 
	dbo.fnGetListAs(DMPerson.[First Name], DMPerson.[Middle Name], DMPerson.[Last Name], DMPerson.Suffix)
WHEN E.ManagerID IS NOT NULL THEN 
	dbo.fnGetListAs(MPerson.[First Name], MPerson.[Middle Name], MPerson.[Last Name], MPerson.Suffix)
ELSE '' END,
[Effective Manager Work E-mail] = CASE
	WHEN Manager.DelegatedManagerID IS NOT NULL AND Manager.DelegatedManagerID<>E.EmployeeID THEN DMPerson.[Work E-mail]
	WHEN E.ManagerID IS NOT NULL THEN MPerson.[Work E-mail] 
	ELSE ''
END,
E.ManagerID,
[Manager Work E-mail] = CASE WHEN E.ManagerID IS NULL THEN '' ELSE MPerson.[Work E-mail] END
FROM dbo.Employee E
LEFT JOIN dbo.Person MPerson ON E.ManagerID = MPerson.PersonID
LEFT JOIN dbo.Employee Manager ON E.ManagerID = Manager.EmployeeID
LEFT JOIN dbo.Person DMPerson ON Manager.DelegatedManagerID = DMPerson.PersonID
GO
ALTER VIEW dbo.vwEmployeeOrg
AS
SELECT E.EmployeeID, E.ManagerID, E.ShiftID, E.DivisionID, E.DepartmentID, E.[Active Employee], E.LocationID,
E.[Employee Number],
S.Shift,
Manager = ISNULL(M.[List As], ''),
D.Division,
Location = L.[List As],
DPT.Department, 
LastPositionID = C.PositionID,
[Last Position] = ISNULL(P.[Job Title], 'To Be Determined'),
E.[Seniority Begins Day past 1900],
[Seniority Begins] = dbo.GetDateFromDaysPast1900(E.[Seniority Begins Day past 1900]),
LastEmploymentStatusID = C.EmploymentStatusID,
[Employment Status] = ISNULL(EMS.Status, 'To Be Determined'),
[DOH Day past 1900] = ISNULL(
	(SELECT TOP 1 [Start Day past 1900] FROM dbo.EmployeeCompensation EC 
	INNER JOIN  dbo.EmployeeCompensationEventStart FE ON EC.EmployeeID=E.EmployeeID AND EC.StartEventID=FE.EventID AND FE.Flags&1=1 ORDER BY [Start Day past 1900] DESC),
	(SELECT TOP 1 [Start Day past 1900] FROM dbo.EmployeeCompensation EC WHERE EC.EmployeeID=E.EmployeeID ORDER BY [Start Day past 1900])
),
[DOH] = ISNULL(
	(SELECT TOP 1 dbo.GetDateFromDaysPast1900([Start Day past 1900]) FROM dbo.EmployeeCompensation EC 
	INNER JOIN  dbo.EmployeeCompensationEventStart FE ON EC.EmployeeID=E.EmployeeID AND EC.StartEventID=FE.EventID AND FE.Flags&1=1 ORDER BY [Start Day past 1900] DESC),
	(SELECT TOP 1 dbo.GetDateFromDaysPast1900([Start Day past 1900]) FROM dbo.EmployeeCompensation EC WHERE EC.EmployeeID=E.EmployeeID ORDER BY [Start Day past 1900])
),
[Job Category] = ISNULL(JC.[Category],''),
[Manager Employee Number] = ISNULL(M2.[Employee Number], ''),
E.OrgUserField1,
[LeaveKeeperID] = DPT.LeaveKeeperID,
[Leave Keeper E-mail] = ISNULL(LK.[Work E-mail],''),
[Leave Keeper] = CASE WHEN DPT.LeaveKeeperID IS NULL THEN '' ELSE dbo.fnGetListAs(LK.[First Name], LK.[Middle Name], LK.[Last Name], LK.Suffix) END,
[DivisionLeaveKeeperID] = D.LeaveKeeperID,
[Division Leave Keeper E-mail] = ISNULL(DLK.[Work E-mail],''),
[Division Leave Keeper] = CASE WHEN D.LeaveKeeperID IS NULL THEN '' ELSE dbo.fnGetListAs(DLK.[First Name], DLK.[Middle Name], DLK.[Last Name], DLK.Suffix) END,
E.EmployeeNumberNumeric,
E.SyncID

FROM dbo.Employee E
INNER JOIN dbo.Shift S ON E.ShiftID = S.ShiftID
INNER JOIN dbo.Division D ON E.DivisionID = D.DivisionID
INNER JOIN dbo.Location L ON E.LocationID = L.LocationID
INNER JOIN dbo.Department DPT ON E.DepartmentID = DPT.DepartmentID
LEFT JOIN dbo.vwPersonListAs M ON E.ManagerID = M.PersonID
LEFT JOIN dbo.Employee M2 ON E.ManagerID = M2.EmployeeID
LEFT JOIN dbo.EmployeeCompensation C ON E.LastCompensationID = C.CompensationID
LEFT JOIN dbo.EmploymentStatus EMS ON C.EmploymentStatusID = EMS.StatusID
LEFT JOIN dbo.Position P ON C.PositionID = P.PositionID
LEFT JOIN dbo.JobCategory JC ON P.CategoryID=JC.CategoryID
LEFT JOIN dbo.Person LK ON DPT.LeaveKeeperID = LK.PersonID
LEFT JOIN dbo.Person DLK ON D.LeaveKeeperID = DLK.PersonID
GO
ALTER VIEW dbo.vwPosition
AS
SELECT 
P.PositionID, P.[Job Title], P.Active, P.PayGradeID, P.CategoryID, P.StatusID, P.FTE, P.[Workers Comp Code], P.[Note], P.[Other Compensation],
P.[Job Description], P.FLSAID, P.[Seconds Per Week],
[FLSA Exempt] = FLSA.Exempt, [FLSA Status] = FLSA.Status, G.[Pay Grade], C.Category, S.Status, [Pay Grade Order] = G.[Order], G.[Pay Table], G.PayTableID,
[Annualized Pay Range] = dbo.fnGetAnnualizedPayRange(G.[Minimum Hourly Rate], G.[Maximum Hourly Rate], P.[Seconds per Week]), 
C.[Report Row], FTE40 = [Seconds per Week] / 144000.0,
P.[Position Number]
FROM Position P
INNER JOIN dbo.JobCategory C ON P.CategoryID = C.CategoryID
INNER JOIN dbo.PositionStatus S ON P.StatusID= S.StatusID
INNER JOIN dbo.vwPayGrade G ON P.PayGradeID = G.PayGradeID
INNER JOIN dbo.FLSA ON P.FLSAID = FLSA.FLSAID
GO
EXEC dbo.spAdminCreateViewifNonexistent 'vwEmployeeLastCompensation'
GO
ALTER VIEW dbo.vwEmployeeLastCompensation
AS
SELECT E.EmployeeID, EC.CompensationID, 
[Annualized Pay] = ISNULL(
	dbo.fnConvertPay2(EC.[Base Pay], POS.FTE40, EC.[Employee Seconds per Week], P.FTEM, P.FTEB, P.Seconds, 1, 0, 7488000)
, 0),
[Daily Pay] = ISNULL(
	dbo.fnConvertPay2(EC.[Base Pay], POS.FTE40, EC.[Employee Seconds per Week], P.FTEM, P.FTEB, P.Seconds, 0, 1, 28800)
, 0),
[Hourly Pay] = ISNULL(
	dbo.fnConvertPay2(EC.[Base Pay], POS.FTE40, EC.[Employee Seconds per Week], P.FTEM, P.FTEB, P.Seconds, 0, 1, 3600)
, 0),
[Employment Status] = CASE WHEN E.[Terminated Day past 1900] IS NULL THEN ISNULL(ES.Status, 'Unspecified') ELSE 'Terminated' END,
OT40 = CAST(CASE WHEN E.[OT Basis] = 1 THEN 1 ELSE 0 END AS bit),
OT8 = CAST(CASE WHEN E.[OT Basis] = 2 THEN 1 ELSE 0 END AS bit),
TOD = CAST(CASE WHEN E.[OT Basis] = 4 THEN 1 ELSE 0 END AS bit),
[Pay Step] = ISNULL(PS.[Pay Step],''),
EC.PayStepID, POS.PayGradeID, 
[Pay Grade] = ISNULL(PG.[Pay Grade],''),
[Job Title] = ISNULL(POS.[Job Title],''), 
[Position Status] = ISNULL(POSSTAT.[Status], ''),
[Payroll Pay] = ISNULL(dbo.fnMultiplyMoney(EC.[Base Pay], 1.0000 * PayrollPeriod.Seconds / P.Seconds),0),
POS.PositionID,
EC.[Start Day past 1900],
EC.[Stop Day past 1900],
Start = dbo.GetDateFromDaysPast1900(EC.[Start Day past 1900]),
[Stop] = dbo.GetDateFromDaysPast1900(EC.[Stop Day past 1900]),
EC.StartEventID, [Start Event] = ISNULL(SE.Event,''),
EC.StopEventID, [Stop Event] = ISNULL(TE.Event,''),
[FLSA Exempt] = ISNULL(POS.[FLSA Exempt], 0),
E.Salaried,
EightyBiweekly = CAST(CASE WHEN E.[OT Basis] = 128 THEN 1 ELSE 0 END AS bit),
FTE = CASE WHEN EC.[Employee Seconds per Week] IS NULL THEN POS.FTE ELSE POS.FTE * EC.[Employee Seconds per Week] / POS.[Seconds per Week] END
FROM dbo.Employee E
LEFT JOIN dbo.EmployeeCompensation EC ON EC.CompensationID = E.LastCompensationID
LEFT JOIN dbo.EmploymentStatus ES ON EC.EmploymentStatusID = ES.StatusID
LEFT JOIN dbo.PayStep PS ON EC.PayStepID = PS.PayStepID
LEFT JOIN dbo.Period P ON EC.PeriodID = P.PeriodID
LEFT JOIN dbo.vwPosition POS ON EC.PositionID = POS.PositionID
LEFT JOIN dbo.PayGrade PG ON POS.PayGradeID = PG.PayGradeID
LEFT JOIN dbo.PositionStatus POSSTAT ON POS.StatusID = POSSTAT.StatusID
LEFT JOIN dbo.EmployeeCompensationEventStart SE ON EC.StartEventID = SE.EventID
LEFT JOIN dbo.EmployeeCompensationEventStop TE ON EC.StopEventID = TE.EventID
CROSS JOIN 
(dbo.Constant 
	INNER JOIN dbo.LeaveRatePeriod LRP ON dbo.Constant.CurrentPayrollPeriodID=LRP.PeriodID
	INNER JOIN Period PayrollPeriod ON LRP.GroupID=PayrollPeriod.PeriodID
)
GO
EXEC dbo.spAdminCreateViewifNonexistent 'vwEmployeeLastCompensationSecure'
GO
GRANT SELECT ON dbo.vwEmployeeLastCompensationSecure TO public 
GO
ALTER VIEW dbo.vwEmployeeLastCompensationSecure
AS
SELECT E.EmployeeID, EC.CompensationID, 
[Annualized Pay] = ISNULL(
	dbo.fnConvertPay2(EC.[Base Pay], POS.FTE40, EC.[Employee Seconds per Week], P.FTEM, P.FTEB, P.Seconds, 1, 0, 7488000)
, 0),
[Daily Pay] = ISNULL(
	dbo.fnConvertPay2(EC.[Base Pay], POS.FTE40, EC.[Employee Seconds per Week], P.FTEM, P.FTEB, P.Seconds, 0, 1, 28800)
, 0),
[Hourly Pay] = ISNULL(
	dbo.fnConvertPay2(EC.[Base Pay], POS.FTE40, EC.[Employee Seconds per Week], P.FTEM, P.FTEB, P.Seconds, 0, 1, 3600)
, 0),
[Employment Status] = CASE WHEN E.[Terminated Day past 1900] IS NULL THEN ISNULL(ES.Status, 'Unspecified') ELSE 'Terminated' END,
OT40 = CAST(CASE WHEN E.[OT Basis] = 1 THEN 1 ELSE 0 END AS bit),
OT8 = CAST(CASE WHEN E.[OT Basis] = 2 THEN 1 ELSE 0 END AS bit),
TOD = CAST(CASE WHEN E.[OT Basis] = 4 THEN 1 ELSE 0 END AS bit),
[Pay Step] = ISNULL(PS.[Pay Step],''),
EC.PayStepID, POS.PayGradeID, 
[Pay Grade] = ISNULL(PG.[Pay Grade],''),
[Job Title] = ISNULL(POS.[Job Title],''), 
[Position Status] = ISNULL(POSSTAT.[Status], ''),
[Payroll Pay] = ISNULL(dbo.fnMultiplyMoney(EC.[Base Pay], 1.0000 * PayrollPeriod.Seconds / P.Seconds),0),
POS.PositionID,
EC.[Start Day past 1900],
EC.[Stop Day past 1900],
Start = dbo.GetDateFromDaysPast1900(EC.[Start Day past 1900]),
[Stop] = dbo.GetDateFromDaysPast1900(EC.[Stop Day past 1900]),
EC.StartEventID, [Start Event] = ISNULL(SE.Event,''),
EC.StopEventID, [Stop Event] = ISNULL(TE.Event,''),
[FLSA Exempt] = ISNULL(POS.[FLSA Exempt], 0),
E.Salaried,
EightyBiweekly = CAST(CASE WHEN E.[OT Basis] = 128 THEN 1 ELSE 0 END AS bit),
FTE = CASE WHEN EC.[Employee Seconds per Week] IS NULL THEN POS.FTE ELSE POS.FTE * EC.[Employee Seconds per Week] / POS.[Seconds per Week] END
FROM dbo.Employee E
LEFT JOIN dbo.EmployeeCompensation EC ON EC.CompensationID = E.LastCompensationID AND (dbo.fnPermissionGetOnPersonForCurrentUser(E.EmployeeID, 1024) & 1) = 1
LEFT JOIN dbo.EmploymentStatus ES ON EC.EmploymentStatusID = ES.StatusID
LEFT JOIN dbo.PayStep PS ON EC.PayStepID = PS.PayStepID
LEFT JOIN dbo.Period P ON EC.PeriodID = P.PeriodID
LEFT JOIN dbo.vwPosition POS ON EC.PositionID = POS.PositionID
LEFT JOIN dbo.PayGrade PG ON POS.PayGradeID = PG.PayGradeID
LEFT JOIN dbo.PositionStatus POSSTAT ON POS.StatusID = POSSTAT.StatusID
LEFT JOIN dbo.EmployeeCompensationEventStart SE ON EC.StartEventID = SE.EventID
LEFT JOIN dbo.EmployeeCompensationEventStop TE ON EC.StopEventID = TE.EventID
CROSS JOIN 
(dbo.Constant 
	INNER JOIN dbo.LeaveRatePeriod LRP ON dbo.Constant.CurrentPayrollPeriodID=LRP.PeriodID
	INNER JOIN Period PayrollPeriod ON LRP.GroupID=PayrollPeriod.PeriodID
)
GO
EXEC dbo.spAdminCreateViewifNonexistent 'vwEmployeeCompensationAdjustment'
GO
ALTER VIEW dbo.vwEmployeeCompensationAdjustment
AS
SELECT EA.ItemID, EA.AdjustmentID, EA.CompensationID, EA.[Minimum Adjustment], EA.[Maximum Adjustment],
A.Adjustment,
[List As] = dbo.fnGetListAs(P.[First Name], P.[Middle Name], P.[Last Name], P.Suffix),
Initials = dbo.fnGetInitials(P.[First Name], P.[Middle Name], P.[Last Name]),
[Full Name] = dbo.fnGetFullName(P.[First Name], P.[Middle Name], P.[Last Name], P.Suffix), 
C.EmployeeID, C.[Start Day past 1900], C.[Stop Day past 1900], A.PeriodID, Period = ISNULL(Period.Period, ''),
Period.Seconds,
[Annualized Minimum Adjustment] = CASE WHEN A.PeriodID IS NULL THEN 0 ELSE dbo.fnConvertPay2(EA.[Minimum Adjustment], /*FTE40*/ POS.[Seconds per Week] / 144000.0, C.[Employee Seconds per Week], Period.FTEM, Period.FTEB, Period.Seconds, 1, 0, 7488000) END,
[Annualized Maximum Adjustment] = CASE WHEN A.PeriodID IS NULL THEN 0 ELSE dbo.fnConvertPay2(EA.[Maximum Adjustment], /*FTE40*/ POS.[Seconds per Week] / 144000.0, C.[Employee Seconds per Week], Period.FTEM, Period.FTEB, Period.Seconds, 1, 0, 7488000) END
FROM dbo.EmployeeCompensationAdjustment EA
INNER JOIN dbo.EmployeeCompensation C ON EA.CompensationID = C.CompensationID
INNER JOIN dbo.Person P ON C.EmployeeID = P.PersonID
INNER JOIN dbo.CompensationAdjustment A ON EA.AdjustmentID = A.AdjustmentID
INNER JOIN dbo.Position POS ON C.PositionID = POS.PositionID
LEFT JOIN dbo.Period ON A.PeriodID = Period.PeriodID
GO
EXEC dbo.spAdminCreateViewifNonexistent 'vwEmployeeCompensation'
GO
ALTER VIEW dbo.vwEmployeeCompensation
AS
SELECT EC.CompensationID, EC.EmployeeID, EC.PeriodID, EC.EmploymentStatusID, EC.[Start Day past 1900], EC.[Stop Day past 1900], EC.Note, EC.PositionID, EC.[Base Pay],EC.[Other Compensation], EC.Budgeted, EC.PayStepID, EC.StartEventID, EC.StopEventID, 
Employee = dbo.fnGetListAs(PSN.[First Name], PSN.[Middle Name], PSN.[Last Name], PSN.Suffix),
[Employee Full Name] = dbo.fnGetFullName(PSN.[First Name], PSN.[Middle Name], PSN.[Last Name], PSN.Suffix),
[Annualized Pay Range] = dbo.fnGetAnnualizedPayRange2(
	ISNULL((
		SELECT MIN([Hourly Rate]) FROM Pay WHERE Pay.PayGradeID = G.PayGradeID
	), 0),
	ISNULL((
		SELECT MAX([Hourly Rate]) FROM Pay WHERE Pay.PayGradeID = G.PayGradeID
	), 0),
	POS.[Seconds per Week],
	EC.[Employee Seconds per Week]
),
[Annualized Pay] = dbo.fnConvertPay2(EC.[Base Pay], /*FTE40*/ POS.[Seconds per Week] / 144000.0, EC.[Employee Seconds per Week], P.FTEM, P.FTEB, P.Seconds, 1, 0, 7488000),
[Annualized Adjustment Min] = ISNULL((
	SELECT SUM(A.[Annualized Minimum Adjustment]) FROM vwEmployeeCompensationAdjustment A 
), 0),
[Annualized Adjustment Max] = ISNULL((
	SELECT SUM(A.[Annualized Maximum Adjustment]) FROM vwEmployeeCompensationAdjustment A 
), 0),
[Annualized Employer Premiums] = dbo.fnConvertPay2(
	ISNULL((SELECT SUM(EB.[Employer Premium]) FROM EmployeeBenefit EB WHERE EB.EmployeeID = EC.EmployeeID),0),
	POS.[Seconds per Week] / 144000.0, EC.[Employee Seconds per Week], BPeriod.FTEM, BPeriod.FTEB, BPeriod.Seconds, 1, 0, 7488000
),
[Employer Premiums] = ISNULL(
	(SELECT SUM(EB.[Employer Premium]) 
	FROM EmployeeBenefit EB WHERE EB.EmployeeID = EC.EmployeeID
), 0),
[Hourly Pay] = dbo.fnConvertPay2(EC.[Base Pay], /*FTE40*/ POS.[Seconds per Week] / 144000.0, EC.[Employee Seconds per Week], P.FTEM, P.FTEB, P.Seconds, 0, 1, 3600),
[Daily Pay] = dbo.fnConvertPay2(EC.[Base Pay], /*FTE40*/ POS.[Seconds per Week] / 144000.0, EC.[Employee Seconds per Week], P.FTEM, P.FTEB, P.Seconds, 1, 0, 28800),
POS.[Job Title],
[Start] = dbo.GetDateFromDaysPast1900(EC.[Start Day past 1900]), [Stop]=dbo.GetDateFromDaysPast1900(EC.[Stop Day past 1900]),
[FLSA Exempt]=FLSA.Exempt, P.Period,
S.Status,
[Receives Other Compensation] = CAST(CASE WHEN LEN(EC.[Other Compensation]) > 0 THEN 1 ELSE 0 END AS bit),
[Employment Status] = CASE WHEN E.[Terminated Day past 1900] IS NULL THEN ES.Status ELSE 'Terminated' END,
FTE = CASE WHEN EC.[Employee Seconds per Week] IS NULL THEN POS.FTE ELSE POS.FTE * EC.[Employee Seconds per Week] / POS.[Seconds per Week] END,
POS.CategoryID,
C.Category,
[Pay Step] = 1, -- Backward compatibility pre V26
[FLSA Status] = FLSA.[Status],
C.[Report Row],
FTE40 = POS.[Seconds per Week] / 144000.0,
[Seconds per Week] = CASE WHEN EC.[Employee Seconds per Week] IS NULL THEN POS.[Seconds per Week] ELSE EC.[Employee Seconds per Week] END,
[Start Event]=FE.Event,
[Stop Event]=ISNULL(LE.Event,''),
[Start Event Flags]=FE.Flags,
[Stop Event Flags]=ISNULL(LE.Flags,0),
POS.[Position Number],
G.[Pay Grade],
EC.[Employee Seconds per Week],
[Position Seconds per Week] = POS.[Seconds per Week]
FROM dbo.EmployeeCompensation EC
INNER JOIN dbo.Period P ON EC.PeriodID = P.PeriodID
INNER JOIN dbo.Person PSN ON EC.EmployeeID = PSN.PersonID
INNER JOIN dbo.Position POS ON EC.PositionID = POS.PositionID
INNER JOIN dbo.EmploymentStatus ES ON EC.EmploymentStatusID = ES.StatusID
INNER JOIN dbo.Employee E ON EC.EmployeeID = E.EmployeeID
INNER JOIN dbo.FLSA ON POS.FLSAID = FLSA.FLSAID
INNER JOIN dbo.EmployeeCompensationEventStart FE ON EC.StartEventID=FE.EventID
INNER JOIN dbo.JobCategory C ON POS.CategoryID = C.CategoryID
INNER JOIN dbo.PositionStatus S ON POS.StatusID= S.StatusID
INNER JOIN dbo.PayGrade G ON POS.PayGradeID = G.PayGradeID
CROSS JOIN dbo.Constant
INNER JOIN Period BPeriod ON dbo.Constant.BenefitPremiumPeriodID = BPeriod.PeriodID
LEFT JOIN dbo.EmployeeCompensationEventStop LE ON EC.StopEventID=LE.EventID
GO
CREATE VIEW dbo.vwEmployeeBINV WITH SCHEMABINDING AS SELECT EmployeeID, BatchCreateInvoice, [Advance Pay] FROM dbo.Employee E
GO
CREATE UNIQUE CLUSTERED INDEX IX_vwEmployeeBINV_EmployeeID ON vwEmployeeBINV(EmployeeID)
GO
CREATE VIEW dbo.vwEmployeeBPMT WITH SCHEMABINDING AS SELECT EmployeeID, NSF FROM dbo.Employee E
GO
CREATE UNIQUE CLUSTERED INDEX IX_vwEmployeeBPMT_EmployeeID ON vwEmployeeBPMT(EmployeeID)
GO
CREATE VIEW dbo.vwEmployeeBenefit WITH SCHEMABINDING
AS
SELECT
E.EmployeeID,
B.BenefitID,
B.Benefit,
Employee = dbo.fnGetListAs(P.[First Name], P.[Middle Name], P.[Last Name], P.Suffix),
[List As] = dbo.fnGetListAs(P.[First Name], P.[Middle Name], P.[Last Name], P.Suffix),
[Employee Full Name] = dbo.fnGetFullName(P.[First Name], P.[Middle Name], P.[Last Name], P.Suffix),
EB.EmployeeBenefitID, 
Eligible = dbo.GetDateFromDaysPast1900(EB.[Eligible Day past 1900]),
Notified = dbo.GetDateFromDaysPast1900(EB.[Notified Day past 1900]),
Expires = dbo.GetDateFromDaysPast1900(EB.[Expires Day past 1900]),
[First Enrolled] = dbo.GetDateFromDaysPast1900(EB.[First Enrolled Day past 1900]),
[Last Enrolled] = dbo.GetDateFromDaysPast1900(EB.[Last Enrolled Day past 1900]),
[Enrolled Day past 1900] = dbo.fnGetEnrolledDayPast1900(EB.[First Enrolled Day past 1900], EB.[Last Enrolled Day past 1900]),
[Enrolled] = dbo.fnGetEnrolled(EB.[First Enrolled Day past 1900], EB.[Last Enrolled Day past 1900]),
Declined = dbo.GetDateFromDaysPast1900(EB.[Declined Day past 1900]),
EB.[Wait List Queue], 
EB.[Wait List Day past 1900], [Wait List Date] = dbo.GetDateFromDaysPast1900(EB.[Wait List Day past 1900]),
Provider = ISNULL(EB.Provider, ''), [Plan] = ISNULL(EB.[Plan], ''), [Coverage] = ISNULL(EB.[Coverage], ''),
[Individual Policy Number] = ISNULL(EB.[Individual Policy Number], ''), [Group Policy Number] = ISNULL(EB.[Group Policy Number], ''),
[Employee Premium] = ISNULL([Employee Premium], 0), [Employer Premium] = ISNULL([Employer Premium], 0),
EB.[Eligible Day past 1900], EB.[Expires Day past 1900], EB.[Notified Day past 1900], EB.[First Enrolled Day past 1900], EB.[Last Enrolled Day past 1900], EB.[Declined Day past 1900],
Note = ISNULL(EB.Note, ''), 
[Active] = dbo.fnIsBenefitActive(EB.[Declined Day past 1900], EB.[Expires Day past 1900], EB.[First Enrolled Day past 1900], EB.[Last Enrolled Day past 1900]),
[Wait Listed] = CAST(CASE
	WHEN EB.[Wait List Day past 1900] IS NOT NULL OR EB.[Wait List Queue] IS NOT NULL THEN 1
	ELSE 0
END as bit),
[Status Code] = dbo.fnGetEBStatusCode(EB.[Wait List Day past 1900], EB.[Wait List Queue], EB.[Declined Day past 1900], EB.[First Enrolled Day past 1900], EB.[Last Enrolled Day past 1900], EB.[Expires Day past 1900], EB.[Eligible Day past 1900], E.[COBRA Declined Day past 1900], E.[COBRA First Enrolled Day past 1900], E.[COBRA Last Enrolled Day past 1900]),
[COBRA Is Enrolled] = CAST(
	CASE WHEN E.[COBRA Declined Day past 1900] IS NULL AND (E.[COBRA First Enrolled Day past 1900] IS NOT NULL OR E.[COBRA Last Enrolled Day past 1900] IS NOT NULL) THEN 1 ELSE 0 END
	AS bit
),
[Total Premium] = ISNULL([Employee Premium], 0) + ISNULL([Employer Premium], 0),
EB.Volume, EB.[Other Premium]
FROM dbo.EmployeeBenefit EB
INNER JOIN dbo.Employee E ON EB.EmployeeID = E.EmployeeID
INNER JOIN dbo.Person P ON E.EmployeeID = P.PersonID
INNER JOIN dbo.Benefit B ON EB.BenefitID = B.BenefitID
GO
CREATE UNIQUE CLUSTERED INDEX IX_vwEmployeeBenefit_EmployeeBenefitID ON vwEmployeeBenefit(EmployeeID, BenefitID)
CREATE INDEX IX_vwEmployeeBenefit_EmployeeID ON vwEmployeeBenefit(EmployeeID)
CREATE INDEX IX_vwEmployeeBenefit_BenefitID ON vwEmployeeBenefit(BenefitID)
GO
CREATE VIEW dbo.vwEmployeeBenefitSecure AS
SELECT EB.*,
[Home Address] = ISNULL(H.[Home Address],''),
[Home Address (cont.)] = ISNULL(H.[Home Address (cont.)],''),
[Home City] = ISNULL(H.[Home City],''),
[Home State] = ISNULL(H.[Home State],''),
[Home ZIP] = ISNULL(H.[Home ZIP],''),
Dependents = 0, --(SELECT COUNT(*) FROM dbo.EmployeeDependent D WHERE D.EmployeeID=EB.EmployeeID),
X.[DOB Day past 1900],
SSN = ISNULL(X.SSN, ''),
ZIP = ISNULL(H.[Home ZIP],''),
DOB = dbo.GetDateFromDaysPast1900(X.[DOB Day past 1900]),
[Benefit Permission Mask] = dbo.fnPermissionGetOnPersonForCurrentUser(EB.EmployeeID, 536870912),
[Write Permission] = CAST(CASE WHEN (dbo.fnPermissionGetOnPersonForCurrentUser(EB.EmployeeID, 536870912) & 2) = 2 THEN 1 ELSE 0 END AS bit),
Enrollment = dbo.fnGetEnrollment(GETDATE(), EB.[Wait List Day past 1900], EB.[Wait List Queue], EB.[Declined Day past 1900], EB.[First Enrolled Day past 1900], EB.[Last Enrolled Day past 1900], EB.[Expires Day past 1900], EB.[Eligible Day past 1900]),
EnrollmentID = dbo.fnGetEnrollmentID(GETDATE(), EB.[Declined Day past 1900],EB.[Expires Day past 1900],EB.[First Enrolled Day past 1900],EB.[Last Enrolled Day past 1900],EB.[Eligible Day past 1900],EB.[Notified Day past 1900])
FROM dbo.vwEmployeeBenefit EB 
LEFT JOIN dbo.Person H ON EB.EmployeeID=H.PersonID AND (dbo.fnPermissionGetOnPersonForCurrentUser(EB.EmployeeID, 1) & 1) = 1
LEFT JOIN dbo.PersonX X ON EB.EmployeeID=X.PersonID AND (dbo.fnPermissionGetOnPersonForCurrentUser(EB.EmployeeID,4) & 1) = 1
WHERE (dbo.fnPermissionGetOnPersonForCurrentUser(EB.EmployeeID, 536870912) & 1) = 1
GO
GRANT SELECT ON dbo.vwEmployeeBenefitSecure TO public 
GO
CREATE UNIQUE CLUSTERED INDEX IX_vwEmployeeLeaveUsedItem_ItemID ON dbo.vwEmployeeLeaveUsedItem(ItemID)
CREATE INDEX IX_vwEmployeeLeaveUsedItem_EmployeeDay ON dbo.vwEmployeeLeaveUsedItem(EmployeeID, [Day past 1900])
GO
ALTER VIEW dbo.vwEmployeeLeaveEarned
AS
SELECT L.*, Effective = dbo.GetDateFromDaysPast1900(L.[Day past 1900]), Employee = E.[List As], [Employee Full Name] = E.[Full Name],
Calculated = CAST(CASE WHEN [Auto] > 0 THEN 1 ELSE 0 END AS bit),
Accrual = CAST(CASE WHEN [Auto] = 1 THEN 1 ELSE 0 END AS bit),
[Limit Adjustment] = CAST(CASE WHEN [Auto] = 2 THEN 1 ELSE 0 END AS bit),
Carryover = CAST(CASE WHEN [Auto] = 3 THEN 1 ELSE 0 END AS bit),
PPE = dbo.GetDateFromDaysPast1900(L.[PPE Day past 1900])
FROM EmployeeLeaveEarned L
INNER JOIN vwPerson E ON L.EmployeeID = E.PersonID
GO
EXEC dbo.spAdminCreateViewIfNonexistent 'vwTimeType'
GO
ALTER VIEW dbo.vwTimeType
AS
SELECT
TT.TypeID, TT.Type, TT.Abbreviation, TT.[Order], TT.CompLeaveTypeID, 
TT.[Pay Rate], TT.PayRateM, TT.PayRateB, TT.[Billing Rate],
TT.BillingRateM, TT.BillingRateB, TT.[Fixed Pay], TT.[Fixed Billing], TT.Flags,
Regular = CAST((Flags & 1) AS bit),
OT = CAST(CASE WHEN (Flags & 2)=2 THEN 1 ELSE 0 END AS bit),
[OT Eligible] = CAST(CASE WHEN (Flags & 4)=4 THEN 1 ELSE 0 END AS bit),
[OT Disable] = CAST(CASE WHEN (Flags & 8)=8 THEN 1 ELSE 0 END AS bit),
[Comp Leave Type] = ISNULL(LT.Type, ''),
[Holiday] = CAST(CASE WHEN (Flags & 16)=16 THEN 1 ELSE 0 END AS bit),
[Disable Non-Exempt Leave Credit]  = CAST(CASE WHEN (Flags & 32)=32 THEN 1 ELSE 0 END AS bit),
TT.[Comp Rate],
[Paid Time] = CAST(CASE WHEN (Flags & 64)=0 THEN 1 ELSE 0 END AS bit)
FROM TimeType TT
LEFT JOIN LeaveType LT ON TT.CompLeaveTypeID = LT.TypeID
GO
EXEC dbo.spAdminCreateViewIfNonexistent 'vwProject'
GO
ALTER VIEW dbo.vwProject AS 
SELECT 
P.ProjectID, P.Project, P.ProjectManagerID, P.LocationID, P.Active, P.[Pay Rate], P.[Billing Rate], P.Note, P.ClassID, P.[Fixed Pay], P.[Fixed Billing], P.[Number], P.[Order], P.DefaultTimeTypeID,
[Project Manager] = ISNULL(M.[List As], ''), Location = L.[List As], C.Class, [Default Time Type] = ISNULL(TT.Type, ''), P.[Terminal Work Code]
FROM dbo.Project P
INNER JOIN dbo.Location L ON P.LocationID = L.LocationID
INNER JOIN dbo.ProjectClass C ON P.ClassID = C.ClassID
LEFT JOIN dbo.vwPersonListAs M ON P.ProjectManagerID = M.PersonID
LEFT JOIN dbo.TimeType TT ON P.DefaultTimeTypeID = TT.TypeID
GO
ALTER VIEW dbo.vwEmployeeTime
AS
SELECT
ET.ItemID, ET.EmployeeID, ET.[In], ET.Seconds, ET.ProjectID, ET.TaskID, ET.StatusID, ET.[Employee Comment], ET.[Manager Comment],
ET.[Pay Rate], ET.[Billing Rate], ET.TypeID, ET.[Odometer Start], ET.[Odometer Stop], ET.[Created Day past 1900], ET.[Last Updated Day past 1900],
ET.[Fixed Billing], ET.[Fixed Pay], ET.SourceIn, ET.SourceOut, ET.[PPE Day past 1900],
TT.Type, TT.[Order], TT.Abbreviation,
[OT Eligible] = CAST(CASE WHEN (TT.Flags & 4)=4 THEN 1 ELSE 0 END AS bit),
TT.CompLeaveTypeID, --TT.[Order], TT.[Pay Rate], TT.PayRateM, TT.PayRateB, TT.[Billing Rate], TT.BillingRateM, TT.BillingRateB,
[Comp Leave Type] = ISNULL(CLT.Type, ''),
Employee = dbo.fnGetListAs(PERS.[First Name], PERS.[Middle Name], PERS.[Last Name], PERS.Suffix),
S.Status,
Hours = ET.Seconds / 3600.0,
Task = ISNULL(T.Task, ''),
Project = ISNULL(P.Project, ''),
ProjectClassID = P.ClassID,
Mileage = ET.[Odometer Stop] - ET.[Odometer Start],
[Out] = CASE WHEN Seconds = 0 THEN NULL ELSE DATEADD(second, ET.Seconds, ET.[In]) END, 
[In Day past 1900] = DATEDIFF(d, 0, [In]),
[Out Day past 1900] = CASE WHEN ET.Seconds = 0 THEN NULL ELSE DATEDIFF(d, 0, DATEADD(s, ET.Seconds, ET.[In])) END,
[Project Class] = ISNULL(PC.[Class], ''),
Regular = CAST((TT.Flags & 1) AS bit),
[Project Number] = ISNULL(P.[Number], ''),
PPE = dbo.GetDateFromDaysPast1900([PPE Day past 1900]),
OT = CAST(CASE WHEN (TT.Flags & 2)=2 THEN 1 ELSE 0 END AS bit),
TT.Flags,
[OT Disable] = CAST(CASE WHEN (TT.Flags & 8)=8 THEN 1 ELSE 0 END AS bit),
ET.[GMT+Hours],
ET.[Time Flags],
TT.[Comp Rate],
E.[Payroll Delay],
[Last Approved by],
[Last Approved Day past 1900], [Last Approved] = DATEADD(day, 0, ET.[Last Approved Day past 1900]),
[Last Submitted by],
[Last Submitted Day past 1900], [Last Submitted] = DATEADD(day, 0, ET.[Last Submitted Day past 1900])
FROM dbo.EmployeeTime ET
INNER JOIN dbo.Person PERS ON ET.EmployeeID = PERS.PersonID
INNER JOIN dbo.EmployeeTimeStatus S ON ET.StatusID = S.StatusID
INNER JOIN dbo.TimeType TT ON ET.TypeID = TT.TypeID
INNER JOIN dbo.Employee E ON ET.EmployeeID = E.EmployeeID
LEFT JOIN dbo.Project P ON ET.ProjectID = P.ProjectID
LEFT JOIN dbo.ProjectTask T ON ET.TaskID = T.TaskID
LEFT JOIN dbo.LeaveType LT ON TT.CompLeaveTypeID = LT.TypeID
LEFT JOIN dbo.LeaveType CLT ON TT.CompLeaveTypeID = CLT.TypeID
LEFT JOIN dbo.ProjectClass PC ON P.ClassID = PC.ClassID
GO
IF OBJECT_id('dbo.vwEmployeeTimeApproved') IS NOT NULL DROP VIEW dbo.vwEmployeeTimeApproved
GO
CREATE VIEW dbo.vwEmployeeTimeApproved
AS
SELECT * FROM vwEmployeeTime WHERE (StatusID & 1) = 1
GO
ALTER VIEW dbo.vwPersonX
AS
SELECT 
P.PersonID, P. RaceID, P. I9StatusID, P. SSN, P. [Renew I9 Status Day past 1900], P. [Country of Citizenship], P. Visa, P. [Visa Expires Day past 1900], P.VisaStatusID, [Visa Status] = ISNULL(VS.[Status],''), P. Passport, P. [Passport Expires Day past 1900], P. [DOB Day past 1900], P. [Driver License], P. [Driver License State], P.
[Driver License Expires Day past 1900], P. [Driver Insurance Expires Day past 1900], P. MilitaryBranchID, P. Reserves, P. [Commercial Driver License], P. MaritalStatusID, P. Dependents, P. Disabled, P. Smoker, P. Spouse, P. Children,
R.Race, [I9 Status] = I.Status,
[Marital Status] = S.Status,
DOB = dbo.GetDateFromDaysPast1900([DOB Day past 1900]),
[Driver License Expires] = dbo.GetDateFromDaysPast1900([Driver License Expires Day past 1900]),
[Driver Insurance Expires] = dbo.GetDateFromDaysPast1900([Driver Insurance Expires Day past 1900]),
[Renew I9 Status] = dbo.GetDateFromDaysPast1900([Renew I9 Status Day past 1900]),
[Visa Expires] = dbo.GetDateFromDaysPast1900([Visa Expires Day past 1900]),
[Passport Expires] = dbo.GetDateFromDaysPast1900([Passport Expires Day past 1900]),
[Military Service] = CASE WHEN P.MilitaryBranchID IS NULL THEN '' ELSE
	B.Branch + CASE WHEN P.[Reserves] = 1 AND B.[Reserves Apply] = 1 THEN ' Reserves' ELSE '' END
END,
[Birth Day past 1900] = dbo.GetBirthdayFromDOB([DOB Day past 1900], GETDATE()),
P.[Driver License Class]
FROM dbo.PersonX P
INNER JOIN dbo.MaritalStatus S ON  P.MaritalStatusID = S.StatusID
INNER JOIN dbo.Race R ON P.RaceID = R.RaceID
INNER JOIN dbo.I9Status I ON P.I9StatusID = I.StatusID
LEFT JOIN dbo.MilitaryBranch B ON P.MilitaryBranchID = B.BranchID
LEFT JOIN dbo.VisaStatus VS ON P.VisaStatusID = VS.StatusID
GO
IF OBJECT_ID('dbo.vwReportTemplate3noImage') IS NOT NULL DROP VIEW dbo.vwReportTemplate3noImage
IF OBJECT_ID('dbo.vwReportTemplate3All') IS NOT NULL DROP VIEW dbo.vwReportTemplate3All
GO
CREATE VIEW dbo.vwReportTemplate3noImage AS
SELECT T.Template, T.TemplateID, T.BasisID, T.Flags, T.Tag, T.ParentMenuID FROM ReportTemplate3 T
GO
CREATE VIEW dbo.vwReportTemplate3All AS
SELECT T.Template, T.TemplateID, T.BasisID, T.Flags, T.Tag, T.ParentMenuID, T.[Fields Stream] FROM ReportTemplate3 T
GO
-- Used by internal stored procedures to compare custom field values against a criterion
CREATE VIEW dbo.vwPersonCustomField2 WITH SCHEMABINDING AS
SELECT C.FieldID, C.Field, C.[Role Mask], C.TypeID, C.CopyItemsFromFieldID, C.LocationID, C.[Order], C.Attributes,
P.PersonID, P.ItemID, P.[Value]
FROM dbo.PersonCustomField P
INNER JOIN dbo.CustomField C ON P.FieldID=C.FieldID
GO
CREATE UNIQUE CLUSTERED INDEX IX_vwPersonCustomField2_PersonIDFieldID ON dbo.vwPersonCustomField2(PersonID,FieldID)
GO

CREATE VIEW dbo.vwEmployeeReview WITH SCHEMABINDING AS
SELECT 
EmployeeID,
[Next Performance Review Day past 1900], 
[Next Performance Review] = dbo.GetDateFromDaysPast1900([Next Performance Review Day past 1900]),
[Last Performance Review Day past 1900],
[Last Performance Review] = dbo.GetDateFromDaysPast1900([Last Performance Review Day past 1900]),
LastEmployeeReviewID,
[Seniority Begins]=dbo.GetDateFromDaysPast1900([Seniority Begins Day past 1900])
FROM dbo.Employee
GO
CREATE UNIQUE CLUSTERED INDEX IX_vwEmployeeReview_EmployeeID ON dbo.vwEmployeeReview(EmployeeID)
GO
ALTER VIEW dbo.vwEmployeeAccount AS SELECT EmployeeID, [Account] = SUBSTRING(ISNULL(SUSER_SNAME(SID), ''), 1, 50), SID FROM Employee
GO
ALTER VIEW dbo.vwEmployeeReview2
AS
SELECT E.ReviewID, E.Comment, E.EmployeeID, [Day past 1900] = dbo.GetDateFromDaysPast1900(E.[Day past 1900]), E.TypeID, E.RatingID, E.ReviewedByEmployeeID,E.[Changed Salary], [Employee Name] = V.[List As], T.Type, R.Rating, [Reviewed By] = ISNULL(RV.[List As],''), 
[Reviewed by Initials] = ISNULL(RV.[Initials],'')
FROM EmployeeReview E
INNER JOIN vwPersonCalculated V ON E.EmployeeID = V.PersonID
INNER JOIN EmployeeReviewType T ON E.TypeID = T.TypeID
INNER JOIN EmployeeReviewRating R ON E.RatingID = R.RatingID
LEFT JOIN vwPersonCalculated RV ON E.ReviewedByEmployeeID = RV.PersonID
GO
IF OBJECT_id('dbo.vwInvoiceTemplate') IS NOT NULL DROP VIEW dbo.vwInvoiceTemplate
IF OBJECT_id('dbo.vwPaymentType') IS NOT NULL DROP VIEW dbo.vwPaymentType
IF OBJECT_id('dbo.vwInvoiceCredit') IS NOT NULL DROP VIEW dbo.vwInvoiceCredit
IF OBJECT_id('dbo.vwPaymentDetail') IS NOT NULL DROP VIEW dbo.vwPaymentDetail
GO
CREATE VIEW dbo.vwPaymentDetail AS SELECT * FROM PaymentDetail
GO
CREATE VIEW dbo.vwPayment WITH SCHEMABINDING AS
SELECT P.PaymentID, P.EmployeeID, P.TypeID, P.[Transaction Number], P.Total, P.[Received Day past 1900], P.[Created Day past 1900], P.[Last Updated Day past 1900], P.[Last Updated By], P.Split, P.Refund, P.Applied, P.Unapplied, P.Invoices, P.[Created By],
Unrefunded = P.Total - P.Refund,
T.[Type],
[Received]=dbo.GetDateFromDaysPast1900(P.[Received Day past 1900]),
[Created]=dbo.GetDateFromDaysPast1900(P.[Created Day past 1900]),
[Last Updated]=dbo.GetDateFromDaysPast1900(P.[Last Updated Day past 1900]),
[Status] = CAST(CASE
	WHEN P.Total=P.Applied THEN 'Fully Applied' 
	WHEN P.Total=P.Refund THEN 'Fully Refunded'
	WHEN P.Unapplied=0 THEN 'Fully Applied & Refunded'
	WHEN P.Applied > 0 AND P.Refund > 0 THEN 'Paritally Applied & Refunded'
	WHEN P.Applied > 0 THEN 'Partialy Applied'
	WHEN P.Refund > 0 THEN 'Unapplied & Partially Refunded'
	ELSE 'Unapplied'
END AS varchar(50)),
Employee = dbo.fnGetListAs(E.[First Name], E.[Middle Name], E.[Last Name], E.Suffix),
[Employee Full Name] = dbo.fnGetFullName(E.[First Name], E.[Middle Name], E.[Last Name], E.Suffix),
EMP.NSF
FROM dbo.Payment P
INNER JOIN dbo.PaymentType T ON P.TypeID = T.TypeID
INNER JOIN dbo.Person E ON P.EmployeeID = E.PersonID
INNER JOIN dbo.Employee EMP ON P.EmployeeID = EMP.EmployeeID
GO
CREATE UNIQUE CLUSTERED INDEX IX_vwPayment_PaymentID ON dbo.vwPayment(PaymentID)
CREATE INDEX IX_vwPayment_EmployeeID ON dbo.vwPayment(EmployeeID)
CREATE INDEX IX_vwPayment_Received ON dbo.vwPayment([Received Day past 1900])
GO
CREATE VIEW dbo.vwPaymentType AS SELECT * FROM PaymentType
GO
CREATE VIEW dbo.vwInvoiceTemplate AS SELECT * FROM InvoiceTemplate
GO
CREATE VIEW dbo.vwInvoiceCredit AS SELECT *, [Date] = dbo.GetDateFromDaysPast1900([Day past 1900]) FROM InvoiceCredit
GO
CREATE VIEW dbo.vwInvoice WITH SCHEMABINDING AS
SELECT TI.TemplateID, TI.Template, TI.[Note], TI.[Sender Text], TI.[Remit Text],
I.InvoiceID, I.[Payment Transactions], I.EmployeeID, I.[Credit],  I.Payment, I.Total, I.[Due Day past 1900], I.[Created Day past 1900], I.[Created By], I.[Last Updated Day past 1900], I.[Last Updated By], 
[Employee Full Name] = dbo.fnGetFullName(P.[First Name], P.[Middle Name], P.[Last Name], P.Suffix),
Employee = dbo.fnGetListAs(P.[First Name], P.[Middle Name], P.[Last Name], P.Suffix),
I.Balance,
Created = dbo.GetDateFromDaysPast1900(I.[Created Day past 1900]),
[Last Updated] = dbo.GetDateFromDaysPast1900(I.[Last Updated Day past 1900]),
Due = dbo.GetDateFromDaysPast1900([Due Day past 1900])
FROM dbo.Invoice I
INNER JOIN dbo.InvoiceTemplate TI ON I.TemplateID = TI.TemplateID
INNER JOIN dbo.Person P ON I.EmployeeID = P.PersonID
GO
CREATE UNIQUE CLUSTERED INDEX IX_vwInvoice_InvoiceID ON dbo.vwInvoice(InvoiceID)
CREATE INDEX IX_vwInvoice_EmployeeID ON dbo.vwInvoice(EmployeeID)
CREATE INDEX IX_vwInvoice_Due ON dbo.vwInvoice(Due)
CREATE INDEX IX_vwInvoice_Created ON dbo.vwInvoice(Created)
GO
CREATE VIEW dbo.vwPaymentRefund WITH SCHEMABINDING AS SELECT R.RefundID, R.PaymentID, R.Amount, R.Comment, R.[Day past 1900], [Date] = dbo.GetDateFromDaysPast1900(R.[Day past 1900]) FROM dbo.PaymentRefund R
GO
CREATE UNIQUE CLUSTERED INDEX IX_vwPaymentRefund_RefundID ON dbo.vwPaymentRefund(RefundID)
CREATE INDEX IX_vwPaymentRefund_PaymentID ON dbo.vwPaymentRefund(PaymentID)
GO
ALTER VIEW dbo.vwNote
AS
SELECT N.NoteID,N.InvoiceID,N.PaymentID,N.PersonID,N.ClassID,N.Subject,N.Note,N.[Created Day past 1900],N.[Created By],N.[Last Updated Day past 1900],N.[Last Updated By], 
[Class] = ISNULL(C.[Class], ''), [Day past 1900] = DATEADD(d, 0, N.[Day past 1900]), [Day] = N.[Day past 1900],
[Created] = DATEADD(d, 0,N. [Created Day past 1900]),
[Last Updated] = DATEADD(d, 0, N.[Last Updated Day past 1900]),
RegardingPersonID = CASE
	WHEN N.PersonID IS NOT NULL THEN N.PersonID
 	WHEN I.EmployeeID IS NOT NULL THEN I.EmployeeID
	-- WHEN PP.PersonID IS NOT NULL THEN PP.PersonID
	ELSE NULL
END,
[Regarding Person] = CASE
	WHEN N.PersonID IS NOT NULL THEN V.[List As]
	WHEN I.EmployeeID IS NOT NULL THEN IPP.[List As]
	-- WHEN PP.PersonID IS NOT NULL THEN PPP.[List As]
	ELSE CAST('' AS varchar(400))
END,
Regarding = CASE
	WHEN N.PersonID IS NOT NULL THEN V.[List As]
	WHEN N.InvoiceID IS NOT NULL THEN CAST(N.InvoiceID AS varchar(400))
	WHEN N.PaymentID IS NOT NULL THEN CAST(P.[Transaction Number] AS varchar(400))
END,
CommunicationID=NoteID, EmployeeID=N.PersonID, Employee=V.[List As], [Employee Full Name]=V.[List As], PayerID=0 -- Legacy

FROM Note N
LEFT JOIN NoteClass C ON N.ClassID = C.ClassID
LEFT JOIN dbo.vwPersonListAs V ON N.PersonID = V.PersonID
LEFT JOIN Payment P ON P.PaymentID = N.PaymentID
-- LEFT JOIN dbo.vwPersonListAs PPP ON PP.PersonID = PPP.PersonID
LEFT JOIN Invoice I ON I.InvoiceID = N.InvoiceID
LEFT JOIN dbo.vwPersonListAs IPP ON I.EmployeeID = IPP.PersonID
GO
IF OBJECT_id('dbo.vwTaskEmail') IS NOT NULL DROP VIEW dbo.vwTaskEmail
GO
CREATE VIEW dbo.vwTaskEmail AS SELECT * FROM dbo.TaskEmail
GO
IF OBJECT_id('dbo.vwEmployeeLeaveUsedItemNotDenied') IS NOT NULL DROP VIEW dbo.vwEmployeeLeaveUsedItemNotDenied
GO
CREATE VIEW dbo.vwEmployeeLeaveUsedItemNotDenied
AS
SELECT I.[Day past 1900], I.Seconds, I.[Date], I.[Extended Type Mask], I.TypeID, I.EmployeeID, I.[Calendar Comment] FROM dbo.vwEmployeeLeaveUsedItem I WHERE I.Status = 2 OR I.Status = 1
UNION ALL
SELECT E.[Day past 1900], -E.Seconds, DATEADD(d, 0, E.[Day past 1900]), E.TypeID, E.TypeID, E.EmployeeID, '' FROM EmployeeLeaveEarned E WHERE E.Seconds < 0 AND E.Auto = 0
GO
IF OBJECT_id('dbo.vwEmployeeLeaveApprovedLOA') IS NOT NULL DROP VIEW dbo.vwEmployeeLeaveApprovedLOA
GO
CREATE VIEW dbo.vwEmployeeLeaveApprovedLOA
AS
SELECT I.[Day past 1900], I.Seconds,
I.[Date], I.[Extended Type Mask], I.TypeID, I.EmployeeID, 
T.[Type], T.Abbreviation, T.Paid, T.[Order], T.Bank, T.[OT Eligible]
FROM dbo.vwEmployeeLeaveUsedItem I
INNER JOIN dbo.LeaveType T ON I.Status = 2 AND I.TypeID = T.TypeID
GO
IF OBJECT_id('dbo.vwEmployeeCheckListNewHire') IS NOT NULL DROP VIEW dbo.vwEmployeeCheckListNewHire
GO
CREATE VIEW dbo.vwEmployeeCheckListNewHire AS
SELECT 
EC.ItemID, EC.[Completed Day past 1900],
E.EmployeeID,
C.*,
[Employee Name] = P.[List As],
Completed=dbo.GetDateFromDaysPast1900(EC.[Completed Day past 1900]),
[Was Completed] = CAST(CASE WHEN EC.[Completed Day past 1900] IS NULL THEN 0 ELSE 1 END AS bit)
FROM CheckListNewHire C
CROSS JOIN Employee E
LEFT JOIN EmployeeCheckListNewHire EC ON EC.EmployeeID=E.EmployeeID AND EC.CheckID=C.CheckID
INNER JOIN dbo.vwPersonListAs P ON P.PersonID=E.EmployeeID
GO
IF OBJECT_id('dbo.vwEmployeeLeavePlanLeaveRate') IS NULL EXEC sp_executesql N'CREATE VIEW dbo.vwEmployeeLeavePlanLeaveRate AS SELECT A=0'
IF OBJECT_id('dbo.vwEmployeeLeavePlanLeaveRateCurrent') IS NULL EXEC sp_executesql N'CREATE VIEW dbo.vwEmployeeLeavePlanLeaveRateCurrent AS SELECT A=0'
GO
ALTER VIEW dbo.vwEmployeeLeavePlanLeaveRate
AS
SELECT [Effective Seconds] = CAST(CAST(R.Seconds AS numeric(13,4)) * CASE WHEN R.Flags & 8 = 8 OR R.PeriodID & 2047 = 512 THEN 1 ELSE E.[Leave Accrual Multiplier] * EP.FTE END AS int), 
EP.EmployeeID, 
R.[Start Month], 
R.[Stop Month], 
R.PeriodID,
EP.[Start Day past 1900],
EP.[Stop Day past 1900],
R.TypeID,
E.[Seniority Begins Day past 1900],
P.[Plan],
[Seniority Begins] = DATEADD(d,0,E.[Seniority Begins Day past 1900]),
[Seconds in Period] = CASE WHEN LRP.PeriodID = 279040 THEN Period.Seconds * 1000 ELSE Period.Seconds END,
[Group] = Period.Period,
[Max Seconds] = 
CASE WHEN L.[Max Seconds] IS NOT NULL AND L.[Max Seconds] < R.[Limit Max Seconds] THEN L.[Max Seconds]
WHEN R.[Limit Max Seconds] < 2147483647 THEN R.[Limit Max Seconds]
WHEN L.[Max Seconds] IS NULL THEN 0
ELSE L.[Max Seconds]
END,
LimitPeriodID = L.PeriodID,
[Limit Month] = L.[Month],
[Limit Day] = L.[Day],
R.[Ineligible Months],
R.Flags,
EP.FTE,
P.[Prorate Accrual Rounding Seconds],
R.ExcludeMonthMask
FROM dbo.EmployeeLeavePlan EP
INNER JOIN dbo.Employee E ON EP.EmployeeID = E.EmployeeID
INNER JOIN dbo.LeaveRate R ON  R.PlanID = EP.PlanID
INNER JOIN dbo.LeavePlan P ON R.PlanID = P.PlanID
INNER JOIN dbo.LeaveRatePeriod LRP ON R.PeriodID = LRP.PeriodID
INNER JOIN dbo.Period ON Period.PeriodID = LRP.GroupID
LEFT JOIN dbo.LeaveLimit L ON R.PlanID = L.PlanID AND R.TypeID = L.TypeID
GO
ALTER VIEW dbo.vwEmployeeLeavePlanLeaveRateCurrent
AS
SELECT * FROM dbo.vwEmployeeLeavePlanLeaveRate WHERE DATEDIFF(mm, [Seniority Begins Day past 1900], GETDATE()) BETWEEN [Start Month] AND [Stop Month]
GO
ALTER PROCEDURE dbo.spShiftGetSecondsFromEmployeeID
	@employee_id int,
	@seconds int OUT
AS
SELECT @seconds = [Effective Seconds per Day] FROM vwEmployeeEffectiveSecondsPerDay WHERE EmployeeID = @employee_id
GO
CREATE VIEW dbo.vwEmployeeSuccessorNames WITH SCHEMABINDING AS
SELECT E.EmployeeID, E.[Successor Names], E.[Successor Initials] FROM dbo.Employee E
GO
CREATE UNIQUE CLUSTERED INDEX IX_vwEmployeeSuccessorNames_EmployeeID ON dbo.vwEmployeeSuccessorNames(EmployeeID)
GO
CREATE VIEW dbo.vwEmployeeSucceedsNames WITH SCHEMABINDING AS
SELECT E.EmployeeID, E.[Succeeds Names], E.[Succeeds Initials] FROM dbo.Employee E
GO
CREATE UNIQUE CLUSTERED INDEX IX_vwEmployeeSucceedsNames_EmployeeID ON dbo.vwEmployeeSucceedsNames(EmployeeID)
GO
EXEC dbo.spAdminCreateViewifNonexistent 'vwEmployeeProject'
GO
ALTER VIEW dbo.vwEmployeeProject
AS
SELECT 
EP.ItemID,EP.EmployeeID,EP.ProjectID,EP.[Billing Rate],EP.[Pay Rate],
EP.[Start Day past 1900],EP.[Stop Day past 1900],EP.[Percent of Time Allocated],
EP.Comment,EP.[Fixed Pay],EP.[Fixed Billing],EP.Flags, 
Employee = V.[List As], P.Project, P.ProjectManagerID, P.Active,
Start = dbo.GetDateFromDaysPast1900(EP.[Start Day past 1900]),
[Stop] = dbo.GetDateFromDaysPast1900(EP.[Stop Day past 1900]),
[Inherited Billing Rate] = CAST(CASE 
	WHEN EP.[Billing Rate] IS NOT NULL THEN EP.[Billing Rate]
	WHEN P.[Billing Rate] IS NOT NULL THEN P.[Billing Rate]
	WHEN E.[Billing Rate] IS NOT NULL THEN E.[Billing Rate]
	ELSE 0
END AS smallmoney),
[Inherited Fixed Billing] = CAST(CASE
	WHEN EP.[Fixed Billing] IS NOT NULL THEN EP.[Fixed Billing]
	WHEN P.[Fixed Billing] IS NOT NULL THEN P.[Fixed Billing]
	ELSE 0
END AS smallmoney),
[Inherited Pay Rate] = CAST(CASE
	WHEN EP.[Pay Rate] IS NOT NULL THEN EP.[Pay Rate]
	WHEN P.[Pay Rate] IS NOT NULL THEN P.[Pay Rate]
	WHEN EC.[Base Pay] IS NOT NULL THEN dbo.fnConvertPay2(EC.[Base Pay], POS.[Seconds per Week] / 144000.0, EC.[Employee Seconds per Week], Period.FTEM, Period.FTEB, Period.Seconds, 0, 1, 3600)
	ELSE 0
END AS smallmoney),
[Inherited Fixed Pay] = CAST(CASE
	WHEN EP.[Fixed Pay] IS NOT NULL THEN EP.[Fixed Pay]
	WHEN P.[Fixed Pay] IS NOT NULL THEN P.[Fixed Pay]
	ELSE 0
END AS smallmoney),
IsDefined = CAST(CASE WHEN EP.[Billing Rate] IS NOT NULL OR
P.[Billing Rate] IS NOT NULL OR
E.[Billing Rate] IS NOT NULL OR
EP.[Fixed Billing] IS NOT NULL OR
P.[Fixed Billing] IS NOT NULL OR
EP.[Pay Rate] IS NOT NULL OR
P.[Pay Rate] IS NOT NULL OR
EP.[Fixed Pay] IS NOT NULL OR
EC.[Base Pay] IS NOT NULL OR
P.[Fixed Pay] IS NOT NULL THEN 1 ELSE 0 END AS bit)
FROM dbo.EmployeeProject EP
INNER JOIN dbo.Project P ON EP.ProjectID = P.ProjectID
INNER JOIN dbo.Employee E ON EP.EmployeeID = E.EmployeeID
INNER JOIN dbo.vwPersonListAs V ON E.EmployeeID = V.PersonID
LEFT JOIN dbo.EmployeeCompensation EC ON E.LastCompensationID = EC.CompensationID
INNER JOIN dbo.Period ON EC.PeriodID = Period.PeriodID
INNER JOIN dbo.Position POS ON EC.PositionID = POS.PositionID
GO

/* VIEW CHANGES END *************************************************************************/


/* STORED PROCS REQUIRED BY TRIGGERS BEGIN ***************************************************/
IF OBJECT_id('dbo.spHolidayRecalc') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spHolidayRecalc AS'
GO
ALTER PROC dbo.spHolidayRecalc
	@force_recalc bit = 1,
	@y int = NULL,
	@start_date datetime = NULL,
	@stop_date datetime = NULL,
	@start_y int = NULL,
	@stop_y int = NULL,
	@start_day int = NULL
AS
-- Holiday and HolidayCalculated will always match regardless of year if there are no recurring holidays
IF @force_recalc = 0 AND NOT EXISTS(SELECT * FROM dbo.Holiday WHERE [Year] IS NULL) AND EXISTS(SELECT * FROM dbo.HolidayCalculated) RETURN

IF @y IS NOT NULL SELECT @start_y = @y, @stop_y = @y
IF @start_y IS NULL SELECT @start_y = YEAR(GETDATE())
IF @stop_y IS NULL SELECT @stop_y = YEAR(GETDATE())
IF @start_day IS NOT NULL SET @start_date = dbo.GetDateFromDaysPast1900(@start_day)
IF @start_date IS NOT NULL SET @start_y = YEAR(@start_date)
IF @stop_date IS NOT NULL SET @stop_y = YEAR(@stop_date)
SELECT @start_y = @start_y - 2, @stop_y = @stop_y + 2
IF @start_y < 1900 SET @start_y = 1900
IF @stop_y > 9999 SET @stop_y = 9999

IF @stop_y < YEAR(GETDATE()) + 5 AND EXISTS(SELECT * FROM dbo.HolidayCalculated WHERE YR >= YEAR(GETDATE()) + 5) DELETE dbo.HolidayCalculated WHERE YR >= YEAR(GETDATE()) + 5 
IF @stop_y > YEAR(GETDATE()) - 5 AND EXISTS(SELECT * FROM dbo.HolidayCalculated WHERE YR <= YEAR(GETDATE()) - 5) DELETE dbo.HolidayCalculated WHERE YR <= YEAR(GETDATE()) - 5 

CREATE TABLE #Y(Y int)
CREATE UNIQUE INDEX Y_TempY ON #Y(Y) WITH IGNORE_DUP_KEY

DECLARE @recalc bit
SET @recalc = @force_recalc

IF @force_recalc = 1
BEGIN
	INSERT #Y 
	SELECT DISTINCT [Year] FROM dbo.Holiday WHERE [Year] IS NOT NULL
	UNION
	SELECT DISTINCT [Year] - 1 FROM dbo.Holiday WHERE [Year] IS NOT NULL
	UNION
	SELECT DISTINCT [Year] + 1 FROM dbo.Holiday WHERE [Year] IS NOT NULL
END

SET @y = @start_y
WHILE @y <= @stop_y
BEGIN
	IF @force_recalc = 1 OR NOT EXISTS(SELECT * FROM dbo.HolidayCalculated WHERE YR = @y)
	BEGIN
		INSERT #Y SELECT @y
		SET @recalc = 1
	END
	SELECT @y = @y + 1
END

IF @recalc = 1
BEGIN
	IF @force_recalc = 1
	INSERT #Y 
	SELECT DISTINCT [Year] FROM dbo.Holiday WHERE [Year] IS NOT NULL
	UNION
	SELECT DISTINCT [Year] - 1 FROM dbo.Holiday WHERE [Year] IS NOT NULL
	UNION
	SELECT DISTINCT [Year] + 1 FROM dbo.Holiday WHERE [Year] IS NOT NULL
	
	BEGIN TRAN
	
	-- Recalc non recurring holidays if force_recalc = 1
	IF @force_recalc = 1
	BEGIN
		DELETE dbo.HolidayCalculated
	
		INSERT dbo.HolidayCalculated (HolidayID,Holiday,PlanID,X,Y,A,B,YR,[Week])
		SELECT HolidayID, Holiday, PlanID,
		dbo.GetDateFromMDY([Month], [Day], [Year]),
		DATEADD(d,[Length]-1,dbo.GetDateFromMDY([Month], [Day], [Year])),
		DATEDIFF(d,0,dbo.GetDateFromMDY([Month], [Day], [Year])),
		DATEDIFF(d,0,dbo.GetDateFromMDY([Month], [Day], [Year])) + [Length] - 1,
		NULL, 0 FROM dbo.Holiday WHERE [Year] IS NOT NULL
		
		UPDATE H SET [Week] = 1 FROM dbo.HolidayCalculated H WHERE DATEPART(dw,H.X) <= 2 AND DATEPART(dw,H.Y) >= 6
	END
	
	-- Recalcs recurring holidays
	INSERT dbo.HolidayCalculated (HolidayID,Holiday,PlanID,X,Y,A,B,YR,[Week])
	SELECT HolidayID, Holiday, PlanID,
	dbo.GetDateFromMDY(H.[Month], H.[Day], #Y.Y),
	DATEADD(d,[Length]-1,dbo.GetDateFromMDY(H.[Month], H.[Day], #Y.Y)),
	DATEDIFF(d,0,dbo.GetDateFromMDY([Month], [Day], #Y.Y)),
	DATEDIFF(d,0,dbo.GetDateFromMDY([Month], [Day], #Y.Y)) + [Length] - 1,
	#Y.Y, 0 FROM dbo.Holiday H CROSS JOIN #Y WHERE H.[Year] IS NULL
	
	UPDATE H SET [Week] = 1
	FROM dbo.HolidayCalculated H INNER JOIN #Y ON H.YR = #Y.Y AND DATEPART(dw,H.X) <= 2 AND DATEPART(dw,H.Y) >= 6
	
	COMMIT TRAN
END
GO
IF OBJECT_id('dbo.spAuditLogPurge') IS NOT NULL DROP PROC dbo.spAuditLogPurge
GO
CREATE PROC dbo.spAuditLogPurge
AS
DECLARE @days int, @last int

SELECT @days = [Audit Purge Days], @last = [Audit Trail Last Purged Day past 1900] FROM dbo.Constant

IF DATEDIFF(d,0,GETDATE()) - @last > 30
BEGIN
	DELETE dbo.AuditTrail WHERE DATEDIFF(d,Created,GETDATE()) > @days
	UPDATE dbo.Constant SET [Audit Trail Last Purged Day past 1900] = DATEDIFF(d,0,GETDATE())
END
GO
IF NOT EXISTS(SELECT * FROM dbo.AuditSetting WHERE ObjectID=536870912) 
INSERT AuditSetting(ObjectID,[Object],[Possible Event Mask], [Audit Event Mask]) 
VALUES(536870912, 'Benefits', 2, 0)
GO
IF NOT EXISTS(SELECT * FROM AuditSetting WHERE ObjectID=262144)
INSERT AuditSetting(ObjectID, [Object], [Possible Event Mask], [Audit Event Mask])
SELECT 262144, 'Timecards', 14, 0

IF NOT EXISTS(SELECT * FROM AuditSetting WHERE ObjectID=1)
INSERT AuditSetting(ObjectID, [Object], [Possible Event Mask], [Audit Event Mask])
SELECT 0, 'Person', 12, 0

IF NOT EXISTS(SELECT * FROM AuditSetting WHERE ObjectID=1)
INSERT AuditSetting(ObjectID, [Object], [Possible Event Mask], [Audit Event Mask])
SELECT 1, 'Person, Home Contact', 2, 0

IF NOT EXISTS(SELECT * FROM AuditSetting WHERE ObjectID=2)
INSERT AuditSetting(ObjectID, [Object], [Possible Event Mask], [Audit Event Mask])
SELECT 2, 'Person, Name and Work Contact', 2, 0

IF NOT EXISTS(SELECT * FROM AuditSetting WHERE ObjectID=4)
INSERT AuditSetting(ObjectID, [Object], [Possible Event Mask], [Audit Event Mask])
SELECT 4, 'Person, Personal Info', 2, 0

IF EXISTS(SELECT * FROM AuditSetting WHERE ObjectID=10002)
BEGIN
	UPDATE AuditSetting SET [Object]='Leave', [Possible Event Mask]=14,[Audit Event Mask]=14
	WHERE ObjectID=10001

	DELETE AuditSetting WHERE ObjectID IN (10002, 10003)
END
GO
IF OBJECT_id('dbo.spEmployeeUpdateInOutStatus') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spEmployeeUpdateInOutStatus AS'
GO
ALTER PROC dbo.spEmployeeUpdateInOutStatus
	@employee_id int,
	@status_id int,
	@comment varchar(50) = '',
	@return smalldatetime,
	@source varchar(50) = NULL
AS
DECLARE @authorized bit
DECLARE @last_updated datetime
EXEC dbo.spPermissionInsureForCurrentUserOnPerson @employee_id, 50, 2, @authorized out

IF @source IS NULL
BEGIN
	SELECT TOP 1 @source = SourceOut, @last_updated = DATEADD(second,Seconds,[In]) FROM dbo.EmployeeTime WHERE EmployeeID=@employee_id AND Seconds > 0 AND DATEADD(second,Seconds,[In]) <= GETDATE() ORDER BY [In] DESC 
	IF @source IS NULL SELECT TOP 1 @source = SourceIn FROM dbo.EmployeeTime WHERE EmployeeID=@employee_id AND [In] <= GETDATE() ORDER BY [In] DESC
	IF @source IS NULL SET @source=''
END

IF @authorized = 1 
UPDATE dbo.Employee SET InOutLastSource=@source,InOutLastUpdated=GETDATE(),InOutComment=@comment,InOutStatusID=@status_id,InOutReturn=@return WHERE EmployeeID=@employee_id
GO
GRANT EXEC ON dbo.spEmployeeUpdateInOutStatus TO public
GO
/* STORED PROCS REQUIRED BY TRIGGERS END ***************************************************/

/* TRIGGER CHANGES BEGIN ***********************************************************************/
IF OBJECT_ID('dbo.PermissionScopeAttributeClearPermissionCache') IS NULL EXEC sp_executesql N'CREATE TRIGGER dbo.PermissionScopeAttributeClearPermissionCache ON dbo.PermissionScopeAttribute FOR INSERT,UPDATE AS SELECT A=0'
GO
ALTER TRIGGER dbo.PermissionScopeAttributeClearPermissionCache ON dbo.PermissionScopeAttribute FOR INSERT,UPDATE
AS
SET NOCOUNT ON DELETE dbo.PermissionCached
GO
IF OBJECT_ID('dbo.DepartmentClearPermissionCache') IS NULL EXEC sp_executesql N'CREATE TRIGGER dbo.DepartmentClearPermissionCache ON dbo.Department FOR INSERT,UPDATE AS SELECT A=0'
GO
ALTER TRIGGER dbo.DepartmentClearPermissionCache ON dbo.Department FOR INSERT,UPDATE
AS
SET NOCOUNT ON DELETE dbo.PermissionCached
GO
IF OBJECT_ID('dbo.DivisionClearPermissionCache') IS NULL EXEC sp_executesql N'CREATE TRIGGER dbo.DivisionClearPermissionCache ON dbo.Division FOR INSERT,UPDATE AS SELECT A=0'
GO
ALTER TRIGGER dbo.DivisionClearPermissionCache ON dbo.Division FOR INSERT,UPDATE
AS
SET NOCOUNT ON DELETE dbo.PermissionCached
GO
IF OBJECT_ID('dbo.EmployeeClearPermissionCache') IS NULL EXEC sp_executesql N'CREATE TRIGGER dbo.EmployeeClearPermissionCache ON dbo.Employee FOR UPDATE AS SELECT A=0'
GO
ALTER TRIGGER dbo.EmployeeClearPermissionCache ON dbo.Employee FOR UPDATE
AS
SET NOCOUNT ON
IF EXISTS(SELECT * FROM inserted I INNER JOIN deleted D ON I.EmployeeID = D.EmployeeID AND (
	dbo.fnNullCompare(I.ManagerID, D.ManagerID) = 0 OR 
	dbo.fnNullCompare(I.DelegatedManagerID, D.DelegatedManagerID) = 0 OR 
	I.LocationID <> D.LocationID OR 
	I.DepartmentID <> D.DepartmentID OR 
	I.DivisionID <> D.DivisionID OR 
	I.OrgUserField1 <> D.OrgUserField1 OR
	I.[Active Employee] <> D.[Active Employee]
))
DELETE dbo.PermissionCached
GO
IF OBJECT_ID('dbo.ConstantClearTimeCache') IS NULL EXEC sp_executesql N'CREATE TRIGGER dbo.ConstantClearTimeCache ON dbo.Constant FOR UPDATE AS SELECT A=0'
GO
ALTER TRIGGER dbo.ConstantClearTimeCache ON dbo.Constant FOR UPDATE
AS
SET NOCOUNT ON
IF EXISTS(
	SELECT * FROM inserted I INNER JOIN deleted D ON I.ConstantID=D.ConstantID AND (
	I.[Timecard Max 24 Hours per Day] != D.[Timecard Max 24 Hours per Day] OR
	I.[Max Shift Seconds] != D.[Max Shift Seconds] OR
	I.[Timecard Flags] != D.[Timecard Flags] OR
	I.[Timecard Authorization] != D.[Timecard Authorization] OR
	I.[TODOption] != D.[TODOption] OR
	I.[Timecard Rounding] != D.[Timecard Rounding] OR
	dbo.fnNullCompare(I.[DateFirst], D.[DateFirst]) = 0 OR
	dbo.fnNullCompare(I.CarryoverTargetLeaveTypeID, D.CarryoverTargetLeaveTypeID) = 0 OR
	dbo.fnNullCompare(I.CarryoverSourceLeaveTypeID, D.CarryoverSourceLeaveTypeID) = 0 OR
	dbo.fnNullCompare(I.HolidayTimeTypeID, D.HolidayTimeTypeID) = 0 OR
	dbo.fnNullCompare(I.OTTimeTypeID, D.OTTimeTypeID) = 0 OR
	dbo.fnNullCompare(I.WeekendTimeTypeID, D.WeekendTimeTypeID) = 0
))
DELETE dbo.EmployeeTimeCached
GO
IF OBJECT_ID('dbo.TimeTypeClearTimeCache') IS NULL EXEC sp_executesql N'CREATE TRIGGER dbo.TimeTypeClearTimeCache ON dbo.TimeType FOR UPDATE,DELETE AS SELECT A=0'
GO
ALTER TRIGGER dbo.TimeTypeClearTimeCache ON dbo.TimeType FOR UPDATE,DELETE
AS
SET NOCOUNT ON DELETE dbo.EmployeeTimeCached
GO
IF OBJECT_ID('dbo.LeaveTypeClearTimeCache') IS NULL EXEC sp_executesql N'CREATE TRIGGER dbo.LeaveTypeClearTimeCache ON dbo.LeaveType FOR UPDATE,DELETE AS SELECT A=0'
GO
ALTER TRIGGER dbo.LeaveTypeClearTimeCache ON dbo.LeaveType FOR UPDATE,DELETE
AS
SET NOCOUNT ON DELETE dbo.EmployeeTimeCached
GO
IF OBJECT_ID('dbo.HolidayClearTimeCache') IS NULL EXEC sp_executesql N'CREATE TRIGGER dbo.HolidayClearTimeCache ON dbo.Holiday FOR INSERT,UPDATE,DELETE AS SELECT A=0'
GO
ALTER TRIGGER dbo.HolidayClearTimeCache ON dbo.Holiday FOR INSERT,UPDATE,DELETE
AS
SET NOCOUNT ON DELETE dbo.EmployeeTimeCached
GO
IF OBJECT_ID('dbo.EmployeeClearTimeCache') IS NULL EXEC sp_executesql N'CREATE TRIGGER dbo.EmployeeClearTimeCache ON dbo.Employee FOR UPDATE AS SELECT A=0'
GO
ALTER TRIGGER dbo.EmployeeClearTimeCache ON dbo.Employee FOR UPDATE
AS
SET NOCOUNT ON
--IF UPDATE([ShiftID]) OR UPDATE(HolidayPlanID) OR UPDATE(TimeSchemaID)
IF EXISTS(
	SELECT * FROM inserted I INNER JOIN deleted D ON I.EmployeeID=D.EmployeeID AND (
	I.ShiftID != D.ShiftID OR
	I.HolidayPlanID != D.HolidayPlanID OR
	I.TimeSchemaID != D.TimeSchemaID OR
	I.[OT Basis] != D.[OT Basis]
))
BEGIN
	DELETE C
	FROM dbo.EmployeeTimeCached C
	INNER JOIN inserted ON C.EmployeeID=inserted.EmployeeID
END
GO
IF OBJECT_ID('dbo.ShiftClearTimeCache') IS NULL EXEC sp_executesql N'CREATE TRIGGER dbo.ShiftClearTimeCache ON dbo.Shift FOR UPDATE AS SELECT A=0'
GO
ALTER TRIGGER dbo.ShiftClearTimeCache ON dbo.Shift FOR UPDATE
AS
SET NOCOUNT ON DELETE dbo.EmployeeTimeCached
GO
IF OBJECT_ID('dbo.TimeSchemaClearTimeCache') IS NULL EXEC sp_executesql N'CREATE TRIGGER dbo.TimeSchemaClearTimeCache ON dbo.TimeSchema FOR UPDATE AS SELECT A=0'
GO
ALTER TRIGGER dbo.TimeSchemaClearTimeCache ON dbo.TimeSchema FOR UPDATE
AS
SET NOCOUNT ON DELETE dbo.EmployeeTimeCached
GO
IF OBJECT_ID('dbo.ShiftScheduleClearTimeCache') IS NULL EXEC sp_executesql N'CREATE TRIGGER dbo.ShiftScheduleClearTimeCache ON dbo.ShiftSchedule FOR UPDATE,DELETE,INSERT AS SELECT A=0'
GO
ALTER TRIGGER dbo.ShiftScheduleClearTimeCache ON dbo.ShiftSchedule FOR UPDATE,DELETE,INSERT
AS
SET NOCOUNT ON DELETE dbo.EmployeeTimeCached
GO
IF OBJECT_ID('dbo.ShiftSlantClearTimeCache') IS NULL EXEC sp_executesql N'CREATE TRIGGER dbo.ShiftSlantClearTimeCache ON dbo.ShiftSlant FOR UPDATE,DELETE,INSERT AS SELECT A=0'
GO
ALTER TRIGGER dbo.ShiftSlantClearTimeCache ON dbo.ShiftSlant FOR UPDATE,DELETE,INSERT
AS
SET NOCOUNT ON DELETE dbo.EmployeeTimeCached
GO
IF OBJECT_ID('dbo.TimeSchemaShiftDiffClearTimeCache') IS NULL EXEC sp_executesql N'CREATE TRIGGER dbo.TimeSchemaShiftDiffClearTimeCache ON dbo.TimeSchemaShiftDiff FOR UPDATE,DELETE,INSERT AS SELECT A=0'
GO
ALTER TRIGGER dbo.TimeSchemaShiftDiffClearTimeCache ON dbo.TimeSchemaShiftDiff FOR UPDATE,DELETE,INSERT
AS
SET NOCOUNT ON DELETE dbo.EmployeeTimeCached
GO
IF OBJECT_ID('dbo.TimeSchemaSlantClearTimeCache') IS NULL EXEC sp_executesql N'CREATE TRIGGER dbo.TimeSchemaSlantClearTimeCache ON dbo.TimeSchemaSlant FOR UPDATE,DELETE,INSERT AS SELECT A=0'
GO
ALTER TRIGGER dbo.TimeSchemaSlantClearTimeCache ON dbo.TimeSchemaSlant FOR UPDATE,DELETE,INSERT
AS
SET NOCOUNT ON DELETE dbo.EmployeeTimeCached
GO
IF OBJECT_ID('dbo.TimeSchemaBreakClearTimeCache') IS NULL EXEC sp_executesql N'CREATE TRIGGER dbo.TimeSchemaBreakClearTimeCache ON dbo.TimeSchemaBreak FOR UPDATE,DELETE,INSERT AS SELECT A=0'
GO
ALTER TRIGGER dbo.TimeSchemaBreakClearTimeCache ON dbo.TimeSchemaBreak FOR UPDATE,DELETE,INSERT
AS
SET NOCOUNT ON DELETE dbo.EmployeeTimeCached
GO
IF OBJECT_ID('dbo.ShiftBreakClearTimeCache') IS NULL EXEC sp_executesql N'CREATE TRIGGER dbo.ShiftBreakClearTimeCache ON dbo.ShiftBreak FOR UPDATE,DELETE,INSERT AS SELECT A=0'
GO
ALTER TRIGGER dbo.ShiftBreakClearTimeCache ON dbo.ShiftBreak FOR UPDATE,DELETE,INSERT
AS
SET NOCOUNT ON DELETE dbo.EmployeeTimeCached
GO
IF OBJECT_ID('dbo.EmployeeTimeSetLastApproved') IS NULL EXEC sp_executesql N'CREATE TRIGGER dbo.EmployeeTimeSetLastApproved ON dbo.EmployeeTime FOR INSERT,UPDATE AS SELECT A=0'
GO
ALTER TRIGGER dbo.EmployeeTimeSetLastApproved ON dbo.EmployeeTime FOR INSERT,UPDATE
AS
SET NOCOUNT ON
UPDATE ET SET 
[Last Approved By] = SUSER_SNAME(),
[Last Approved Day past 1900] = DATEDIFF(d,0,GETDATE())
FROM dbo.EmployeeTime ET
INNER JOIN inserted I ON ET.ItemID=I.ItemID
LEFT JOIN deleted D ON I.ItemID=D.ItemID
WHERE I.StatusID&1=1 AND (D.ItemID IS NULL OR D.StatusID&1=0)
GO
IF NOT EXISTS(SELECT * FROM dbo.AuditSetting WHERE ObjectID=5)
INSERT dbo.AuditSetting(ObjectID,[Object],[Possible Event Mask],[Audit Event Mask])
SELECT 5,'Reviews',14,0
GO
IF OBJECT_ID('dbo.EmployeeReviewLogUpdate') IS NULL EXEC sp_executesql N'CREATE TRIGGER dbo.EmployeeReviewLogUpdate ON dbo.EmployeeReview FOR UPDATE AS SELECT A=0'
GO
ALTER TRIGGER dbo.EmployeeReviewLogUpdate ON dbo.EmployeeReview FOR UPDATE
AS
SET NOCOUNT ON
DECLARE @audit_reviews bit

EXEC dbo.spAuditGetOperation 5, 2, @audit_reviews OUT
IF @audit_reviews=0 RETURN

INSERT AuditTrail(SID, [User], RegardingPersonID, [ID], ObjectID, TableID, [Event Mask], Event)
SELECT SUSER_SID(), SUSER_SNAME(), I.EmployeeID, I.ReviewID, 5, 5, 2,
'Review changed. ' +
CASE WHEN I.EmployeeID=D.EmployeeID THEN '' ELSE 'Person changed from ' + DP.[List As] + ' to ' + IP.[List As] + '. ' END +
-- PaymentID, InvoiceID not logged
CASE WHEN I.ReviewedByEmployeeID=D.ReviewedByEmployeeID THEN '' ELSE 'ReviewedBy from ' + ISNULL(DRP.[List As], 'NONE') + ' to ' + ISNULL(IRP.[List As], 'NONE') + '. ' END +
CASE WHEN I.[Comment]=D.[Comment] THEN '' ELSE 'Comment changed from ''' + D.[Comment] + ''' to ''' + I.[Comment] + '''. ' END +
CASE WHEN I.[Day past 1900]=D.[Day past 1900] THEN '' ELSE 'Date changed from ' + 
ISNULL(CAST(dbo.GetDateFromDaysPast1900(D.[Day past 1900]) AS char(11)), '''') + ' to ' + ISNULL(CAST(dbo.GetDateFromDaysPast1900(I.[Day past 1900]) AS char(11)), '''') + '. ' END +
CASE WHEN I.[Changed Salary]=D.[Changed Salary] THEN '' ELSE '[Changed Salary] from ''' + CASE WHEN D.[Changed Salary]=0 THEN 'No' ELSE 'Yes' END + ''' to ''' + CASE WHEN I.[Changed Salary]=0 THEN 'No' ELSE 'Yes' END + '''. ' END +
CASE WHEN dbo.fnNullCompare(I.RatingID, D.RatingID) = 1 THEN '' ELSE 'Rating changed from ' + ISNULL(IRATE.Rating, 'NONE') + ' to ' + ISNULL(DRATE.Rating, 'NONE') END + '.' +
CASE WHEN dbo.fnNullCompare(I.TypeID, D.TypeID) = 1 THEN '' ELSE 'Type changed from ' + ISNULL(ITYPE.[Type], 'NONE') + ' to ' + ISNULL(DTYPE.[Type], 'NONE') END + '.'

FROM inserted I INNER JOIN deleted D ON I.ReviewID=D.ReviewID
INNER JOIN dbo.vwPersonListAs IP ON I.EmployeeID = IP.PersonID
INNER JOIN dbo.vwPersonListAs DP ON D.EmployeeID = DP.PersonID
LEFT JOIN dbo.vwPersonListAs IRP ON I.ReviewedByEmployeeID = IRP.PersonID
LEFT JOIN dbo.vwPersonListAs DRP ON D.ReviewedByEmployeeID = DRP.PersonID
LEFT JOIN dbo.EmployeeReviewRating IRATE ON I.RatingID = IRATE.RatingID
LEFT JOIN dbo.EmployeeReviewRating DRATE ON D.RatingID = DRATE.RatingID
LEFT JOIN dbo.EmployeeReviewType ITYPE ON I.TypeID = ITYPE.TypeID
LEFT JOIN dbo.EmployeeReviewType DTYPE ON D.TypeID = DTYPE.TypeID
GO
IF OBJECT_ID('dbo.EmployeeReviewLogInsert') IS NULL EXEC sp_executesql N'CREATE TRIGGER dbo.EmployeeReviewLogInsert ON dbo.EmployeeReview FOR UPDATE AS SELECT A=0'
GO
ALTER TRIGGER dbo.EmployeeReviewLogInsert ON dbo.EmployeeReview FOR INSERT
AS
SET NOCOUNT ON
DECLARE @audit_reviews bit

EXEC dbo.spAuditGetOperation 5, 4, @audit_reviews OUT
IF @audit_reviews=0 RETURN

INSERT AuditTrail(SID, [User], RegardingPersonID, [ID], ObjectID, TableID, [Event Mask], Event)
SELECT SUSER_SID(), SUSER_SNAME(), I.EmployeeID, I.ReviewID, 5, 5, 4,
'Review inserted. ' +
'Person is ' + IP.[List As] + '. ' +
-- PaymentID, InvoiceID not logged
'ReviewedBy is ' + ISNULL(IRP.[List As], 'NONE') + '. ' +
'Comment is ''' + I.[Comment] + '''. ' +
'Date is ' + ISNULL(CAST(dbo.GetDateFromDaysPast1900(I.[Day past 1900]) AS char(11)), 'NONE') + '. '  +
'[Changed Salary] is ' + CASE WHEN I.[Changed Salary]=0 THEN 'No' ELSE 'Yes' END + '''. '  +
'Rating is ' + ISNULL(IRATE.Rating, 'NONE') + '.'  +
'Type is ' + ISNULL(ITYPE.[Type], 'NONE') + '.'

FROM inserted I
INNER JOIN dbo.vwPersonListAs IP ON I.EmployeeID = IP.PersonID
LEFT JOIN dbo.vwPersonListAs IRP ON I.ReviewedByEmployeeID = IRP.PersonID
LEFT JOIN dbo.EmployeeReviewRating IRATE ON I.RatingID = IRATE.RatingID
LEFT JOIN dbo.EmployeeReviewType ITYPE ON I.TypeID = ITYPE.TypeID
GO
IF OBJECT_ID('dbo.EmployeeReviewLogDelete') IS NULL EXEC sp_executesql N'CREATE TRIGGER dbo.EmployeeReviewLogDelete ON dbo.EmployeeReview FOR DELETE AS SELECT A=0'
GO
ALTER TRIGGER dbo.EmployeeReviewLogDelete ON dbo.EmployeeReview FOR DELETE
AS
SET NOCOUNT ON
DECLARE @audit_reviews bit

EXEC dbo.spAuditGetOperation 5, 8, @audit_reviews OUT
IF @audit_reviews=0 RETURN

INSERT AuditTrail(SID, [User], RegardingPersonID, [ID], ObjectID, TableID, [Event Mask], Event)
SELECT SUSER_SID(), SUSER_SNAME(), I.EmployeeID, I.ReviewID, 5, 5, 8,
'Review deleted. ' +
'Person was ' + IP.[List As] + '. ' +
-- PaymentID, InvoiceID not logged
'ReviewedBy was ' + ISNULL(IRP.[List As], 'NONE') + '. ' +
'Comment was ''' + I.[Comment] + '''. ' +
'Date was ' + ISNULL(CAST(dbo.GetDateFromDaysPast1900(I.[Day past 1900]) AS char(11)), '''') + '. '  +
'[Changed Salary] was ' + CASE WHEN I.[Changed Salary]=0 THEN 'No' ELSE 'Yes' END + '''. '  +
'Rating was ' + ISNULL(IRATE.Rating, 'NONE') + '.'  +
'Type was ' + ISNULL(ITYPE.[Type], 'NONE') + '.'

FROM deleted I
INNER JOIN dbo.vwPersonListAs IP ON I.EmployeeID = IP.PersonID
LEFT JOIN dbo.vwPersonListAs IRP ON I.ReviewedByEmployeeID = IRP.PersonID
LEFT JOIN dbo.EmployeeReviewRating IRATE ON I.RatingID = IRATE.RatingID
LEFT JOIN dbo.EmployeeReviewType ITYPE ON I.TypeID = ITYPE.TypeID
GO
IF OBJECT_ID('dbo.EmployeeLogUpdate') IS NULL EXEC sp_executesql N'CREATE TRIGGER dbo.EmployeeLogUpdate ON dbo.Employee FOR UPDATE AS SELECT A=0'
GO
ALTER TRIGGER dbo.EmployeeLogUpdate ON dbo.Employee FOR UPDATE
AS
IF NOT UPDATE([Next Performance Review Day past 1900]) RETURN

DECLARE @audit_reviews bit

EXEC dbo.spAuditGetOperation 5, 8, @audit_reviews OUT
IF @audit_reviews=0 RETURN

INSERT AuditTrail(SID, [User], RegardingPersonID, [ID], ObjectID, TableID, [Event Mask], Event)
SELECT SUSER_SID(), SUSER_SNAME(), I.EmployeeID, I.EmployeeID, 5, -1, 2,
'Employee changed. ' +
CASE WHEN dbo.fnNullCompare(I.[Next Performance Review Day past 1900], D.[Next Performance Review Day past 1900])=1 THEN '' ELSE 'Next Performance Review changed from ' + 
ISNULL(CAST(dbo.GetDateFromDaysPast1900(D.[Next Performance Review Day past 1900]) AS char(11)), 'NONE') + ' to ' + ISNULL(CAST(dbo.GetDateFromDaysPast1900(I.[Next Performance Review Day past 1900]) AS char(11)), 'NONE') + '. ' END 
FROM inserted I INNER JOIN deleted D ON I.EmployeeID=D.EmployeeID

AND dbo.fnNullCompare(I.[Next Performance Review Day past 1900], D.[Next Performance Review Day past 1900])=0
GO
IF OBJECT_ID('dbo.PersonCustomFieldLogUpdate') IS NULL EXEC sp_executesql N'CREATE TRIGGER dbo.PersonCustomFieldLogUpdate ON dbo.PersonCustomField FOR UPDATE AS SELECT A=0'
GO
ALTER TRIGGER dbo.PersonCustomFieldLogUpdate ON dbo.PersonCustomField FOR UPDATE
AS
SET NOCOUNT ON
DECLARE @audit_update bit

EXEC dbo.spAuditGetOperation 4194304, 2, @audit_update OUT
IF @audit_update=0 RETURN

INSERT AuditTrail(SID, [User], RegardingPersonID, [ID], ObjectID, TableID, [Event Mask], Event)
SELECT SUSER_SID(), SUSER_SNAME(), D.PersonID, D.ItemID, 4194304, 4194304, 2,
'Updated custom field value ' + CF.Field + '. ' +
'Value changed from ''' + dbo.fnGetCustomFieldText(D.FieldID, D.Value) + ''' to ''' + dbo.fnGetCustomFieldText(I.FieldID, I.Value) + ''''

FROM deleted D
INNER JOIN inserted I ON D.ItemID=I.ItemID AND dbo.fnGetCustomFieldText(I.FieldID, I.Value) != dbo.fnGetCustomFieldText(D.FieldID, D.Value)
INNER JOIN CustomField CF ON I.FieldID = CF.FieldID

EXEC dbo.spAuditLogPurge
GO
IF OBJECT_ID('dbo.PersonCustomFieldLogDelete') IS NULL EXEC sp_executesql N'CREATE TRIGGER dbo.PersonCustomFieldLogDelete ON dbo.PersonCustomField FOR DELETE AS SELECT A=0'
GO
ALTER TRIGGER dbo.PersonCustomFieldLogDelete ON dbo.PersonCustomField FOR DELETE
AS
SET NOCOUNT ON
DECLARE @audit_delete bit

EXEC dbo.spAuditGetOperation 4194304, 8, @audit_delete OUT
IF @audit_delete=0 RETURN

INSERT AuditTrail(SID, [User], RegardingPersonID, [ID], ObjectID, TableID, [Event Mask], Event)
SELECT SUSER_SID(), SUSER_SNAME(), D.PersonID, D.ItemID, 4194304, 4194304, 2,
'Deleted custom field value ' + CF.Field + '. ' +
'Value was ''' + dbo.fnGetCustomFieldText(D.FieldID, D.Value) + ''''

FROM deleted D
INNER JOIN CustomField CF ON D.FieldID = CF.FieldID AND dbo.fnGetCustomFieldText(D.FieldID, D.Value) != ''

EXEC dbo.spAuditLogPurge
GO
IF OBJECT_ID('dbo.NoteLogUpdate') IS NULL EXEC sp_executesql N'CREATE TRIGGER dbo.NoteLogUpdate ON dbo.Note FOR UPDATE AS SELECT A=0'
GO
ALTER TRIGGER dbo.NoteLogUpdate ON dbo.Note FOR UPDATE
AS
SET NOCOUNT ON
DECLARE @audit_notes bit

EXEC dbo.spAuditGetOperation 1024, 2, @audit_notes OUT
IF @audit_notes=0 RETURN

INSERT AuditTrail(SID, [User], RegardingPersonID, [ID], ObjectID, TableID, [Event Mask], Event)
SELECT SUSER_SID(), SUSER_SNAME(), I.PersonID, I.NoteID, 1024, 1024, 2,
'Note changed. ' +
CASE WHEN I.PersonID=D.PersonID THEN '' ELSE 'Person changed from ' + DP.[List As] + ' to ' + IP.[List As] + '. ' END +
-- PaymentID, InvoiceID not logged
CASE WHEN I.ClassID=D.ClassID THEN '' ELSE 'Class changed from ' + DClass.Class + ' to ' + IClass.Class + '. ' END +
CASE WHEN I.[Subject]=D.[Subject] THEN '' ELSE 'Subject changed from ''' + D.[Subject] + ''' to ''' + I.[Subject] + '''. ' END +
CASE WHEN I.[Day past 1900]=D.[Day past 1900] THEN '' ELSE 'Date changed from ' + 
CAST(dbo.GetDateFromDaysPast1900(D.[Day past 1900]) AS char(11)) + ' to ' + CAST(dbo.GetDateFromDaysPast1900(I.[Day past 1900]) AS char(11)) + '. ' END +
CASE WHEN I.Note=D.Note THEN '' ELSE 'Note changed from ''' + D.Note + ''' to ''' + I.Note + '''. ' END

FROM inserted I INNER JOIN deleted D ON I.NoteID=D.NoteID
INNER JOIN dbo.NoteClass IClass ON I.ClassID=IClass.ClassID
INNER JOIN dbo.NoteClass DClass ON D.ClassID = DClass.ClassID
INNER JOIN dbo.vwPersonListAs IP ON I.PersonID = IP.PersonID
INNER JOIN dbo.vwPersonListAs DP ON D.PersonID = DP.PersonID
GO
IF OBJECT_ID('dbo.NoteLogInsert') IS NULL EXEC sp_executesql N'CREATE TRIGGER dbo.NoteLogInsert ON dbo.Note FOR INSERT AS SELECT A=0'
GO
ALTER TRIGGER dbo.NoteLogInsert ON dbo.Note FOR INSERT
AS
SET NOCOUNT ON
DECLARE @audit_notes bit

EXEC dbo.spAuditGetOperation 1024, 4, @audit_notes OUT
IF @audit_notes=0 RETURN

INSERT AuditTrail(SID, [User], RegardingPersonID, [ID], ObjectID, TableID, [Event Mask], Event)
SELECT SUSER_SID(), SUSER_SNAME(), I.PersonID, I.NoteID, 1024, 1024, 4,
'Note inserted. ' +
'Person=' + IP.[List As] + '. ' +
-- PaymentID, InvoiceID not logged
'Class=' +IClass.Class + '. ' +
'Subject=''' + I.[Subject] + '''. ' +
'Date=' + CAST(dbo.GetDateFromDaysPast1900(I.[Day past 1900]) AS char(11)) + '. ' +
'Note=''' + I.Note + '''. '
FROM inserted I
INNER JOIN dbo.NoteClass IClass ON I.ClassID=IClass.ClassID
INNER JOIN dbo.vwPersonListAs IP ON I.PersonID = IP.PersonID
GO
IF OBJECT_ID('dbo.NoteLogDelete') IS NULL EXEC sp_executesql N'CREATE TRIGGER dbo.NoteLogDelete ON dbo.Note FOR DELETE AS SELECT A=0'
GO
ALTER TRIGGER dbo.NoteLogDelete ON dbo.Note FOR DELETE
AS
SET NOCOUNT ON
DECLARE @audit_notes bit

EXEC dbo.spAuditGetOperation 1024, 8, @audit_notes OUT
IF @audit_notes=0 RETURN

INSERT AuditTrail(SID, [User], RegardingPersonID, [ID], ObjectID, TableID, [Event Mask], Event)
SELECT SUSER_SID(), SUSER_SNAME(), D.PersonID, D.NoteID, 1024, 1024, 8,
'Note deleted. ' +
'Person=' + DP.[List As] + '. ' +
-- PaymentID, InvoiceID not logged
'Class=' + DClass.Class + '. ' +
'Subject=''' + D.[Subject] + '''. ' +
'Date=' + CAST(dbo.GetDateFromDaysPast1900(D.[Day past 1900]) AS char(11)) + '. ' +
'Note=''' + D.Note + '''. '
FROM deleted D
INNER JOIN dbo.NoteClass DClass ON D.ClassID=DClass.ClassID
INNER JOIN dbo.vwPersonListAs DP ON D.PersonID = DP.PersonID
GO
IF OBJECT_ID('dbo.PersonXUnionSetPersonX_UnionsOnChange') IS NULL EXEC sp_executesql N'CREATE TRIGGER dbo.PersonXUnionSetPersonX_UnionsOnChange On dbo.PersonXUnion FOR INSERT,UPDATE,DELETE AS SELECT A=0'
GO
-- Updates PersonX.Unions from dbo.PersonXUnion changes
ALTER TRIGGER dbo.PersonXUnionSetPersonX_UnionsOnChange On dbo.PersonXUnion FOR INSERT,UPDATE,DELETE
AS
SET NOCOUNT ON
SELECT DISTINCT(PersonID),UnionID=NULL INTO #UnionP FROM deleted
IF NOT EXISTS(SELECT * FROM #UnionP) INSERT #UnionP SELECT DISTINCT(PersonID),NULL FROM inserted

UPDATE #UnionP SET UnionID=(SELECT MIN(UnionID) FROM dbo.PersonXUnion PU WHERE PU.PersonID=#UnionP.PersonID)

UPDATE P SET Unions = U.[Union]
FROM dbo.PersonX P
INNER JOIN #UnionP ON #UnionP.PersonID = P.PersonID
INNER JOIN [Union] U ON #UnionP.UnionID = U.UnionID


UPDATE #UnionP SET UnionID=(SELECT MIN(UnionID) FROM dbo.PersonXUnion PU WHERE PU.PersonID=#UnionP.PersonID AND PU.UnionID > #UnionP.UnionID) WHERE UnionID IS NOT NULL
WHILE @@ROWCOUNT > 0
BEGIN
	UPDATE P SET Unions = SUBSTRING(P.Unions + ',' + U.[Union], 1, 400)
	FROM dbo.PersonX P
	INNER JOIN #UnionP ON #UnionP.PersonID = P.PersonID
	INNER JOIN [Union] U ON #UnionP.UnionID = U.UnionID
	
	UPDATE #UnionP SET UnionID=(SELECT MIN(UnionID) FROM dbo.PersonXUnion PU WHERE PU.PersonID=#UnionP.PersonID AND PU.UnionID > #UnionP.UnionID) WHERE UnionID IS NOT NULL
END
GO
IF OBJECT_ID('dbo.UnionSetPersonX_UnionsOnChange') IS NULL EXEC sp_executesql N'CREATE TRIGGER dbo.UnionSetPersonX_UnionsOnChange On PersonXUnion FOR INSERT,UPDATE,DELETE AS SELECT A=0'
GO
-- Updates PersonX.Unions from dbo.Union changes
ALTER TRIGGER dbo.UnionSetPersonX_UnionsOnChange On PersonXUnion FOR INSERT,UPDATE,DELETE AS
SET NOCOUNT ON
-- Triggers PersonXUnionSetPersonX_UnionsOnChange
UPDATE dbo.PersonXUnion SET UnionID=UnionID WHERE UnionID IN (SELECT UnionID FROM inserted) OR UnionID IN (SELECT UnionID FROM deleted)
GO
-- Initially sets PersonX.Unions
IF NOT EXISTS(SELECT * FROM dbo.PersonX WHERE Unions != '') UPDATE dbo.PersonXUnion SET UnionID=UnionID -- Triggers PersonXUnionSetPersonX_UnionsOnChange
GO
IF OBJECT_ID('dbo.EmployeeBenefitLogUpdate') IS NULL EXEC sp_executesql N'CREATE TRIGGER dbo.EmployeeBenefitLogUpdate ON dbo.EmployeeBenefit FOR UPDATE AS SELECT A=0'
GO
ALTER TRIGGER dbo.EmployeeBenefitLogUpdate ON dbo.EmployeeBenefit FOR UPDATE
AS
DECLARE @audit_benefits bit

SET NOCOUNT ON

EXEC dbo.spAuditGetOperation 536870912, 2, @audit_benefits OUT
IF @audit_benefits=0 RETURN

INSERT AuditTrail(SID, [User], RegardingPersonID, [ID], ObjectID, TableID, [Event Mask], Event)
SELECT SUSER_SID(), SUSER_SNAME(), I.EmployeeID, I.BenefitID, 536870912, 536870912, 2,
'Benefit changed. ' +
CASE WHEN I.EmployeeID=D.EmployeeID THEN '' ELSE 'Employee changed from ' + DP.[List As] + ' to ' + IP.[List As] + '. ' END +
CASE WHEN I.BenefitID=D.BenefitID THEN '' ELSE 'Benefit changed from ' + DBenefit.Benefit + ' to ' + IBenefit.Benefit + '. ' END +
CASE WHEN I.[Plan]=D.[Plan] THEN '' ELSE 'Plan changed from ''' + D.[Plan] + ''' to ''' + I.[Plan] + '''. ' END +
CASE WHEN I.Coverage=D.Coverage THEN '' ELSE 'Coverage changed from ''' + D.Coverage + ''' to ''' + I.Coverage + '''. ' END +
CASE WHEN I.[Individual Policy Number]=D.[Individual Policy Number] THEN '' ELSE 'Individual Policy # changed from ''' + D.[Individual Policy Number] + ''' to ''' + I.[Individual Policy Number] + '''. ' END +
CASE WHEN I.[Group Policy Number]=D.[Group Policy Number] THEN '' ELSE 'Group Policy # changed from ''' + D.[Group Policy Number] + ''' to ''' + I.[Group Policy Number] + '''. ' END +
CASE WHEN I.[Employee Premium]=D.[Employee Premium] THEN '' ELSE 'Employee premium changed from ' + CAST(CAST(D.[Employee Premium] AS numeric(23,2)) AS varchar(50)) + ' to ' + CAST(CAST(I.[Employee Premium] AS numeric(23,2)) AS varchar(50)) + '. ' END +
CASE WHEN I.[Employer Premium]=D.[Employer Premium] THEN '' ELSE 'Employer premium changed from ' + CAST(CAST(D.[Employer Premium] AS numeric(23,2)) AS varchar(50)) + ' to ' + CAST(CAST(I.[Employer Premium] AS numeric(23,2)) AS varchar(50)) + '. ' END +
CASE WHEN ISNULL(I.[Eligible Day past 1900],0x7FFFFFFF)=ISNULL(D.[Eligible Day past 1900], 0x7FFFFFFF) THEN '' ELSE 'Eligible changed from ' + CASE WHEN D.[Eligible Day past 1900] IS NULL THEN 'Unspecified' ELSE CAST(dbo.GetDateFromDaysPast1900(D.[Eligible Day past 1900]) AS char(11)) END + ' to ' + CASE WHEN I.[Eligible Day past 1900] IS NULL THEN 'Unspecified' ELSE CAST(dbo.GetDateFromDaysPast1900(I.[Eligible Day past 1900]) AS char(11)) END  + '. ' END +
CASE WHEN ISNULL(I.[Expires Day past 1900],0x7FFFFFFF)=ISNULL(D.[Expires Day past 1900], 0x7FFFFFFF) THEN '' ELSE 'Expires changed from ' + CASE WHEN D.[Expires Day past 1900] IS NULL THEN 'Unspecified' ELSE CAST(dbo.GetDateFromDaysPast1900(D.[Expires Day past 1900]) AS char(11)) END + ' to ' + CASE WHEN I.[Expires Day past 1900] IS NULL THEN 'Unspecified' ELSE CAST(dbo.GetDateFromDaysPast1900(I.[Expires Day past 1900]) AS char(11)) END  + '. ' END +
CASE WHEN ISNULL(I.[Notified Day past 1900],0x7FFFFFFF)=ISNULL(D.[Notified Day past 1900], 0x7FFFFFFF) THEN '' ELSE 'Notified changed from ' + CASE WHEN D.[Notified Day past 1900] IS NULL THEN 'Unspecified' ELSE CAST(dbo.GetDateFromDaysPast1900(D.[Notified Day past 1900]) AS char(11)) END + ' to ' + CASE WHEN I.[Notified Day past 1900] IS NULL THEN 'Unspecified' ELSE CAST(dbo.GetDateFromDaysPast1900(I.[Notified Day past 1900]) AS char(11)) END  + '. ' END +
CASE WHEN ISNULL(I.[First Enrolled Day past 1900],0x7FFFFFFF)=ISNULL(D.[First Enrolled Day past 1900], 0x7FFFFFFF) THEN '' ELSE 'First Enrolled changed from ' + CASE WHEN D.[First Enrolled Day past 1900] IS NULL THEN 'Unspecified' ELSE CAST(dbo.GetDateFromDaysPast1900(D.[First Enrolled Day past 1900]) AS char(11)) END + ' to ' + CASE WHEN I.[First Enrolled Day past 1900] IS NULL THEN 'Unspecified' ELSE CAST(dbo.GetDateFromDaysPast1900(I.[First Enrolled Day past 1900]) AS char(11)) END  + '. ' END +
CASE WHEN ISNULL(I.[Last Enrolled Day past 1900],0x7FFFFFFF)=ISNULL(D.[Last Enrolled Day past 1900], 0x7FFFFFFF) THEN '' ELSE 'Last Enrolled changed from ' + CASE WHEN D.[Last Enrolled Day past 1900] IS NULL THEN 'Unspecified' ELSE CAST(dbo.GetDateFromDaysPast1900(D.[Last Enrolled Day past 1900]) AS char(11)) END + ' to ' + CASE WHEN I.[Last Enrolled Day past 1900] IS NULL THEN 'Unspecified' ELSE CAST(dbo.GetDateFromDaysPast1900(I.[Last Enrolled Day past 1900]) AS char(11)) END  + '. ' END +
CASE WHEN ISNULL(I.[Declined Day past 1900],0x7FFFFFFF)=ISNULL(D.[Declined Day past 1900], 0x7FFFFFFF) THEN '' ELSE 'Declined changed from ' + CASE WHEN D.[Declined Day past 1900] IS NULL THEN 'Unspecified' ELSE CAST(dbo.GetDateFromDaysPast1900(D.[Declined Day past 1900]) AS char(11)) END + ' to ' + CASE WHEN I.[Declined Day past 1900] IS NULL THEN 'Unspecified' ELSE CAST(dbo.GetDateFromDaysPast1900(I.[Declined Day past 1900]) AS char(11)) END  + '. ' END +
CASE WHEN I.Coverage=D.Coverage THEN '' ELSE 'Note changed from ''' + D.Note + ''' to ''' + I.Note + '''. ' END +
CASE WHEN 
	((I.[Wait List Queue] IS NULL) AND (D.[Wait List Queue] IS NULL)) OR
	I.[Wait List Queue]=D.[Wait List Queue] THEN '' ELSE 
	'Wait List Queue changed from ' + CASE WHEN D.[Wait List Queue] IS NULL THEN 'Unspecified' ELSE CAST(D.[Wait List Queue] as varchar(50)) END + ' to ' + CASE WHEN I.[Wait List Queue] IS NULL THEN 'Unspecified' ELSE CAST(I.[Wait List Queue] as varchar(50)) END + '. ' 
END +
CASE WHEN ISNULL(I.[Wait List Day past 1900],0x7FFFFFFF)=ISNULL(D.[Wait List Day past 1900], 0x7FFFFFFF) THEN '' ELSE 'Wait List Date changed from ' + CASE WHEN D.[Wait List Day past 1900] IS NULL THEN 'Unspecified' ELSE CAST(dbo.GetDateFromDaysPast1900(D.[Wait List Day past 1900]) AS char(11)) END + ' to ' + CASE WHEN I.[Wait List Day past 1900] IS NULL THEN 'Unspecified' ELSE CAST(dbo.GetDateFromDaysPast1900(I.[Wait List Day past 1900]) AS char(11)) END  + '. ' END +
CASE WHEN 
	((I.[Volume] IS NULL) AND (D.[Volume] IS NULL)) OR
	I.[Volume]=D.[Volume] THEN '' ELSE 
	'Volume changed from ' + CASE WHEN D.[Volume] IS NULL THEN 'Unspecified' ELSE CAST(CAST(D.[Volume] AS numeric(23,2)) AS varchar(50)) END + ' to ' + CASE WHEN I.[Volume] IS NULL THEN 'Unspecified' ELSE CAST(CAST(I.[Volume] AS numeric(23,2)) AS varchar(50)) END + '. ' 
END +
CASE WHEN I.[Other Premium]=D.[Other Premium] THEN '' ELSE 'Other premium changed from ' + CAST(CAST(D.[Other Premium] AS numeric(23,2)) AS varchar(50)) + ' to ' + CAST(CAST(I.[Other Premium] AS numeric(23,2)) AS varchar(50)) + '. ' END

FROM inserted I INNER JOIN deleted D ON I.EmployeeBenefitID=D.EmployeeBenefitID
INNER JOIN dbo.Benefit IBenefit ON I.BenefitID=IBenefit.BenefitID
INNER JOIN dbo.Benefit DBenefit ON D.BenefitID = DBenefit.BenefitID
INNER JOIN dbo.vwPersonListAs IP ON I.EmployeeID = IP.PersonID
INNER JOIN dbo.vwPersonListAs DP ON D.EmployeeID = DP.PersonID
GO
IF OBJECT_ID('dbo.CalculatedFlagsROOnTimeTypeInsertUpdateDelete') IS NULL EXEC sp_executesql N'CREATE TRIGGER dbo.CalculatedFlagsROOnTimeTypeInsertUpdateDelete ON dbo.TimeType FOR INSERT, UPDATE, DELETE AS SELECT A=0'
GO
-- Flips a flag in LeaveType to indicate that the leave type is comp
ALTER TRIGGER dbo.CalculatedFlagsROOnTimeTypeInsertUpdateDelete ON dbo.TimeType FOR INSERT,UPDATE,DELETE
AS
SET NOCOUNT ON

SELECT DISTINCT TypeID=CompLeaveTypeID, FlagsRO=0 INTO #T_20110801 FROM inserted
UNION /* implicit distinct */
SELECT DISTINCT CompLeaveTypeID, FlagsRO=0 FROM deleted
UPDATE _LT SET FlagsRO=1 FROM #T_20110801 _LT WHERE EXISTS (SELECT * FROM dbo.TimeType TT WHERE TT.CompLeaveTypeID=_LT.TypeID)
UPDATE LT SET FlagsRO = (LT.FlagsRO & 0x7FFFFFFE) | _LT.FlagsRO FROM dbo.LeaveType LT INNER JOIN #T_20110801 _LT ON _LT.TypeID=LT.TypeID AND (LT.FlagsRO & 1) != _LT.FlagsRO
GO
IF OBJECT_ID('dbo.CastEmployeeNumberToNumericOnEmployeeInsertUpdate') IS NULL EXEC sp_executesql N'CREATE TRIGGER dbo.CastEmployeeNumberToNumericOnEmployeeInsertUpdate ON dbo.Employee FOR INSERT, UPDATE AS SELECT A=0'
GO
ALTER TRIGGER dbo.CastEmployeeNumberToNumericOnEmployeeInsertUpdate ON dbo.Employee FOR INSERT, UPDATE
AS
SET NOCOUNT ON

IF NOT UPDATE([Employee Number]) RETURN

UPDATE E SET EmployeeNumberNumeric=NULL
FROM dbo.Employee E INNER JOIN deleted D ON E.EmployeeID=D.EmployeeID

UPDATE E SET EmployeeNumberNumeric=CAST(I.[Employee Number] AS numeric(38,6)) 
FROM dbo.Employee E INNER JOIN inserted I ON E.EmployeeID=I.EmployeeID AND ISNUMERIC(I.[Employee Number])=1 
GO
IF OBJECT_ID('dbo.UpdateUnusedCompOnEmployeeTimeChange') IS NULL EXEC sp_executesql N'CREATE TRIGGER dbo.UpdateUnusedCompOnEmployeeTimeChange ON dbo.EmployeeTime FOR INSERT, UPDATE, DELETE AS SELECT A=0'
GO
ALTER TRIGGER dbo.UpdateUnusedCompOnEmployeeTimeChange ON dbo.EmployeeTime FOR INSERT, UPDATE, DELETE 
AS
SET NOCOUNT ON

-- Recalculates unused leave totals for comp time
CREATE TABLE #T_02022011(EmployeeID int, TypeID int, D int)
CREATE INDEX T_02022011_EmployeeIDTypeID ON #T_02022011(EmployeeID,TypeID)
INSERT #T_02022011
SELECT T.EmployeeID, TypeID=TT.CompLeaveTypeID, D=MIN(DATEDIFF(d,0,T.[In])) FROM inserted T
INNER JOIN dbo.TimeType TT ON T.TypeID=TT.TypeID AND TT.CompLeaveTypeID IS NOT NULL
GROUP BY T.EmployeeID, TT.CompLeaveTypeID
UNION
SELECT T.EmployeeID, TypeID=TT.CompLeaveTypeID, D=MIN(DATEDIFF(d,0,T.[In])) FROM deleted T
INNER JOIN dbo.TimeType TT ON T.TypeID=TT.TypeID AND TT.CompLeaveTypeID IS NOT NULL
GROUP BY T.EmployeeID, TT.CompLeaveTypeID

DECLARE t_cursor CURSOR LOCAL FORWARD_ONLY STATIC FOR SELECT EmployeeID, TypeID, MIN(D) FROM #T_02022011 GROUP BY EmployeeID, TypeID
OPEN t_cursor

DECLARE @employee_id int, @type_id int, @d int
FETCH t_cursor INTO @employee_id, @type_id, @d
WHILE @@FETCH_STATUS = 0
BEGIN
	EXEC dbo.spEmployeeLeaveCalcForEmployeeType @employee_id, @type_id, @d
	FETCH t_cursor INTO @employee_id, @type_id, @d
END
	
CLOSE t_cursor
DEALLOCATE t_cursor
GO
CREATE TRIGGER dbo.HolidayInsertUpdate ON dbo.Holiday FOR INSERT, UPDATE
AS
-- Test years for recurring holidays
CREATE TABLE #Y(Y int)
INSERT #Y 
SELECT DISTINCT [Year] FROM dbo.Holiday WHERE [Year] IS NOT NULL
UNION
SELECT DISTINCT [Year] - 1 FROM dbo.Holiday WHERE [Year] IS NOT NULL
UNION
SELECT DISTINCT [Year] + 1 FROM dbo.Holiday WHERE [Year] IS NOT NULL
UNION
SELECT YEAR(GETDATE())
UNION
SELECT YEAR(GETDATE()) - 1
UNION
SELECT YEAR(GETDATE()) + 1

CREATE TABLE #H(HolidayID int, PlanID int, X datetime, Y datetime, Holiday varchar(50) COLLATE SQL_Latin1_General_CP1_CI_AS)
CREATE INDEX H_HolidayID ON #H(HolidayID)
CREATE INDEX H_PlanID ON #H(PlanID)
CREATE INDEX H_X ON #H(X)
CREATE INDEX H_Y ON #H(Y)

INSERT #H
SELECT HolidayID, PlanID, dbo.GetDateFromMDY([Month], [Day], [Year]), DATEADD(d,[Length]-1,dbo.GetDateFromMDY([Month], [Day], [Year])), [Holiday] FROM dbo.Holiday WHERE [Year] IS NOT NULL
UNION
SELECT HolidayID, PlanID, dbo.GetDateFromMDY(H.[Month], H.[Day], #Y.Y), DATEADD(d,[Length]-1,dbo.GetDateFromMDY(H.[Month], H.[Day], #Y.Y)), H.[Holiday] FROM dbo.Holiday H CROSS JOIN #Y WHERE H.[Year] IS NULL

DECLARE @h1x varchar(11), @h1y varchar(11), @h2x varchar(11), @h2y varchar(11), @h1 varchar(50), @h2 varchar(50)
SELECT TOP 1 
@h1x=CAST(H1.X AS varchar(11)), @h1y = CAST(H1.Y AS varchar(11)), @h1=H1.Holiday, @h2x=CAST(H2.X AS varchar(11)),@h2y=CAST(H2.Y AS varchar(11)),@h2=H2.Holiday
FROM #H H1
INNER JOIN #H H2 ON H1.PlanID=H2.PlanID AND H1.HolidayID <> H2.HolidayID AND (H1.X BETWEEN H2.X AND H2.Y OR H1.Y BETWEEN H2.X AND H2.Y)

IF @@ROWCOUNT > 0
BEGIN
	DECLARE @message varchar(500)
	SELECT @message = 'Duplicate holiday. ' + @h1 + ' ' + @h1x
	IF @h1y <> @h1x SET @message = @message + ' to ' + @h1y
	SET @message = @message + ' intersects ' + @h2 + ' ' + @h2x
	IF @h2y <> @h2x SET @message = @message + ' to ' + @h2y
	SET @message = @message + '.'
	RAISERROR(@message, 16,1)
	ROLLBACK
END
ELSE EXEC dbo.spHolidayRecalc
GO
GRANT EXEC ON dbo.spHolidayRecalc TO public
GO
IF NOT EXISTS(SELECT * FROM dbo.HolidayCalculated) EXEC dbo.spHolidayRecalc
GO
IF OBJECT_id('dbo.UpdateDependentRoleOnEmployeeDependent') IS NOT NULL DROP TRIGGER dbo.UpdateDependentRoleOnEmployeeDependent
GO
CREATE TRIGGER dbo.UpdateDependentRoleOnEmployeeDependent ON dbo.[EmployeeDependent] 
FOR INSERT, DELETE
AS
SET NOCOUNT ON

-- Set dependent role on people associated with inserted dependent
UPDATE P SET [Role Mask] = [Role Mask] | 0x20
FROM Person P INNER JOIN inserted C ON P.PersonID = C.PersonID

-- Remove dependent role on people associated with deleted dependent
UPDATE P SET [Role Mask] = [Role Mask] & 0x7FFFFFDF
FROM Person P INNER JOIN deleted C ON P.PersonID = C.PersonID AND P.PersonID NOT IN
(
	SELECT DISTINCT PersonID FROM EmployeeDependent
)

GO
IF OBJECT_id('dbo.spAuditGetOperation') IS NOT NULL DROP PROC dbo.spAuditGetOperation
GO
CREATE PROC dbo.spAuditGetOperation
	@object_id int,
	@operation int,
	@audit_operation bit OUT,
	@audit_unauthorized_attempt bit = 0 OUT
AS
DECLARE @audit_event_mask int
SELECT @audit_event_mask = [Audit Event Mask] FROM AuditSetting WHERE ObjectID=@object_id
IF @@ROWCOUNT = 0 SELECT @audit_operation = 0, @audit_unauthorized_attempt = 0
ELSE 
BEGIN
	SELECT @audit_operation = CASE WHEN (@audit_event_mask & @operation) = 0 THEN 0 ELSE 1 END
	SELECT @audit_unauthorized_attempt = CASE WHEN @audit_operation = 0 OR (@audit_event_mask & 16) = 0 THEN 0 ELSE 1 END
END
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spEmployeeTimeInsert3', 0
GO
-- Inserts time entry without check permissions. DBO permissions required
ALTER PROC dbo.spEmployeeTimeInsert3
	@employee_id int,
	@in smalldatetime,
	@out smalldatetime,
	@item_id int = NULL OUT,
	@employee_comment varchar(50) = '',
	@project_id int,
	@change_status bit,
	@source varchar(50),
	@time_type_id int,
	@gmt_hours int,
	@status_id int,
	@ppe_day int
AS
DECLARE @authorized bit
DECLARE @type_id int

IF @employee_comment IS NULL SET @employee_comment = ''

DECLARE @audit_text varchar(400)

DECLARE @d int, @pay_rate smallmoney, @billing_rate smallmoney
SELECT @d = DATEDIFF(d, 0, @in)

DECLARE @fixed_pay money, @fixed_billing money, @default_time_type_id int
EXEC dbo.spEmployeeRateSelect2 @employee_id, @project_id, @time_type_id, @d, @pay_rate OUT, @billing_rate OUT, @default_time_type_id OUT, @fixed_pay OUT, @fixed_billing OUT
IF @time_type_id IS NULL SET @time_type_id = @default_time_type_id

IF @out IS NULL
BEGIN
	DECLARE @batch_id int, @in_day int
	SELECT @batch_id = RAND() * 2147483647, @in_day = DATEDIFF(d,0,@in)

	-- Not closing out previous in\out?
	INSERT dbo.TempXYZ(BatchID, [ID], X, Y, Z, I)
	SELECT @batch_id, EmployeeID, @in_day, DATEDIFF(s, @in_day, [In]), DATEDIFF(s, @in_day, [In]) + Seconds, ItemID
	FROM dbo.vwEmployeeTime WHERE EmployeeID=@employee_id AND [In Day past 1900] = @in_day

	INSERT TempXYZ(BatchID, [ID], X, Y, Z, I, N)
	SELECT @batch_id, @employee_id, @in_day, DATEDIFF(s, @in_day, @in), 0, -1, @employee_comment

	SELECT @item_id = SCOPE_IDENTITY()

	EXEC dbo.spEmployeeTimeRound @batch_id, 0

	INSERT EmployeeTime(EmployeeID, [PPE Day past 1900], [In], Seconds, StatusID, [Pay Rate], [Billing Rate], TypeID, [Employee Comment], ProjectID, SourceIn, [GMT+Hours], [Fixed Billing], [Fixed Pay])
	SELECT @employee_id, CASE WHEN @ppe_day IS NULL THEN X ELSE @ppe_day END, DATEADD(s, Y, X), 0, @status_id, @pay_rate, @billing_rate, @time_type_id, N, @project_id, @source, @gmt_hours, @fixed_billing, @fixed_pay FROM TempXYZ WHERE ItemID=@item_id
	SELECT @item_id = SCOPE_IDENTITY()

	DELETE TempXYZ WHERE BatchID=@batch_id OR DATEDIFF(hour, Created, GETDATE()) > 1

END
ELSE
BEGIN
	INSERT EmployeeTime(EmployeeID, [PPE Day past 1900], [In], Seconds, StatusID, [Pay Rate], [Billing Rate], TypeID, [Employee Comment], ProjectID, SourceIn, [GMT+Hours], [Fixed Billing], [Fixed Pay])
	VALUES(@employee_id, CASE WHEN @ppe_day IS NULL THEN @d ELSE @ppe_day END, @in, DATEDIFF(s, @in, @out), @status_id, @pay_rate, @billing_rate, @time_type_id, @employee_comment, @project_id, @source, @gmt_hours, @fixed_billing, @fixed_pay)
	SELECT @item_id = SCOPE_IDENTITY()
END

IF @change_status = 1
BEGIN
	DECLARE @in_out_status_id int, @delta_last_punch_this_punch int, @lunch bit
	
	-- Change status to in or out
	SELECT @in_out_status_id = NULL

	-- Project status (1)
	SELECT TOP 1 @in_out_status_id = CASE WHEN @out IS NULL THEN InStatusID ELSE OutStatusID END FROM dbo.Project WHERE ProjectID=@project_id
	IF @in_out_status_id IS NULL 
	BEGIN
		IF @out IS NULL SELECT TOP 1 @in_out_status_id = StatusID FROM InOutStatus WHERE [In]= 1 ORDER BY [Order]
		ELSE 
		BEGIN
			SELECT TOP 1 @delta_last_punch_this_punch = DATEDIFF(second,[In],@out) FROM dbo.EmployeeTime WHERE EmployeeID=@employee_id AND DATEDIFF(d,0, [In]) = DATEDIFF(d,0,@out) ORDER BY [In]
			IF @delta_last_punch_this_punch IS NULL SELECT TOP 1 @delta_last_punch_this_punch = DATEDIFF(second,@in,@out)
			SELECT @lunch = CASE WHEN @delta_last_punch_this_punch IS NOT NULL AND @delta_last_punch_this_punch < 18000 THEN 1 ELSE 0 END

			-- Lunch status
			IF @in_out_status_id IS NULL AND @lunch = 1 SELECT TOP 1 @in_out_status_id = StatusID FROM InOutStatus WHERE [In]= 0 AND Status LIKE '%lunch%' ORDER BY [Order] 
			-- No lunch status
			IF @in_out_status_id IS NULL AND @lunch = 0 SELECT TOP 1 @in_out_status_id = StatusID FROM InOutStatus WHERE [In]= 0 AND Status NOT LIKE '%lunch%' ORDER BY [Order] 
			-- Any out status
			IF @in_out_status_id IS NULL SELECT TOP 1 @in_out_status_id = StatusID FROM InOutStatus WHERE [In]= 0 ORDER BY [Order]
		END
	END
	
	IF @in_out_status_id IS NOT NULL EXEC dbo.spEmployeeUpdateInOutStatus @employee_id, @in_out_status_id, '', NULL, @source
END
GO
IF OBJECT_ID('dbo.spErrorRaiseNoPermission') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spErrorRaiseNoPermission @attribute_id int,@permission_mask int,@employee_id int = NULL AS'
GO
CREATE PROC dbo.spEmployeeTimeInsert
	@employee_id int,
	@in smalldatetime,
	@out smalldatetime,
	@item_id int OUT,
	@employee_comment varchar(50) = '',
	@project_id int = NULL,
	@change_status bit = 1,
	@source varchar(50) = '',
	@time_type_id int = NULL,
	@gmt_hours int = NULL
AS
DECLARE @authorized bit
DECLARE @type_id int
DECLARE @approved_status_id int, @attribute int

IF @employee_comment IS NULL SET @employee_comment = ''

SELECT 
@attribute=CASE WHEN [Column Mask] & 2 = 2 THEN 262144 ELSE 262145 END,
@approved_status_id=CASE WHEN [Column Mask] & 2 = 2 THEN 8 ELSE 1 END
FROM Employee E
INNER JOIN TimeSchema T ON E.EmployeeID=@employee_id AND E.TimeSchemaID=T.TimeSchemaID

DECLARE @audit_text varchar(400)

EXEC dbo.spPermissionGetOnPersonForCurrentUser2 @employee_id, @attribute, 4, @authorized out
IF @authorized = 0
BEGIN
	IF @attribute=262145 RAISERROR('You lack permission to create pre-approved timecard entries. An administrator needs to change your time schema (Timecards > Schemas) and click the "Require manager approval" checkbox. Or, if a manager does not need to approve your timecard, an administrator needs to grant you RWC- or RWCD permission on "Timecard Entries, Approved" (Company > Security).', 16, 1)
	EXEC dbo.spErrorRaiseNoPermission @attribute, 4
END

IF @authorized = 1
BEGIN
	EXEC dbo.spEmployeeTimeInsert3 @employee_id, @in, @out, @item_id OUT, @employee_comment, @project_id, @change_status, @source, @time_type_id, @gmt_hours, @approved_status_id, NULL
END
GO
GRANT EXEC ON dbo.spEmployeeTimeInsert TO public
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spEmployeeTimeBreak', 0
GO
ALTER PROC dbo.spEmployeeTimeBreak
	@schema_id int,
	@shift_id int,
	@in datetime,
	@out smalldatetime,
	@seconds int OUT,
	@change_out_time_for_breaks bit
AS
SET NOCOUNT ON

DECLARE @day int, @shift_start_day int, @dayson int, @daysoff int, @dayson2 int, @daysoff2 int, @day_of_shift int

SELECT
@day = DATEDIFF(d,0,@in),
@shift_start_day = [Start Day past 1900],
@dayson = [Days On],
@daysoff = [Days Off],
@dayson2 = DaysOn2,
@daysoff2 = DaysOff2
FROM dbo.Shift WHERE ShiftID=@shift_id

SELECT @day_of_shift = dbo.fnGetShiftDay(@day, @shift_id, @shift_start_day, @dayson, @daysoff, @dayson2, @daysoff2)

DECLARE @out_midnight datetime, @in_midnight datetime, @in_seconds int, @out_seconds int, @total_break_seconds int

SELECT @out_midnight = CAST(@out AS varchar(11)), @in_midnight = CAST(@in AS varchar(11)),
@in_seconds=DATEPART(hh,@in)*3600 + DATEPART(m,@in)*60 + DATEPART(s,@in)

SELECT @out_seconds=DATEDIFF(second,@in_midnight,@out_midnight) + DATEPART(hh,@out)*3600 + DATEPART(m,@out)*60 + DATEPART(s,@out)

CREATE TABLE #BreakB0629(ItemID int IDENTITY(1,1), [In] datetime, [Out] datetime, [Next In] datetime)

INSERT #BreakB0629([In], [Out], [Next In])
SELECT [In]=NULL, [Out]=DATEADD(s,[Break Start],@in_midnight), [Next In]=DATEADD(s,[Break Start]+[Break Seconds],@in_midnight) FROM dbo.TimeSchemaBreak
WHERE TimeSchemaID=@schema_id AND @in_seconds <= Start AND @out_seconds >= (Start + Seconds)
ORDER BY [Break Start]

INSERT #BreakB0629([In], [Out], [Next In])
SELECT [In]=NULL, [Out]=DATEADD(s,[Break Start],@in_midnight), [Next In]=DATEADD(s,[Break Start]+[Break Seconds],@in_midnight) FROM dbo.ShiftBreak
WHERE ShiftID=@shift_id AND @in_seconds <= Start AND @out_seconds >= (Start + Seconds) AND (
	[Day of Shift] IS NULL OR [Day of Shift] = @day_of_shift
)
ORDER BY [Break Start]

/*INSERT #BreakB0629([In], [Out], [Next In])
SELECT [In]=NULL, [Out]=DATEADD(s,[Lunch Start],@in_midnight), [Next In]=DATEADD(s,[Lunch Start]+[Lunch Seconds],@in_midnight) FROM dbo.Shift
WHERE ShiftID=@shift_id AND (Flags & 0x10) = 0x10 AND @in_seconds <= [Lunch Start] - 1800 AND @out_seconds >= [Lunch Start]+[Lunch Seconds] + 1800
ORDER BY [Lunch Start]*/

INSERT #BreakB0629([In], [Out], [Next In])
SELECT [In]=NULL, [Out]=DATEADD(s,[Lunch Start],@in_midnight), [Next In]=DATEADD(s,[Lunch Start]+[Lunch Seconds],@in_midnight) FROM dbo.ShiftSchedule
WHERE ShiftID=@shift_id AND (Flags & 0x10) = 0x10 AND @in_seconds <= [Lunch Start] - 1800 AND @out_seconds >= [Lunch Start]+[Lunch Seconds] + 1800 AND [Day of Shift] = @day_of_shift
ORDER BY [Lunch Start]

DECLARE @last_id int
SET @last_id = SCOPE_IDENTITY()

UPDATE #BreakB0629 SET [In]=T2.[Next In] FROM #BreakB0629 INNER JOIN #BreakB0629 T2 ON #BreakB0629.ItemID=T2.ItemID+1

IF @change_out_time_for_breaks = 1 SET @total_break_seconds = ISNULL((SELECT SUM(DATEDIFF(d,[Out],[Next In])) FROM #BreakB0629),0)
ELSE SET @total_break_seconds = 0


SELECT [In], Seconds=DATEDIFF(s,[In],[Out]) FROM #BreakB0629 WHERE ItemID>1
UNION ALL
SELECT [Next In], Seconds=DATEDIFF(s,[Next In],@out) + @total_break_seconds FROM #BreakB0629 WHERE ItemID=@last_id
ORDER BY [In]

IF @@ROWCOUNT=0 SELECT @seconds=DATEDIFF(s,@in,@out)
ELSE SELECT @seconds=DATEDIFF(s,@in,[Out]) FROM #BreakB0629 WHERE ItemID=1
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spEmployeeTimeUpdateOutNoPermissionCheck', 0
GO
ALTER PROC dbo.spEmployeeTimeUpdateOutNoPermissionCheck
	@out smalldatetime,
	@item_id int,
	@employee_comment varchar(50) = '',
	@project_id int = null,
	@change_status bit = 1,
	@source varchar(50)='',
	@time_type_id int = NULL,
	@change_out_time_for_breaks bit = 0,
	@ppe_day int = NULL
AS
DECLARE @in smalldatetime, @attribute int, @gmt_hours int
DECLARE @employee_id int, @approval_status_id int, @max_shift_seconds int



IF @employee_comment IS NULL SET @employee_comment = ''

SELECT @gmt_hours = [GMT+Hours], @employee_id = EmployeeID, @in = [In], @approval_status_id = StatusID FROM EmployeeTime WHERE ItemID = @item_id

-- Sets status to approved if manager approval is not required
DECLARE @schema_id int, @shift_id int
SELECT @shift_id=E.ShiftID, @schema_id=E.TimeSchemaID, @approval_status_id = CASE WHEN (TS.[Column Mask] & 2) = 2 THEN 8 ELSE 1 END FROM Employee E
INNER JOIN dbo.TimeSchema TS ON E.TimeSchemaID=TS.TimeSchemaID AND E.EmployeeID=@employee_id

IF @ppe_day IS NULL 
BEGIN
	DECLARE @shift_2nd bit
	SELECT @shift_2nd = Flags & 2048 FROM dbo.Shift S INNER JOIN dbo.Employee E ON E.EmployeeID = @employee_id AND E.ShiftID = S.ShiftID
	IF @shift_2nd = 1 SET @ppe_day = DATEDIFF(d,0,DATEADD(hour,-9,@out))
END

-- Checks for missed punch
SELECT @max_shift_seconds = [Max Shift Seconds] FROM dbo.Constant
IF DATEDIFF(second, @in, @out) < @max_shift_seconds
BEGIN
	DECLARE @seconds int

	DECLARE @batch_id int
	SELECT @batch_id = RAND() * 2147483647

	INSERT TempXYZ(BatchID, [ID], X, Y, Z, I)
	SELECT @batch_id, EmployeeID, [In Day past 1900], DATEDIFF(s, [In Day past 1900], [In]), DATEDIFF(s, [In Day past 1900], [In]) + Seconds, ItemID
	FROM dbo.vwEmployeeTime WHERE EmployeeID=@employee_id AND [In Day past 1900] = DATEDIFF(d,0,@in) AND ItemID <> @item_id

	INSERT TempXYZ(BatchID, [ID], X, Y, Z, I, N)
	SELECT @batch_id, EmployeeID, [In Day past 1900], DATEDIFF(s, [In Day past 1900], [In]), DATEDIFF(s, [In Day past 1900], @out), ItemID, @employee_comment
	FROM dbo.vwEmployeeTime WHERE ItemID = @item_id

	EXEC dbo.spEmployeeTimeRound @batch_id, 0

	SELECT @seconds = X.Z - X.Y, @out = DATEADD(s,X.Z,X.X), @employee_comment = X.N
	FROM EmployeeTime T
	INNER JOIN TempXYZ X ON X.BatchID=@batch_id AND X.[I]=T.ItemID AND T.ItemID=@item_id

	DELETE TempXYZ WHERE BatchID=@batch_id OR DATEDIFF(hour,Created,GETDATE()) > 1

	CREATE TABLE #NewTimecardEntries0629([In] datetime, Seconds int)
	INSERT #NewTimecardEntries0629
	EXEC dbo.spEmployeeTimeBreak @schema_id, @shift_id, @in, @out, @seconds OUT, @change_out_time_for_breaks

	IF EXISTS(SELECT * FROM #NewTimecardEntries0629)
	BEGIN
		DECLARE @d int, @default_time_type_id int, @pay_rate smallmoney, @billing_rate smallmoney
		SELECT @d = DATEDIFF(d, 0, @in)

		DECLARE @fixed_pay money, @fixed_billing money
		EXEC dbo.spEmployeeRateSelect2 @employee_id, @project_id, @time_type_id, @d, @pay_rate OUT, @billing_rate OUT, @default_time_type_id OUT, @fixed_pay OUT, @fixed_billing OUT
		IF @time_type_id IS NULL SET @time_type_id = @default_time_type_id

		INSERT EmployeeTime(EmployeeID, [In], Seconds, StatusID, [Pay Rate], [Billing Rate], TypeID, [Employee Comment], ProjectID, SourceIn, [PPE Day past 1900], [Fixed Pay], [Fixed Billing], [GMT+Hours])
		SELECT @employee_id, [In], Seconds, @approval_status_id, @pay_rate, @billing_rate, @time_type_id, @employee_comment, @project_id, @source, @ppe_day, @fixed_pay, @fixed_billing, @gmt_hours FROM #NewTimecardEntries0629
	END

	UPDATE T SET 
	Seconds = @seconds,
	[Last Updated User] = SUSER_SNAME(),
	[Last Updated Day past 1900] = DATEDIFF(d, 0, GETDATE()),
	ProjectID = @project_id,
	SourceOut = @source,
	[Employee Comment] = @employee_comment
	FROM EmployeeTime T WHERE T.ItemID=@item_id

	DELETE TempXYZ WHERE BatchID=@batch_id OR DATEDIFF(hour,Created,GETDATE()) > 1

	-- Change status to out
	IF @change_status = 1
	BEGIN
		DECLARE @in_out_status_id int, @delta_last_punch_this_punch int, @lunch bit

		SELECT TOP 1 @delta_last_punch_this_punch = DATEDIFF(second,[In],@out) FROM dbo.EmployeeTime WHERE EmployeeID=@employee_id AND DATEDIFF(d,0, [In]) = DATEDIFF(d,0,@out) ORDER BY [In]
		SELECT @lunch = CASE WHEN @delta_last_punch_this_punch IS NOT NULL AND @delta_last_punch_this_punch < 18000 THEN 1 ELSE 0 END

		SELECT @in_out_status_id = NULL

		-- Project status
		SELECT TOP 1 @in_out_status_id = OutStatusID FROM dbo.Project WHERE ProjectID=@project_id
		-- Lunch status
		IF @in_out_status_id IS NULL AND @lunch = 1 SELECT TOP 1 @in_out_status_id = StatusID FROM InOutStatus WHERE [In]= 0 AND Status LIKE '%lunch%' ORDER BY [Order] 
		-- No lunch status
		IF @in_out_status_id IS NULL AND @lunch = 0 SELECT TOP 1 @in_out_status_id = StatusID FROM InOutStatus WHERE [In]= 0 AND Status NOT LIKE '%lunch%' ORDER BY [Order] 
		-- Any out status
		IF @in_out_status_id IS NULL SELECT TOP 1 @in_out_status_id = StatusID FROM InOutStatus WHERE [In]= 0 ORDER BY [Order]
		IF @in_out_status_id IS NOT NULL EXEC dbo.spEmployeeUpdateInOutStatus @employee_id, @in_out_status_id, '', NULL, @source
	END
END
ELSE	
BEGIN
	SET @in = DATEADD(mi, 1, @in)
	UPDATE EmployeeTime SET Seconds = 1 WHERE ItemID = @item_id

	-- spEmployeeTimeInsert will handle audit recording for this case
	EXEC dbo.spEmployeeTimeInsert3 @employee_id=@employee_id, @in=@out, @out=NULL, @item_id=NULL, @employee_comment=@employee_comment, @project_id=@project_id, @change_status=@change_status, @source=@source, @time_type_id=@time_type_id, @gmt_hours=@gmt_hours, @status_id=@approval_status_id, @ppe_day = @ppe_day
END
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spEmployeeTimeUpdateOut'
GO
ALTER PROC dbo.spEmployeeTimeUpdateOut
	@out smalldatetime,
	@item_id int,
	@employee_comment varchar(50) = '',
	@project_id int = null,
	@change_status bit = 1,
	@source varchar(50)='',
	@time_type_id int = NULL,
	@change_out_time_for_breaks bit = 0
AS
DECLARE @attribute int, @employee_id int, @approval_status_id int, @authorized bit

SELECT @employee_id = EmployeeID, @approval_status_id = StatusID FROM EmployeeTime WHERE ItemID = @item_id

SELECT @attribute = CASE WHEN StatusID = 8 AND @approval_status_id = 8 THEN 262144 ELSE 262145 END, 
@employee_id = EmployeeID 
FROM dbo.EmployeeTime WHERE ItemID = @item_id

EXEC dbo.spPermissionInsureForCurrentUserOnPerson @employee_id, @attribute, 2, @authorized out

IF @authorized = 1 EXEC dbo.spEmployeeTimeUpdateOutNoPermissionCheck @out, @item_id, @employee_comment, @project_id, @change_status, @source, @time_type_id, @change_out_time_for_breaks, NULL
GO
IF OBJECT_ID('dbo.EmployeeFlagTerminalSyncOnUpdate') IS NOT NULL DROP TRIGGER dbo.EmployeeFlagTerminalSyncOnUpdate
GO
CREATE TRIGGER dbo.EmployeeFlagTerminalSyncOnUpdate ON dbo.Employee FOR UPDATE
AS
/*
Terminal Sync State Mask
public enum TerminalUserSyncStateMaskEnum
	{
		PushDbEmployeeNameToEnrolledTerminals = 1,
		PushDbCardNumberToEnrolledTerminals = 2,
		PushDbPasswordPrivilegeEnabledToEnrolledTerminals = 4,
		PushDbFingerprintsToEnrolledTerminals = 8,
		DropUserFromTerminal = 0x10,
		DbTerminalEnrollmentMaskChanged = 0x20,
		PullMasterTerminalFingerprintsToDb = 0x40,
		PullMasterTerminalCardNumberToDb = 0x80
	}
*/

-- Schedule re-activated employee to be enrolled in terminal
IF UPDATE([Active Employee]) UPDATE E SET 
[Terminal Sync State Mask] = (E.[Terminal Sync State Mask] | 0x2F),
TerminalSyncFlags = (I.TerminalSyncFlags & 0x7FFFFFF7) | 4 -- Uncheck "remove from all terminals" and check "enroll in all terminals"
FROM dbo.Employee E
INNER JOIN inserted I on E.EmployeeID = I.EmployeeID
INNER JOIN deleted D ON E.EmployeeID = D.EmployeeID AND 
D.[Active Employee] = 0 AND I.[Active Employee] = 1 AND
(I.[TerminalSyncFlags] & 0x21) = 0x21 AND -- User is set to sync (1) and be enrolled when employee is activated (0x10)
(E.[Terminal Sync State Mask] & 0x2F) != 0x2F

-- Schedule inactivated employee to be removed from terminal
IF UPDATE([Active Employee]) UPDATE E SET 
[Terminal Sync State Mask] = E.[Terminal Sync State Mask] | 0x10,
TerminalSyncFlags = (I.TerminalSyncFlags & 0x7FFFFFFB) | 8 -- Uncheck "enroll in all terminals" and check "remove from all terminals"
FROM dbo.Employee E
INNER JOIN inserted I on E.EmployeeID = I.EmployeeID
INNER JOIN deleted D ON E.EmployeeID = D.EmployeeID AND 
D.[Active Employee] = 1 AND I.[Active Employee] = 0 AND
(I.[TerminalSyncFlags] & 0x11) = 0x11 AND -- User is set to sync (1) and be removed when employee is inactivated (0x10)
(E.[Terminal Sync State Mask] & 0x10) != 0x10

-- Raise DropUserFromTerminal
IF UPDATE([TerminalSyncFlags]) UPDATE E SET 
[Terminal Sync State Mask] = E.[Terminal Sync State Mask] | 0x10
FROM dbo.Employee E
INNER JOIN inserted I on E.EmployeeID = I.EmployeeID
INNER JOIN deleted D ON E.EmployeeID = D.EmployeeID AND 
(I.TerminalSyncFlags & 9) = 9 AND (D.TerminalSyncFlags & 8) = 0 AND -- User is set to sync (1) and be removed (8)
(E.[Terminal Sync State Mask] & 0x10) != 0x10

-- Raise PushDbCardNumberToEnrolledTerminals
IF UPDATE([PID Card Number]) UPDATE E SET
[Terminal Sync State Mask] = E.[Terminal Sync State Mask] | 2
FROM dbo.Employee E
INNER JOIN inserted I on E.EmployeeID = I.EmployeeID
INNER JOIN deleted D ON E.EmployeeID = D.EmployeeID AND
I.[PID Card Number] != D.[PID Card Number] AND
(I.[TerminalSyncFlags] & 1) = 1 AND -- User is set to sync (1)
(E.[Terminal Sync State Mask] & 2) != 2

-- Raise PushDbPasswordPrivilegeEnabledToEnrolledTerminals
IF UPDATE([Terminal Password]) OR UPDATE([TerminalSyncFlags2]) OR UPDATE([TerminalSyncFlags]) UPDATE E SET
[Terminal Sync State Mask] = E.[Terminal Sync State Mask] | 4
FROM dbo.Employee E
INNER JOIN inserted I on E.EmployeeID = I.EmployeeID
INNER JOIN deleted D ON E.EmployeeID = D.EmployeeID AND
(
	I.[Terminal Password] != D.[Terminal Password] OR 
	I.TerminalSyncFlags2 != D.TerminalSyncFlags2 OR
	(I.TerminalSyncFlags & 2) != (D.TerminalSyncFlags & 2) -- Enable changed
) AND
(I.[TerminalSyncFlags] & 1) = 1 AND -- User is set to sync (1)
(E.[Terminal Sync State Mask] & 4) != 4

-- Raise DbTerminalEnrollmentMaskChanged
IF UPDATE([Enrolled Terminals Mask]) OR UPDATE(TerminalSyncFlags) UPDATE E SET
[Terminal Sync State Mask] = E.[Terminal Sync State Mask] | 0x20
FROM dbo.Employee E
INNER JOIN inserted I on E.EmployeeID = I.EmployeeID
INNER JOIN deleted D ON E.EmployeeID = D.EmployeeID AND
(
	((E.TerminalSyncFlags & 12) = 0 AND I.[Enrolled Terminals Mask] != D.[Enrolled Terminals Mask])  OR
	(I.TerminalSyncFlags & 12) != (D.TerminalSyncFlags & 12)
	
) AND (I.[TerminalSyncFlags] & 1) = 1 AND -- User is set to sync (1)
(E.[Terminal Sync State Mask] & 0x20) != 0x20

/* 
	TerminalSyncFlags
	public enum TerminalUserSyncFlagEnum
	{
		SynchUser = 1,
		EnableUserOnEnrolledTerminals = 2,
		EnrollUserOnAllTerminals = 4,
		RemoveUserFromAllTerminals = 8,
		RemoveUserFromAllTerminalsWhenInactivated = 0x10,
		EnrollUserOnAllTerminalsWhenReactivated = 0x20
	}
*/
GO
IF OBJECT_ID('dbo.PersonFlagTerminalSyncOnUpdate') IS NOT NULL DROP TRIGGER dbo.PersonFlagTerminalSyncOnUpdate
GO
CREATE TRIGGER dbo.PersonFlagTerminalSyncOnUpdate ON dbo.Person FOR UPDATE
AS
/*
Terminal Sync State Mask
public enum TerminalUserSyncStateMaskEnum
	{
		PushDbEmployeeNameToEnrolledTerminals = 1,
		PushDbCardNumberToEnrolledTerminals = 2,
		PushDbPasswordPrivilegeEnabledToEnrolledTerminals = 4,
		PushDbFingerprintsToEnrolledTerminals = 8,
		DropUserFromTerminal = 0x10,
		DbTerminalEnrollmentMaskChanged = 0x20,
		PullMasterTerminalFingerprintsToDb = 0x40,
		PullMasterTerminalCardNumberToDb = 0x80
	}
*/

-- Schedule name change to be pushed to terminal
IF UPDATE([First Name]) OR UPDATE([Last Name]) OR UPDATE([Middle Name]) OR UPDATE(Suffix)
UPDATE E SET 
[Terminal Sync State Mask] = E.[Terminal Sync State Mask] | 1
FROM dbo.Employee E
INNER JOIN inserted I on E.EmployeeID = I.PersonID
INNER JOIN deleted D ON E.EmployeeID = D.PersonID AND 
(E.[TerminalSyncFlags] & 1) = 1 AND -- User is set to sync (1)
(E.[Terminal Sync State Mask] & 0xF) != 0xF


/* 
	TerminalSyncFlags
	public enum TerminalUserSyncFlagEnum
	{
		SynchUser = 1,
		EnableUserOnEnrolledTerminals = 2,
		EnrollUserOnAllTerminals = 4,
		RemoveUserFromAllTerminals = 8,
		RemoveUserFromAllTerminalsWhenInactivated = 0x10,
		EnrollUserOnAllTerminalsWhenReactivated = 0x20
	}
*/
GO
CREATE TRIGGER dbo.CustomFieldItemMarkFieldDirtyOnChange ON dbo.CustomFieldItem FOR INSERT,UPDATE,DELETE AS 
UPDATE dbo.CustomField SET [Dirty]=1 WHERE FieldID IN (SELECT FieldID FROM inserted) OR FieldID IN (SELECT FieldID FROM deleted)
GO
CREATE TRIGGER dbo.EmployeeCreateBlankEmployeeBenefitOnInsert ON dbo.Employee FOR INSERT
AS
INSERT dbo.EmployeeBenefit(
	EmployeeID,
	BenefitID,
	[Employee Premium],
	[Employer Premium],
	[Expires Day past 1900],
	[Eligible Day past 1900],
	[Notified Day past 1900],
	[First Enrolled Day past 1900],
	[Last Enrolled Day past 1900],
	[Declined Day past 1900],
	Note,
	[Group Policy Number],
	[Individual Policy Number],
	Coverage,
	[Plan],
	Provider,
	[Wait List Queue],
	[Wait List Day past 1900],
	[Other Premium]
)
SELECT
E.EmployeeID,
B.BenefitID,
0, -- [Employee Premium]
0, -- [Employer Premium]
NULL, -- [Expires Day past 1900]
NULL, -- [Eligible Day past 1900]
NULL, -- [Notified Day past 1900]
NULL, -- [First Enrolled Day past 1900]
NULL, -- [Last Enrolled Day past 1900]
NULL, -- [Declined Day past 1900]
'', -- Note
'', -- [Group Policy Number]
'', -- [Individual Policy Number]
'', -- Coverage
'', -- [Plan]
'', -- Provider
NULL, -- [Wait List Queue]
NULL, -- [Wait List Day past 1900]
0 -- Other premium
FROM inserted E CROSS JOIN dbo.Benefit B
GO
IF OBJECT_ID('dbo.spEmployeeTimeGetDefaults') IS NOT NULL DROP PROC dbo.spEmployeeTimeGetDefaults
GO
CREATE PROC dbo.spEmployeeTimeGetDefaults
	@employee_id int,
	@project_id int OUT,
	@time_type_id int OUT
AS
SET @project_id = NULL
SELECT TOP 1 @project_id=EP.ProjectID, @time_type_id=P.DefaultTimeTypeID FROM dbo.EmployeeProject EP
INNER JOIN Project P ON EP.ProjectID=P.ProjectID AND (Flags&1)=1 AND EmployeeID=@employee_id ORDER BY EP.[Start Day past 1900] DESC

IF @time_type_id IS NULL SELECT TOP 1 @time_type_id=TypeID FROM dbo.vwTimeType WHERE Regular=1
IF @time_type_id IS NULL SELECT TOP 1 @time_type_id=TypeID FROM dbo.vwTimeType
GO
GRANT EXEC ON dbo.spEmployeeTimeGetDefaults TO public
GO
IF OBJECT_id('dbo.spEmployeeRateSelect2') IS NOT NULL DROP PROC dbo.spEmployeeRateSelect2
GO
CREATE PROC dbo.spEmployeeRateSelect2
	@employee_id int, -- Nullable
	@project_id int, -- Nullable
	@time_type_id int, -- Nullable
	@day int,
	@pay_rate smallmoney OUT, 
	@billing_rate smallmoney OUT,
	@default_time_type_id int = NULL OUT,
	@fixed_pay smallmoney = NULL OUT,
	@fixed_billing smallmoney = NULL OUT
AS
DECLARE @paym smallmoney, @payb smallmoney, @billm smallmoney, @billb smallmoney

SELECT @pay_rate = NULL, @billing_rate = NULL, @default_time_type_id = NULL, @paym = 1, @payb = 0, @billm = 1, @billb = 0

IF @employee_id IS NOT NULL
BEGIN
	SELECT @default_time_type_id = DefaultTimeTypeID FROM Employee WHERE EmployeeID = @employee_id
	IF @time_type_id IS NULL SELECT @time_type_id = @default_time_type_id
END
IF @time_type_id IS NOT NULL SELECT @fixed_pay = [Fixed Pay], @fixed_billing = [Fixed Billing], @pay_rate = [Pay Rate], @paym = PayRateM, @payb = PayRateB, @billing_rate = [Billing Rate], @billm = BillingRateM, @billb = BillingRateB FROM TimeType WHERE TypeID = @time_type_id

IF @employee_id IS NOT NULL
BEGIN
	IF @project_id IS NOT NULL SELECT @pay_rate = CASE WHEN @pay_rate IS NULL THEN [Inherited Pay Rate] ELSE @pay_rate END,
	@billing_rate = CASE WHEN @billing_rate IS NULL THEN [Inherited Billing Rate] ELSE @billing_rate END,
	@fixed_pay = CASE WHEN @fixed_pay IS NULL THEN [Inherited Fixed Pay] ELSE @fixed_pay END,
	@fixed_billing = CASE WHEN @fixed_billing IS NULL THEN [Inherited Fixed Billing] ELSE @fixed_pay END
	FROM dbo.vwEmployeeProject WHERE EmployeeID = @employee_id AND ProjectID = @project_id
END

IF @project_id IS NOT NULL
BEGIN
	SELECT @pay_rate = CASE WHEN @pay_rate IS NULL THEN [Pay Rate] ELSE @pay_rate END,
	@billing_rate = CASE WHEN @billing_rate IS NULL THEN [Billing Rate] ELSE @billing_rate END,
	@fixed_pay = CASE WHEN @fixed_pay IS NULL THEN [Fixed Pay] ELSE @fixed_pay END,
	@fixed_billing = CASE WHEN @fixed_billing IS NULL THEN [Fixed Billing] ELSE @fixed_pay END
	FROM Project WHERE ProjectID = @project_id
END

IF @employee_id IS NOT NULL
BEGIN
	IF @pay_rate IS NULL SELECT TOP 1 @pay_rate = C.[Hourly Pay] FROM vwEmployeeCompensation C WHERE C.EmployeeID = @employee_id AND dbo.DoesRayContain(C.[Start Day past 1900], C.[Stop Day past 1900], @day) = 1
	IF @billing_rate IS NULL SELECT @billing_rate = E.[Billing Rate] FROM Employee E WHERE E.EmployeeID = @employee_id
END


SELECT @pay_rate = 0 WHERE @pay_rate IS NULL
SELECT @billing_rate = 0 WHERE @billing_rate IS NULL
SELECT @fixed_pay = 0 WHERE @fixed_pay IS NULL
SELECT @fixed_billing = 0 WHERE @fixed_billing IS NULL

SELECT @pay_rate = @pay_rate * @paym + @payb, @billing_rate = @billing_rate * @billm + @billb
GO
GRANT EXEC ON dbo.spEmployeeRateSelect2 TO public
GO
IF OBJECT_id('dbo.spEmployeeTimeUpdate') IS NOT NULL DROP PROC dbo.spEmployeeTimeUpdate
GO
CREATE PROC dbo.spEmployeeTimeUpdate
	@in smalldatetime,
	@out smalldatetime,
	@item_id int,
	@source varchar(50) = ''
AS
DECLARE @employee_id int
DECLARE @authorized bit
DECLARE @more_info nvarchar(MAX)

SET @more_info = CASE WHEN @in IS NULL THEN 'NULL' ELSE CAST(@in as nvarchar(50)) END + ' to ' + CASE WHEN @out IS NULL THEN 'Unspecified' ELSE CAST(@out as nvarchar(50)) END
SELECT @employee_id = EmployeeID FROM EmployeeTime WHERE ItemID = @item_id
EXEC dbo.spPermissionInsureForCurrentUserOnPerson @employee_id, 262145, 2, @authorized out, @more_info

IF @authorized = 1
UPDATE EmployeeTime SET
	[In] = @in,
	Seconds = CASE WHEN @out IS NULL THEN 0 ELSE DATEDIFF(s, @in, @out) END,
	[Last Updated User] = SUSER_SNAME(),
	[Last Updated Day past 1900] = DATEDIFF(d, 0, GETDATE()),
	SourceOut = @source
WHERE ItemID = @item_id
GO
GRANT EXEC ON dbo.spEmployeeTimeUpdate TO public
GO
IF OBJECT_ID('dbo.Break') IS NOT NULL DROP TABLE dbo.[Break]
GO
IF OBJECT_ID('dbo.spEmployeeTimePunch') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEmployeeTimePunch AS'
	GRANT EXEC ON dbo.spEmployeeTimePunch TO public
END
GO
ALTER PROC dbo.spEmployeeTimePunch
	@employee_id int, @time smalldatetime, @source varchar(50), @project_id int, @time_type_id int,
	@change_status bit = 1, @employee_comment varchar(50) = NULL, 
	@ignored_in_out smallint = 0 out, -- returns actual action taken: 0 no punches recorded (debounce), 1 in recorded, 2 out recorded, 3 in and out recorded (project changed)
	@gmt_hours int = NULL, @force_in_out smallint = 0,
	@employee_comment_append varchar(50) = '', @ppe_day int = NULL
AS
DECLARE @authorized bit, @default_project_id int, @terminal varchar(50), @new_project_id int, @item_id int, @in datetime, @last_project_id int
DECLARE @employee_shift_length int, @in_plus_shift_length datetime, @status_id int, @debounce_minutes int, @max_shift_seconds int, @flags int
DECLARE @shift_start_seconds int, @shift_stop_seconds int, @shift_2nd bit, @shift_id int
DECLARE @ignore_shift_when_deciding_if_punch_missed bit


-- Checks for write permission on either timecards pending or timecard punch
EXEC dbo.spPermissionGetOnPersonForCurrentUser2 @employee_id, 262144, 2, @authorized out
IF @authorized = 0 EXEC dbo.spPermissionInsureForCurrentUserOnPerson @employee_id, 262143, 2, @authorized out

SELECT TOP 1 @max_shift_seconds = [Max Shift Seconds], @debounce_minutes = [Debounce Minutes],  @flags = Flags FROM dbo.Constant
SELECT @ignore_shift_when_deciding_if_punch_missed = @flags & 0x40000000

IF @authorized=1
BEGIN

	SELECT @new_project_id = @project_id, @ignored_in_out = 0

	SELECT 
	@status_id=CASE WHEN [Column Mask] & 2 = 2 THEN 8 ELSE 1 END
	FROM dbo.Employee E
	INNER JOIN dbo.TimeSchema T ON E.EmployeeID=@employee_id AND E.TimeSchemaID=T.TimeSchemaID

	IF @new_project_id IS NULL OR @time_type_id IS NULL
	BEGIN
		DECLARE @default_time_type_id int
		EXEC dbo.spEmployeeTimeGetDefaults @employee_id, @default_project_id OUT, @default_time_type_id OUT
		IF @time_type_id IS NULL SET @time_type_id = @default_time_type_id
	END

	SELECT @shift_id = E.ShiftID, @shift_2nd = Flags & 2048 FROM dbo.Shift S INNER JOIN dbo.Employee E ON E.EmployeeID = @employee_id AND E.ShiftID = S.ShiftID

	DECLARE @day int, @shift_start_day int, @dayson int, @daysoff int, @dayson2 int, @daysoff2 int, @day_of_shift int

	SELECT
	@day = DATEDIFF(d,0,@in),
	@shift_start_day = [Start Day past 1900],
	@dayson = [Days On],
	@daysoff = [Days Off],
	@dayson2 = DaysOn2,
	@daysoff2 = DaysOff2,
	@shift_start_seconds = [Start Seconds], @shift_stop_seconds = [Stop Seconds] 
	FROM dbo.Shift WHERE ShiftID=@shift_id

	SELECT @day_of_shift = dbo.fnGetShiftDay(@day, @shift_id, @shift_start_day, @dayson, @daysoff, @dayson2, @daysoff2)

	IF @ignore_shift_when_deciding_if_punch_missed = 0 SELECT @shift_start_seconds = [Start Seconds], @shift_stop_seconds = [Stop Seconds] FROM dbo.ShiftSchedule WHERE ShiftID=@shift_id AND [Day of Shift] = @day
	ELSE  SELECT @shift_start_seconds = 0, @shift_stop_seconds = 0

	SELECT TOP 1 @employee_shift_length=[Effective Seconds per Day] FROM dbo.vwEmployeeEffectiveSecondsPerDay WHERE EmployeeID=@employee_id
	IF @ppe_day IS NULL
	BEGIN
		IF @shift_2nd = 1 AND DATEPART(hour, @time) < 9 SET @ppe_day = DATEDIFF(d,0,@time) - 1 ELSE SET @ppe_day = DATEDIFF(d,0,@time)
	END

	DECLARE @exists bit, @employee_comment_old varchar(50), @employee_comment_insert varchar(50), @employee_comment_update varchar(50)

	-- Find previous clock in within last max_shift_seconds
	SELECT TOP 1 @employee_comment_old = [Employee Comment], @item_id=ItemID, @in=[In], @in_plus_shift_length = DATEADD(second, @employee_shift_length, [In]), @last_project_id=ProjectID FROM dbo.EmployeeTime WHERE EmployeeID=@employee_id AND DATEDIFF(second,[In],@time) BETWEEN 0 AND @max_shift_seconds AND Seconds=0 ORDER BY [In] DESC
	SET @exists = CASE WHEN @@ROWCOUNT > 0 THEN 1 ELSE 0 END
	
	
	SET @employee_comment_insert = ISNULL(@employee_comment, '')
	IF @employee_comment_append IS NOT NULL AND @employee_comment_append <> ''
	BEGIN
		IF LEN(@employee_comment_insert) > 0 SET @employee_comment_insert = @employee_comment_insert + ' '
		SET @employee_comment_insert = @employee_comment_insert + @employee_comment_append
	END
	
	IF @exists=1
	BEGIN
		SET @employee_comment_update = CASE
			WHEN @employee_comment IS NOT NULL AND @employee_comment <> '' THEN @employee_comment
			ELSE @employee_comment_old
		END
		
		IF @employee_comment_append IS NOT NULL AND @employee_comment_append <> ''
		BEGIN
			IF LEN(@employee_comment_update) > 0 SET @employee_comment_update = @employee_comment_update + ' '
			SET @employee_comment_update = @employee_comment_update + @employee_comment_append
		END
	END
	ELSE
	BEGIN
		SET @employee_comment_update = @employee_comment_insert
	END
	
	

	IF @exists=1 AND @force_in_out IN (0, 2)
	BEGIN
		If @new_project_id IS NULL SET @new_project_id = @last_project_id

		-- Debounce. Clock out if there is a previous clock-in (where seconds=0) and (more than @debounce_minutes minute lapsed between clock-in/clock-out or the project changed)
		IF DATEDIFF(second,@in,@time) > 0 AND (DATEDIFF(n,@in,@time) > @debounce_minutes OR dbo.fnNullCompare(@last_project_id, @new_project_id)=0)
		BEGIN	
			DECLARE @zero_out_missed_punch bit, @auto_punch_out_missed_punch bit, @ignore_missed_punch bit
		
			SELECT @zero_out_missed_punch = 0, @auto_punch_out_missed_punch = @flags & 0x200, @ignore_missed_punch = @flags & 0x400
			IF @auto_punch_out_missed_punch = 0 AND @ignore_missed_punch = 0 SET @zero_out_missed_punch = 1


			-- Immediately clock back in if the project changed
			IF dbo.fnNullCompare(@last_project_id, @new_project_id)=0
			BEGIN
				-- As long as less than 15 hours passed
				IF @auto_punch_out_missed_punch=1 AND dbo.fnIsMissedPunch2(@in,@time,NULL,@max_shift_seconds,@shift_start_seconds,@shift_stop_seconds)=1
				BEGIN
					EXEC dbo.spEmployeeTimeUpdateOutNoPermissionCheck @out=@in_plus_shift_length, @item_id=@item_id, @source=@source, @project_id=@last_project_id, @time_type_id=@time_type_id, @change_status=0, @employee_comment=@employee_comment_update, @change_out_time_for_breaks=1, @ppe_day = @ppe_day
					EXEC dbo.spEmployeeTimeInsert3 @employee_id=@employee_id, @in=@time, @out=NULL, @item_id=NULL, @source=@source, @project_id=@new_project_id, @time_type_id=@time_type_id, @change_status=@change_status, @employee_comment=@employee_comment_insert, @gmt_hours = @gmt_hours, @status_id = @status_id, @ppe_day = @ppe_day
					
					SET @ignored_in_out = 3 -- in out
				END
				ELSE IF dbo.fnIsMissedPunch2(@in,@time,NULL,@max_shift_seconds,@shift_start_seconds,@shift_stop_seconds)=1 AND @zero_out_missed_punch=1 
				BEGIN
					EXEC dbo.spEmployeeTimeInsert3 @employee_id=@employee_id, @in=@time, @out=NULL, @item_id=NULL, @source=@source, @project_id=@new_project_id, @time_type_id=@time_type_id, @change_status=@change_status, @employee_comment=@employee_comment_insert, @gmt_hours = @gmt_hours, @status_id = @status_id, @ppe_day = @ppe_day
					SET @ignored_in_out = 1 -- in
				END
				ELSE
				BEGIN
					EXEC dbo.spEmployeeTimeUpdateOutNoPermissionCheck @out=@time, @item_id=@item_id, @source=@source, @project_id=@last_project_id, @time_type_id=@time_type_id, @change_status=0, @employee_comment=@employee_comment_update, @change_out_time_for_breaks=0, @ppe_day = @ppe_day
					EXEC dbo.spEmployeeTimeInsert3 @employee_id=@employee_id, @in=@time, @out=NULL, @item_id=NULL, @source=@source, @project_id=@new_project_id, @time_type_id=@time_type_id, @change_status=@change_status, @employee_comment=@employee_comment_insert, @gmt_hours = @gmt_hours, @status_id = @status_id, @ppe_day = @ppe_day
					SET @ignored_in_out = 3 -- out and in
				END			
			END

			-- Treat punch as a forgotten clock out if more than 15 hours passed
			ELSE IF dbo.fnIsMissedPunch2(@in,@time,NULL,@max_shift_seconds,@shift_start_seconds,@shift_stop_seconds)=1 AND @zero_out_missed_punch = 1
			BEGIN
				EXEC dbo.spEmployeeTimeInsert3 @employee_id=@employee_id, @in=@time, @out=NULL, @item_id=NULL, @source=@source, @project_id=@new_project_id, @time_type_id=@time_type_id, @change_status=@change_status, @employee_comment=@employee_comment_insert, @gmt_hours = @gmt_hours, @status_id = @status_id, @ppe_day = @ppe_day
				SET @ignored_in_out = 1 -- in
			END
			ELSE IF dbo.fnIsMissedPunch2(@in,@time,NULL,@max_shift_seconds,@shift_start_seconds,@shift_stop_seconds)=1 AND @auto_punch_out_missed_punch = 1
			BEGIN
				EXEC dbo.spEmployeeTimeUpdateOutNoPermissionCheck @out=@in_plus_shift_length, @item_id=@item_id, @source=@source, @project_id=@last_project_id, @time_type_id=@time_type_id, @change_status=0, @employee_comment=@employee_comment_update, @change_out_time_for_breaks=1, @ppe_day = @ppe_day
				EXEC dbo.spEmployeeTimeInsert3 @employee_id=@employee_id, @in=@time, @out=NULL, @item_id=NULL, @source=@source, @project_id=@new_project_id, @time_type_id=@time_type_id, @change_status=@change_status, @employee_comment=@employee_comment_insert, @gmt_hours = @gmt_hours, @status_id = @status_id, @ppe_day = @ppe_day
				SET @ignored_in_out = 3 -- in out
			END
			ELSE
			BEGIN
				EXEC dbo.spEmployeeTimeUpdateOutNoPermissionCheck @out=@time, @item_id=@item_id, @source=@source, @project_id=@last_project_id, @time_type_id=@time_type_id, @change_status=@change_status, @employee_comment=@employee_comment_update, @ppe_day = @ppe_day
				SET @ignored_in_out = 2 -- out
			END
		END

		
	END

	-- Create a new EmployeeTime record if no previous clock-in (where seconds=0)
	ELSE IF @force_in_out IN (0, 1)
	BEGIN

		If @new_project_id IS NULL SET @new_project_id = @default_project_id

		-- Debounce. Clock-in if there is no recent clock-out (for the same project)
		IF NOT EXISTS(SELECT * FROM dbo.vwEmployeeTime WHERE EmployeeID=@employee_id AND (
			DATEDIFF(second,[In],@time)=0 OR DATEDIFF(second,[Out],@time)=0 OR
			(dbo.fnNullCompare(ProjectID, @new_project_id)=1 AND (DATEDIFF(n,[Out],@time) BETWEEN 0-@debounce_minutes AND @debounce_minutes or DATEDIFF(n,[In],@time) BETWEEN 0-@debounce_minutes AND @debounce_minutes)
		)))
		BEGIN
			EXEC dbo.spEmployeeTimeInsert3 @employee_id=@employee_id, @in=@time, @out=NULL, @item_id=NULL, @source=@source, @project_id=@new_project_id, @time_type_id=@time_type_id, @change_status=@change_status, @employee_comment=@employee_comment_insert, @gmt_hours=@gmt_hours, @status_id = @status_id, @ppe_day = @ppe_day
			SET @ignored_in_out = 1 -- in
		END
	END

	-- Ignore punch if force_in_out=1 (force out) but there's no previous entry to clock out
	ELSE SET @ignored_in_out = 0
END
GO
IF OBJECT_ID('dbo.spEmployeeTimePunch2') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEmployeeTimePunch2 AS'
	GRANT EXEC ON dbo.spEmployeeTimePunch2 TO public
END
GO
ALTER PROC dbo.spEmployeeTimePunch2
	@must_be_in_group varchar(50) = '',
	@source varchar(50) = '', @project_id int = NULL, @time_type_id int = NULL,
	@change_status bit = 1, @employee_comment varchar(50) = NULL, @ignored_in_out smallint = 0 out, @gmt_hours int = NULL, @force_in_out smallint = 0
AS
SET @ignored_in_out = 0
IF @must_be_in_group IS NULL OR @must_be_in_group = '' OR IS_MEMBER(@must_be_in_group) = 1
BEGIN
	DECLARE @sid varbinary(85), @employee_id int, @time datetime
	SELECT @sid = SUSER_SID(), @time = GETDATE()
	SELECT TOP 1 @employee_id = EmployeeID FROM dbo.Employee WHERE [SID]=@sid
	IF @employee_id IS NOT NULL EXEC dbo.spEmployeeTimePunch
	@employee_id = @employee_id,
	@time=@time, @source=@source, @project_id=@project_id, @time_type_id=@time_type_id,
	@change_status=@change_status, @employee_comment=@employee_comment, @ignored_in_out=@ignored_in_out out, @gmt_hours=@gmt_hours, @force_in_out=@force_in_out
END
GO
IF OBJECT_ID('dbo.spEmployeeTimeZKQProcess2') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEmployeeTimeZKQProcess2 AS'
	GRANT EXEC ON dbo.spEmployeeTimeZKQProcess2 TO public
END
GO
ALTER PROC dbo.spEmployeeTimeZKQProcess2 @flags int = 0 -- 1: no transaction
AS
-- Looks up projectid from work code and stores it in #P
SELECT DISTINCT 
Number=CAST(Number as int), 
ProjectID=NULL 
INTO #P FROM dbo.Project WHERE ISNUMERIC(Number) = 1

UPDATE #P SET ProjectID = (SELECT TOP 1 P.ProjectID FROM dbo.Project P WHERE ISNUMERIC(P.Number)=1 AND CAST(P.Number as int) = #P.Number) FROM #P

-- Makes unique list of projectid\terminalinoutmode in case terminalinoutmode is not unique
SELECT 
ProjectID=MIN(ProjectID), 
TerminalInOutMode
INTO #P2 FROM dbo.Project 
WHERE TerminalInOutMode IS NOT NULL GROUP BY TerminalInOutMode

-- Converts badge # at employeeid, time
SELECT T.ItemID, E.EmployeeID, [Time], T.Terminal, P.ProjectID, P.DefaultTimeTypeID, Terminal.[Source] --, RecordDateTime = CAST(CASE WHEN S.Flags & 2048 = 2048 THEN 1 ELSE 0 END AS bit)
INTO #T
FROM dbo.EmployeeTimeZKQ T
INNER JOIN dbo.Employee E ON T.Imported IS NULL AND dbo.fnNormalizeTerminalEnrollNumber(E.[Employee Number], E.EmployeeID) = dbo.fnTrimLeadingZeros(T.Badge)
INNER JOIN dbo.Shift S ON E.ShiftID = S.ShiftID
LEFT JOIN dbo.Terminal ON Terminal.TerminalID = T.Terminal
LEFT JOIN #P ON T.[Work Code] = #P.[Number]
LEFT JOIN #P2 ON #P.ProjectID IS NULL AND T.[In Out Mode]=#P2.TerminalInOutMode
LEFT JOIN dbo.Project P ON #P.ProjectID=P.ProjectID OR #P2.ProjectID=P.ProjectID

DECLARE @terminal varchar(50), @employee_id int, @time smalldatetime, @project_id int, @time_type_id int, @terminal_source varchar(50) -- @record_date_time bit  @employee_comment_append varchar(50),

-- Import every non-imported EmployeeTimeZKQ record whose badge has a matching employee number and record the success or rollback the whole attempt
IF (@flags & 1) = 0 BEGIN TRAN

-- spEmployeeTimePunch receives @time as a smalldatetime which rounds off seconds. Subtracting 30 seconds effectively makes the [Time] conversion from datetime to smalldatetime truncate. (7:32:30 and 7:32:59 --> 7:32 instead of 7:33)
DECLARE t_cursor CURSOR LOCAL FORWARD_ONLY STATIC FOR SELECT EmployeeID, [Time]=DATEADD(second,-30,[Time]), Terminal, ProjectID, DefaultTimeTypeID, [Source] FROM #T ORDER BY [Time]
OPEN t_cursor
FETCH t_cursor INTO @employee_id, @time, @terminal, @project_id, @time_type_id, @terminal_source

-- Steps through each non-imported EmployeeTimeZKQ record and updates an existing EmployeeTime entry (clock-out) or inserts a new entry (clock-in)
WHILE @@FETCH_STATUS=0
BEGIN
	DECLARE @source varchar(50)
	IF @terminal_source IS NOT NULL AND @terminal_source <> '' SET @source = @terminal_source
	ELSE SET @source = SUBSTRING('Terminal ' + @terminal, 1, 50)

	--IF @record_date_time = 1 SELECT @employee_comment_append = @time, @time = DATEADD(hour,-9, @time)
	--ELSE SET @employee_comment_append = ''

	EXEC dbo.spEmployeeTimePunch @employee_id=@employee_id, @time=@time, @source=@source, @project_id=@project_id, @time_type_id=@time_type_id -- @employee_comment_append=@employee_comment_append

	FETCH t_cursor INTO @employee_id, @time, @terminal, @project_id, @time_type_id, @terminal_source
END

CLOSE t_cursor
DEALLOCATE t_cursor

-- Marks queued entries imported
UPDATE T SET Imported=GETDATE(), EmployeeID=#T.EmployeeID FROM dbo.EmployeeTimeZKQ T INNER JOIN #T ON T.ItemID=#T.ItemID

IF (@flags & 1) = 0 COMMIT TRAN

-- Deletes entries that were imported and are older than 60 days
IF EXISTS(SELECT * FROM EmployeeTimeZKQ WHERE Imported IS NOT NULL AND DATEDIFF(d,[Created],GETDATE()) > 90)
DELETE FROM dbo.EmployeeTimeZKQ WHERE Imported IS NOT NULL AND DATEDIFF(d,[Created],GETDATE()) > 60
GO
-- Imports time from ZK devices into EmployeeTime
CREATE TRIGGER dbo.EmployeeTimeZKQImport ON dbo.EmployeeTimeZKQ FOR INSERT
AS
SET NOCOUNT ON

--IF EXISTS(SELECT * FROM dbo.Constant WHERE EmployeeTimeZKQImportEnable=0) RETURN

EXEC dbo.spEmployeeTimeZKQProcess2
GO
CREATE TRIGGER dbo.LeaveRateCheckPeriod ON LeaveRate FOR INSERT, UPDATE AS
SET NOCOUNT ON
DECLARE @rate_id int
SELECT @rate_id = NULL
SELECT @rate_id = MIN(P2.RateID) FROM inserted P 
INNER JOIN LeaveRate P2 ON P.RateID <> P2.RateID AND P.TypeID=P2.TypeID AND P.PlanID=P2.PlanID AND ((P2.[Start Month] BETWEEN P.[Start Month] AND P.[Stop Month]) OR (P2.[Stop Month] BETWEEN P.[Start Month] And P.[Stop Month]))
GROUP BY P.PlanID, P.TypeID

IF @rate_id IS NOT NULL
BEGIN
	DECLARE @t nvarchar(400)
	SELECT @t = Error FROM Error WHERE ErrorID = 50056
	SELECT @t = @t + N' (RateID=' + CAST(@rate_id AS varchar(50)) + N' Start Month=' + CAST([Start Month] AS varchar(50)) + N' Stop Month=' + CAST([Stop Month] AS varchar(50)) + N').'
	FROM LeaveRate WHERE RateID = @rate_id
	RAISERROR (@t, 16, 1)

	ROLLBACK TRAN
END
GO
CREATE TRIGGER dbo.EmployeeCompensationLogUpdate ON dbo.EmployeeCompensation FOR UPDATE
AS
DECLARE @audit_comp bit

EXEC dbo.spAuditGetOperation 1073741824, 2, @audit_comp OUT
IF @audit_comp=0 RETURN

-- EmployeeID should never change. If it does then two entries are recorded so that a search for either employee will show the change.
INSERT AuditTrail(SID, [User], RegardingPersonID, [ID], ObjectID, TableID, [Event Mask], Event)
SELECT SUSER_SID(), SUSER_SNAME(), D.EmployeeID, I.CompensationID, 1073741824, 1073741824, 2,
'Employment history\comp changed. Employee changed from ' + DP.[List As] + ' to ' + IP.[List As] + '. See audit trail for ' + IP.[List As] + ' for more detail.'
FROM inserted I INNER JOIN deleted D ON I.CompensationID=D.CompensationID AND I.EmployeeID <> D.EmployeeID
INNER JOIN dbo.vwPersonListAs IP ON I.EmployeeID=IP.PersonID
INNER JOIN dbo.vwPersonListAs DP ON D.EmployeeID=DP.PersonID

INSERT AuditTrail(SID, [User], RegardingPersonID, [ID], ObjectID, TableID, [Event Mask], Event)
SELECT SUSER_SID(), SUSER_SNAME(), I.EmployeeID, I.CompensationID, 1073741824, 1073741824, 2,
'Employment history\comp changed. ' +
CASE WHEN I.EmployeeID=D.EmployeeID THEN '' ELSE 'Employee changed from ' + DP.[List As] + ' to ' + IP.[List As] + '. ' END +
CASE WHEN I.PeriodID=D.PeriodID THEN '' ELSE 'Period changed from ' + DPeriod.Period + ' to ' + IPeriod.Period + '. ' END +
CASE WHEN I.[Start Day past 1900]=D.[Start Day past 1900] THEN '' ELSE 'Start changed from ' + CAST(dbo.GetDateFromDaysPast1900(D.[Start Day past 1900]) AS varchar(50)) + ' to ' + CAST(dbo.GetDateFromDaysPast1900(I.[Start Day past 1900]) AS varchar(50)) + '. ' END +
CASE
	WHEN D.[Stop Day past 1900] IS NULL AND I.[Stop Day past 1900] IS NULL THEN ''
	WHEN D.[Stop Day past 1900] IS NULL AND I.[Stop Day past 1900] IS NOT NULL THEN 'Stop set to ' + CAST(dbo.GetDateFromDaysPast1900(I.[Start Day past 1900]) AS varchar(50)) + '. '
	WHEN D.[Stop Day past 1900] IS NOT NULL AND I.[Stop Day past 1900] IS NULL THEN 'Stop changed from ' + CAST(dbo.GetDateFromDaysPast1900(D.[Start Day past 1900]) AS varchar(50)) + ' to unspecified. '
	WHEN D.[Stop Day past 1900] = I.[Stop Day past 1900] THEN ''
	ELSE 'Stop changed from ' + CAST(dbo.GetDateFromDaysPast1900(D.[Start Day past 1900]) AS varchar(50)) + ' to ' + CAST(dbo.GetDateFromDaysPast1900(I.[Start Day past 1900]) AS varchar(50)) + '. '
END +
CASE WHEN I.PositionID=D.PositionID THEN '' ELSE 'Position changed from ' + DPosition.[Job Title] + ' to ' + IPosition.[Job Title] + '. ' END +
CASE WHEN I.[Base Pay]=D.[Base Pay] THEN '' ELSE 'Base pay changed from ' + CAST(CAST(D.[Base Pay] AS numeric(23,2)) AS varchar(50)) + ' to ' + CAST(CAST(I.[Base Pay] AS numeric(23,2)) AS varchar(50)) + '. ' END +
CASE WHEN I.Budgeted=D.Budgeted THEN '' ELSE 'Budgeted changed from ' + CAST(D.Budgeted AS char(1)) + ' to ' + CAST(I.Budgeted AS char(1)) + '. ' END +
CASE WHEN I.PayStepID=D.PayStepID THEN '' ELSE 'Pay step changed from ' + DPayStep.[Pay Step] + ' to ' + IPayStep.[Pay Step] + '. ' END +
CASE WHEN I.StartEventID=D.StartEventID THEN '' ELSE 'Start Event changed from ' + DStart.Event + ' to ' + DStart.Event + '. ' END +
CASE
	WHEN D.StopEventID IS NULL AND I.StopEventID IS NULL THEN ''
	WHEN D.StopEventID IS NULL AND I.StopEventID IS NOT NULL THEN 'Stop Event set to ' + IStop.Event + '. '
	WHEN D.StopEventID IS NOT NULL AND I.StopEventID IS NULL THEN 'Stop Event changed from ' + DStop.Event + ' to unspecified.'
	WHEN D.StopEventID = I.StopEventID THEN ''
	ELSE 'Stop Event changed from ' + DStop.Event + ' to ' + IStop.Event + '. '
END +
CASE WHEN I.[Other Compensation]=D.[Other Compensation] THEN '' ELSE 'Other comp changed from ''' + D.[Other Compensation] + ''' to ''' + I.[Other Compensation] + '''. ' END +
CASE WHEN I.Note=D.Note THEN '' ELSE 'Note changed from ''' + D.Note + ''' to ''' + I.Note + '''. ' END
FROM inserted I INNER JOIN deleted D ON I.CompensationID=D.CompensationID
INNER JOIN dbo.vwPersonListAs IP ON I.EmployeeID=IP.PersonID
INNER JOIN dbo.vwPersonListAs DP ON D.EmployeeID=DP.PersonID
INNER JOIN EmployeeCompensationEventStart IStart ON I.StartEventID = IStart.EventID
INNER JOIN EmployeeCompensationEventStart DStart ON D.StartEventID = DStart.EventID
INNER JOIN Position IPosition ON I.PositionID = IPosition.PositionID
INNER JOIN Position DPosition ON D.PositionID = DPosition.PositionID
INNER JOIN PayStep IPayStep ON I.PayStepID = IPayStep.PayStepID
INNER JOIN PayStep DPayStep ON D.PayStepID = DPayStep.PayStepID
INNER JOIN Period IPeriod ON I.PeriodID = IPeriod.PeriodID
INNER JOIN Period DPeriod ON D.PeriodID = DPeriod.PeriodID
LEFT JOIN EmployeeCompensationEventStop IStop ON I.StopEventID = IStop.EventID
LEFT JOIN EmployeeCompensationEventStop DStop ON D.StopEventID = DStop.EventID

EXEC dbo.spAuditLogPurge
GO
CREATE TRIGGER dbo.EmployeeCompensationLogInsert ON dbo.EmployeeCompensation FOR INSERT
AS
DECLARE @audit_comp bit

EXEC dbo.spAuditGetOperation 1073741824, 4, @audit_comp OUT
IF @audit_comp=0 RETURN

INSERT AuditTrail(SID, [User], RegardingPersonID, [ID], ObjectID, TableID, [Event Mask], Event)
SELECT SUSER_SID(), SUSER_SNAME(), I.EmployeeID, I.CompensationID, 1073741824, 1073741824, 4,
'Employment history\comp inserted. ' +
'Employee=' + IP.[List As] + '. ' +
'Period=' + IPeriod.Period + '. ' +
'Start=' + CAST(dbo.GetDateFromDaysPast1900(I.[Start Day past 1900]) AS varchar(50)) + '. ' +
CASE
	WHEN I.[Stop Day past 1900] IS NULL THEN 'Stop is unspecified. '
	ELSE 'Stop=' + CAST(dbo.GetDateFromDaysPast1900(I.[Start Day past 1900]) AS varchar(50)) + '. '
END +
'Position=' + IPosition.[Job Title] + '. ' +
'Base pay=' + CAST(CAST(I.[Base Pay] AS numeric(23,2)) AS varchar(50)) + '. ' +
'Budgeted=' + CAST(I.Budgeted AS char(1)) + '. ' +
'Pay step=' + IPayStep.[Pay Step] + '. ' +
'Start Event=' + IStart.Event + '. ' +
CASE
	WHEN I.StopEventID IS NULL THEN 'Stop Event is unspecified. '
	ELSE 'Stop Event=' + IStop.Event
END +
CASE WHEN I.[Other Compensation]='' THEN '' ELSE 'Other Comp=''' + I.[Other Compensation] + '''. ' END +
CASE WHEN I.Note='' THEN '' ELSE 'Note=''' + I.Note + '''. ' END
FROM inserted I
INNER JOIN dbo.vwPersonListAs IP ON I.EmployeeID=IP.PersonID
INNER JOIN EmployeeCompensationEventStart IStart ON I.StartEventID = IStart.EventID
INNER JOIN Position IPosition ON I.PositionID = IPosition.PositionID
INNER JOIN PayStep IPayStep ON I.PayStepID = IPayStep.PayStepID
INNER JOIN Period IPeriod ON I.PeriodID = IPeriod.PeriodID
LEFT JOIN EmployeeCompensationEventStop IStop ON I.StopEventID = IStop.EventID

EXEC dbo.spAuditLogPurge
GO
CREATE TRIGGER dbo.EmployeeCompensationLogDelete ON dbo.EmployeeCompensation FOR DELETE
AS
DECLARE @audit_comp bit

EXEC dbo.spAuditGetOperation 1073741824, 8, @audit_comp OUT
IF @audit_comp=0 RETURN

INSERT AuditTrail(SID, [User], RegardingPersonID, [ID], ObjectID, TableID, [Event Mask], Event)
SELECT SUSER_SID(), SUSER_SNAME(), I.EmployeeID, I.CompensationID, 1073741824, 1073741824, 8,
'Employment history\comp deleted. ' +
'Employee=' + IP.[List As] + '. ' +
'Period=' + IPeriod.Period + '. ' +
'Start=' + CAST(dbo.GetDateFromDaysPast1900(I.[Start Day past 1900]) AS varchar(50)) + '. ' +
CASE
	WHEN I.[Stop Day past 1900] IS NULL THEN 'Stop is unspecified. '
	ELSE 'Stop=' + CAST(dbo.GetDateFromDaysPast1900(I.[Start Day past 1900]) AS varchar(50)) + '. '
END +
CASE WHEN I.Note='' THEN '' ELSE 'Note=' + I.Note + '. ' END +
'Position=' + IPosition.[Job Title] + '. ' +
'Base pay=' + CAST(CAST(I.[Base Pay] AS numeric(23,2)) AS varchar(50)) + '. ' +
CASE WHEN I.[Other Compensation]='' THEN '' ELSE 'Other Comp=' + I.[Other Compensation] + '. ' END +
'Budgeted=' + CAST(I.Budgeted AS char(1)) + '. ' +
'Pay step=' + IPayStep.[Pay Step] + '. ' +
'Start Event=' + IStart.Event + '. ' +
CASE
	WHEN I.StopEventID IS NULL THEN 'Stop Event is unspecified. '
	ELSE 'Stop Event=' + IStop.Event
END
FROM deleted I
INNER JOIN dbo.vwPersonListAs IP ON I.EmployeeID=IP.PersonID
INNER JOIN EmployeeCompensationEventStart IStart ON I.StartEventID = IStart.EventID
INNER JOIN Position IPosition ON I.PositionID = IPosition.PositionID
INNER JOIN PayStep IPayStep ON I.PayStepID = IPayStep.PayStepID
INNER JOIN Period IPeriod ON I.PeriodID = IPeriod.PeriodID
LEFT JOIN EmployeeCompensationEventStop IStop ON I.StopEventID = IStop.EventID

EXEC dbo.spAuditLogPurge
GO
CREATE TRIGGER dbo.CheckPeriodOnEmployeeCompensation ON dbo.EmployeeCompensation
FOR INSERT, UPDATE, DELETE
AS
DECLARE @batch_id int
DECLARE @error int
DECLARE @error_msg varchar(400)
DECLARE @item_id int, @dup_item_id int

SET NOCOUNT ON

SELECT @error = 0, @batch_id = RAND() * 2147483647, @error_msg = '', @dup_item_id = NULL, @item_id = NULL

-- Selects the affected employees into TempX.[ID]
IF EXISTS(SELECT * FROM inserted)
BEGIN
	INSERT TempX (BatchID, [ID])
	SELECT DISTINCT @batch_id, EmployeeID FROM inserted
END
ELSE
BEGIN
	INSERT TempX (BatchID, [ID])
	SELECT DISTINCT @batch_id, EmployeeID FROM deleted
END

-- Updates LastCompensationID
UPDATE Employee SET LastCompensationID = (
	SELECT TOP 1 EC.CompensationID FROM EmployeeCompensation EC WHERE EC.EmployeeID = E.EmployeeID
	ORDER BY EC.[Start Day past 1900] DESC
) 
FROM Employee E
INNER JOIN TempX X ON X.BatchID = @batch_id AND X.[ID] = E.EmployeeID

-- Checks period integrity if start or stop was inserted or updated
IF (UPDATE([Start Day past 1900]) OR UPDATE([Stop Day past 1900]))
BEGIN
	-- Ensures only the last period is left open
	SELECT TOP 1 @error = 50018 FROM EmployeeCompensation P
	INNER JOIN TempX T ON T.BatchID = @batch_id AND T.[ID] = P.EmployeeID AND P.[Stop Day past 1900] IS NULL
	INNER JOIN EmployeeCompensation P2 ON P.EmployeeID = P2.EmployeeID AND P.CompensationID <> P2.CompensationID AND P2.[Start Day past 1900] >= P.[Start Day past 1900]

	-- Ensures periods for the same employee do not overlap upon insert and update
	SELECT TOP 1 @error = 50010 FROM EmployeeCompensation C
	INNER JOIN [TempX] T ON T.BatchID = @batch_id AND T.[ID] = C.EmployeeID
	INNER JOIN EmployeeCompensation C2 ON C.EmployeeID = C2.EmployeeID AND C.CompensationID <> C2.CompensationID AND C.[Start Day past 1900] BETWEEN C2.[Start Day past 1900] AND ISNULL(C2.[Stop Day past 1900], 0x7FFFFFFF)



	SELECT TOP 1 @dup_item_id = EC2.CompensationID, @item_id = EC.CompensationID FROM EmployeeCompensation EC
	INNER JOIN [TempX] T ON T.BatchID = @batch_id AND T.[ID] = EC.EmployeeID
	INNER JOIN EmployeeCompensation EC2 ON EC.EmployeeID = EC2.EmployeeID AND EC.CompensationID <> EC2.CompensationID AND dbo.DoRaysIntersect(EC.[Start Day past 1900], EC.[Stop Day past 1900], EC2.[Start Day past 1900], EC2.[Stop Day past 1900]) = 1
	
	IF @@ROWCOUNT > 0
	BEGIN
		SELECT @error_msg = 'The compensation entry for ' + P.[First Name] +  ' ' + P.[Last Name] + ' (' + CAST(EC.[Start] AS char(11)) + CASE WHEN EC.[Stop] IS NULL THEN '' ELSE ' to ' +  CAST(EC.[Stop] AS char(11)) END + ') overlaps the entry for '
		FROM vwEmployeeCompensation EC
		INNER JOIN Person P ON EC.CompensationID = @item_id AND EC.EmployeeID = P.PersonID
		
		SELECT @error_msg = @error_msg  + P.[First Name] + ' (' + CAST(EC2.[Start] AS char(11)) + CASE WHEN EC2.[Stop] Is NULL THEN '' ELSE ' to ' +  CAST(EC2.[Stop] AS char(11)) END + '). Please fix the entry and try again.'
		FROM vwEmployeeCompensation EC2
		INNER JOIN Person P ON EC2.CompensationID = @dup_item_id AND EC2.EmployeeID = P.PersonID
	END
END


DELETE [TempX] WHERE BatchID = @batch_id OR DATEDIFF(hh, Created, GETDATE()) > 1

IF LEN(@error_msg) > 0 RAISERROR (@error_msg, 16, 1)
ELSE IF @error <> 0 EXEC dbo.spErrorRaise @error
IF (@error <> 0 OR LEN(@error_msg) > 0) AND @@TRANCOUNT > 0 ROLLBACK
GO

/* TRIGGER CHANGES END ***********************************************************************/


/* DYNAMIC FLAT VIEW CHANGES BEGIN ***********************************************************************/
GO
IF OBJECT_ID('dbo.spCustomFieldClean') IS NOT NULL DROP PROC dbo.spCustomFieldClean
GO
-- Should be called before using any flat views to make sure that PersonCustomFieldFlat is up to date
-- Table will be out of date if any of the custom field items changed
CREATE PROC dbo.spCustomFieldClean
/*WITH EXECUTE AS 'dbo'*/
AS
SET NOCOUNT ON
DECLARE @field_id int, @sql nvarchar(4000)
DECLARE f_cursor CURSOR LOCAL FORWARD_ONLY STATIC FOR SELECT FieldID FROM CustomField WHERE Dirty=1
OPEN f_cursor FETCH f_cursor INTO @field_id
WHILE @@FETCH_STATUS=0
BEGIN
	DECLARE @id sysname, @colValue sysname, @colText sysname
	SELECT @id = 'CF_' + CAST(@field_id AS varchar(50)) + N'_X'
	SELECT @colValue = @id + 'Value', @colText = @id + 'Text'

	SET @sql = N'UPDATE F SET ' +
	@colValue + '=V.Value2,' + @colText + '=V.Text ' +
	'FROM dbo.PersonCustomFieldFlat F ' +
	'INNER JOIN dbo.vwPersonCustomField V ON F.PCFPersonID=V.PersonID AND V.FieldID=' + CAST(@field_id AS varchar(50))

	EXEC dbo.spExecSQLAsDBO @sql
	FETCH f_cursor INTO @field_id
END
CLOSE f_cursor DEALLOCATE f_cursor

UPDATE dbo.CustomField SET Dirty=0 WHERE Dirty=1
GO
IF OBJECT_ID('dbo.spPersonXSkillCreateFlatView') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spPersonXSkillCreateFlatView AS'
END
GO
ALTER PROC dbo.spPersonXSkillCreateFlatView AS
DECLARE @skill_id nvarchar(50), @v nvarchar(50)

CREATE TABLE #BigSQLStatement([SQL] ntext COLLATE SQL_Latin1_General_CP1_CI_AS, SQL2 ntext COLLATE SQL_Latin1_General_CP1_CI_AS)


INSERT #BigSQLStatement([SQL], SQL2)
VALUES (N'ALTER VIEW dbo.vwPersonXSkillFlat AS SELECT PXSPersonID=E.PersonID', N' FROM dbo.PersonX E ')

DECLARE @sql_ptr binary(16), @SQL2_ptr binary(16)
SELECT @sql_ptr = TEXTPTR([SQL]), @SQL2_ptr = TEXTPTR(SQL2) FROM #BigSQLStatement

DECLARE b_cursor CURSOR LOCAL FORWARD_ONLY STATIC FOR SELECT SkillID FROM Skill
OPEN b_cursor

FETCH b_cursor INTO @skill_id
WHILE @@FETCH_STATUS=0
BEGIN
	DECLARE @id nvarchar(50), @sql_temp nvarchar(4000)
	SELECT @id = N'PS_' + @skill_id + N'_X', @v = N'v' + @skill_id

	SET @sql_temp = N',' + @id + N'SkillID=' + @skill_id + ','
	SET @sql_temp = @sql_temp + @id + N'Level=ISNULL(' + @v + N'.Level,0)'

	UPDATETEXT #BigSQLStatement.[SQL] @sql_ptr NULL 0 @sql_temp

	SET @sql_temp = N' LEFT JOIN dbo.PersonXSkill ' + @v + N' ON E.PersonID=' + @v + N'.PersonID AND ' + @v + N'.SkillID=' + @skill_id
	UPDATETEXT #BigSQLStatement.SQL2 @SQL2_ptr NULL 0 @sql_temp

	FETCH b_cursor INTO @skill_id
END

CLOSE b_cursor
DEALLOCATE b_cursor

UPDATETEXT #BigSQLStatement.[SQL] @sql_ptr NULL 0 #BigSQLStatement.SQL2 @SQL2_ptr

CREATE TABLE #DEPENDENT_VIEWS(ID int, [Order] int NOT NULL identity(1,1))
EXEC dbo.spAdminDependentViews_Identify 'dbo.vwPersonXSkillFlat'
--SELECT * FROM #BigSQLStatement
EXEC dbo.spExecuteSQLBigForSQL2000
DROP TABLE #BigSQLStatement
EXEC dbo.spAdminDependentViews_Refresh
GO
IF OBJECT_ID('dbo.vwPersonXSkillFlat') IS NOT NULL AND NOT EXISTS(SELECT * FROM dbo.syscolumns WHERE [name]='PXSPersonID' AND [ID]=OBJECT_ID('dbo.vwPersonXSkillFlat'))
BEGIN
	DROP VIEW dbo.vwPersonXSkillFlat
END
GO
IF OBJECT_ID('dbo.vwPersonXSkillFlat') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE VIEW dbo.vwPersonXSkillFlat AS SELECT PXSPersonID=PersonID FROM PersonX'
	EXEC dbo.spPersonXSkillCreateFlatView
END
GO
IF OBJECT_ID('dbo.PersonXSkillRecreateFlatViewOnInsertDelete') IS NULL
EXEC sp_executesql N'CREATE TRIGGER dbo.PersonXSkillRecreateFlatViewOnInsertDelete ON dbo.Skill FOR INSERT, DELETE AS SELECT 0'
GO
ALTER TRIGGER dbo.PersonXSkillRecreateFlatViewOnInsertDelete ON dbo.Skill FOR INSERT, DELETE AS 
SET NOCOUNT ON
IF EXISTS(SELECT * FROM deleted) OR EXISTS(SELECT * FROM inserted) EXEC dbo.spPersonXSkillCreateFlatView
GO
IF OBJECT_ID('dbo.spEmployeeDeductionCreateFlatView') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEmployeeDeductionCreateFlatView AS'
END
GO
ALTER PROC dbo.spEmployeeDeductionCreateFlatView AS
DECLARE @Deduction_id nvarchar(50), @v nvarchar(50)

CREATE TABLE #BigSQLStatement([SQL] ntext COLLATE SQL_Latin1_General_CP1_CI_AS, SQL2 ntext COLLATE SQL_Latin1_General_CP1_CI_AS)


INSERT #BigSQLStatement([SQL], SQL2)
VALUES (N'ALTER VIEW dbo.vwEmployeeDeductionFlat AS SELECT EDFEmployeeID=E.EmployeeID', N' FROM dbo.Employee E ')

DECLARE @sql_ptr binary(16), @SQL2_ptr binary(16)
SELECT @sql_ptr = TEXTPTR([SQL]), @SQL2_ptr = TEXTPTR(SQL2) FROM #BigSQLStatement

DECLARE b_cursor CURSOR LOCAL FORWARD_ONLY STATIC FOR SELECT DeductionID FROM Deduction
OPEN b_cursor

FETCH b_cursor INTO @Deduction_id
WHILE @@FETCH_STATUS=0
BEGIN
	DECLARE @id nvarchar(50), @sql_temp nvarchar(4000)
	SELECT @id = N'ED_' + @Deduction_id + N'_X', @v = N'v' + @Deduction_id

	SET @sql_temp = N',' + @id + N'DeductionID=' + @Deduction_id + ','
	SET @sql_temp = @sql_temp + @id + N'Comment=ISNULL(' + @v + N'.Comment,''''),'
	SET @sql_temp = @sql_temp + @id + N'Amount2=ISNULL(' + @v + N'.Amount,0),'
	SET @sql_temp = @sql_temp + @id + N'Amount=ISNULL(' + @v + N'.Amount,0)'

	UPDATETEXT #BigSQLStatement.[SQL] @sql_ptr NULL 0 @sql_temp

	SET @sql_temp = N' LEFT JOIN dbo.EmployeeDeduction ' + @v + N' ON E.EmployeeID=' + @v + N'.EmployeeID AND ' + @v + N'.DeductionID=' + @Deduction_id
	UPDATETEXT #BigSQLStatement.SQL2 @SQL2_ptr NULL 0 @sql_temp

	FETCH b_cursor INTO @Deduction_id
END

CLOSE b_cursor
DEALLOCATE b_cursor

UPDATETEXT #BigSQLStatement.[SQL] @sql_ptr NULL 0 #BigSQLStatement.SQL2 @SQL2_ptr

CREATE TABLE #DEPENDENT_VIEWS(ID int, [Order] int NOT NULL identity(1,1))
EXEC dbo.spAdminDependentViews_Identify 'dbo.vwEmployeeDeductionFlat'
--SELECT * FROM #BigSQLStatement
EXEC dbo.spExecuteSQLBigForSQL2000
DROP TABLE #BigSQLStatement
EXEC dbo.spAdminDependentViews_Refresh
GO
IF OBJECT_ID('dbo.vwEmployeeDeductionFlat') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE VIEW dbo.vwEmployeeDeductionFlat AS SELECT EDFEmployeeID=EmployeeID FROM Employee'
	EXEC dbo.spEmployeeDeductionCreateFlatView
END
GO
IF OBJECT_ID('dbo.EmployeeDeductionRecreateFlatViewOnInsertDelete') IS NULL
EXEC sp_executesql N'CREATE TRIGGER dbo.EmployeeDeductionRecreateFlatViewOnInsertDelete ON dbo.Deduction FOR INSERT, DELETE AS SELECT 0'
GO
ALTER TRIGGER dbo.EmployeeDeductionRecreateFlatViewOnInsertDelete ON dbo.Deduction FOR INSERT, DELETE AS 
SET NOCOUNT ON
IF EXISTS(SELECT * FROM deleted) OR EXISTS(SELECT * FROM inserted) EXEC dbo.spEmployeeDeductionCreateFlatView
GO
IF OBJECT_ID('dbo.spEmployeeBenefitCreateFlatView') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spEmployeeBenefitCreateFlatView AS'
GO
ALTER PROC dbo.spEmployeeBenefitCreateFlatView WITH EXEC AS 'dbo' AS
DECLARE @benefit_id nvarchar(50), @benefit nvarchar(50), @v nvarchar(50), @sql1 nvarchar(MAX), @sql2 nvarchar(MAX), @sql3 nvarchar(MAX), @sql4 nvarchar(MAX)

SET @sql1 = N'ALTER VIEW dbo.vwEmployeeBenefitFlat AS SELECT EBFEmployeeID=E.EmployeeID'
SET @sql2 = N' FROM dbo.Employee E  CROSS JOIN dbo.Constant C INNER JOIN dbo.Period P ON C.BenefitPremiumPeriodID = P.PeriodID'

SET @sql3 = N'ALTER VIEW dbo.vwEmployeeBenefitFlatForMerge AS SELECT EBFEmployeeID=E.EmployeeID'
SET @sql4 = N' FROM dbo.Employee E INNER JOIN dbo.MailMerge M ON E.EmployeeID=M.PersonID CROSS JOIN dbo.Constant C INNER JOIN dbo.Period P ON C.BenefitPremiumPeriodID = P.PeriodID'

DECLARE b_cursor CURSOR LOCAL FORWARD_ONLY STATIC FOR SELECT BenefitID, Benefit FROM Benefit
OPEN b_cursor

FETCH b_cursor INTO @benefit_id, @benefit
WHILE @@FETCH_STATUS=0
BEGIN
	DECLARE @id nvarchar(50), @sql_temp nvarchar(MAX)
	SELECT @id = N'EB_' + @benefit_id + N'_X', @v = N'v' + @benefit_id

	SET @sql_temp = N',' + @id + N'BenefitID=' + @v + N'.BenefitID,'
	SET @sql_temp = @sql_temp + @id + N'Provider=' + @v + N'.Provider,'
	SET @sql_temp = @sql_temp + @id + N'Plan=' + @v + N'.[Plan],'
	SET @sql_temp = @sql_temp + @id + N'Coverage=' + @v + N'.Coverage,'
	SET @sql_temp = @sql_temp + @id + N'Volume=' + @v + N'.Volume,'
	SET @sql_temp = @sql_temp + @id + N'WaitListQueue=' + @v + N'.[Wait List Queue],'
	SET @sql_temp = @sql_temp + @id + N'EmployeePremium=' + @v + N'.[Employee Premium],'
	SET @sql_temp = @sql_temp + @id + N'EmployerPremium=' + @v + N'.[Employer Premium],'
	SET @sql_temp = @sql_temp + @id + N'OtherPremium=' + @v + N'.[Other Premium],'
	SET @sql_temp = @sql_temp + @id + N'TotalPremium=' + @v + N'.[Employee Premium]+' + @v + N'.[Employer Premium],'
	SET @sql_temp = @sql_temp + @id + N'AnnualEmployerPremium=7488000.0/P.Seconds*' + @v + N'.[Employer Premium],'
	SET @sql_temp = @sql_temp + @id + N'AnnualEmployeePremium=7488000.0/P.Seconds*' + @v + N'.[Employee Premium],'
	SET @sql_temp = @sql_temp + @id + N'AnnualPremium=7488000.0/P.Seconds*(' + @v + N'.[Employee Premium]+' + @v + N'.[Employer Premium]),'
	SET @sql_temp = @sql_temp + @id + N'StatusCode=dbo.fnGetEBStatusCode('+@v+N'.[Wait List Day past 1900],'+@v+N'.[Wait List Queue],'+@v+N'.[Declined Day past 1900],'+@v+N'.[First Enrolled Day past 1900],'+@v+N'.[Last Enrolled Day past 1900],'+@v+N'.[Expires Day past 1900],'+@v+N'.[Eligible Day past 1900],E.[COBRA Declined Day past 1900],E.[COBRA First Enrolled Day past 1900],E.[COBRA Last Enrolled Day past 1900]),'
	SET @sql_temp = @sql_temp + @id + N'Enrollment=dbo.fnGetEnrollment(GETDATE(),'+@v+N'.[Wait List Day past 1900],'+@v+N'.[Wait List Queue],'+@v+N'.[Declined Day past 1900],'+@v+N'.[First Enrolled Day past 1900],'+@v+N'.[Last Enrolled Day past 1900],'+@v+N'.[Expires Day past 1900],'+@v+N'.[Eligible Day past 1900]),'
	SET @sql_temp = @sql_temp + @id + N'Enrolled=dbo.fnGetEnrolled('+@v+N'.[First Enrolled Day past 1900],'+@v+N'.[Last Enrolled Day past 1900]),'
	SET @sql_temp = @sql_temp + @id + N'Note=' + @v + N'.Note'
	SET @sql1 = @sql1 + @sql_temp
	SET @sql2 = @sql2 + N' INNER JOIN dbo.EmployeeBenefit ' + @v + N' ON E.EmployeeID=' + @v + N'.EmployeeID AND ' + @v + N'.BenefitID=' + @benefit_id

	
	DECLARE @i int, @a int, @c nchar(1)
	SELECT @id = 'Benefit_', @i = 1
	WHILE @i <= LEN(@benefit)
	BEGIN
		SET @c = SUBSTRING(@benefit, @i, 1)
		SET @a = ASCII(@c)
		SET @id = @id + CASE WHEN @a BETWEEN 65 AND 90 OR @a BETWEEN 97 AND 122 OR @a BETWEEN 48 AND 57 THEN @c ELSE '_' END
		SET @i = @i + 1
	END

	SET @id = @id + '_'
	SET @v = @id + '_v'

	IF NOT EXISTS (SELECT * FROM dbo.Benefit WHERE BenefitID != @benefit_id AND (Benefit = @id OR Benefit = @v))
	BEGIN
		SET @sql_temp = N',' + @id + N'BenefitID=' + @v + N'.BenefitID,'
		SET @sql_temp = @sql_temp + @id + N'Provider=' + @v + N'.Provider,'
		SET @sql_temp = @sql_temp + @id + N'Plan=' + @v + N'.[Plan],'
		SET @sql_temp = @sql_temp + @id + N'Coverage=' + @v + N'.Coverage,'
		SET @sql_temp = @sql_temp + @id + N'Volume=dbo.fnFormatCurrencyAsString(' + @v + N'.Volume),'
		SET @sql_temp = @sql_temp + @id + N'WaitListQueue=' + @v + N'.[Wait List Queue],'
		SET @sql_temp = @sql_temp + @id + N'EmployeePremium=dbo.fnFormatCurrencyAsString(' + @v + N'.[Employee Premium]),'
		SET @sql_temp = @sql_temp + @id + N'EmployerPremium=dbo.fnFormatCurrencyAsString(' + @v + N'.[Employer Premium]),'
		SET @sql_temp = @sql_temp + @id + N'OtherPremium=dbo.fnFormatCurrencyAsString(' + @v + N'.[Other Premium]),'
		SET @sql_temp = @sql_temp + @id + N'TotalPremium=dbo.fnFormatCurrencyAsString(' + @v + N'.[Employee Premium]+' + @v + N'.[Employer Premium]),'
		SET @sql_temp = @sql_temp + @id + N'AnnualEmployerPremium=dbo.fnFormatCurrencyAsString(7488000.0/P.Seconds*' + @v + N'.[Employer Premium]),'
		SET @sql_temp = @sql_temp + @id + N'AnnualEmployeePremium=dbo.fnFormatCurrencyAsString(7488000.0/P.Seconds*' + @v + N'.[Employee Premium]),'
		SET @sql_temp = @sql_temp + @id + N'AnnualPremium=dbo.fnFormatCurrencyAsString(7488000.0/P.Seconds*(' + @v + N'.[Employee Premium]+' + @v + N'.[Employer Premium])),'
		SET @sql_temp = @sql_temp + @id + N'StatusCode=dbo.fnGetEBStatusCode('+@v+N'.[Wait List Day past 1900],'+@v+N'.[Wait List Queue],'+@v+N'.[Declined Day past 1900],'+@v+N'.[First Enrolled Day past 1900],'+@v+N'.[Last Enrolled Day past 1900],'+@v+N'.[Expires Day past 1900],'+@v+N'.[Eligible Day past 1900],E.[COBRA Declined Day past 1900],E.[COBRA First Enrolled Day past 1900],E.[COBRA Last Enrolled Day past 1900]),'
		SET @sql_temp = @sql_temp + @id + N'Enrollment=dbo.fnGetEnrollment(GETDATE(),'+@v+N'.[Wait List Day past 1900],'+@v+N'.[Wait List Queue],'+@v+N'.[Declined Day past 1900],'+@v+N'.[First Enrolled Day past 1900],'+@v+N'.[Last Enrolled Day past 1900],'+@v+N'.[Expires Day past 1900],'+@v+N'.[Eligible Day past 1900]),'
		SET @sql_temp = @sql_temp + @id + N'Enrolled=dbo.fnGetEnrolled('+@v+N'.[First Enrolled Day past 1900],'+@v+N'.[Last Enrolled Day past 1900]),'
		SET @sql_temp = @sql_temp + @id + N'Note=' + @v + N'.Note'
		SET @sql3 = @sql3 + @sql_temp
		SET @sql4 = @sql4 + N' INNER JOIN dbo.EmployeeBenefit ' + @v + N' ON E.EmployeeID=' + @v + N'.EmployeeID AND ' + @v + N'.BenefitID=' + @benefit_id

	END

	FETCH b_cursor INTO @benefit_id, @benefit
END

CLOSE b_cursor
DEALLOCATE b_cursor

CREATE TABLE #DEPENDENT_VIEWS(ID int, [Order] int NOT NULL identity(1,1))
EXEC dbo.spAdminDependentViews_Identify 'dbo.vwEmployeeBenefitFlat'
EXEC dbo.spAdminDependentViews_Identify 'dbo.vwEmployeeBenefitFlatForMerge'
--EXEC (N'sp_executesql N''' + @sql + N'''')
SET @sql1 = @sql1 + @sql2
SET @sql3 = @sql3 + @sql4

EXEC sp_executesql @sql1
EXEC sp_executesql @sql3

EXEC dbo.spAdminDependentViews_Refresh
GO
IF OBJECT_ID('dbo.vwEmployeeBenefitFlat') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE VIEW dbo.vwEmployeeBenefitFlat AS SELECT EBFEmployeeID=EmployeeID FROM Employee'
	--EXEC dbo.spEmployeeBenefitCreateFlatView
END
GO
IF OBJECT_ID('dbo.vwEmployeeBenefitFlatForMerge') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE VIEW dbo.vwEmployeeBenefitFlatForMerge AS SELECT EBFEmployeeID=PersonID FROM MailMerge'
	GRANT SELECT ON dbo.vwEmployeeBenefitFlatForMerge TO public
END
GO
IF OBJECT_ID('dbo.vwMailMerge') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE VIEW dbo.vwMailMerge AS SELECT M.*, B.* FROM dbo.MailMerge M INNER JOIN dbo.vwEmployeeBenefitFlatForMerge B ON M.PersonID = B.EBFEmployeeID'
	GRANT SELECT ON dbo.vwMailMerge TO public
END
GO
CREATE TRIGGER dbo.EmployeeBenefitRecreateFlatViewOnInsertDelete ON dbo.Benefit FOR INSERT, DELETE AS 
IF EXISTS(SELECT * FROM inserted)
INSERT dbo.EmployeeBenefit(
	EmployeeID,
	BenefitID,
	[Employee Premium],
	[Employer Premium],
	[Expires Day past 1900],
	[Eligible Day past 1900],
	[Notified Day past 1900],
	[First Enrolled Day past 1900],
	[Last Enrolled Day past 1900],
	[Declined Day past 1900],
	Note,
	[Group Policy Number],
	[Individual Policy Number],
	Coverage,
	[Plan],
	Provider,
	[Wait List Queue],
	[Wait List Day past 1900],
	[Other Premium]
)
SELECT
E.EmployeeID,
B.BenefitID,
0, -- [Employee Premium]
0, -- [Employer Premium]
NULL, -- [Expires Day past 1900]
NULL, -- [Eligible Day past 1900]
NULL, -- [Notified Day past 1900]
NULL, -- [First Enrolled Day past 1900]
NULL, -- [Last Enrolled Day past 1900]
NULL, -- [Declined Day past 1900]
'', -- Note
'', -- [Group Policy Number]
'', -- [Individual Policy Number]
'', -- Coverage
'', -- [Plan]
'', -- Provider
NULL, -- [Wait List Queue]
NULL, -- [Wait List Day past 1900]
0 -- Other premium
FROM dbo.Employee E CROSS JOIN inserted B WHERE NOT EXISTS (
	SELECT * FROM dbo.EmployeeBenefit EB WHERE EB.EmployeeID=E.EmployeeID AND EB.BenefitID=B.BenefitID
)

IF EXISTS(SELECT * FROM deleted) OR EXISTS(SELECT * FROM inserted) EXEC dbo.spEmployeeBenefitCreateFlatView
GO
CREATE TRIGGER dbo.PersonAddFlatTableColumnOnInsert ON [dbo].[Person] FOR INSERT AS
INSERT dbo.PersonCustomFieldFlat(PCFPersonID) SELECT PersonID FROM inserted

INSERT dbo.PersonCustomField(PersonID, FieldID, [Value])
SELECT I.PersonID, F.FieldID, NULL
FROM inserted I CROSS JOIN CustomField F

UPDATE PCF SET 
[Value] = CASE 
	WHEN C.TypeID = 167 AND (C.Attributes & 0x100) = 0 THEN '' -- text nonnullable
	ELSE NULL
END
FROM dbo.PersonCustomField PCF -- Calls trigger on PersonCustomField that sets PersonCustomFieldFlat Text fields to '' or text for default
INNER JOIN inserted I ON PCF.PersonID=I.PersonID
INNER JOIN dbo.CustomField C ON PCF.FieldID = C.FieldID AND C.TypeID = 167

UPDATE PCF SET 
[Value] = CASE 
	WHEN C.TypeID = 2 AND (C.Attributes & 0x100) = 0 THEN CAST(0 AS decimal(29,6)) -- decimal nonnullable
	ELSE NULL
END
FROM dbo.PersonCustomField PCF -- Calls trigger on PersonCustomField that sets PersonCustomFieldFlat Text fields to '' or text for default
INNER JOIN inserted I ON PCF.PersonID=I.PersonID
INNER JOIN dbo.CustomField C ON PCF.FieldID = C.FieldID AND C.TypeID = 2

UPDATE PCF SET 
[Value] = CASE 
	WHEN C.TypeID = 3 AND (C.Attributes & 0x100) = 0 THEN CAST(0 AS bit) -- checkbox nonnullable
	ELSE NULL
END
FROM dbo.PersonCustomField PCF -- Calls trigger on PersonCustomField that sets PersonCustomFieldFlat Text fields to '' or text for default
INNER JOIN inserted I ON PCF.PersonID=I.PersonID
INNER JOIN dbo.CustomField C ON PCF.FieldID = C.FieldID AND C.TypeID = 3

UPDATE PCF SET 
[Value] = CASE 
	--WHEN C.TypeID = 167 AND (C.Attributes & 0x100) = 0 THEN '' -- text nonnullable
	--WHEN C.TypeID = 3 AND (C.Attributes & 0x100) = 0 THEN CAST(0 AS bit) -- checkbox nonnullable
	--WHEN C.TypeID = 2 AND (C.Attributes & 0x100) = 0 THEN CAST(0 AS decimal(29,6)) -- decimal nonnullable
	WHEN C.TypeID = 1 AND (C.Attributes & 0x100) = 0x100 THEN NULL -- Nullable
	WHEN C.TypeID = 1 AND (C.Attributes & 0xFF) IN (1,2) THEN CAST(0 AS int) -- Radios or checkboxes >> 0
	WHEN C.TypeID = 1 AND (C.Attributes & 0xFF) = 3 THEN CAST((SELECT MIN([Value]) FROM dbo.CustomFieldItem CFI WHERE CFI.FieldID = C.FieldID) as int) -- Custom combo
	ELSE NULL
END
FROM dbo.PersonCustomField PCF -- Calls trigger on PersonCustomField that sets PersonCustomFieldFlat Text fields to '' or text for default
INNER JOIN inserted I ON PCF.PersonID=I.PersonID
INNER JOIN dbo.CustomField C ON PCF.FieldID = C.FieldID AND C.TypeID NOT IN (167, 2, 3)
GO
CREATE TRIGGER dbo.CustomFieldAddFlatTableColumnOnInsert ON dbo.CustomField FOR INSERT AS
DECLARE @field_id int

INSERT dbo.PersonCustomField(PersonID, FieldID, [Value])
SELECT P.PersonID, F.FieldID, NULL
FROM Person P CROSS JOIN inserted F WHERE F.TypeID <> 3

INSERT dbo.PersonCustomField(PersonID, FieldID, [Value])
SELECT P.PersonID, F.FieldID, CAST(0 AS bit)
FROM Person P CROSS JOIN inserted F WHERE F.TypeID = 3

DECLARE f_cursor CURSOR LOCAL FORWARD_ONLY STATIC FOR SELECT FieldID FROM inserted
OPEN f_cursor FETCH f_cursor INTO @field_id
WHILE @@FETCH_STATUS=0
BEGIN
	EXEC dbo.spPersonCustomFieldInsertFlatTableColumn @field_id, 0
	FETCH f_cursor INTO @field_id
END
CLOSE f_cursor DEALLOCATE f_cursor
GO
CREATE TRIGGER dbo.CustomFieldDropFlatTableColumnOnDelete ON dbo.CustomField FOR DELETE AS
DECLARE @field_id int
DECLARE f_cursor CURSOR LOCAL FORWARD_ONLY STATIC FOR SELECT FieldID FROM deleted
OPEN f_cursor FETCH f_cursor INTO @field_id
WHILE @@FETCH_STATUS=0
BEGIN
	EXEC dbo.spPersonCustomFieldDeleteFlatTableColumn @field_id
	FETCH f_cursor INTO @field_id
END
CLOSE f_cursor DEALLOCATE f_cursor
GO
-- Updates PersonCustomFieldFlat when PersonCustomField is updated
-- Updates PersonCustomFieldFlat when PersonCustomField is updated
CREATE TRIGGER dbo.PersonCustomFieldUpdateFlatTableOnUpdate
ON [dbo].[PersonCustomField] 
FOR UPDATE 
AS
SET NOCOUNT ON
DECLARE @batch_id int, @sql nvarchar(4000), @field_id int, @type varchar(50)
SELECT @batch_id = RAND() * 2147483647

INSERT TempXYZ(BatchID, [ID], X) SELECT @batch_id, PersonID, FieldID FROM inserted

DECLARE f_cursor CURSOR LOCAL FORWARD_ONLY STATIC FOR SELECT DISTINCT inserted.FieldID, dbo.fnGetTypeNameForCustomFieldType(TypeID) FROM inserted
INNER JOIN dbo.CustomField F ON inserted.FieldID = F.FieldID

OPEN f_cursor FETCH f_cursor INTO @field_id, @type
WHILE @@FETCH_STATUS=0
BEGIN
	DECLARE @id sysname, @colValue sysname, @colText sysname
	SELECT @id = 'CF_' + CAST(@field_id AS varchar(50)) + N'_X'
	SELECT @colValue = @id + 'Value', @colText = @id + 'Text'

	SET @sql = N'UPDATE F SET ' +
	@colValue + '=CAST(V.Value2 AS ' + @type + '),' + @colText + '=V.Text ' +
	'FROM dbo.PersonCustomFieldFlat F ' +
	'INNER JOIN dbo.vwPersonCustomField V ON F.PCFPersonID=V.PersonID AND V.FieldID=' + CAST(@field_id AS varchar(50)) +
	' INNER JOIN TempXYZ X ON X.BatchID=' + CAST(@batch_id AS varchar(50)) + ' AND X.[ID]=V.PersonID AND X.X=V.FieldID'

	EXEC dbo.spExecSQLAsDBO @sql
	FETCH f_cursor INTO @field_id, @type
END
CLOSE f_cursor DEALLOCATE f_cursor
DELETE TempXYZ WHERE BatchID=@batch_id OR DATEDIFF(hour,Created,GETDATE()) > 1
GO
/* DYNAMIC FLAT VIEW CHANGES END ***********************************************************************/

/* VIEWS DEPENDENT ON FLAT VIEWS BEGIN ***********************************************************************/
IF OBJECT_id('dbo.vwEmployeeEffectiveSecondsPerDay') IS NULL EXEC sp_executesql N'CREATE VIEW dbo.vwEmployeeEffectiveSecondsPerDay AS SELECT A=0'
GO
ALTER VIEW dbo.vwEmployeeEffectiveSecondsPerDay
AS
SELECT E.EmployeeID,
[Effective Seconds per Day] = CASE WHEN E.[Seconds per Day Override]=0 THEN S.[Seconds per Day] ELSE E.[Seconds per Day Override] END,
[Shift Seconds per Day] = S.[Seconds per Day],
E.[Seconds per Day Override],
S.[Days On],
S.[Days Off],
S.ShiftID,
E.[Leave Accrual Multiplier],
[Shift FTE] = S.[FTE],
S.[DaysOn2],
S.[DaysOff2]
FROM dbo.Employee E INNER JOIN dbo.Shift S ON E.ShiftID=S.ShiftID
GO
EXEC dbo.spAdminCreateViewIfNonexistent 'vwInOutStatus'
GO
EXEC spAdminCreateViewifNonexistent 'vwEmployeeSecure'
GO
ALTER VIEW dbo.vwEmployeeSecure
AS
SELECT EID = P.PersonID, 
P.[Role Mask],
P.[First Name],
P.[Middle Name],
P.[Last Name],
P.[Full Name],
P.Title,
P.Initials,
P.Suffix,
P.Credentials,
P.[Formal Name],
[Person List As] = P.[List As],

[Work Permission Mask] = dbo.fnPermissionGetOnPersonForCurrentUser(W.PersonID, 2),
[Work E-mail] = ISNULL(W.[Work E-mail], ''), 
[Work Phone] = ISNULL(W.[Work Phone], ''),
Extension = ISNULL(W.[Extension], ''),
[Work Phone Note] = ISNULL(W.[Work Phone Note], ''),
[Toll Free Phone] = ISNULL(W.[Toll Free Phone], ''),
[Mobile Phone] = ISNULL(W.[Mobile Phone], ''),
[Work Fax] = ISNULL(W.[Work Fax], ''),
Pager = ISNULL(W.Pager, ''),
[Employee Note] = ISNULL(W.[Note], ''),
[Work Address] = ISNULL(W.[Work Address], ''),
[Work Address (cont.)] = ISNULL(W.[Work Address (cont.)], ''),
[Work City] = ISNULL(W.[Work City], ''),
[Work State] = ISNULL(W.[Work State], ''),
[Work ZIP] = ISNULL(W.[Work ZIP], ''),
[Work Country] = ISNULL(W.[Work Country], ''),
[Home Office Phone] = ISNULL(W.[Home Office Phone], ''),
[Extended Work Address] = ISNULL(W.[Extended Work Address], ''),
[Extended Work Phone] = ISNULL(W.[Extended Work Phone], ''),
Gender = CASE WHEN W.Male IS NULL THEN '' WHEN W.Male=1 THEN 'Male' ELSE 'Female' END,
W.[IsEmployee], W.[Male], W.[IsApplicant], W.[IsRecruiter], W.[IsPhysician], W.[IsEmergencyContact],W.PFlags,

[Home Permission Mask] = dbo.fnPermissionGetOnPersonForCurrentUser(W.PersonID, 1),
[Home Fax] = ISNULL(H.[Home Fax], ''),
[Home Phone] = ISNULL(H.[Home Phone], ''),
[Home E-mail] = ISNULL(H.[Home E-mail], ''),
[Home Address] = ISNULL(H.[Home Address], ''),
[Home Address (cont.)] = ISNULL(H.[Home Address (cont.)], ''),
[Home City] = ISNULL(H.[Home City], ''),
[Home State] = ISNULL(H.[Home State], ''),
[Home Zip] = ISNULL(H.[Home Zip], ''),
[Home Country] = ISNULL(H.[Home Country], ''),
[Extended Home Address] = ISNULL(H.[Extended Home Address], ''),

[Review Permission Mask] = dbo.fnPermissionGetOnPersonForCurrentUser(P.PersonID, 16),
[Filing Status] = ISNULL(PS.[Filing Status], ''),
[Direct Deposit Account Number] = ISNULL(PS.[Direct Deposit Account Number], ''),
[Employee Number] = ISNULL(O.[Employee Number], ''),
Shift = ISNULL(O.Shift, ''),
Manager = ISNULL(O.Manager, ''),
[Manager Employee Number] = ISNULL(O.[Manager Employee Number], ''),
Division = ISNULL(O.Division, ''),
Location = ISNULL(O.Location, ''),
Department = ISNULL(O.Department, ''),
[Last Position] = ISNULL(O.[Last Position], ''),
R.[Next Performance Review Day past 1900], R.[Last Performance Review Day past 1900], R.[Next Performance Review], R.[Last Performance Review],

[Pay Step Permission Mask] = dbo.fnPermissionGetOnPersonForCurrentUser(P.PersonID, 64),
PS.[FilingStatusID], PS.[Salaried], PS.[Payroll Delay], PS.DefaultTimeTypeID, PS.[OT Pay Multiplier], PS.[Holiday Pay Multiplier], PS.[Weekend Pay Multiplier], PS.[OT Basis], PS.[FIT Exemptions],

[Org Permission Mask] = dbo.fnPermissionGetOnPersonForCurrentUser(P.PersonID, 8),
O.ManagerID, O.ShiftID, O.DivisionID, O.DepartmentID, O.[Active Employee], O.LocationID,
O.LastPositionID, O.[Seniority Begins Day past 1900], O.[Seniority Begins], O.DOH, O.[DOH Day past 1900], O.[Job Category], O.OrgUserField1,
O.LeaveKeeperID, O.[Leave Keeper], O.[Leave Keeper E-mail],
O.DivisionLeaveKeeperID, O.[Division Leave Keeper], O.[Division Leave Keeper E-mail], O.SyncID, O.EmployeeNumberNumeric,

[Delegated Manager Permission Mask] = dbo.fnPermissionGetOnPersonForCurrentUser(P.PersonID, 9),
DM.DelegatedManagerID, DM.EffectiveManagerID, DM.[Delegated Manager], DM.[Effective Manager], DM.[Effective Manager Work E-mail],

[Personal Permission Mask] = dbo.fnPermissionGetOnPersonForCurrentUser(P.PersonID, 4),
SSN = ISNULL(PX.SSN, ''),
[Country of Citizenship] = ISNULL(PX.[Country of Citizenship], ''),
Visa = ISNULL(PX.Visa, ''),
Spouse = ISNULL(PX.Spouse, ''),
Children = ISNULL(PX.Children, ''),
Race = ISNULL(PX.Race, ''),
[I9 Status] = ISNULL(PX.[I9 Status], ''),
[Marital Status] = ISNULL(PX.[Marital Status], ''),
[Driver License Class] = ISNULL(PX.[Driver License Class], ''),
Passport = ISNULL(PX.Passport, ''),
[Driver License] = ISNULL(PX.[Driver License], ''),
[Driver License State] = ISNULL(PX.[Driver License State], ''),
PX.[RaceID], PX.[I9StatusID], PX.[Renew I9 Status Day past 1900], PX.[Visa Expires Day past 1900], PX.VisaStatusID, PX.[Visa Status], PX.[Passport Expires Day past 1900], PX.[DOB Day past 1900], PX.[Driver License Expires Day past 1900], PX.[Driver Insurance Expires Day past 1900], PX.[Commercial Driver License], PX.[MaritalStatusID], PX.[Dependents], PX.[Disabled], PX.[Smoker],
PX.[DOB], PX.[Driver License Expires], PX.[Driver Insurance Expires], PX.[Renew I9 Status], PX.[Visa Expires], PX.[Passport Expires], PX.[Military Service], PX.[Birth Day past 1900], PX.MilitaryBranchID, PX.Reserves,

[Account Permission Mask] = dbo.fnPermissionGetOnPersonForCurrentUser(P.PersonID, 32),
Account = ISNULL(EA.Account, ''),
EA.[SID],

[Termination Permission Mask] = dbo.fnPermissionGetOnPersonForCurrentUser(P.PersonID, 16777216),
[Reason for Termination] = ISNULL(T.[Reason for Termination], ''),
Reason = ISNULL(T.Reason, ''),
T.[Rehire], T.[Terminated], T.[Terminated Day past 1900], T.TerminationReasonID,
T.ExitInterviewByEmployeeID, T.[Exit Interview by], T.[Exit Interview Day past 1900], T.[Exit Interview],
[Days Employed] = 1 + CASE 
	WHEN T.[Terminated Day past 1900] IS NULL THEN DATEDIFF(d,0,GETDATE())
	ELSE T.[Terminated Day past 1900]
END - ISNULL(O.[DOH Day past 1900], O.[Seniority Begins Day past 1900]),
[Compensation Permission Mask] = dbo.fnPermissionGetOnPersonForCurrentUser(P.PersonID, 1024),
[Current Annualized Pay]=ISNULL(EC.[Annualized Pay], 0), 
[Current Daily Pay]=ISNULL(EC.[Daily Pay], 0), 
[Current Hourly Pay]=ISNULL(EC.[Hourly Pay],0), 
[Current Position Status]=ISNULL(EC.[Position Status],''), [Current Employment Status]=ISNULL(EC.[Employment Status],''), [Current Pay Grade]=ISNULL(EC.[Pay Grade],''), [Current Pay Step]=ISNULL(EC.[Pay Step],''), [Current Job Title]=ISNULL(EC.[Job Title],''),
[Current FTE] = ISNULL(EC.FTE, 0),

[Successor Permission Mask] = dbo.fnPermissionGetOnPersonForCurrentUser(P.PersonID, 524288),
[Successor Names] = ISNULL(ES.[Successor Names], ''),
[Successor Initials] = ISNULL(ES.[Successor Initials], ''),

[Succeeds Permission Mask] = dbo.fnPermissionGetOnPersonForCurrentUser(P.PersonID, 67108864),
[Succeeds Names] = ISNULL(EX.[Succeeds Names], ''),
[Succeeds Initials] = ISNULL(EX.[Succeeds Initials], ''),

[InOut Permission Mask] = dbo.fnPermissionGetOnPersonForCurrentUser(P.PersonID, 50),
InOut.InOutStatusID,
InOutStatus = ISNULL(InOut.Status, ''),
InOutComment = ISNULL(InOut.InOutComment, ''),
InOutColor=InOut.Color,
InOut.InOutReturn, InOut.InOutLastUpdated, InOut.InOutLastSource,

[Language Permission Mask] = dbo.fnPermissionGetOnPersonForCurrentUser(P.PersonID, 10007),
[Primary Language] = ISNULL(PX2.PrimaryLanguages2,''),
[Secondary Languages] = ISNULL(PX2.SecondaryLanguages2,''),
L.PrimaryLanguageID, L.[Secondary Language Mask], L.[Language Mask],

[Union Permission Mask] = dbo.fnPermissionGetOnPersonForCurrentUser(P.PersonID, 32768),
Unions = ISNULL(PX3.Unions,''),

[Benefit Invoice Permission Mask] = dbo.fnPermissionGetOnPersonForCurrentUser(P.PersonID, 536870913),
[Advance Pay] = ISNULL(INV.[Advance Pay], 0),
BatchCreateInvoice = ISNULL(INV.BatchCreateInvoice, 0),

[Benefit Payment Permission Mask] = dbo.fnPermissionGetOnPersonForCurrentUser(P.PersonID, 536870914),
NSF = ISNULL(PMT.NSF, 0),

COBRA.[Track COBRA],
[COBRA First Payment Due Day past 1900] = COBRA.[First Payment Due Day past 1900],
[COBRA First Payment] = COBRA.[First Payment Due],
[COBRA Next Payment Due Day past 1900] = COBRA.[Next Payment Due Day past 1900],
[COBRA Next Payment] = COBRA.[Next Payment Due],
COBRA.[COBRA Eligible Day past 1900], COBRA.[COBRA Eligible],
COBRA.[COBRA Declined Day past 1900], COBRA.[COBRA Declined],
COBRA.[COBRA First Enrolled Day past 1900], COBRA.[COBRA First Enrolled],
COBRA.[COBRA Last Enrolled Day past 1900], COBRA.[COBRA Last Enrolled],
COBRA.[COBRA Enrolled Day past 1900], COBRA.[COBRA Enrolled],
COBRA.[COBRA Notified Day past 1900], COBRA.[COBRA Notified],
COBRA.[COBRA Expires Day past 1900], COBRA.[COBRA Expires],
[COBRA Enrollment] = COBRA.Enrollment,
COBRA.[COBRA First Qualifying Event], COBRA.[COBRA Last Qualifying Event],
COBRA.[COBRA First Qualifying Event Date],
COBRA.[COBRA Last Qualifying Event Date],

[Benefit Permission Mask] = dbo.fnPermissionGetOnPersonForCurrentUser(P.PersonID, 536870912), EB.*,
[Custom Permission Mask] = dbo.fnPermissionGetOnPersonForCurrentUser(P.PersonID, 4194304), PC.*,

[Employee Terminal Permission Mask] = dbo.fnPermissionGetOnPersonForCurrentUser(P.PersonID, 10),
[Terminal Password] = ISNULL(TERMINAL.[Terminal Password],''),
[PID Card Number] = ISNULL(TERMINAL.[PID Card Number],''),
TerminalSyncFlags = ISNULL(TERMINAL.TerminalSyncFlags,0),
TerminalSyncFlags2 = ISNULL(TERMINAL.TerminalSyncFlags2,0),
[Enrolled Terminals Mask] = ISNULL(TERMINAL.[Enrolled Terminals Mask],0),
[Terminal Sync State Mask] = ISNULL(TERMINAL.[Terminal Sync State Mask],0),
TERMINAL.[Terminal Last Sync],
[Terminal Sync Status] = dbo.fnGetTerminalSyncStatus(TERMINAL.[Terminal Last Sync], TERMINAL.[Terminal Sync State Mask]),
TERMINAL.[Fingerprints Stream],
EmployeeNumberT = dbo.fnNormalizeTerminalEnrollNumber(TERMINAL.[Employee Number], TERMINAL.EmployeeID),
-- TERMINAL.[Active Employee], -- Required by client but already selected

[Effective Seconds per Day] = ISNULL(SPD.[Effective Seconds per Day], 0),
[Shift Seconds per Day] = ISNULL(SPD.[Shift Seconds per Day], 0),
[Seconds per Day Override] = ISNULL(SPD.[Seconds per Day Override], 0),
[Days On] = ISNULL(SPD.[Days On], 7), [DaysOn2] = ISNULL(SPD.[DaysOn2], 0),
[Days Off] = ISNULL(SPD.[Days Off],0), [DaysOff2] = ISNULL(SPD.[DaysOff2], 0),
[Leave Accrual Multiplier] = ISNULL(SPD.[Leave Accrual Multiplier],1),
[Shift FTE] = ISNULL(SPD.[Shift FTE],1),

[Leave Permission Mask] = dbo.fnPermissionGetOnPersonForCurrentUser(W.PersonID, 10001),
[Holiday Plan] = ISNULL(HP.[Plan], ''),
[Leave Note] = ISNULL(LEAVE.[Leave Note],''),
[Ongoing Condition] = ISNULL(LEAVE.[Ongoing Condition],0),
LEAVE.[Recertify Condition Day past 1900],
[Recertify Condition] = dbo.GetDateFromDaysPast1900(LEAVE.[Recertify Condition Day past 1900]),
LEAVE.HolidayPlanID,

L2.*, ED.*, PXS.*

FROM dbo.vwPersonCalculated P
LEFT JOIN dbo.vwPersonWork W ON P.PersonID = W.PersonID AND (dbo.fnPermissionGetOnPersonForCurrentUser(P.PersonID, 2) & 1) = 1
LEFT JOIN dbo.vwPersonHome H ON P.PersonID = H.PersonID AND (dbo.fnPermissionGetOnPersonForCurrentUser(P.PersonID, 1) & 1) = 1
LEFT JOIN dbo.vwEmployeeReview R ON P.PersonID = R.EmployeeID AND (dbo.fnPermissionGetOnPersonForCurrentUser(P.PersonID, 16) & 1) = 1
LEFT JOIN dbo.vwEmployeePayStep PS ON P.PersonID = PS.EmployeeID AND (dbo.fnPermissionGetOnPersonForCurrentUser(P.PersonID, 64) & 1) = 1
LEFT JOIN dbo.vwEmployeeOrg O ON P.PersonID = O.EmployeeID AND (dbo.fnPermissionGetOnPersonForCurrentUser(P.PersonID, 8) & 1) = 1
LEFT JOIN dbo.vwPersonX PX ON P.PersonID = PX.PersonID AND (dbo.fnPermissionGetOnPersonForCurrentUser(P.PersonID, 4) & 1) = 1
LEFT JOIN dbo.vwEmployeeAccount EA ON P.PersonID = EA.EmployeeID AND (dbo.fnPermissionGetOnPersonForCurrentUser(P.PersonID, 32) & 1) = 1
LEFT JOIN dbo.vwEmployeeTermination T ON P.PersonID = T.EmployeeID AND (dbo.fnPermissionGetOnPersonForCurrentUser(P.PersonID, 16777216) & 1) = 1
LEFT JOIN dbo.vwEmployeeLastCompensation EC ON P.PersonID = EC.EmployeeID AND (dbo.fnPermissionGetOnPersonForCurrentUser(P.PersonID, 1024) & 1) = 1
LEFT JOIN dbo.vwEmployeeSuccessorNames ES ON P.PersonID = ES.EmployeeID AND (dbo.fnPermissionGetOnPersonForCurrentUser(P.PersonID, 524288) & 1) = 1
LEFT JOIN dbo.vwEmployeeSucceedsNames EX ON P.PersonID = EX.EmployeeID AND (dbo.fnPermissionGetOnPersonForCurrentUser(P.PersonID, 67108864) & 1) = 1
LEFT JOIN dbo.vwEmployeeUpdateInOutStatus InOut ON P.PersonID=InOut.EmployeeID AND (dbo.fnPermissionGetOnPersonForCurrentUser(P.PersonID, 50) & 1) = 1
LEFT JOIN dbo.vwEmployeeBINV INV ON P.PersonID = INV.EmployeeID AND (dbo.fnPermissionGetOnPersonForCurrentUser(P.PersonID, 536870913) & 1) = 1
LEFT JOIN dbo.vwEmployeeBPMT PMT ON P.PersonID = PMT.EmployeeID AND (dbo.fnPermissionGetOnPersonForCurrentUser(P.PersonID, 536870914) & 1) = 1
LEFT JOIN dbo.vwEmployeeBenefitFlat EB ON P.PersonID = EB.EBFEmployeeID AND (dbo.fnPermissionGetOnPersonForCurrentUser(P.PersonID, 536870912) & 1) = 1
LEFT JOIN dbo.vwEmployeeDeductionFlat ED ON P.PersonID = ED.EDFEmployeeID AND (dbo.fnPermissionGetOnPersonForCurrentUser(P.PersonID, 536870912) & 1) = 1
LEFT JOIN dbo.vwPersonXSkillFlat PXS ON P.PersonID = PXS.PXSPersonID AND (dbo.fnPermissionGetOnPersonForCurrentUser(P.PersonID, 2097152) & 1) = 1
LEFT JOIN dbo.vwEmployeeCOBRA COBRA ON P.PersonID = COBRA.EmployeeID AND (dbo.fnPermissionGetOnPersonForCurrentUser(P.PersonID, 536870912) & 1) = 1
LEFT JOIN dbo.vwPersonCustomFieldFlatSecure PC ON P.PersonID = PC.PCFPersonID
LEFT JOIN dbo.vwEmployeeDelegatedManager DM ON P.PersonID = DM.EmployeeID AND (dbo.fnPermissionGetOnPersonForCurrentUser(P.PersonID, 9) & 1) = 1
LEFT JOIN dbo.Employee TERMINAL ON P.PersonID = TERMINAL.EmployeeID AND (dbo.fnPermissionGetOnPersonForCurrentUser(P.PersonID, 10) & 1) = 1
LEFT JOIN dbo.PersonXLanguageFlat L2 ON P.PersonID=L2.LPPersonID AND (dbo.fnPermissionGetOnPersonForCurrentUser(P.PersonID, 10007) & 1) = 1
LEFT JOIN dbo.vwPersonXLanguages L ON P.PersonID=L.PersonID AND (dbo.fnPermissionGetOnPersonForCurrentUser(P.PersonID, 10007) & 1) = 1
LEFT JOIN dbo.PersonX PX2 ON P.PersonID=PX2.PersonID AND (dbo.fnPermissionGetOnPersonForCurrentUser(P.PersonID, 10007) & 1) = 1
LEFT JOIN dbo.PersonX PX3 ON P.PersonID=PX3.PersonID AND (dbo.fnPermissionGetOnPersonForCurrentUser(P.PersonID, 32768) & 1) = 1
LEFT JOIN dbo.vwEmployeeEffectiveSecondsPerDay SPD ON P.PersonID = SPD.EmployeeID -- AND (dbo.fnPermissionGetOnPersonForCurrentUser(P.PersonID, 8) & 1) = 1 Used in calculations of dependent stored procs
LEFT JOIN dbo.Employee LEAVE ON P.PersonID = LEAVE.EmployeeID AND (dbo.fnPermissionGetOnPersonForCurrentUser(P.PersonID, 10001) & 1) = 1
LEFT JOIN dbo.HolidayPlan HP ON LEAVE.HolidayPlanID = HP.PlanID
GO
GRANT SELECT ON dbo.vwEmployeeSecure TO public
GO
IF OBJECT_ID('dbo.vwEmployeeCompensationFlat') IS NULL EXEC sp_executesql N'CREATE VIEW dbo.vwEmployeeCompensationFlat AS SELECT A=0'
GO
ALTER VIEW dbo.vwEmployeeCompensationFlat
AS
SELECT EC.*, E.*
FROM dbo.vwEmployeeCompensation EC
INNER JOIN dbo.vwEmployeeSecure E ON EC.EmployeeID=E.EID AND (dbo.fnPermissionGetOnPersonForCurrentUser(EC.EmployeeID, 1024) & 1) = 1
GO
GRANT SELECT ON dbo.vwEmployeeCompensationFlat TO public
GO
CREATE VIEW dbo.vwInvoiceFlat
AS
SELECT  I.*, E.*,
[Status] = dbo.fnGetInvoiceStatus(I.Total, I.Payment, I.Credit, I.[Due Day past 1900], GETDATE()),
Aging = dbo.fnGetInvoiceAging(I.Balance, I.[Due Day past 1900], GETDATE()),
AmountDue0 = dbo.fnGetAmountDueBetween(I.EmployeeID, GETDATE(), 0, 0),
AmountDue30 = dbo.fnGetAmountDueBetween(I.EmployeeID, GETDATE(), 1, 30),
AmountDue60 = dbo.fnGetAmountDueBetween(I.EmployeeID, GETDATE(), 31, 60),
AmountDue90 = dbo.fnGetAmountDueBetween(I.EmployeeID, GETDATE(), 61, 90),
AmountDue91 = dbo.fnGetAmountDueBetween(I.EmployeeID, GETDATE(), 91, 2147483647),
AmountDueAll = dbo.fnGetAmountDueBetween(I.EmployeeID, GETDATE(), 0, 2147483647)
FROM dbo.vwInvoice I
INNER JOIN dbo.vwEmployeeSecure E ON I.EmployeeID = E.EID AND (dbo.fnPermissionGetOnPersonForCurrentUser(I.EmployeeID, 536870913) & 1) = 1
GO
GRANT SELECT ON dbo.vwInvoiceFlat TO public
GO
IF OBJECT_ID('dbo.vwPaymentFlat') IS NOT NULL DROP VIEW dbo.vwPaymentFlat
GO
CREATE VIEW dbo.vwPaymentFlat
AS
SELECT P.PaymentID,P.EmployeeID,P.TypeID,P.[Transaction Number],P.Total,P.[Received Day past 1900],P.[Created Day past 1900],P.[Created By],P.[Last Updated Day past 1900],P.[Last Updated By],P.Split,P.Refund,P.Applied,P.Unapplied,P.Invoices,P.Unrefunded,P.Type,P.Received,P.Created,P.[Last Updated],P.Status,P.Employee,P.[Employee Full Name],
E.*
FROM vwPayment P
INNER JOIN vwEmployeeSecure E ON P.EmployeeID = E.EID AND (dbo.fnPermissionGetOnPersonForCurrentUser(P.EmployeeID, 536870914) & 1) = 1
GO
GRANT SELECT ON dbo.vwPaymentFlat TO public
GO
IF OBJECT_ID('dbo.vwEmployeeBenefitFlat2') IS NOT NULL DROP VIEW dbo.vwEmployeeBenefitFlat2
GO
CREATE VIEW dbo.vwEmployeeBenefitFlat2
AS
SELECT EB.*, E.*,
Enrollment = dbo.fnGetEnrollment(GETDATE(),EB.[Wait List Day past 1900], EB.[Wait List Queue], EB.[Declined Day past 1900], EB.[First Enrolled Day past 1900], EB.[Last Enrolled Day past 1900], EB.[Expires Day past 1900], EB.[Eligible Day past 1900]),
EnrollmentID = dbo.fnGetEnrollmentID(GETDATE(), EB.[Declined Day past 1900],EB.[Expires Day past 1900],EB.[First Enrolled Day past 1900],EB.[Last Enrolled Day past 1900],EB.[Eligible Day past 1900],EB.[Notified Day past 1900])
FROM dbo.vwEmployeeBenefit EB
INNER JOIN dbo.vwEmployeeSecure E ON EB.EmployeeID = E.EID AND (dbo.fnPermissionGetOnPersonForCurrentUser(EB.EmployeeID, 536870912) & 1) = 1
GO
GRANT SELECT ON dbo.vwEmployeeBenefitFlat2 TO public
GO
/* VIEWS DEPENDENT ON FLAT VIEWS END ***********************************************************************/

/* OBSOLETE STORED PROCS ***********************************************************************/
IF OBJECT_id('dbo.spEmployeeLeaveSummarizeUnusedPaidLeaveAsOfToday') IS NOT NULL DROP PROC dbo.spEmployeeLeaveSummarizeUnusedPaidLeaveAsOfToday
IF OBJECT_id('dbo.spAdminCompareCalculatedToActual') IS NOT NULL DROP PROC dbo.spAdminCompareCalculatedToActual
IF OBJECT_id('dbo.spEmployeePositionDelete') IS NOT NULL DROP PROC dbo.spEmployeePositionDelete
IF OBJECT_id('dbo.spEmployeeTimeListCreditsForHourlyEmployees') IS NOT NULL DROP PROC dbo.spEmployeeTimeListCreditsForHourlyEmployees
IF OBJECT_ID('dbo.spEmployeeTimePunchIn') IS NOT NULL DROP PROC dbo.spEmployeeTimePunchIn
/* NORMAL STORED PROC CHANGES BEGIN ***********************************************************************/
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spCalendarRemarkUpdate', 0
EXEC dbo.spAdminCreateSPifNonexistent 'spCalendarRemarkDelete', 0
EXEC dbo.spAdminCreateSPifNonexistent 'spCalendarRemarkUpdateOthers', 0
EXEC dbo.spAdminCreateSPifNonexistent 'spCalendarRemarkDeleteOthers', 0
GO
ALTER PROC dbo.spCalendarRemarkUpdate
	@remark_id int,
	@remark varchar(4000),
	@day int
AS
SET NOCOUNT ON

IF IS_MEMBER('db_owner') = 1 OR PERMISSIONS(OBJECT_ID('dbo.spCalendarRemarkUpdateOthers')) & 32 = 32 OR EXISTS(
	SELECT * FROM dbo.CalendarRemark WHERE RemarkID = @remark_id AND SUSER_SNAME() = [Created By]
)
UPDATE CalendarRemark SET Remark = @remark, [Day past 1900] = @day WHERE RemarkID = @remark_id
ELSE RAISERROR(N'You lack write permission on leave web calendar remarks that were created by other users.', 16, 1)
GO
ALTER PROC dbo.spCalendarRemarkDelete
	@remark_id int
AS
SET NOCOUNT ON

IF IS_MEMBER('db_owner') = 1 OR PERMISSIONS(OBJECT_ID('dbo.spCalendarRemarkDeleteOthers')) & 32 = 32 OR EXISTS(
	SELECT * FROM dbo.CalendarRemark WHERE RemarkID = @remark_id AND SUSER_SNAME() = [Created By]
)
DELETE CalendarRemark WHERE RemarkID = @remark_id
ELSE RAISERROR(N'You lack delete permission on leave web calendar remarks that were created by other users.', 16, 1)
GO
IF NOT EXISTS(SELECT * FROM dbo.PermissionObject WHERE ObjectID=68)
BEGIN
	IF PERMISSIONS(OBJECT_ID('dbo.spCalendarRemarkUpdate')) & 32 = 32 GRANT EXEC ON dbo.spCalendarRemarkUpdateOthers TO public
	IF PERMISSIONS(OBJECT_ID('dbo.spCalendarRemarkDelete')) & 32 = 32 GRANT EXEC ON dbo.spCalendarRemarkDeleteOthers TO public
END
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spEmployeeTimeSetRateBasedOnComp', 1
GO
ALTER PROC dbo.spEmployeeTimeSetRateBasedOnComp @compensation_id int AS
DECLARE @hourly_pay money, @start datetime, @stop datetime, @employee_id int, @employee nvarchar(400)
DECLARE @auth_comp bit, @auth_approved bit, @auth_pending bit

SELECT
@hourly_pay = dbo.fnConvertPay2(EC.[Base Pay], /*FTE40*/ POS.[Seconds per Week] / 144000.0, EC.[Employee Seconds per Week], P.FTEM, P.FTEB, P.Seconds, 0, 1, 3600),
@employee_id = EC.EmployeeID,
@start = DATEADD(d, 0, EC.[Start Day past 1900]),
@stop = CASE WHEN EC.[Stop Day past 1900] IS NULL THEN '9999-12-31' ELSE DATEADD(millisecond, 86399994, DATEADD(d, 0, EC.[Stop Day past 1900])) END
FROM dbo.EmployeeCompensation EC
INNER JOIN dbo.Period P ON EC.PeriodID = P.PeriodID AND EC.CompensationID = @compensation_id
INNER JOIN dbo.Position POS ON EC.PositionID = POS.PositionID
INNER JOIN dbo.Person PSN ON EC.EmployeeID = PSN.PersonID

IF @@ROWCOUNT = 0 RETURN

EXEC dbo.spPermissionInsureForCurrentUserOnPerson @employee_id, 1024, 2, @auth_comp out -- Comp entry

IF @auth_comp = 1
BEGIN
	EXEC dbo.spPermissionGetOnPersonForCurrentUser2 @employee_id, 262144, 2, @auth_approved out -- Time approved
	EXEC dbo.spPermissionGetOnPersonForCurrentUser2 @employee_id, 262145, 2, @auth_pending out -- Time pending

	DECLARE @m nvarchar(MAX)

	SET @m = ''
	IF @auth_approved = 0 AND EXISTS(SELECT * FROM dbo.EmployeeTime WHERE EmployeeID = @employee_id AND [In] BETWEEN @start AND @stop AND StatusID != 8 AND ISNULL([Pay Rate],0) <> @hourly_pay) SET @m = @m + 'You lack update permission on approved timecards for ' + @employee + '. '
	IF @auth_pending = 0 AND EXISTS(SELECT * FROM dbo.EmployeeTime WHERE EmployeeID = @employee_id AND [In] BETWEEN @start AND @stop AND StatusID = 8 AND ISNULL([Pay Rate],0) <> @hourly_pay) SET @m = @m + 'You lack update permission on pending timecards for ' + @employee + '. '

	IF @m <> '' RAISERROR(16,1,@m)
	ELSE UPDATE ET SET [Pay Rate] = @hourly_pay FROM dbo.EmployeeTime ET WHERE EmployeeID = @employee_id AND [In] BETWEEN @start AND @stop AND ([Pay Rate] IS NULL OR [Pay Rate] <> @hourly_pay)
END
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spEmployeeTimeCompareRateToComp', 1
GO
ALTER PROC dbo.spEmployeeTimeCompareRateToComp @compensation_id int, @results varchar(400) OUT AS
SET @results = ''
DECLARE @hourly_pay money, @start datetime, @stop datetime, @employee_id int, @employee nvarchar(400), @in datetime, @out datetime, @pay_rate money
DECLARE @auth_comp bit, @auth_approved bit, @auth_pending bit, @i int, @usd varchar(400)

SELECT
@hourly_pay = dbo.fnConvertPay2(EC.[Base Pay], /*FTE40*/ POS.[Seconds per Week] / 144000.0, EC.[Employee Seconds per Week], P.FTEM, P.FTEB, P.Seconds, 0, 1, 3600),
@employee_id = EC.EmployeeID,
@start = DATEADD(d, 0, EC.[Start Day past 1900]),
@stop = CASE WHEN EC.[Stop Day past 1900] IS NULL THEN '9999-12-31' ELSE DATEADD(millisecond, 86399994, DATEADD(d, 0, EC.[Stop Day past 1900])) END
FROM dbo.EmployeeCompensation EC
INNER JOIN dbo.Period P ON EC.PeriodID = P.PeriodID AND EC.CompensationID = @compensation_id
INNER JOIN dbo.Position POS ON EC.PositionID = POS.PositionID
INNER JOIN dbo.Person PSN ON EC.EmployeeID = PSN.PersonID

IF @@ROWCOUNT = 0 RETURN

EXEC dbo.spPermissionGetOnPersonForCurrentUser2 @employee_id, 1024, 1, @auth_comp out -- Comp entry
EXEC dbo.spPermissionGetOnPersonForCurrentUser2 @employee_id, 262144, 1, @auth_approved out -- Time approved
EXEC dbo.spPermissionGetOnPersonForCurrentUser2 @employee_id, 262145, 1, @auth_pending out -- Time pending

IF @auth_comp = 0 OR @auth_approved = 0 OR @auth_pending = 0 RETURN

SELECT @usd = Currency FROM dbo.Constant

DECLARE e_cursor CURSOR LOCAL FOR SELECT [In], [Out], [Pay Rate] FROM dbo.vwEmployeeTime WHERE EmployeeID = @employee_id AND [In] BETWEEN @start AND @stop AND ISNULL([Pay Rate],0) <> @hourly_pay ORDER BY [In]

OPEN e_cursor

SET @i = 0
FETCH e_cursor INTO @in, @out, @pay_rate
WHILE @@FETCH_STATUS = 0 AND @i < 10
BEGIN
	IF @results <> '' SET @results = @results + ', '
	SET @results = @results + @usd + CAST(CAST(@pay_rate AS numeric(9,2)) AS nvarchar(MAX)) + '\hr ' + CAST(@in AS nvarchar(MAX)) + CASE WHEN @out = @in OR @out IS NULL THEN '' ELSE ' to ' + CAST(@out AS nvarchar(MAX)) END
	FETCH e_cursor INTO @in, @out, @pay_rate
	SET @i = @i + 1
END
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spEmployeeList', 1
GO
ALTER PROCEDURE [dbo].[spEmployeeList]
	@active bit,
	@employee_id int,
	--@list_all_nurses bit = 0,
	--@list_all_hr_coordinators bit = 0,
	@list_all_managers bit = 0,
	@list_all_successors bit = 0
AS
DECLARE @batch_id int

SET NOCOUNT ON

IF @active IS NULL
BEGIN
	IF IS_MEMBER('db_owner')=1
	SELECT P.PersonID, P.[List As] FROM vwPersonListAs P
	INNER JOIN Employee E ON P.PersonID = E.EmployeeID ORDER BY P.[List As]
	ELSE
BEGIN
EXEC dbo.spAdminGetNextRandom @batch_id out
INSERT dbo.TempX(BatchID, [ID])
SELECT @batch_id, E.EmployeeID FROM Employee E
EXEC dbo.spPermissionGetOnPeopleForCurrentUser2 @batch_id, 2
SELECT P.PersonID, P.[List As], [Active Employee] = 1 FROM dbo.vwPersonListAs P
INNER JOIN dbo.TempX X ON X.BatchID = @batch_id AND X.[ID]= P.PersonID AND (X.X & 1) = 1
ORDER BY P.[List As]
DELETE dbo.Tempx WHERE BatchID=@batch_id
END

END
ELSE IF @list_all_managers = 0 AND @list_all_successors = 0 -- @list_all_nurses = 0 AND @list_all_hr_coordinators = 0 AND 
BEGIN
	IF IS_MEMBER('db_owner')=1
	SELECT P.PersonID, P.[List As] FROM vwPersonListAs P
	INNER JOIN Employee E ON P.PersonID = E.EmployeeID AND (E.[Active Employee] = @active OR P.PersonID = @employee_id) 
	ORDER BY P.[List As]
ELSE
BEGIN
EXEC dbo.spAdminGetNextRandom @batch_id out
INSERT dbo.TempX(BatchID, [ID])
SELECT @batch_id, E.EmployeeID FROM Employee E WHERE (E.[Active Employee] = @active OR E.EmployeeID = @employee_id)
EXEC dbo.spPermissionGetOnPeopleForCurrentUser2 @batch_id, 2
SELECT P.PersonID, P.[List As], [Active Employee] = 1 FROM dbo.vwPersonListAs P
INNER JOIN dbo.TempX X ON X.BatchID = @batch_id AND X.[ID]= P.PersonID AND (X.X & 1) = 1
ORDER BY P.[List As]
DELETE dbo.Tempx WHERE BatchID=@batch_id
END

END
ELSE
BEGIN
	SELECT @batch_id = RAND() * 2148473647

	INSERT TempX(BatchID, [ID])
	SELECT @batch_id, EmployeeID FROM Employee WHERE [Active Employee] = @active OR EmployeeID = @employee_id

	--IF @list_all_nurses = 1
	--INSERT TempX(BatchID, [ID])
	--SELECT DISTINCT @batch_id, NurseEmployeeID FROM Department WHERE NurseEmployeeID IS NOT NULL

	--IF @list_all_hr_coordinators = 1
	--INSERT TempX(BatchID, [ID])
	--SELECT DISTINCT @batch_id, HRCoordinatorEmployeeID FROM Department WHERE HRCoordinatorEmployeeID IS NOT NULL

	IF @list_all_managers = 1
	INSERT TempX(BatchID, [ID])
	SELECT DISTINCT @batch_id, ManagerID FROM Employee WHERE ManagerID IS NOT NULL

	IF @list_all_successors = 1
	BEGIN
		INSERT TempX(BatchID, [ID])
		SELECT DISTINCT @batch_id, SuccessorID FROM EmployeeSuccessor

		INSERT TempX(BatchID, [ID])
		SELECT DISTINCT @batch_id, EmployeeID FROM EmployeeSuccessor
	END

EXEC dbo.spPermissionGetOnPeopleForCurrentUser2 @batch_id, 2

	-- Distinct is not required because TempX ignores duplicate keys
	SELECT P.PersonID, P.[List As] FROM vwPersonListAs P
	INNER JOIN TempX T ON T.BatchID = @batch_id AND T.[ID] = P.PersonID AND (T.X & 1) = 1
	ORDER BY P.[List As]

DELETE dbo.Tempx WHERE BatchID=@batch_id

END

GO

EXEC dbo.spAdminCreateSPifNonexistent 'spEmployeeListManagers', 1
GO
ALTER PROCEDURE [dbo].[spEmployeeListManagers]
AS
SET NOCOUNT ON

IF IS_MEMBER('db_owner')=1
SELECT P.PersonID, P.[List As]
FROM vwPersonListAs P WHERE P.PersonID IN
(
	SELECT ManagerID FROM Employee WHERE [Active Employee] = 1
)
ORDER BY P.[List As]
ELSE
BEGIN
DECLARE @batch_id int
EXEC dbo.spAdminGetNextRandom @batch_id out

INSERT dbo.TempX(BatchID, [ID])
SELECT DISTINCT @batch_id, ManagerID FROM Employee WHERE [Active Employee] = 1 AND ManagerID IS NOT NULL


EXEC dbo.spPermissionGetOnPeopleForCurrentUser2 @batch_id, 2


SELECT P.PersonID, P.[List As] FROM dbo.vwPersonListAs P
INNER JOIN dbo.TempX X ON X.BatchID = @batch_id AND X.[ID]= P.PersonID AND (X.X & 1) = 1
ORDER BY P.[List As]

DELETE dbo.Tempx WHERE BatchID=@batch_id
END
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spEmployeeListInDepartment', 1
GO
ALTER PROCEDURE [dbo].[spEmployeeListInDepartment]
	@active bit,
	@department_id int
AS
SET NOCOUNT ON

IF IS_MEMBER('db_owner')=1
SELECT P.PersonID, P.[List As] FROM vwPersonListAs P
INNER JOIN Employee E ON P.PersonID = E.EmployeeID AND DepartmentID = @department_id AND ((@active IS NULL) OR E.[Active Employee] = @active) ORDER BY P.[List As]
ELSE
BEGIN
DECLARE @batch_id int
EXEC dbo.spAdminGetNextRandom @batch_id out

INSERT dbo.TempX(BatchID, [ID])
SELECT @batch_id, E.EmployeeID FROM Employee E WHERE DepartmentID = @department_id AND (@active IS NULL OR E.[Active Employee] = @active)

EXEC dbo.spPermissionGetOnPeopleForCurrentUser2 @batch_id, 2


SELECT P.PersonID, P.[List As] FROM dbo.vwPersonListAs P
INNER JOIN dbo.TempX X ON X.BatchID = @batch_id AND X.[ID]= P.PersonID AND (X.X & 1) = 1
ORDER BY P.[List As]

DELETE dbo.Tempx WHERE BatchID=@batch_id
END

GO


EXEC dbo.spAdminCreateSPifNonexistent 'spEmployeeListInDivision', 1
GO
ALTER PROCEDURE [dbo].[spEmployeeListInDivision]
	@division_id int,
	@active bit
AS
SET NOCOUNT ON

IF IS_MEMBER('db_owner')=1
SELECT P.PersonID, P.[List As] FROM dbo.vwPersonListAs P
INNER JOIN Employee E ON P.PersonID = E.EmployeeID AND DivisionID = @division_id AND (@active IS NULL OR E.[Active Employee] = @active)
ORDER BY P.[List As]
ELSE
BEGIN
DECLARE @batch_id int
EXEC dbo.spAdminGetNextRandom @batch_id out

INSERT dbo.TempX(BatchID, [ID])
SELECT @batch_id, E.EmployeeID FROM Employee E WHERE DivisionID = @division_id AND (@active IS NULL OR E.[Active Employee] = @active)

EXEC dbo.spPermissionGetOnPeopleForCurrentUser2 @batch_id, 2


SELECT P.PersonID, P.[List As] FROM dbo.vwPersonListAs P
INNER JOIN dbo.TempX X ON X.BatchID = @batch_id AND X.[ID]= P.PersonID AND (X.X & 1) = 1
ORDER BY P.[List As]

DELETE dbo.Tempx WHERE BatchID=@batch_id
END
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spEmployeeListAtLocation', 1
GO
ALTER PROCEDURE [dbo].[spEmployeeListAtLocation]
	@active bit,
	@location_id int
AS
SET NOCOUNT ON

IF IS_MEMBER('db_owner')=1
SELECT P.PersonID, P.[List As] FROM vwPersonListAs P
INNER JOIN Employee E ON P.PersonID = E.EmployeeID AND LocationID = @location_id AND ((@active IS NULL) OR E.[Active Employee] = @active) ORDER BY P.[List As]
ELSE
BEGIN
DECLARE @batch_id int
EXEC dbo.spAdminGetNextRandom @batch_id out

INSERT dbo.TempX(BatchID, [ID])
SELECT @batch_id, E.EmployeeID FROM Employee E WHERE LocationID = @location_id AND (@active IS NULL OR E.[Active Employee] = @active)

EXEC dbo.spPermissionGetOnPeopleForCurrentUser2 @batch_id, 2


SELECT P.PersonID, P.[List As] FROM dbo.vwPersonListAs P
INNER JOIN dbo.TempX X ON X.BatchID = @batch_id AND X.[ID]= P.PersonID AND (X.X & 1) = 1
ORDER BY P.[List As]

DELETE dbo.Tempx WHERE BatchID=@batch_id
END
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spCompanyUpdateFlags', 0
GO
ALTER PROC dbo.spCompanyUpdateFlags @flags int, @reserved_flags int = 0x7F000000 AS UPDATE Constant SET Flags = (Flags & @reserved_flags) | @flags
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spPermissionGetCommonForCurrentUserOnPerson'
GO
ALTER PROC dbo.spPermissionGetCommonForCurrentUserOnPerson
	@person_id int,

	@benefits int out,
	@equipment int out,

	@delete int out,
	@termination int out,
	@terminal_sync int out,
	@delegated_manager int out,
	@binv int out,
	@bpmt int out,
	@employee_benefits int out,
	@leave_detail_pending int out,
	@leave_detail_approved int out,
	@leave_accrual int out,
	@leave_summary int out,
	@org int out,
	@pay int out,
	@account int out,
	@next_review int out,
	@reviews int out,
	@compensation int out,
	@timecard_pending int out,
	@communication int out,
	@personal int out,
	@languages int out,
	@employers int out,
	@home int out,
	@work int out,
	@custom int out
AS
DECLARE @batch_id int

SET NOCOUNT ON

EXEC dbo.spPermissionGetOnObjectForCurrentUser 24, @benefits out
EXEC dbo.spPermissionGetOnObjectForCurrentUser 25, @equipment out
EXEC dbo.spPermissionGetOnObjectForCurrentUser 22, @delete out -- delete any employee

SELECT @batch_id = RAND() * 2147483647

EXEC dbo.spAdminGetNextRandom @batch_id out

-- Delete employee
INSERT dbo.TempPersonPermission(BatchID, PersonID, AttributeID) VALUES(@batch_id, @person_id, 12)
-- Termination
INSERT dbo.TempPersonPermission(BatchID, PersonID, AttributeID) VALUES(@batch_id, @person_id, 0x1000000)
-- Home
INSERT dbo.TempPersonPermission(BatchID, PersonID, AttributeID) VALUES(@batch_id, @person_id, 1)
-- Work
INSERT dbo.TempPersonPermission(BatchID, PersonID, AttributeID) VALUES(@batch_id, @person_id, 2)
-- Custom
INSERT dbo.TempPersonPermission(BatchID, PersonID, AttributeID) VALUES(@batch_id, @person_id, 4194304)
-- TerminalSyncPermission
INSERT dbo.TempPersonPermission(BatchID, PersonID, AttributeID) VALUES(@batch_id, @person_id, 10)
-- DelegatedManagerPermission
INSERT dbo.TempPersonPermission(BatchID, PersonID, AttributeID) VALUES(@batch_id, @person_id, 9)
-- EmployeeBINVPermission
INSERT dbo.TempPersonPermission(BatchID, PersonID, AttributeID) VALUES(@batch_id, @person_id, 536870913)
-- EmployeeBPMTPermission
INSERT dbo.TempPersonPermission(BatchID, PersonID, AttributeID) VALUES(@batch_id, @person_id, 536870914)
-- EmployeeBenefits
INSERT dbo.TempPersonPermission(BatchID, PersonID, AttributeID) VALUES(@batch_id, @person_id, 536870912)
-- EmployeeLeaveDetailPendingPermission
INSERT dbo.TempPersonPermission(BatchID, PersonID, AttributeID) VALUES(@batch_id, @person_id, 10001)
-- EmployeeLeaveDetailPendingApproved
INSERT dbo.TempPersonPermission(BatchID, PersonID, AttributeID) VALUES(@batch_id, @person_id, 10013)
-- EmployeeLeaveAccrualPlanPermission
INSERT dbo.TempPersonPermission(BatchID, PersonID, AttributeID) VALUES(@batch_id, @person_id, 128)
-- EmployeeLeaveSummaryPermission
INSERT dbo.TempPersonPermission(BatchID, PersonID, AttributeID) VALUES(@batch_id, @person_id, 10003)
-- OrgPermission
INSERT dbo.TempPersonPermission(BatchID, PersonID, AttributeID) VALUES(@batch_id, @person_id, 8)
-- PayPermission
INSERT dbo.TempPersonPermission(BatchID, PersonID, AttributeID) VALUES(@batch_id, @person_id, 0x40)
-- AccountPermission
INSERT dbo.TempPersonPermission(BatchID, PersonID, AttributeID) VALUES(@batch_id, @person_id, 0x20)
-- NextReviewPermission
INSERT dbo.TempPersonPermission(BatchID, PersonID, AttributeID) VALUES(@batch_id, @person_id, 0x10)
-- ReviewsPermission
INSERT dbo.TempPersonPermission(BatchID, PersonID, AttributeID) VALUES(@batch_id, @person_id, 16384)
-- Compensation
INSERT dbo.TempPersonPermission(BatchID, PersonID, AttributeID) VALUES(@batch_id, @person_id, 1024)
-- Timecard pending
INSERT dbo.TempPersonPermission(BatchID, PersonID, AttributeID) VALUES(@batch_id, @person_id, 262144)
-- Communication
INSERT dbo.TempPersonPermission(BatchID, PersonID, AttributeID) VALUES(@batch_id, @person_id, 131072)
-- Personal
INSERT dbo.TempPersonPermission(BatchID, PersonID, AttributeID) VALUES(@batch_id, @person_id, 4)
-- Employers
INSERT dbo.TempPersonPermission(BatchID, PersonID, AttributeID) VALUES(@batch_id, @person_id, 1073741824)
-- languages
INSERT dbo.TempPersonPermission(BatchID, PersonID, AttributeID) VALUES(@batch_id, @person_id, 10007)

EXEC dbo.spPermissionGetOnPeopleForCurrentUser @batch_id

SELECT @terminal_sync = [Permission Mask] FROM dbo.TempPersonPermission WHERE BatchID=@batch_id AND AttributeID=10
SELECT @delegated_manager = [Permission Mask] FROM dbo.TempPersonPermission WHERE BatchID=@batch_id AND AttributeID=9
SELECT @binv = [Permission Mask] FROM dbo.TempPersonPermission WHERE BatchID=@batch_id AND AttributeID=536870913
SELECT @bpmt = [Permission Mask] FROM dbo.TempPersonPermission WHERE BatchID=@batch_id AND AttributeID=536870914
SELECT @employee_benefits = [Permission Mask] FROM dbo.TempPersonPermission WHERE BatchID=@batch_id AND AttributeID=536870912
SELECT @leave_detail_pending = [Permission Mask] FROM dbo.TempPersonPermission WHERE BatchID=@batch_id AND AttributeID=10001
SELECT @leave_detail_approved = [Permission Mask] FROM dbo.TempPersonPermission WHERE BatchID=@batch_id AND AttributeID=10013
SELECT @leave_accrual = [Permission Mask] FROM dbo.TempPersonPermission WHERE BatchID=@batch_id AND AttributeID=128
SELECT @leave_summary = [Permission Mask] FROM dbo.TempPersonPermission WHERE BatchID=@batch_id AND AttributeID=10003
SELECT @org = [Permission Mask] FROM dbo.TempPersonPermission WHERE BatchID=@batch_id AND AttributeID=8
SELECT @pay = [Permission Mask] FROM dbo.TempPersonPermission WHERE BatchID=@batch_id AND AttributeID=0x40
SELECT @account = [Permission Mask] FROM dbo.TempPersonPermission WHERE BatchID=@batch_id AND AttributeID=0x20
SELECT @next_review = [Permission Mask] FROM dbo.TempPersonPermission WHERE BatchID=@batch_id AND AttributeID=0x10
SELECT @reviews = [Permission Mask] FROM dbo.TempPersonPermission WHERE BatchID=@batch_id AND AttributeID=16384
SELECT @compensation = [Permission Mask] FROM dbo.TempPersonPermission WHERE BatchID=@batch_id AND AttributeID=1024
SELECT @timecard_pending = [Permission Mask] FROM dbo.TempPersonPermission WHERE BatchID=@batch_id AND AttributeID=262144
SELECT @communication = [Permission Mask] FROM dbo.TempPersonPermission WHERE BatchID=@batch_id AND AttributeID=131072
SELECT @personal = [Permission Mask] FROM dbo.TempPersonPermission WHERE BatchID=@batch_id AND AttributeID=4
SELECT @employers = [Permission Mask] FROM dbo.TempPersonPermission WHERE BatchID=@batch_id AND AttributeID=1073741824
SELECT @languages = [Permission Mask] FROM dbo.TempPersonPermission WHERE BatchID=@batch_id AND AttributeID=10007
SELECT @home = [Permission Mask] FROM dbo.TempPersonPermission WHERE BatchID=@batch_id AND AttributeID=1
SELECT @work = [Permission Mask] FROM dbo.TempPersonPermission WHERE BatchID=@batch_id AND AttributeID=2
SELECT @custom = [Permission Mask] FROM dbo.TempPersonPermission WHERE BatchID=@batch_id AND AttributeID=4194304
SELECT @termination = [Permission Mask] FROM dbo.TempPersonPermission WHERE BatchID=@batch_id AND AttributeID=0x1000000
IF (@delete & 8) = 0 SELECT @delete = [Permission Mask] FROM dbo.TempPersonPermission WHERE BatchID=@batch_id AND AttributeID=12 -- delete employee

DELETE dbo.TempPersonPermission WHERE BatchID=@batch_id OR DATEDIFF(minute, Created, GETDATE()) > 60
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spPermissionCacheAllForCurrentUser'
GO
ALTER PROC dbo.spPermissionCacheAllForCurrentUser
	@batch_id int
AS
IF IS_MEMBER('db_owner') = 0 AND @batch_id IS NOT NULL
BEGIN
	DECLARE @pbatch_id int, @cached_records int, @requested_records int, @sid varbinary(85), @cache_expires datetime

	SELECT @sid = SUSER_SID(), @cache_expires = DATEADD(hour,-1,GETDATE())

	DELETE dbo.PermissionCached WHERE Created < @cache_expires

	SELECT @cached_records = COUNT(*) FROM dbo.PermissionCached C INNER JOIN dbo.TempX X ON X.BatchID = @batch_id AND C.SID = @sid AND C.PersonID = X.[ID]
	SELECT @requested_records = COUNT(*) FROM dbo.TempX X CROSS JOIN dbo.PermissionAttribute A WHERE X.BatchID = @batch_id 

	IF @cached_records <> @requested_records
	BEGIN
		EXEC dbo.spAdminGetNextRandom @pbatch_id out

		INSERT dbo.TempPersonPermission(BatchID, PersonID, AttributeID)
		SELECT @pbatch_id, X.[ID], A.AttributeID
		FROM dbo.TempX X
		CROSS JOIN dbo.PermissionAttribute A WHERE X.BatchID = @batch_id

		DELETE P FROM dbo.TempPersonPermission P
		INNER JOIN dbo.PermissionCached C ON C.SID = @sid AND P.BatchID = @pbatch_id AND C.PersonID = P.PersonID AND C.AttributeID = P.AttributeID

		EXEC dbo.spPermissionGetOnPeopleForCurrentUser @pbatch_id

		DELETE dbo.TempPersonPermission WHERE BatchID = @pbatch_id
	END
END
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spEmployeeLeaveCalcAll'
GO
ALTER PROC dbo.spEmployeeLeaveCalcAll
AS
SET NOCOUNT ON
DECLARE @employee_id int

DECLARE e_cursor CURSOR LOCAL FOR 
SELECT E.EmployeeID
FROM Employee E

OPEN e_cursor

FETCH e_cursor INTO @employee_id
WHILE @@FETCH_STATUS = 0
BEGIN
	-- Applies limits
	EXEC spEmployeeLeaveCalcForEmployee @employee_id
	FETCH e_cursor INTO @employee_id
END

CLOSE e_cursor
DEALLOCATE e_cursor

-- Updates Start, Stop, Type Mask (Used and UsedItem)
DECLARE i_cursor CURSOR LOCAL FAST_FORWARD FOR SELECT LeaveID FROM EmployeeLeaveUsed
OPEN i_cursor

DECLARE @leave_id int
FETCH i_cursor INTO @leave_id
WHILE @@FETCH_STATUS = 0
BEGIN
	EXEC spEmployeeLeaveUsedRecalc @leave_id
	FETCH i_cursor INTO @leave_id
END

CLOSE i_cursor
DEALLOCATE i_cursor

-- Redundant
-- Updates EmployeeUsedLeave Start, Stop
/*UPDATE L SET 
[Start Day past 1900] = ISNULL((SELECT MIN([Day past 1900]) FROM EmployeeLeaveUsedItem I WHERE I.LeaveID = L.LeaveID), 0),
[Stop Day past 1900] = ISNULL((SELECT MAX([Day past 1900]) FROM EmployeeLeaveUsedItem I WHERE I.LeaveID = L.LeaveID), 0),
[Type Mask] = ISNULL((SELECT SUM(I.TypeID) FROM vwEmployeeLeaveUsedItemDistinctTypes I WHERE I.LeaveID = L.LeaveID), 0),
[Seconds] = ISNULL((SELECT SUM(I.Seconds) FROM EmployeeLeaveUsedItem I WHERE I.LeaveID = L.LeaveID), 0)
FROM EmployeeLeaveUsed L */
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spEmployeeDeductionSummarize'
GO
ALTER PROC dbo.spEmployeeDeductionSummarize @batch_id int, @authorized bit OUT AS

EXEC dbo.spPermissionGetOnPeopleForCurrentUser2 @batch_id, 536870912
DELETE TempX WHERE BatchID = @batch_id AND (X & 1) = 0
SELECT @authorized = CASE WHEN @@ROWCOUNT = 0 THEN 1 ELSE 0 END

SELECT D.EmployeeID, Deduction = SUM(D.[Amount]) FROM dbo.vwEmployeeDeductionUnion2 D
INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND D.EmployeeID=X.[ID] GROUP BY D.EmployeeID ORDER BY D.EmployeeID

DELETE X FROM dbo.TempX X WHERE X.BatchID=@batch_id OR DATEDIFF(minute, X.Created, GETDATE()) > 60
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spPermissionGetMembershipListGroups', 1
GO
ALTER PROC dbo.spPermissionGetMembershipListGroups WITH EXEC AS 'dbo' AS
SELECT [name] FROM sysusers WHERE isntgroup=1 or issqlrole=1
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spPermissionGetMembership', 1
GO
ALTER PROC dbo.spPermissionGetMembership
	@groups nvarchar(MAX) out
AS
-- Lists Groups as dbo
CREATE TABLE #G([name] sysname)
INSERT #G
EXEC dbo.spPermissionGetMembershipListGroups

DECLARE g_cursor CURSOR LOCAL FORWARD_ONLY STATIC FOR 
SELECT [name] FROM #G

OPEN g_cursor

DECLARE @g sysname, @gcount int
SELECT @groups = '', @gcount = 0

FETCH NEXT FROM g_cursor INTO @g
WHILE @@FETCH_STATUS=0
BEGIN
	IF IS_MEMBER(@g)=1 AND LEN(@groups) > 0 SET @groups = @groups + ','
	IF IS_MEMBER(@g)=1 SELECT @groups = @groups + @g, @gcount = @gcount + 1
	FETCH NEXT FROM g_cursor INTO @g
END

IF @gcount = 1 SET @groups = 'group=' + @groups
ELSE IF @gcount > 1 SET @groups = 'groups=' + @groups

IF SUSER_SNAME() IS NOT NULL SET @groups = 'user=' + SUSER_SNAME() + ' ' + @groups
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spErrorRaiseNoPermission', 1
GO
ALTER PROC dbo.spErrorRaiseNoPermission
	@attribute_id int,
	@permission_mask int,
	@employee_id int = NULL,
	@more_info nvarchar(MAX) = ''
AS
DECLARE @error nvarchar(MAX)
SELECT @error = Attribute FROM PermissionAttribute WHERE AttributeID = @attribute_id
IF @@ROWCOUNT = 0 SELECT @error = Error FROM Error WHERE ErrorID = 50016
ELSE
BEGIN
	DECLARE @permission nvarchar(400), @groups nvarchar(MAX)

	SELECT @permission = CASE @permission_mask
		WHEN 1 THEN 'read'
		WHEN 2 THEN 'write'
		WHEN 4 THEN 'create'
		WHEN 8 THEN 'delete'
		ELSE ''
	END

	IF LEN(@permission) = 0 SELECT @error = 'Insufficient Permission on ' + @error
	ELSE SELECT @error = 'You lack ' + @permission + ' permission on ' + @error 
	
	EXEC dbo.spPermissionGetMembership @groups out
	IF @employee_id IS NOT NULL 
	BEGIN
		DECLARE @n nvarchar(MAX)
		SELECT @n = [Employee Number] FROM dbo.Employee WHERE EmployeeID=@employee_id
		IF @n IS NOT NULL AND @n != '' SET @groups = @groups + ' requestedEmployee#=' + @n
		
		SET @groups = @groups + ' requestedEmployeeID=' + CAST(@employee_id AS varchar(50))
	END	

	IF @groups != '' AND @more_info != '' SET @groups = @groups + ' '
	SET @groups = @groups + @more_info

	IF @groups != '' SET @error = @error + ' (' + @groups + ')'
	
	SET @error = @error + '.'
END

RAISERROR(@error, 16, 1)
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spErrorRaiseNoPermission2', 1
GO
ALTER PROC dbo.spErrorRaiseNoPermission2
	@object_id int,
	@permission_mask int
AS
DECLARE @error nvarchar(MAX)
SELECT @error = [Object] FROM PermissionObject WHERE ObjectID = @object_id
IF @@ROWCOUNT = 0 SELECT @error = Error FROM Error WHERE ErrorID = 50016
ELSE
BEGIN
	DECLARE @permission nvarchar(400), @groups nvarchar(MAX)

	SELECT @permission = CASE @permission_mask
		WHEN 1 THEN 'read'
		WHEN 2 THEN 'write'
		WHEN 4 THEN 'create'
		WHEN 8 THEN 'delete'
		ELSE ''
	END

	IF LEN(@permission) = 0 SELECT @error = 'Insufficient Permission on ' + @error
	ELSE SELECT @error = 'You lack ' + @permission + ' permission on ' + @error
	EXEC dbo.spPermissionGetMembership @groups out
	IF @groups != '' SET @error = @error + ' (' + @groups + ')'
	SELECT @error = @error + '.'
END

RAISERROR(@error, 16, 1)
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spLeaveRateGetMaxStartMonth', 1
GO
-- Obsolete as of v235. Corrected to fix an issue prior to v235 +where rate grid incorrectly shows fixed view instead of years view
ALTER PROC dbo.spLeaveRateGetMaxStartMonth
	@plan_id int,
	@month int OUT
AS
SET NOCOUNT ON

SELECT @month = 0
-- SELECT TOP 1 @month = [Start Month] FROM LeaveRate WHERE PlanID = @plan_id AND [Stop Month] < 2147483647
SELECT @month = 1 FROM LeaveRate WHERE PlanID = @plan_id AND [Stop Month] < 2147483647
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spLeaveRateGetView', 1
GO
ALTER PROC dbo.spLeaveRateGetView
	@plan_id int,
	@view int OUT -- Fixed = 1, Years = 2, Months = 3
AS
SET NOCOUNT ON

SET @view = 1
SELECT TOP 1 @view=3 FROM LeaveRate WHERE PlanID = @plan_id AND ([Start Month] % 12 <> 0 OR ([Stop Month] <> 2147483647 AND [Stop Month] % 12 <> 11))
SELECT TOP 1 @view=2 FROM LeaveRate WHERE @view=1 AND PlanID = @plan_id AND [Stop Month] < 2147483647
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spEmployeeTimeSubmit', 1
GO
ALTER PROC dbo.spEmployeeTimeSubmit
	@start_day int,
	@stop_day int,
	@employee_id int
AS
DECLARE @authorized bit
EXEC dbo.spPermissionInsureForCurrentUserOnPerson @employee_id, 262144, 1, @authorized out

IF @authorized=1
UPDATE ET SET [Last Submitted Day past 1900] = DATEDIFF(d,0,GETDATE()), [Last Submitted by] = SUSER_SNAME()
FROM dbo.EmployeeTime ET WHERE DATEDIFF(d,0,ET.[In]) BETWEEN @start_day AND @stop_day AND ET.EmployeeID = @employee_id
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spPersonSelect', 1
GO
ALTER PROC dbo.spPersonSelect
	@person_id int, @extended bit = 0
AS
DECLARE @batch_id int

SET NOCOUNT ON

SELECT @batch_id = RAND() * 2147483647

INSERT TempX(BatchID, [ID])
VALUES(@batch_id, @person_id)

IF @extended = 0 EXEC dbo.spPersonListBase @batch_id
ELSE EXEC dbo.spPersonListBase2 @batch_id
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spEmployeeLeaveEarnMapMonth', 0
GO
ALTER PROC dbo.spEmployeeLeaveEarnMapMonth
	@month int,
	@month_increment int,
	@seniority_begins datetime,
	@start_date datetime,
	@stop_date datetime,
	@eligible_start datetime,
	@employee_id int,
	@type_id int,
	@seconds int,
	@note varchar(4000),
	@day_offset int
AS
DECLARE @first datetime, @ineligible_seconds int

SET NOCOUNT ON

WHILE DATEADD(day, @day_offset, DATEADD(month, @month, @seniority_begins)) < @start_date
BEGIN
	SET @month = @month + @month_increment
END


SELECT @ineligible_seconds = 0, @start_date = DATEADD(month, @month, @seniority_begins)
WHILE DATEADD(d, @day_offset, @start_date) <= @stop_date
BEGIN
	IF DATEADD(d, @day_offset, @start_date) < @eligible_start
	BEGIN
		SET @ineligible_seconds = @ineligible_seconds + @seconds
	END
	ELSE
	BEGIN
		INSERT EmployeeLeaveEarned(EmployeeID, TypeID, Seconds, [Day past 1900], [PPE Day past 1900], Note, [Auto]) 
		VALUES (@employee_id, @type_id, @seconds + @ineligible_seconds, DATEDIFF(d, 0, @start_date) + @day_offset, DATEDIFF(d, 0, @start_date) + @day_offset, @note, 1)
		SET @ineligible_seconds = 0
	END
	
	SELECT @month = @month + @month_increment
	SELECT @start_date = DATEADD(m, @month, @seniority_begins)	
END
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spEmployeeTimeCopyPrevious', 1
GO
ALTER PROC dbo.spEmployeeTimeCopyPrevious
	@employee_id int,
	@source_start_day int,
	@source_stop_day int,
	@target_start_day int,
	@source varchar(50) = '',
	@rows int = 0 OUT
AS
SET NOCOUNT ON

DECLARE @delta int, @target_stop_date datetime, @authorized bit, @error int, @holiday_plan_id int
SELECT @delta = @target_start_day - @source_start_day, @rows = 0, @error = 0
SET @target_stop_date = DATEADD(d, @delta, @target_start_day)

EXEC dbo.spPermissionInsureForCurrentUserOnPerson @employee_id, 262144, 4, @authorized out
IF @authorized=0 RETURN

EXEC dbo.spHolidayRecalc @force_recalc = 0, @stop_date = @target_stop_date

SELECT @holiday_plan_id = HolidayPlanID FROM dbo.Employee WHERE EmployeeID=@employee_id

DECLARE t_cursor CURSOR LOCAL FORWARD_ONLY STATIC FOR SELECT
[In]=DATEADD(day,@delta,ET.[In]),
[Out]=DATEADD(day,@delta,DATEADD(second, ET.Seconds, ET.[In])),
ET.ProjectID, ET.TypeID, ET.[GMT+Hours]
FROM dbo.EmployeeTime ET
INNER JOIN dbo.Employee E ON ET.EmployeeID=@employee_id AND ET.EmployeeID = E.EmployeeID AND 
DATEDIFF(d,0,ET.[In]) BETWEEN @source_start_day AND @source_stop_day 
-- Does not insert time if time already exists for new day
-- Excludes second punches for each day for some reason???
LEFT JOIN dbo.EmployeeTime ET2 ON ET.EmployeeID=ET2.EmployeeID AND DATEDIFF(d,0,ET2.[In]) = DATEDIFF(d,0,ET.[In]) + @delta 
WHERE ET2.ItemID IS NULL -- H.ItemID IS NULL AND  

OPEN t_cursor

DECLARE @in datetime, @out datetime, @project_id int, @time_type_id int, @gmt_hours int
FETCH t_cursor INTO @in, @out, @project_id, @time_type_id, @gmt_hours

BEGIN TRAN

WHILE @@FETCH_STATUS = 0
BEGIN
	-- Skips holidays
	IF NOT EXISTS(
		SELECT * FROM dbo.HolidayCalculated H WHERE H.PlanID=@holiday_plan_id AND DATEDIFF(d,0,@in) IN (H.A, H.A - @delta)
	)
	EXEC dbo.spEmployeeTimeInsert3
	@employee_id=@employee_id,
	@in=@in,
	@out=@out,
	@project_id=@project_id,
	@change_status=0,
	@source=@source,
	@time_type_id=@time_type_id,
	@gmt_hours=@gmt_hours,
	@status_id=8,
	@ppe_day = NULL

	SET @rows = @rows + 1

	FETCH t_cursor INTO @in, @out, @project_id, @time_type_id, @gmt_hours
END

COMMIT TRAN
	
CLOSE t_cursor
DEALLOCATE t_cursor
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spEmployeeLeaveUsedItemList', 1
GO
ALTER PROC dbo.spEmployeeLeaveUsedItemList
	@leave_id int,
	@start_day int = -2147483648,
	@stop_day int = 2147483647,
	@flags int = 0 -- 1: include accumulated columns
AS
DECLARE @employee_id int
DECLARE @authorized bit

SET NOCOUNT ON

SELECT @employee_id = EmployeeID FROM EmployeeLeaveUsed WHERE LeaveID = @leave_id
IF @@ROWCOUNT = 0
BEGIN
	-- RAISERROR (N'LeaveID does not exist in call to dbo.spEmployeeLeaveUsedItemList', 16, 1)
	SELECT TOP 0 * FROM dbo.vwEmployeeLeaveUsedItem
	RETURN
END

EXEC dbo.spPermissionInsureForCurrentUserOnPerson @employee_id, 10001, 1, @authorized out

IF @authorized = 1 
BEGIN
	IF (@flags & 1) = 0 -- Do not include accumulated columns
	BEGIN
		SELECT * FROM dbo.vwEmployeeLeaveUsedItem WHERE LeaveID = @leave_id AND [Day past 1900] BETWEEN @start_day AND @stop_day ORDER BY [Day past 1900]
	END
	ELSE
	BEGIN -- Include accumulated column
		SELECT ItemID, D=[Day past 1900], EmployeeID, [Extended Type Mask], AccumulatedTypeID=NULL, [Accumulated Seconds]=NULL, [Rolling Bank]=NULL, [Rolling Days]=NULL, [Rolling Used]=NULL, [Accumulated Day]=NULL INTO #R FROM dbo.vwEmployeeLeaveUsedItem WHERE LeaveID = @leave_id AND [Day past 1900] BETWEEN @start_day AND @stop_day ORDER BY [Day past 1900]
	
		-- Pick which type to accumulate
		UPDATE #R SET AccumulatedTypeID = (SELECT TOP 1 LT.TypeID FROM dbo.LeaveType LT WHERE LT.Advanced=1 AND LT.Bank=1 AND (LT.TypeID & #R.[Extended Type Mask]) > 0 ORDER BY [Order]) -- Prefer advanced banked type
		UPDATE #R SET AccumulatedTypeID = LT.TypeID FROM #R INNER JOIN dbo.LeaveType LT ON  #R.AccumulatedTypeID IS NULL AND LT.Bank=1 AND (LT.TypeID & #R.[Extended Type Mask]) > 0 -- Otherwsie accumulated simple banked type
		
		-- Identify which employees\types have rolling accrual
		UPDATE #R SET 
		[Rolling Bank] = EP.[Effective Seconds],
		[Rolling Days] = CASE WHEN EP.PeriodID = 2049 THEN 729 ELSE 364 END
		FROM #R
		INNER JOIN dbo.vwEmployeeLeavePlanLeaveRate EP ON 
		#R.EmployeeID = EP.EmployeeID AND EP.TypeID = #R.AccumulatedTypeID AND EP.PeriodID IN (2049, 38914) AND -- 2049: 2 yr rolling  38914: 1 yr rolling
		#R.D >= EP.[Start Day past 1900] AND (#R.D <= EP.[Stop Day past 1900] OR EP.[Stop Day past 1900] IS NULL) AND
		DATEDIFF(mm,EP.[Seniority Begins],dbo.GetDateFromDaysPast1900(#R.D)) BETWEEN EP.[Start Month] AND EP.[Stop Month]
		
		-- Calculate rolling used for each day
		UPDATE #R SET
		[Rolling Used] = ISNULL((
			SELECT SUM(0-U.Seconds) FROM vwEmployeeLeaveApproved U WHERE U.EmployeeID = #R.EmployeeID AND (U.[Extended Type Mask] & #R.AccumulatedTypeID) != 0 AND U.[Day past 1900] BETWEEN (#R.D - #R.[Rolling Days]) AND #R.D
		),0) FROM #R WHERE #R.[Rolling Bank] IS NOT NULL

		-- Accumulated for rolling = bank - used
		UPDATE #R SET [Accumulated Seconds] = [Rolling Bank] - [Rolling Used] WHERE [Rolling Bank] IS NOT NULL
		
		-- Find last unused day entry for non-rolling types
		UPDATE #R SET [Accumulated Day] = (
			SELECT MAX(U.[Day past 1900]) FROM dbo.EmployeeLeaveUnused U WHERE U.EmployeeID = #R.EmployeeID AND U.TypeID = #R.AccumulatedTypeID AND U.[Day past 1900] <= #R.D
		)
		FROM #R WHERE AccumulatedTypeID IS NOT NULL AND [Rolling Bank] IS NULL
		
		-- Find unused seconds for non-rolling types
		UPDATE #R SET [Accumulated Seconds] = U.[Unused] + [Limit Seconds] FROM #R
		INNER JOIN dbo.EmployeeLeaveUnused U ON #R.EmployeeID=U.EmployeeID AND #R.AccumulatedTypeID=U.TypeID AND #R.[Accumulated Day] = U.[Day past 1900]
		
		-- Return results, appending [accumulated hrs] and [accumulated days] columns
		SELECT I.*, [Accumulated Hrs] = #R.[Accumulated Seconds] / 3600.0, [Accumulated Days] = #R.[Accumulated Seconds] * 1.00 / S.[Effective Seconds per Day] FROM dbo.vwEmployeeLeaveUsedItem I
		INNER JOIN #R ON I.ItemID=#R.ItemID
		INNER JOIN dbo.vwEmployeeEffectiveSecondsPerDay S ON I.EmployeeID = S.EmployeeID
	END
END
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spLeaveTypeDeleteCheck', 1
GO
ALTER PROC dbo.spLeaveTypeDeleteCheck
	@type_id int,
	@exists bit out
AS
SELECT @exists = 0

SELECT @exists = 1 FROM EmployeeLeaveUsedItem WHERE @type_id = TypeID
--IF @exists = 0 SELECT @exists = 1 FROM LeaveRate WHERE @type_id = TypeID
--IF @exists = 0 SELECT @exists = 1 FROM EmployeeLeaveUsedCompCost WHERE @type_id = TypeID
IF @exists = 0 SELECT @exists = 1 FROM EmployeeLeaveUnused WHERE @type_id = TypeID
IF @exists = 0 SELECT @exists = 1 FROM EmployeeLeaveEarned WHERE @type_id = TypeID
IF @exists = 0 SELECT @exists = 1 FROM EmployeeLeaveUsedItem WHERE @type_id = TypeID
IF @exists = 0 SELECT @exists = 1 FROM LeaveLimit WHERE @type_id = TypeID
IF @exists = 0 SELECT @exists = 1 FROM EmployeeLeaveUsedItem WHERE @type_id = TypeID
IF @exists = 0 SELECT @exists = 1 FROM EmployeeLeaveUsed WHERE (([Type Mask] | [Advanced Type Mask]) & @type_id) != 0
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spLeaveTypeListAffected', 1
GO
ALTER PROC dbo.spLeaveTypeListAffected
	@type_id int
AS
SET NOCOUNT ON

SELECT [List As], PersonID FROM dbo.vwPersonListAs WHERE PersonID IN
(
	SELECT DISTINCT EmployeeID FROM dbo.vwEmployeeLeaveApproved
) ORDER BY [List As]
GO
ALTER PROC dbo.spLeaveTypeCount
	@advanced bit,
	@count int OUT
AS
SET NOCOUNT ON

SELECT @count = COUNT(*) FROM LeaveType WHERE @advanced IS NULL OR Advanced = @advanced
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spLeaveTypeAddStateFML', 1
GO
-- Will throw error if insufficient typeids available
ALTER PROC dbo.spLeaveTypeAddStateFML
	@state_id int
AS
SET NOCOUNT ON

DECLARE @next_type_id int, @next_order int, @error int
SELECT @next_type_id = ISNULL(MAX(TypeID) * 2, 1) FROM LeaveType
SELECT @next_order = ISNULL(MAX([Order]) + 1, 1) FROM LeaveType

BEGIN TRAN

INSERT LeaveType(TypeID, Advanced, [Type], Abbreviation, Paid, [Order], InitialPeriodID, [Initial Seconds])
SELECT TypeID * @next_type_id , 1, [Type], UPPER(SUBSTRING([Type], 1, 4)), 0, [Order] + @next_order, PeriodID, Seconds FROM StateFMLType WHERE StateID = @state_id
SELECT @error = @@ERROR

IF @error = 0
BEGIN
	INSERT LeaveRate(PlanID, TypeID, Seconds, [Start Month], [Stop Month], PeriodID)
	SELECT P.PlanID, F.TypeID * @next_type_id, F.Seconds * P.FTE, 0, 0x7FFFFFFF, F.PeriodID
	FROM StateFMLType F
	CROSS JOIN LeavePlan P
	WHERE F.StateID = @state_id
	SELECT @error = @@ERROR
END

IF @error = 0
BEGIN
	
	DECLARE @ptrSrc binary(16), @ptrTarget binary(16)

	SELECT @ptrSrc = TEXTPTR([Leave Note]) FROM StateFML WHERE StateID = @state_id
	SELECT @ptrTarget = TEXTPTR([Leave Note]) FROM dbo.Constant
	
	DECLARE @nl varchar(2000)
	SELECT @nl = CHAR(13) + CHAR(10) + '===========================================' + CHAR(13) + CHAR(10) +
		'DISCLAIMER: The accuracy of the documentation that Apex Software provides about federal and state law is deemed reliable but not guaranteed. Apex recommends that you thoroughly understand how this software will credit and debit leave before you incorporate it into your family and medical leave procedures and that you consult a specialist in family and medical law. You may need to modify the leave accrual plans in this software, changing the types and amounts of automatically credited family leave. Apex assumes no liability for damages sought regarding tracking, accruing, approving, or denying leave. By using this software, you and/or your employer accept full responsibility and liability.' + CHAR(13) + CHAR(10) +
		'===========================================' + CHAR(13) + CHAR(10) + CHAR(13) + CHAR(10)
	UPDATETEXT Constant.[Leave Note] @ptrTarget NULL NULL @nl
	SELECT @error = @@ERROR

	IF @error = 0
	BEGIN
		UPDATETEXT Constant.[Leave Note] @ptrTarget NULL NULL StateFML.[Leave Note] @ptrSrc
		SELECT @error = @@ERROR
	END
END

IF @error = 0 COMMIT TRAN
ELSE IF @@ROWCOUNT > 0 ROLLBACK
GO
-- Will throw error if insufficient typeids available
/*ALTER PROC dbo.spLeaveTypeAddStateFML
	@state_id int
AS
DECLARE @next_type_id int, @next_order int, @error int
SELECT @next_type_id = ISNULL(MAX(TypeID) * 2, 1) FROM LeaveType
SELECT @next_order = ISNULL(MAX([Order]) + 1, 1) FROM LeaveType

BEGIN TRAN

INSERT LeaveType(TypeID, Advanced, Bank, [Type], Abbreviation, Paid, [Order], InitialPeriodID, [Initial Seconds])
SELECT TypeID * @next_type_id , 1, 1, [Type], UPPER(SUBSTRING([Type], 1, 4)), 0, [Order] + @next_order, PeriodID, Seconds FROM StateFMLType WHERE StateID = @state_id
SELECT @error = @@ERROR

IF @error = 0
BEGIN
	INSERT LeaveRate(PlanID, TypeID, Seconds, [Start Month], [Stop Month], PeriodID)
	SELECT P.PlanID, F.TypeID * @next_type_id, F.Seconds * P.FTE, 0, 0x7FFFFFFF, F.PeriodID
	FROM StateFMLType F
	CROSS JOIN LeavePlan P
	WHERE F.StateID = @state_id
	SELECT @error = @@ERROR
END

IF @error = 0
BEGIN
	
	DECLARE @ptrSrc binary(16), @ptrTarget binary(16)

	SELECT @ptrSrc = TEXTPTR([Leave Note]) FROM StateFML WHERE StateID = @state_id
	SELECT @ptrTarget = TEXTPTR([Leave Note]) FROM dbo.Constant
	
	DECLARE @nl varchar(2000)
	SELECT @nl = CHAR(13) + CHAR(10) + '===========================================' + CHAR(13) + CHAR(10) +
		'DISCLAIMER: The accuracy of the documentation that Apex Software provides about federal and state law is deemed reliable but not guaranteed. Apex recommends that you thoroughly understand how this software will credit and debit leave before you incorporate it into your family and medical leave procedures and that you consult a specialist in family and medical law. You may need to modify the leave accrual plans in this software, changing the types and amounts of automatically credited family leave. Apex assumes no liability for damages sought regarding tracking, accruing, approving, or denying leave. By using this software, you and/or your employer accept full responsibility and liability.' + CHAR(13) + CHAR(10) +
		'===========================================' + CHAR(13) + CHAR(10) + CHAR(13) + CHAR(10)
	UPDATETEXT Constant.[Leave Note] @ptrTarget NULL NULL @nl
	SELECT @error = @@ERROR

	IF @error = 0
	BEGIN
		UPDATETEXT Constant.[Leave Note] @ptrTarget NULL NULL StateFML.[Leave Note] @ptrSrc
		SELECT @error = @@ERROR
	END
END

IF @error = 0 COMMIT TRAN
ELSE IF @@ROWCOUNT > 0 ROLLBACK
*/
EXEC dbo.spAdminCreateSPifNonexistent 'spLeaveTypeSelectPrimaryComp', 1
GO
ALTER PROC dbo.spLeaveTypeSelectPrimaryComp
AS
SELECT * FROM dbo.vwLeaveType WHERE TypeID IN
(
	SELECT CompLeaveTypeID FROM TimeType
) ORDER BY [Order]
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spLeaveTypeList', 1
GO
ALTER PROC dbo.spLeaveTypeList
	@advanced bit
AS
SET NOCOUNT ON

SELECT T.* FROM dbo.vwLeaveType T
WHERE @advanced IS NULL OR T.Advanced = @advanced 
ORDER BY T.[Order]
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spLeaveTypeListAccrued', 1
GO
ALTER PROC dbo.spLeaveTypeListAccrued
	@employee_id int = NULL
AS
SET NOCOUNT ON

IF @employee_id IS NULL
SELECT T.* FROM dbo.vwLeaveType T WHERE T.Bank = 1 
ORDER BY T.[Order]

ELSE
SELECT T.* FROM dbo.vwLeaveType T WHERE T.Bank = 1 AND EXISTS
(
	SELECT R.* FROM LeaveRate R
	INNER JOIN EmployeeLeavePlan P ON R.TypeID = T.TypeID AND P.PlanID = R.PlanID AND P.EmployeeID = @employee_id
)
ORDER BY T.[Order]

GO
EXEC dbo.spAdminCreateSPifNonexistent 'spLeaveTypeListComp', 1
GO
ALTER PROC dbo.spLeaveTypeListComp
AS
SELECT * FROM dbo.vwLeaveType WHERE TypeID IN
(
	SELECT CompLeaveTypeID FROM TimeType
) ORDER BY [Order]
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spLeaveTypeSelect', 1
GO
ALTER PROC dbo.spLeaveTypeSelect
	@type_id int
AS
SET NOCOUNT ON

SELECT * FROM dbo.vwLeaveType WHERE TypeID = @type_id
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spShiftScheduleList', 1
GO
ALTER PROC dbo.spShiftScheduleList @shift_id int AS
SET NOCOUNT ON
SELECT ItemID, ShiftID,[Day of Shift],[Start Seconds],[Stop Seconds],[Lunch Start],[Lunch Seconds],Flags,[Length Seconds]
FROM dbo.ShiftSchedule
WHERE ShiftID=@shift_id
ORDER BY [Day of Shift]
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spShiftScheduleClear', 0
GO
ALTER PROC dbo.spShiftScheduleClear @shift_id int AS
DELETE dbo.ShiftSchedule WHERE ShiftID=@shift_id
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spShiftScheduleInsert', 0
GO
ALTER PROC dbo.spShiftScheduleInsert @shift_id int, @day_of_shift int, @start_seconds int, @stop_seconds int, @lunch_start int, @lunch_seconds int, @flags int, @item_id int = NULL out AS
-- Flags: SlantIn = 4, SlantOut = 8, LunchPunch = 0x10, 0x40000000 entry was automatically created
IF @stop_seconds IS NULL SET @stop_seconds = @start_seconds + 8 * 3600 + @lunch_seconds

INSERT dbo.ShiftSchedule(ShiftID,[Day of Shift],[Start Seconds],[Stop Seconds],[Lunch Start],[Lunch Seconds],Flags,[Length Seconds])
VALUES (@shift_id, @day_of_shift, @start_seconds, @stop_seconds, @lunch_start, @lunch_seconds, @flags, 
CASE WHEN @stop_seconds - @start_seconds - @lunch_seconds > 0 THEN @stop_seconds - @start_seconds - @lunch_seconds ELSE 0 END)
SET @item_id = SCOPE_IDENTITY()
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spShiftScheduleInsertAuto', 0
GO
ALTER PROC dbo.spShiftScheduleInsertAuto @shift_id int, @start_seconds int, @lunch_start int, @lunch_seconds int, @stop_seconds int, @length_seconds int, @days_on int, @days_off int, @days_on2 int, @days_off2 int, @flags int AS
DELETE dbo.ShiftSchedule WHERE ShiftID=@shift_id

IF @stop_seconds IS NULL SET @stop_seconds = @start_seconds + @length_seconds + @lunch_seconds

DECLARE @day int
SET @day = 0

WHILE @day < @days_on
BEGIN
	INSERT dbo.ShiftSchedule(ShiftID,[Day of Shift],[Start Seconds],[Stop Seconds],[Lunch Start],[Lunch Seconds],Flags,[Length Seconds])
	SELECT @shift_id, @day, @start_seconds, @stop_seconds, @lunch_start, @lunch_seconds, @flags | 0x40000000, @length_seconds
	SET @day = @day + 1
END

SET @day = @days_on + @days_off

WHILE @day < @days_on + @days_off + @days_on2
BEGIN
	INSERT dbo.ShiftSchedule(ShiftID,[Day of Shift],[Start Seconds],[Stop Seconds],[Lunch Start],[Lunch Seconds],Flags,[Length Seconds])
	SELECT @shift_id, @day, @start_seconds, @stop_seconds, @lunch_start, @lunch_seconds, @flags | 0x40000000, @length_seconds
	SET @day = @day + 1
END
GO
-- Initially fills ShiftSchedule. spShiftInsert and spShiftUpdate will keep ShiftSchedule filled after initial operation
DECLARE @shift_id int, @start_seconds int, @lunch_start int, @lunch_seconds int, @stop_seconds int, @length_seconds int, @days_on int, @days_off int, @days_on2 int, @days_off2 int, @flags int

DECLARE s_cursor CURSOR LOCAL STATIC FORWARD_ONLY FOR SELECT ShiftID, 
[Start Seconds],
[Stop Seconds],
[Lunch Start],
[Lunch Seconds],
[Seconds per Day],
Flags,
[Days On],
[Days Off],
DaysOn2,
DaysOff2 FROM dbo.Shift WHERE ShiftID NOT IN (SELECT ShiftID FROM dbo.ShiftSchedule)

OPEN s_cursor
FETCH s_cursor INTO @shift_id, @start_seconds, @stop_seconds, @lunch_start, @lunch_seconds, @length_seconds, @flags, @days_on, @days_off, @days_on2, @days_off2
WHILE @@FETCH_STATUS = 0
BEGIN
	EXEC dbo.spShiftScheduleInsertAuto @shift_id, @start_seconds, @lunch_start, @lunch_seconds, @stop_seconds, @length_seconds, @days_on, @days_off, @days_on2, @days_off2, @flags
	FETCH s_cursor INTO @shift_id, @start_seconds, @stop_seconds, @lunch_start, @lunch_seconds, @length_seconds, @flags, @days_on, @days_off, @days_on2, @days_off2
END
CLOSE s_cursor
DEALLOCATE s_cursor
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spPersonUpdate', 1
GO
ALTER PROC dbo.spPersonUpdate
	@person_id int,
	@title varchar(50),
	@first_name varchar(50),
	@middle_name varchar(50),
	@last_name varchar(50),
	@suffix varchar(50),
	@male bit,
	@work_email varchar(50),
	@work_phone varchar(50),
	@extension varchar(50),
	@work_phone_note varchar(50),
	@home_office_phone varchar(50),
	@toll_free_phone varchar(50),
	@mobile_phone varchar(50),
	@work_fax varchar(50),
	@pager varchar(50),
	@note varchar(4000) = NULL, -- Note update is optional
	@work_address varchar(50),
	@work_address2 varchar(50),
	@work_city varchar(50),
	@work_state varchar(50),
	@work_zip varchar(50),
	@work_country varchar(50),
	@credentials varchar(50)
AS
DECLARE @result int

DECLARE @authorized bit

EXEC dbo.spPermissionInsureForCurrentUserOnPerson @person_id, 2, 2, @authorized out
IF @authorized = 1 
BEGIN
	SELECT @title = RTRIM(LTRIM(@title)),
	@credentials = RTRIM(LTRIM(@credentials)),
	@first_name = RTRIM(LTRIM(@first_name)),
	@middle_name = RTRIM(LTRIM(@middle_name)),
	@last_name = RTRIM(LTRIM(@last_name)),
	@home_office_phone = RTRIM(LTRIM(@home_office_phone)),
	@suffix = RTRIM(LTRIM(@suffix)),
	@work_email = RTRIM(LTRIM(@work_email)),
	@work_phone = RTRIM(LTRIM(@work_phone)),
	@extension = RTRIM(LTRIM(@extension)),
	@work_phone_note = RTRIM(LTRIM(@work_phone_note)),
	@toll_free_phone = RTRIM(LTRIM(@toll_free_phone)),
	@mobile_phone = RTRIM(LTRIM(@mobile_phone)),
	@work_fax = RTRIM(LTRIM(@work_fax)),
	@pager = RTRIM(LTRIM(@pager)),
	@work_address = RTRIM(LTRIM(@work_address)),
	@work_address2 = RTRIM(LTRIM(@work_address2)),
	@work_city = RTRIM(LTRIM(@work_city)),
	@work_state = RTRIM(LTRIM(@work_state)),
	@work_zip = RTRIM(LTRIM(@work_zip)),
	@work_country = RTRIM(LTRIM(@work_country)),
	@note = RTRIM(LTRIM(@note))
	
	UPDATE Person SET
	Title = @title,
	[Credentials] = @credentials,
	[First Name] = @first_name,
	[Middle Name] = @middle_name,
	[Last Name] = @last_name,
	[Home Office Phone] = @home_office_phone,
	Suffix = @suffix,
	Male = @male,
	[Work E-mail] = @work_email,
	[Work Phone] = @work_phone,
	Extension = @extension,
	[Work Phone Note] = @work_phone_note,
	[Toll Free Phone] = @toll_free_phone,
	[Mobile Phone] = @mobile_phone,
	[Work Fax] = @work_fax,
	Pager = @pager,
	[Work Address] = @work_address,
	[Work Address (cont.)] = @work_address2,
	[Work City] = @work_city,
	[Work State] = @work_state,
	[Work Zip] = @work_zip,
	[Work Country] = @work_country,
	Note = CASE WHEN @note IS NULL THEN Note ELSE @note END
	WHERE PersonID = @person_id /*AND (
		@title != Title OR
		[Credentials] != @credentials OR
		[First Name] != @first_name OR
		[Middle Name] != @middle_name OR
		[Last Name] != @last_name OR
		[Home Office Phone] != @home_office_phone OR
		Suffix != @suffix OR
		Male != @male OR
		[Work E-mail] != @work_email OR
		[Work Phone] != @work_phone OR
		Extension != @extension OR
		[Work Phone Note] != @work_phone_note OR
		[Toll Free Phone] != @toll_free_phone OR
		[Mobile Phone] != @mobile_phone OR
		[Work Fax] != @work_fax OR
		Pager != @pager OR
		[Work Address] != @work_address OR
		[Work Address (cont.)] != @work_address2 OR
		[Work City] != @work_city OR
		[Work State] != @work_state OR
		[Work Zip] != @work_zip OR
		[Work Country] != @work_country OR
		(@note IS NOT NULL AND Note != @note)
	) */ -- case insensitivity made these checks invalid
END
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spEmployeeTimeRoundAndCalcOT'
GO
ALTER PROC [dbo].[spEmployeeTimeRoundAndCalcOT]
	@batch_id int, -- List of employees
	@flags int,
	@start_day int OUT,
	@stop_day int OUT,
	@project_class_id int = NULL,
	@project_class_id_is_null bit = NULL,
	@authorized bit OUT,
	@pending_type_id int = NULL OUT,
	@denied_type_id int = NULL OUT,
	@flags2 int = 0 -- 1: Time has already been added to TempXYZ
--WITH EXEC AS 'dbo'
AS
DECLARE @rounding decimal(19,4), @start_date datetime, @stop_date datetime

SET NOCOUNT ON

IF @start_day IS NULL RAISERROR(N'@start_day cannot be null',16,1)
IF @stop_day IS NULL RAISERROR(N'@stop_day cannot be null',16,1)

DECLARE @split_time_into_days int
IF EXISTS(SELECT * FROM dbo.Constant WHERE [Timecard Max 24 Hours per Day] = 0) SET @split_time_into_days = 365
ELSE SET @split_time_into_days = 1

DECLARE @min_entry int, @max_entry int

EXEC dbo.spEmployeeTimeBoundRange @batch_id, @start_day, @stop_day, @min_entry out, @max_entry out

/*DECLARE @m varchar(4000)
SET @m = ''
SET @m = @m + CAST(@start_day as varchar(50))
SET @m = @m + '-' + CAST(@stop_day as varchar(50))

RAISERROR(@m,16,1)*/




CREATE TABLE #T(StartDate datetime, StopDate datetime)
IF @min_entry IS NOT NULL
BEGIN
	DELETE #T
	INSERT #T
	EXEC dbo.spEmployeeTimeCalculateFilterInverse @min_entry, 1
	SELECT TOP 1 @min_entry = DATEDIFF(d,0,StartDate) FROM #T
	IF @min_entry > @start_day SET @start_day = @min_entry
END

IF @max_entry IS NULL SET @min_entry = @stop_day
ELSE
BEGIN
	DELETE #T
	INSERT #T
	EXEC dbo.spEmployeeTimeCalculateFilterInverse @max_entry, 1
	SELECT TOP 1 @max_entry = DATEDIFF(d,0,StopDate) FROM #T
	IF @max_entry < @stop_day SET @stop_day = @max_entry
END
DROP TABLE #T


/*IF @min_entry IS NOT NULL SET @m = @m + CAST(@min_entry as varchar(50))
IF @max_entry IS NOT NULL SET @m = @m + '-' + CAST(@max_entry as varchar(50))
SET @m = @m + ':' + CAST(@start_day as varchar(50))
SET @m = @m + '-' + CAST(@stop_day as varchar(50))
RAISERROR(@m,16,1)*/

SELECT @pending_type_id = -2147483637 -- ISNULL((SELECT MIN(TypeID) FROM TimeType), 0) - 1
SELECT @denied_type_id = @pending_type_id - 1

EXEC dbo.spPermissionGetOnPeopleForCurrentUser2 @batch_id, 262144
DELETE TempX WHERE BatchID = @batch_id AND (X & 1) = 0
SELECT @authorized = CASE WHEN @@ROWCOUNT = 0 THEN 1 ELSE 0 END

SELECT @rounding = [Timecard Rounding] FROM dbo.Constant
SELECT @start_date = dbo.GetDateFromDaysPast1900(@start_day), @stop_date = dbo.GetDateFromDaysPast1900(@stop_day)

DECLARE @start_week_begin_date datetime, @stop_week_end_date datetime, @dw int, @cday int
DECLARE @start_week_begin_day int, @stop_week_end_day int


SELECT @dw=DatePartDW FROM dbo.vwDateFirst
SELECT @start_week_begin_date=dbo.GetDateFromDaysPast1900(@start_day), @stop_week_end_date=dbo.GetDateFromDaysPast1900(@stop_day)
EXEC dbo.spCompanyRoundStartStopToWeekBeginEnd @start_week_begin_date out, @stop_week_end_date out

SELECT @start_week_begin_day = DATEDIFF(d,0,@start_week_begin_date), @stop_week_end_day = DATEDIFF(d,0,@stop_week_end_date)

/* BEGIN Works around an intermittent error where cache duplicates itself for a reporting period */

-- Do not use cache if employeecached contains corrupted, duplicate records
SELECT DISTINCT C.EmployeeID INTO #CORRUPTEDCACHE FROM dbo.EmployeeTimeCached C
INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID]=C.EmployeeID AND (
	C.[In Day past 1900] BETWEEN @start_week_begin_day AND @stop_week_end_day
	--OR DATEDIFF(d,0,DATEADD(second, T.Seconds, T.[In])) BETWEEN @start_week_begin_day AND @stop_week_end_day
)
GROUP BY C.EmployeeID, C.OriginalTimeItemID, C.CopyTimeItemID, C.OriginalTypeID, C.CalculatedTypeID, C.[In Day past 1900], C.[Time Seconds], C.[Base Seconds]
HAVING COUNT(*) > 1

DELETE dbo.EmployeeTimeCached WHERE EmployeeID IN (SELECT EmployeeID FROM #CORRUPTEDCACHE)
/* END Works around an intermittent error where cache duplicates itself for a reporting period */


-- Do not use cache if employeetime contains any uncalculated records
SELECT DISTINCT T.EmployeeID INTO #NOTCACHED FROM
dbo.EmployeeTime T
INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID]=T.EmployeeID AND (
	DATEDIFF(d,0,T.[In]) BETWEEN @start_week_begin_day AND @stop_week_end_day
	--OR DATEDIFF(d,0,DATEADD(second, T.Seconds, T.[In])) BETWEEN @start_week_begin_day AND @stop_week_end_day
)
LEFT JOIN dbo.EmployeeTimeCached C ON T.ItemID = C.OriginalTimeItemID
WHERE C.ETCID IS NULL OR (@flags2 & 1) = 1 

-- Do not use cache if cached last day doesn't add up
IF @split_time_into_days = 1
INSERT #NOTCACHED
SELECT DISTINCT T.EmployeeID FROM
dbo.EmployeeTime T
INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID]=T.EmployeeID 
AND T.EmployeeID NOT IN (SELECT EmployeeID FROM #NOTCACHED) 
AND DATEDIFF(d,0, DATEADD(second, T.[Seconds], T.[In])) = @stop_week_end_day AND NOT EXISTS (
	SELECT ETCID FROM dbo.EmployeeTimeCached C WHERE C.EmployeeID = T.EmployeeID AND C.[In Day past 1900] = @stop_week_end_day
)


/*SELECT F = @flags2, T.* INTO _nc FROM
dbo.EmployeeTime T
INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID]=T.EmployeeID AND (
	DATEDIFF(d,0,T.[In]) BETWEEN @start_week_begin_day AND @stop_week_end_day 
	OR DATEDIFF(d,0,DATEADD(second, T.Seconds, T.[In])) BETWEEN @start_week_begin_day AND @stop_week_end_day
)
LEFT JOIN dbo.EmployeeTimeCached C ON T.ItemID = C.OriginalTimeItemID
WHERE C.ETCID IS NULL OR (@flags2 & 1) = 1 */


-- Rounds time entries
IF (@flags2 & 1) = 0
BEGIN
	IF NOT EXISTS(SELECT * FROM #NOTCACHED)
	BEGIN
		-- Cache holds everything. Inserts cached entries to temp calculated time and then returns
		INSERT #EMPLOYEE_TIME_ROUNDED(
			EmployeeID,
			OriginalTypeID,
			CalculatedTypeID,
			[In Day past 1900],
			[OT Eligible],
			[OT Disable],
			[Pay Rate],
			[Fixed Pay],
			[Fixed Items],
			Regular,
			[In Seconds],
			[Out Seconds],
			TimeSchemaID,
			ShiftDiffItemID,
			TempShiftDiffSeconds,
			TempShiftDiffItemID,
			OriginalTimeItemID,
			CopyTimeItemID,
			[Time Seconds],
			[Holiday Seconds],
			[OT Seconds],
			Flags,
			[Actual In],
			[Actual Out],
			[Base Seconds],
			[X2 Seconds]
		)
		SELECT
			EmployeeID,
			OriginalTypeID,
			CalculatedTypeID,
			[In Day past 1900],
			[OT Eligible],
			[OT Disable],
			[Pay Rate],
			[Fixed Pay],
			[Fixed Items],
			Regular,
			[In Seconds],
			[Out Seconds],
			TimeSchemaID,
			ShiftDiffItemID,
			TempShiftDiffSeconds,
			TempShiftDiffItemID,
			OriginalTimeItemID,
			CopyTimeItemID,
			[Time Seconds],
			[Holiday Seconds],
			[OT Seconds],
			Flags,
			[Actual In],
			[Actual Out],
			[Base Seconds],
			[X2 Seconds]
		FROM dbo.EmployeeTimeCached C
		INNER JOIN dbo.TempX T ON T.BatchID=@batch_id AND T.[ID]=C.EmployeeID AND C.[In Day past 1900] BETWEEN @start_day AND @stop_day

		RETURN
	END

	-- Deletes cached entries that only cover part of the reporting period because they will be recalculated
	BEGIN TRAN

	DELETE C
	FROM dbo.EmployeeTimeCached C
	INNER JOIN #NOTCACHED ON C.EmployeeID=#NOTCACHED.EmployeeID AND 
	(
		C.[In Day past 1900] BETWEEN @start_week_begin_day - 1 AND @stop_week_end_day + 1
	)


	INSERT TempXYZ(BatchID, [ID], X, Y, Z, I)
	SELECT @batch_id, ET.EmployeeID, 
	X = DATEDIFF(d, 0, ET.[In]),
	Y = DATEDIFF(second,DATEDIFF(d, 0, ET.[In]), ET.[In]), 
	Z = DATEDIFF(second,DATEDIFF(d, 0, ET.[In]), ET.[In]) + Seconds, 
	I = ET.ItemID
	FROM dbo.EmployeeTime ET
	INNER JOIN dbo.TempX X ON X.BatchID = @batch_id AND X.[ID] = ET.EmployeeID
	INNER JOIN #NOTCACHED ON #NOTCACHED.EmployeeID = ET.EmployeeID
	INNER JOIN dbo.Employee E ON ET.EmployeeID = E.EmployeeID AND
	--(
		DATEDIFF(d, 0, ET.[In]) /* + CASE WHEN @flags & 8 = 8 THEN E.[Payroll Delay] ELSE 0 END */ BETWEEN @start_week_begin_day - 1 AND @stop_week_end_day + 1 -- OR
		/*(DATEADD(d, CASE WHEN @flags & 8 = 8 THEN E.[Payroll Delay] ELSE 0 END, DATEADD(s,ET.[Seconds], ET.[In])) BETWEEN @start_week_begin_date AND @stop_week_end_date) */
		/*(DATEDIFF(d, 0, DATEADD(s,ET.[Seconds], ET.[In])) BETWEEN @start_week_begin_day AND @stop_week_end_day) */

	--)
	LEFT JOIN Project P ON ET.ProjectID = P.ProjectID
	WHERE 
		((@project_class_id_is_null IS NULL) OR (@project_class_id_is_null=1 AND ET.ProjectID IS NULL) OR (@project_class_id_is_null=0 AND ET.ProjectID IS NOT NULL)) AND
		((@project_class_id IS NULL) OR (@project_class_id IS NOT NULL AND @project_class_id=P.ClassID))

	COMMIT TRAN
END

-- Rounds time
EXEC dbo.spEmployeeTimeRound @batch_id, 1

DECLARE @d int, @r int
SELECT @d=0, @r=1



WHILE @r > 0
BEGIN
	INSERT #EMPLOYEE_TIME_ROUNDED(
		EmployeeID,
		[In Day past 1900],
		OriginalTypeID,
		CalculatedTypeID,
		[OT Eligible],
		[OT Disable],
		[Pay Rate],
		[Fixed Pay],
		Regular,
		[In Seconds],
		[Out Seconds],
		TimeSchemaID,
		OriginalTimeItemID,
		CopyTimeItemID,
		Flags,
		[Actual In],
		[Actual Out]
	)
	SELECT
	ET.EmployeeID,
	DATEDIFF(d, 0, ET.[In]) + @d,
	OriginalTypeID = ET.TypeID,
	CalculatedTypeID = CASE ET.StatusID
		WHEN 2 THEN @denied_type_id
		WHEN 8 THEN @pending_type_id
		ELSE ET.TypeID
	END,
	[OT Eligible]= CASE
		WHEN ET.StatusID IN (2) THEN 0 -- denied time cannot count toward OT
		--WHEN ET.StatusID IN (2, 8) THEN 0
		WHEN E.[OT Basis]=0 THEN 0
		ELSE TT.[OT Eligible]
	END,
	TT.[OT Disable],
	[Pay Rate] = ET.[Pay Rate], 
	[Fixed Pay] = CAST(ET.[Fixed Pay] AS decimal(19,4)),
	TT.Regular,
	[In Seconds] = CASE WHEN @d=0 THEN X.Y ELSE 0 END,
	[Out Seconds] = CASE 
		WHEN X.Z  > (@d + @split_time_into_days) * 86400 THEN 86400
		ELSE X.Z - @d * 86400
	END,
	TimeSchemaID,
	OriginalTimeItemID = CASE WHEN @d=0 OR (@d=1 AND X.Y = 86400) THEN ET.ItemID ELSE NULL END,
	CopyTimeItemID = ET.ItemID,
	Flags = 2 | (TT.Flags & 64) |
	CASE 
		WHEN ET.[PPE Day past 1900] IS NULL THEN 0
		WHEN DATEDIFF(hour,dbo.GetDateFromDaysPast1900(ET.[PPE Day past 1900]), ET.[In]) BETWEEN 24 AND 47 THEN 128
		ELSe 0
	END
	, -- 2: Original entry to differentiate automatically created shift-diff and ot entries, 64 unpaid time, 128 second shift adjustment (ppe < in)
	[Actual In] = CASE
		WHEN @d=0 OR (@d=1 AND X.Y = 86400) THEN ET.[In]
		ELSE DATEADD(day, @d, DATEDIFF(d,0,ET.[In]))
	END,
	[Actual Out] = CASE
		WHEN DATEADD(second,ET.Seconds,ET.[In]) > DATEADD(day,0,DATEDIFF(d, 0, ET.[In])+@d+@split_time_into_days) AND X.Z  > (@d + @split_time_into_days) * 86400 THEN DATEADD(day, @d + @split_time_into_days, DATEDIFF(d,0,ET.[In]))
		ELSE DATEADD(second,ET.Seconds,ET.[In])
	END

	FROM dbo.EmployeeTime ET
	INNER JOIN dbo.TempXYZ X ON X.BatchID=@batch_id AND X.I=ET.ItemID
	INNER JOIN dbo.Employee E ON ET.EmployeeID=E.EmployeeID AND (
		(X.Y >= @d * 86400 AND X.Y < (@d + @split_time_into_days) * 86400) OR
		(X.Z >= @d * 86400 AND X.Z < (@d + @split_time_into_days) * 86400) OR
		(X.Y < @d * 86400 AND X.Z >= (@d + @split_time_into_days) * 86400)
	)
	INNER JOIN dbo.vwTimeType TT ON ET.TypeID = TT.TypeID
	
	SET @r = @@ROWCOUNT
	SET @d = @d + @split_time_into_days
END

DELETE #EMPLOYEE_TIME_ROUNDED WHERE [In Seconds] = [Out Seconds] AND OriginalTimeItemID IS NULL

UPDATE #EMPLOYEE_TIME_ROUNDED SET [Base Seconds] = [Out Seconds] - [In Seconds]

-- 2nd shift
UPDATE #EMPLOYEE_TIME_ROUNDED 
SET [In Day past 1900] = [In Day past 1900] - 1, [In Seconds] = [In Seconds] + 86400, [Out Seconds] = [Out Seconds] + 86400 WHERE (Flags & 128) = 128 -- [In Seconds] < 9 * 3600 OR [Out Seconds] < 9 * 3600

CREATE INDEX [T_EmployeeID_120308] ON #EMPLOYEE_TIME_ROUNDED(EmployeeID) WITH  FILLFACTOR = 80 ON [PRIMARY]
CREATE INDEX [T_InDay_120308] ON #EMPLOYEE_TIME_ROUNDED([In Day past 1900]) WITH  FILLFACTOR = 80 ON [PRIMARY]
CREATE INDEX [T_EmpoyeeIDInDay_120308] ON #EMPLOYEE_TIME_ROUNDED(EmployeeID, [In Day past 1900]) WITH  FILLFACTOR = 80 ON [PRIMARY]
CREATE INDEX [T_SchemaID_120308] ON #EMPLOYEE_TIME_ROUNDED(TimeSchemaID) WITH  FILLFACTOR = 80 ON [PRIMARY]
CREATE INDEX [T_ShiftDiffItemID_120308] ON #EMPLOYEE_TIME_ROUNDED(ShiftDiffItemID) WITH  FILLFACTOR = 80 ON [PRIMARY]
CREATE INDEX [T_TempShiftDiffItemID_120308] ON #EMPLOYEE_TIME_ROUNDED(TempShiftDiffItemID) WITH  FILLFACTOR = 80 ON [PRIMARY]
CREATE INDEX [T_InSeconds_120308] ON #EMPLOYEE_TIME_ROUNDED([In Seconds]) WITH  FILLFACTOR = 80 ON [PRIMARY]
CREATE INDEX [T_OutSeconds_120308] ON #EMPLOYEE_TIME_ROUNDED([Out Seconds]) WITH  FILLFACTOR = 80 ON [PRIMARY]

-- Carves time slices into units that neatly fit inside shift diff blocks


-- Shift diff begins during time slice
WHILE 1=1
BEGIN
	UPDATE S SET TempShiftDiffItemID = (
		SELECT TOP 1 D.ItemID FROM TimeSchemaShiftDiff D WHERE D.TimeSchemaID = S.TimeSchemaID
		AND S.[In Seconds] < D.[Range Start Seconds Past Midnight] AND S.[Out Seconds] > D.[Range Start Seconds Past Midnight] AND S.[Out Seconds] <= D.[Range Stop Seconds Past Midnight]
	) FROM #EMPLOYEE_TIME_ROUNDED S WHERE ShiftDiffItemID IS NULL

	UPDATE #EMPLOYEE_TIME_ROUNDED SET TempShiftDiffSeconds = D.[Range Start Seconds Past Midnight] FROM #EMPLOYEE_TIME_ROUNDED
	INNER JOIN TimeSchemaShiftDiff D ON #EMPLOYEE_TIME_ROUNDED.TempShiftDiffItemID=D.ItemID

	-- Make new entries
	INSERT #EMPLOYEE_TIME_ROUNDED(EmployeeID, [In Day past 1900], OriginalTypeID, CalculatedTypeID, [OT Eligible], [OT Disable], [Pay Rate],
	[Fixed Pay], Regular, [In Seconds], [Out Seconds], TimeSchemaID, ShiftDiffItemID, CopyTimeItemID)
	SELECT EmployeeID, [In Day past 1900], OriginalTypeID, CalculatedTypeID, [OT Eligible], [OT Disable], [Pay Rate],
	[Fixed Pay], Regular, [In Seconds] = TempShiftDiffSeconds, [Out Seconds], TimeSchemaID, ShiftDiffItemID = TempShiftDiffItemID, CopyTimeItemID
	FROM #EMPLOYEE_TIME_ROUNDED WHERE TempShiftDiffItemID IS NOT NULL

	-- Change existing entries
	UPDATE #EMPLOYEE_TIME_ROUNDED SET [Out Seconds] = TempShiftDiffSeconds, TempShiftDiffSeconds = NULL, TempShiftDiffItemID = NULL WHERE TempShiftDiffItemID IS NOT NULL

	IF @@ROWCOUNT=0 BREAK
END



-- Shift diff ends during time slice
WHILE 1=1
BEGIN
	UPDATE S SET TempShiftDiffItemID = (
		SELECT TOP 1 D.ItemID FROM TimeSchemaShiftDiff D WHERE D.TimeSchemaID = S.TimeSchemaID
		AND S.[In Seconds] < D.[Range Stop Seconds Past Midnight] AND S.[Out Seconds] > D.[Range Stop Seconds Past Midnight]
	) FROM #EMPLOYEE_TIME_ROUNDED S WHERE ShiftDiffItemID IS NULL

	UPDATE #EMPLOYEE_TIME_ROUNDED SET TempShiftDiffSeconds = D.[Range Stop Seconds Past Midnight] FROM #EMPLOYEE_TIME_ROUNDED
	INNER JOIN TimeSchemaShiftDiff D ON #EMPLOYEE_TIME_ROUNDED.TempShiftDiffItemID=D.ItemID

	-- Make new entries
	INSERT #EMPLOYEE_TIME_ROUNDED(EmployeeID, [In Day past 1900], OriginalTypeID, CalculatedTypeID, [OT Eligible], [OT Disable], [Pay Rate],
	[Fixed Pay], Regular, [In Seconds], [Out Seconds], TimeSchemaID, ShiftDiffItemID, CopyTimeItemID)
	SELECT EmployeeID, [In Day past 1900], OriginalTypeID, CalculatedTypeID, [OT Eligible], [OT Disable], [Pay Rate],
	[Fixed Pay], Regular, [In Seconds], [Out Seconds] = TempShiftDiffSeconds, TimeSchemaID, ShiftDiffItemID = TempShiftDiffItemID, CopyTimeItemID
	FROM #EMPLOYEE_TIME_ROUNDED WHERE TempShiftDiffItemID IS NOT NULL

	-- Change existing entries
	UPDATE #EMPLOYEE_TIME_ROUNDED SET [In Seconds] = TempShiftDiffSeconds, TempShiftDiffSeconds = NULL, TempShiftDiffItemID = NULL WHERE TempShiftDiffItemID IS NOT NULL

	IF @@ROWCOUNT=0 BREAK
END


-- Catches time that is completely contained in shift diff
UPDATE #EMPLOYEE_TIME_ROUNDED SET ShiftDiffItemID = D.ItemID
FROM #EMPLOYEE_TIME_ROUNDED
INNER JOIN TimeSchemaShiftDiff D ON #EMPLOYEE_TIME_ROUNDED.TimeSchemaID=D.TimeSchemaID AND 
	#EMPLOYEE_TIME_ROUNDED.[In Seconds] BETWEEN D.[Range Start Seconds Past Midnight] AND D.[Range Stop Seconds Past Midnight] AND
	#EMPLOYEE_TIME_ROUNDED.[Out Seconds] BETWEEN D.[Range Start Seconds Past Midnight] AND D.[Range Stop Seconds Past Midnight]

CREATE INDEX [ET_EI_073106] ON #EMPLOYEE_TIME_ROUNDED([EmployeeID], [In Day past 1900]) WITH  FILLFACTOR = 80 ON [PRIMARY]
CREATE INDEX [ET_IP_073106] ON #EMPLOYEE_TIME_ROUNDED([In Day past 1900], [Pay Rate]) WITH  FILLFACTOR = 80 ON [PRIMARY]
CREATE INDEX [ET_IO_073106] ON #EMPLOYEE_TIME_ROUNDED([In Day past 1900], [OT Eligible]) WITH  FILLFACTOR = 80 ON [PRIMARY]
CREATE INDEX [ET_CT_120308] ON #EMPLOYEE_TIME_ROUNDED(EmployeeID, CopyTimeItemID) WITH  FILLFACTOR = 80 ON [PRIMARY]

DECLARE @holiday_type_id int

SELECT @holiday_type_id = HolidayTimeTypeID FROM dbo.Constant
IF @holiday_type_id IS NOT NULL
BEGIN
	EXEC dbo.spHolidayRecalc @force_recalc = 0, @stop_date = @stop_date
	
	-- Holidays
	UPDATE #EMPLOYEE_TIME_ROUNDED SET CalculatedTypeID=@holiday_type_id
	FROM #EMPLOYEE_TIME_ROUNDED ET
	INNER JOIN dbo.Employee E ON ET.EmployeeID = E.EmployeeID
	INNER JOIN dbo.HolidayCalculated H ON E.HolidayPlanID = H.PlanID AND ET.CalculatedTypeID <> @pending_type_id AND ET.Regular = 1 AND
	ET.[In Day past 1900] BETWEEN H.A AND H.B
END

UPDATE #EMPLOYEE_TIME_ROUNDED SET Regular=0, [OT Eligible]=TT.[OT Eligible], [Holiday Seconds] = ET.[Out Seconds] - ET.[In Seconds]
FROM #EMPLOYEE_TIME_ROUNDED ET
INNER JOIN dbo.vwTimeType TT ON ET.CalculatedTypeID = TT.TypeID AND TT.Holiday = 1

DECLARE @ot_type_id int, @dt_type_id int
SELECT @ot_type_id = OTTimeTypeID, @dt_type_id = DTTimeTypeID FROM dbo.Constant

DECLARE @weeks int
SET @weeks = (@stop_week_end_day - @start_week_begin_day + 1) / 7

-- DT Sunday (>8 hrs)
EXEC dbo.spEmployeeTimeChangeRegToSunOT @start_week_begin_day, @weeks, 258, @dt_type_id, 28800

-- OT Sunday
EXEC dbo.spEmployeeTimeChangeRegToSunOT @start_week_begin_day, @weeks, 66, @ot_type_id, 0

-- DT12
EXEC dbo.spEmployeeTimeChangeRegToOTDaily @start_week_begin_day, @stop_week_end_day, 2, 43200, @dt_type_id

-- OT8
EXEC dbo.spEmployeeTimeChangeRegToOTDaily @start_week_begin_day, @stop_week_end_day, 18, 28800, @ot_type_id

-- OT9
EXEC dbo.spEmployeeTimeChangeRegToOTDaily @start_week_begin_day, @stop_week_end_day, 32, 32400, @ot_type_id

-- OT10
EXEC dbo.spEmployeeTimeChangeRegToOTDaily @start_week_begin_day, @stop_week_end_day, 8, 36000, @ot_type_id

-- OT40
EXEC dbo.spEmployeeTimeChangeRegToOT40 @start_week_begin_day, @weeks, 283, 144000

-- OT45
EXEC dbo.spEmployeeTimeChangeRegToOT40 @start_week_begin_day, @weeks, 32, 162000

-- OT54
EXEC dbo.spEmployeeTimeChangeRegToOT40 @start_week_begin_day, @weeks, 64, 194400


-- Applies shift diff
UPDATE R SET [Pay Rate] = PayRateM * [Pay Rate] + PayRateB
FROM #EMPLOYEE_TIME_ROUNDED R INNER JOIN TimeSchemaShiftDiff S ON S.ItemID=R.ShiftDiffItemID

UPDATE #EMPLOYEE_TIME_ROUNDED SET [Time Seconds] = [Out Seconds] - [In Seconds] - [Holiday Seconds]


DELETE TempXYZ WHERE BatchID=@batch_id OR DATEDIFF(hour,Created,GETDATE()) > 1


-- Time from beginning of week and end of week had to be considered so OT40 would calculate correctly
DELETE ET
FROM #EMPLOYEE_TIME_ROUNDED ET
INNER JOIN dbo.Employee E ON ET.EmployeeID = E.EmployeeID AND (
	/* CASE WHEN (@flags & 8) = 0 THEN 0 ELSE E.[Payroll Delay] END + */ ET.[In Day past 1900] < @start_day OR 
	/* CASE WHEN (@flags & 8) = 0 THEN 0 ELSE E.[Payroll Delay] END + */ ET.[In Day past 1900] > @stop_day
)


UPDATE E SET [OT Seconds] = [Out Seconds] - [In Seconds]
FROM #EMPLOYEE_TIME_ROUNDED E
INNER JOIN dbo.vwTimeType T ON E.CalculatedTypeID = T.TypeID AND T.OT = 1

-- Older custom time stored procs might not have double time
/*IF EXISTS (SELECT * FROM TempDB.INFORMATION_SCHEMA.COLUMNS WHERE COLUMN_NAME = 'X2 Seconds' AND TABLE_NAME LIKE '#EMPLOYEE_TIME_ROUNDED%')
BEGIN
	EXEC dbo.spExecSQLAsDBO N'UPDATE E SET [OT Seconds] = 0, [X2 Seconds] = [Out Seconds] - [In Seconds]
	FROM #EMPLOYEE_TIME_ROUNDED E
	INNER JOIN dbo.TimeType T ON E.CalculatedTypeID = T.TypeID AND T.PayRateM = 2'
END*/

UPDATE E SET [OT Seconds] = 0, [X2 Seconds] = [Out Seconds] - [In Seconds]
FROM #EMPLOYEE_TIME_ROUNDED E
INNER JOIN dbo.TimeType T ON E.CalculatedTypeID = T.TypeID AND T.PayRateM = 2


SELECT EmployeeID, CopyTimeItemID, [In Day past 1900]=MAX([In Day past 1900]), [Out Seconds] = 0 INTO #ET_LASTCHUNKS FROM #EMPLOYEE_TIME_ROUNDED E GROUP BY EmployeeID, CopyTimeItemID
CREATE UNIQUE CLUSTERED INDEX ETLC_EmployeeItem ON #ET_LASTCHUNKS(EmployeeID, CopyTimeItemID)

UPDATE ETLC SET [Out Seconds] = (
	SELECT MAX(E.[Out Seconds]) FROM #EMPLOYEE_TIME_ROUNDED E WHERE E.EmployeeID=ETLC.EmployeeID AND E.CopyTimeItemID=ETLC.CopyTimeItemID AND E.[In Day past 1900] = ETLC.[In Day past 1900]
) FROM #ET_LASTCHUNKS ETLC

UPDATE E SET Flags=E.Flags | 1 FROM #EMPLOYEE_TIME_ROUNDED E
INNER JOIN #ET_LASTCHUNKS ETLC ON E.EmployeeID=ETLC.EmployeeID AND E.CopyTimeItemID=ETLC.CopyTimeItemID AND E.[In Day past 1900] = ETLC.[In Day past 1900] AND E.[Out Seconds] = ETLC.[Out Seconds]




-- Uses cache
IF (@flags2 & 1) = 0
BEGIN

	-- Copies the temp calculated time before cached entries are added
	SELECT * INTO #EMPLOYEE_TIME_ROUNDED_NEW FROM #EMPLOYEE_TIME_ROUNDED

	-- Inserts cached entries to temp calculated time
	INSERT #EMPLOYEE_TIME_ROUNDED(
		EmployeeID,
		OriginalTypeID,
		CalculatedTypeID,
		[In Day past 1900],
		[OT Eligible],
		[OT Disable],
		[Pay Rate],
		[Fixed Pay],
		[Fixed Items],
		Regular,
		[In Seconds],
		[Out Seconds],
		TimeSchemaID,
		ShiftDiffItemID,
		TempShiftDiffSeconds,
		TempShiftDiffItemID,
		OriginalTimeItemID,
		CopyTimeItemID,
		[Time Seconds],
		[Holiday Seconds],
		[OT Seconds],
		Flags,
		[Actual In],
		[Actual Out],
		[Base Seconds],
		[X2 Seconds]
	)
	SELECT
		EmployeeID,
		OriginalTypeID,
		CalculatedTypeID,
		[In Day past 1900],
		[OT Eligible],
		[OT Disable],
		[Pay Rate],
		[Fixed Pay],
		[Fixed Items],
		Regular,
		[In Seconds],
		[Out Seconds],
		TimeSchemaID,
		ShiftDiffItemID,
		TempShiftDiffSeconds,
		TempShiftDiffItemID,
		OriginalTimeItemID,
		CopyTimeItemID,
		[Time Seconds],
		[Holiday Seconds],
		[OT Seconds],
		Flags,
		[Actual In],
		[Actual Out],
		[Base Seconds],
		[X2 Seconds]
	FROM dbo.EmployeeTimeCached C
	INNER JOIN dbo.TempX T ON T.BatchID=@batch_id AND T.[ID]=C.EmployeeID AND C.[In Day past 1900] BETWEEN @start_day AND @stop_day

	-- Caches newly calculated entries
	INSERT dbo.EmployeeTimeCached(
		EmployeeID,
		OriginalTypeID,
		CalculatedTypeID,
		[In Day past 1900],
		[OT Eligible],
		[OT Disable],
		[Pay Rate],
		[Fixed Pay],
		[Fixed Items],
		Regular,
		[In Seconds],
		[Out Seconds],
		TimeSchemaID,
		ShiftDiffItemID,
		TempShiftDiffSeconds,
		TempShiftDiffItemID,
		OriginalTimeItemID,
		CopyTimeItemID,
		[Time Seconds],
		[Holiday Seconds],
		[OT Seconds],
		Flags,
		[Actual In],
		[Actual Out],
		[Base Seconds],
		[X2 Seconds]
	)
	SELECT
		EmployeeID,
		OriginalTypeID,
		CalculatedTypeID,
		[In Day past 1900],
		[OT Eligible],
		[OT Disable],
		[Pay Rate],
		[Fixed Pay],
		[Fixed Items],
		Regular,
		[In Seconds],
		[Out Seconds],
		TimeSchemaID,
		ShiftDiffItemID,
		TempShiftDiffSeconds,
		TempShiftDiffItemID,
		OriginalTimeItemID,
		CopyTimeItemID,
		[Time Seconds],
		[Holiday Seconds],
		[OT Seconds],
		Flags,
		[Actual In],
		[Actual Out],
		[Base Seconds],
		[X2 Seconds]
	FROM #EMPLOYEE_TIME_ROUNDED_NEW WHERE @split_time_into_days = 365 OR [In Day past 1900] <> @stop_week_end_day OR [Out Seconds] <> 86400 OR OriginalTimeItemID IS NULL
END
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spEmployeeTimeListPayrollItems', 0
GO
ALTER PROC dbo.spEmployeeTimeListPayrollItems
	@start_day int = 0,
	@stop_day int = 0x7FFFFFFF,
	@batch_id int = NULL
AS
IF @batch_id IS NULL
BEGIN
	SELECT @batch_id = RAND() * 2147483647
	INSERT TempX(BatchID,[ID]) SELECT @batch_id,EmployeeID FROM dbo.Employee WHERE [Active Employee]=1 AND Salaried=0
END

DECLARE @default_approval_type_id int
SELECT @default_approval_type_id = MIN(TypeID) FROM dbo.LeaveApprovalType

-- Assigns rates if none were assigned
UPDATE ET SET [Pay Rate]=EC.[Hourly Pay]
FROM dbo.EmployeeTime ET
INNER JOIN dbo.vwEmployeeCompensation EC ON DATEDIFF(d,0,[In]) BETWEEN @start_day AND @stop_day AND 
EC.EmployeeID=ET.EmployeeID AND DATEDIFF(d,0,[In]) BETWEEN EC.[Start Day past 1900] AND ISNULL(EC.[Stop Day past 1900], 0x7FFFFFFF) AND
ET.[Pay Rate]=0 AND ET.[Fixed Pay]=0 AND EC.[Hourly Pay] > 0

-- Approves all time and leave before stop_day
UPDATE dbo.EmployeeTime SET StatusID=1 WHERE DATEDIFF(d,0,[In]) <= @stop_day AND ([StatusID] & 1) = 0
SELECT DISTINCT EmployeeID INTO #RecalcLeave FROM dbo.EmployeeLeaveUsed WHERE [Start Day past 1900] <= @stop_day AND [Status] = 1
UPDATE dbo.EmployeeLeaveUsed SET [Status] = 2, ApprovalTypeID = CASE WHEN ApprovalTypeID IS NULL THEN @default_approval_type_id ELSE ApprovalTypeID END WHERE [Start Day past 1900] <= @stop_day AND [Status] = 1

-- Recalculates unused leave totals
DECLARE t_cursor CURSOR LOCAL FORWARD_ONLY STATIC FOR 
SELECT EmployeeID FROM #RecalcLeave

OPEN t_cursor

DECLARE @employee_id int
FETCH NEXT FROM t_cursor INTO @employee_id

WHILE @@FETCH_STATUS = 0
BEGIN
	EXEC spEmployeeLeaveCalcForEmployee @employee_id
	FETCH NEXT FROM t_cursor INTO @employee_id
END

CLOSE t_cursor
DEALLOCATE t_cursor

-- Start --
CREATE TABLE #EMPLOYEE_TIME_ROUNDED(
TempItemID int NOT NULL IDENTITY(1,1) PRIMARY KEY,
EmployeeID int NOT NULL,
OriginalTypeID int NOT NULL, 
CalculatedTypeID int NOT NULL,
[In Day past 1900] int NOT NULL, 
[OT Eligible] bit NOT NULL,
[OT Disable] bit NOT NULL,
[Pay Rate] money NOT NULL,
[Fixed Pay] money NOT NULL DEFAULT(0),
[Fixed Items] int DEFAULT(0),
Regular bit DEFAULT(0),
[In Seconds] int NOT NULL,
[Out Seconds] int NOT NULL,
TimeSchemaID int NOT NULL,
ShiftDiffItemID int NULL,
TempShiftDiffSeconds int NULL,
TempShiftDiffItemID int NULL,
OriginalTimeItemID int NULL,
CopyTimeItemID int NULL,
[Time Seconds] int NOT NULL DEFAULT(0),
[Holiday Seconds] int NOT NULL DEFAULT(0),
[OT Seconds] int NOT NULL DEFAULT(0),
Flags int NOT NULL DEFAULT(0),
[Actual In] datetime NULL,
[Actual Out] datetime NULL,
[Base Seconds] int NOT NULL DEFAULT(0),
[X2 Seconds] int NOT NULL DEFAULT(0)
)

DECLARE @pending_type_id int, @denied_type_id int
EXEC dbo.spEmployeeTimeRoundAndCalcOT @batch_id, 0, @start_day, @stop_day, NULL, NULL, 0, @pending_type_id OUT, @denied_type_id OUT

SELECT ET.EmployeeID,T.[Type],ET.[Pay Rate], Fixed=CAST(0 AS bit) INTO #ETR FROM
#EMPLOYEE_TIME_ROUNDED ET
INNER JOIN dbo.TimeType T ON ET.CalculatedTypeID=T.TypeID AND ET.[In Day past 1900] BETWEEN @start_day AND @stop_day AND (ET.[Pay Rate] > 0 OR ET.[In Seconds] <> ET.[Out Seconds])
GROUP BY ET.EmployeeID,T.[Type],ET.[Pay Rate]

INSERT #ETR
SELECT ET.EmployeeID,
[Type] = 'Fixed Pay', --ISNULL(P.Project, 'Fixed Pay'),
[Pay Rate] = SUM(ET.[Fixed Pay]) * 200,
0
FROM
#EMPLOYEE_TIME_ROUNDED ET
INNER JOIN dbo.TimeType T ON ET.CalculatedTypeID=T.TypeID AND ET.[In Day past 1900] BETWEEN @start_day AND @stop_day AND ET.[Fixed Pay] > 0
LEFT JOIN dbo.EmployeeTime EMPTIME ON ET.CopyTimeItemID = EMPTIME.ItemID
LEFT JOIN dbo.Project P ON EMPTIME.ProjectID = P.ProjectID
GROUP BY ET.EmployeeID --,T.[Type],P.Project

INSERT #ETR
SELECT A.EmployeeID,A.[Type],ISNULL(EC.[Hourly Pay],0),0
FROM dbo.vwEmployeeLeaveApproved  A
INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID]=A.EmployeeID
LEFT JOIN dbo.vwEmployeeCompensation EC ON EC.EmployeeID=A.EmployeeID AND A.[Day past 1900] BETWEEN EC.[Start Day past 1900] AND ISNULL(EC.[Stop Day past 1900], 0x7FFFFFFF)
WHERE A.[Seconds] < 0 AND A.[Limit Adjustment]=0 
GROUP BY A.EmployeeID,A.[Type],ISNULL(EC.[Hourly Pay],0)

-- Insures every employee has at least one rate
INSERT #ETR
SELECT EmployeeID=X.[ID],'Regular',ISNULL(EC.[Hourly Pay],0),0
FROM dbo.TempX X
LEFT JOIN dbo.vwEmployeeCompensation EC ON EC.EmployeeID=X.[ID] AND @stop_day BETWEEN EC.[Start Day past 1900] AND ISNULL(EC.[Stop Day past 1900], 0x7FFFFFFF)
WHERE X.BatchID=@batch_id AND X.[ID] NOT IN (
	SELECT EmployeeID FROM #ETR
)


SELECT #ETR.EmployeeID,E.SyncID,
#ETR.[Type],Rate=#ETR.[Pay Rate],Fixed
FROM #ETR
INNER JOIN dbo.Employee E ON #ETR.EmployeeID=E.EmployeeID
INNER JOIN dbo.PersonX PX ON PX.PersonID=E.EmployeeID
INNER JOIN dbo.Person P ON E.EmployeeID=P.PersonID
ORDER BY #ETR.EmployeeID,Fixed,#ETR.[Type],#ETR.[Pay Rate]

DELETE dbo.TempX WHERE BatchID=@batch_id OR DATEDIFF(hour,Created,GETDATE()) > 1
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spEmployeeTimeExportAndApprove', 0
GO
ALTER PROC dbo.spEmployeeTimeExportAndApprove
	@batch_id int = NULL, @start_day int = -2147483648, @stop_day int = 2147483647, @flags int = 0
AS
SET NOCOUNT ON

IF @batch_id IS NULL
BEGIN
	SET @batch_id = RAND() * 2147483647
	INSERT dbo.TempX(BatchID,[ID]) SELECT @batch_id,EmployeeID FROM dbo.Employee WHERE [Active Employee]=1 AND [Salaried]=0
END

DELETE X FROM dbo.TempX X
INNER JOIN dbo.Employee E ON X.BatchID=@batch_id AND X.[ID]=E.EmployeeID AND E.Salaried=1

DECLARE @default_approval_type_id int
SELECT @default_approval_type_id = MIN(TypeID) FROM dbo.LeaveApprovalType

-- Assigns rates if none were assigned
UPDATE ET SET [Pay Rate]=EC.[Hourly Pay]
FROM dbo.EmployeeTime ET
INNER JOIN dbo.vwEmployeeCompensation EC ON DATEDIFF(d,0,[In]) BETWEEN @start_day AND @stop_day AND 
EC.EmployeeID=ET.EmployeeID AND DATEDIFF(d,0,[In]) BETWEEN EC.[Start Day past 1900] AND ISNULL(EC.[Stop Day past 1900], 0x7FFFFFFF) AND
ET.[Pay Rate]=0 AND ET.[Fixed Pay]=0 AND EC.[Hourly Pay] > 0

-- Approves all time and leave before stop_day
UPDATE dbo.EmployeeTime SET StatusID=1 WHERE DATEDIFF(d,0,[In]) <= @stop_day AND ([StatusID] & 1) = 0
SELECT DISTINCT EmployeeID INTO #RecalcLeave FROM dbo.EmployeeLeaveUsed WHERE [Start Day past 1900] <= @stop_day AND [Status] = 1
UPDATE dbo.EmployeeLeaveUsed SET [Status] = 2, ApprovalTypeID = CASE WHEN ApprovalTypeID IS NULL THEN @default_approval_type_id ELSE ApprovalTypeID END WHERE [Start Day past 1900] <= @stop_day AND [Status] = 1

-- Recalculates unused leave totals
DECLARE t_cursor CURSOR LOCAL FORWARD_ONLY STATIC FOR 
SELECT EmployeeID FROM #RecalcLeave

OPEN t_cursor

DECLARE @employee_id int
FETCH NEXT FROM t_cursor INTO @employee_id

WHILE @@FETCH_STATUS = 0
BEGIN
	EXEC spEmployeeLeaveCalcForEmployee @employee_id
	FETCH NEXT FROM t_cursor INTO @employee_id
END

CLOSE t_cursor
DEALLOCATE t_cursor

CREATE TABLE #EMPLOYEE_TIME_ROUNDED(
TempItemID int NOT NULL IDENTITY(1,1) PRIMARY KEY,
EmployeeID int NOT NULL,
OriginalTypeID int NOT NULL, 
CalculatedTypeID int NOT NULL,
[In Day past 1900] int NOT NULL, 
[OT Eligible] bit NOT NULL,
[OT Disable] bit NOT NULL,
[Pay Rate] money NOT NULL,
[Fixed Pay] money NOT NULL DEFAULT(0),
[Fixed Items] int DEFAULT(0),
Regular bit DEFAULT(0),
[In Seconds] int NOT NULL,
[Out Seconds] int NOT NULL,
TimeSchemaID int NOT NULL,
ShiftDiffItemID int NULL,
TempShiftDiffSeconds int NULL,
TempShiftDiffItemID int NULL,
OriginalTimeItemID int NULL,
CopyTimeItemID int NULL,
[Time Seconds] int NOT NULL DEFAULT(0),
[Holiday Seconds] int NOT NULL DEFAULT(0),
[OT Seconds] int NOT NULL DEFAULT(0),
Flags int NOT NULL DEFAULT(0),
[Actual In] datetime NULL,
[Actual Out] datetime NULL,
[Base Seconds] int NOT NULL DEFAULT(0),
[X2 Seconds] int NOT NULL DEFAULT(0)
)
DECLARE @pending_type_id int, @denied_type_id int
EXEC dbo.spEmployeeTimeRoundAndCalcOT @batch_id, 0, @start_day, @stop_day, NULL, NULL, 0, @pending_type_id OUT, @denied_type_id OUT


SELECT
ET.EmployeeID,
E.SyncID,
[Date]=DATEADD(d,0,ET.[In Day past 1900]),
TT.[Type],
Project = '', --T.Project,
Seconds = ET.[Out Seconds] - ET.[In Seconds],
Rate = ET.[Pay Rate],
Fixed = CAST(0 as bit),
WW = 0
INTO #Export
FROM #EMPLOYEE_TIME_ROUNDED ET
INNER JOIN dbo.Employee E ON ET.EmployeeID=E.EmployeeID
LEFT JOIN dbo.EmployeeTime OriginalEmployeeTime ON ET.CopyTimeItemID=OriginalEmployeeTime.ItemID
LEFT JOIN dbo.vwEmployeeTime T ON ET.CopyTimeItemID=T.ItemID
LEFT JOIN dbo.TimeType TT ON ET.CalculatedTypeID=TT.TypeID
WHERE ET.CalculatedTypeID NOT IN (@pending_type_id, @denied_type_id) AND 
ET.[In Day past 1900] BETWEEN @start_day AND @stop_day AND ET.[Out Seconds] <> ET.[In Seconds] -- AND ET.[Pay Rate] > 0

-- Taken care of by employee payroll items
/*
INSERT #Export
SELECT
ET.EmployeeID,
E.SyncID,
[Date]=MAX(DATEADD(d,0,ET.[In Day past 1900])),
[Type] = ISNULL(T.Project, 'Fixed Pay'),
Project = '', --T.Project,
Seconds = SUM(ET.[Out Seconds] - ET.[In Seconds]),
Rate = SUM(ET.[Fixed Pay]),
Fixed = 1,
WW = 0
FROM #EMPLOYEE_TIME_ROUNDED ET
INNER JOIN dbo.Employee E ON ET.EmployeeID=E.EmployeeID
LEFT JOIN dbo.EmployeeTime OriginalEmployeeTime ON ET.CopyTimeItemID=OriginalEmployeeTime.ItemID
LEFT JOIN dbo.vwEmployeeTime T ON ET.CopyTimeItemID=T.ItemID
LEFT JOIN dbo.TimeType TT ON ET.CalculatedTypeID=TT.TypeID
WHERE ET.CalculatedTypeID NOT IN (@pending_type_id, @denied_type_id) AND 
ET.[In Day past 1900] BETWEEN @start_day AND @stop_day AND ET.[Fixed Pay] > 0
GROUP BY
ET.EmployeeID,
E.SyncID,
T.Project
*/


INSERT #Export
SELECT
ET.EmployeeID,
E.SyncID,
[Date]=MAX(DATEADD(d,0,ET.[In Day past 1900])),
[Type] = 'Fixed Pay', --ISNULL(T.Project, 'Fixed Pay'),
Project = '', --T.Project,
Seconds = 18,
Rate = SUM(ET.[Fixed Pay]) * 200,
Fixed = 0,
WW = 0
FROM #EMPLOYEE_TIME_ROUNDED ET
INNER JOIN dbo.Employee E ON ET.EmployeeID=E.EmployeeID
LEFT JOIN dbo.EmployeeTime OriginalEmployeeTime ON ET.CopyTimeItemID=OriginalEmployeeTime.ItemID
LEFT JOIN dbo.vwEmployeeTime T ON ET.CopyTimeItemID=T.ItemID
LEFT JOIN dbo.TimeType TT ON ET.CalculatedTypeID=TT.TypeID
WHERE ET.CalculatedTypeID NOT IN (@pending_type_id, @denied_type_id) AND 
ET.[In Day past 1900] BETWEEN @start_day AND @stop_day AND ET.[Fixed Pay] > 0
GROUP BY
ET.EmployeeID,
E.SyncID -- , T.Project



INSERT #Export
SELECT
E.EmployeeID,
E.SyncID,
[Date] = DATEADD(d,0,I.[Day past 1900]),
T.[Type],
Project = '',
I.Seconds,
Rate = ISNULL([Hourly Pay],0),
WW = 0,
Fixed = 0
FROM dbo.vwEmployeeLeaveUsedItemApproved I
INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID]=I.EmployeeID
INNER JOIN dbo.Employee E ON E.EmployeeID=I.EmployeeID
INNER JOIN dbo.vwLeaveType T ON I.TypeID = T.TypeID AND T.Paid=1 AND I.[Day past 1900] BETWEEN @start_day AND @stop_day
INNER JOIN dbo.vwPersonListAs P ON I.EmployeeID = P.PersonID
LEFT JOIN dbo.vwEmployeeCompensation EC ON EC.EmployeeID=E.EmployeeID AND I.[Day past 1900] BETWEEN EC.[Start Day past 1900] AND ISNULL(EC.[Stop Day past 1900],0x7FFFFFFF)


DELETE dbo.TempX WHERE BatchID=@batch_id OR DATEDIFF(hour,Created,GETDATE()) > 1

UPDATE #Export SET WW = dbo.GetPayrollPeriodNumber([Date])
-- DATEPART(year,[Date]) * 100 + DATEPART(ww,[Date])

SELECT
EmployeeID,
SyncID,
[Date] = MAX([Date]),
[Type],
[Project],
Seconds = SUM(Seconds),
Rate,
[Fixed]
FROM #Export
GROUP BY EmployeeID,SyncID,[Type],[Project],Rate,WW,Fixed
ORDER BY EmployeeID, [Date], [Type], Rate, Fixed
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spEmployeeLeaveUsedCalculateFilter', 1
GO
ALTER PROC [dbo].[spEmployeeLeaveUsedCalculateFilter]
	@batch_id int,
 	@start_date datetime,
 	@group_by smallint,
	@work_week int,
	@work_week_year int
AS
DECLARE @stop_date datetime

SET NOCOUNT ON

-- Each row requires read permission on Employee Leave and Tardiness Summaries
EXEC dbo.spPermissionGetOnPeopleForCurrentUser2 @batch_id, 10003

IF @group_by = 0
	SELECT @stop_date = DATEADD(d,14,@start_date)
ELSE IF @group_by = 1
BEGIN
	IF (DATEPART(wk, dbo.GetDateFromMDY(12, 31, @work_week_year)) < @work_week)
	-- @work_week might be 53 or 54, but the max week in @work_week_year is only 52 or 53 (less than given @work_week number)
		RETURN
	SELECT @start_date = dbo.GetDateFromMDY(1, 1, @work_week_year)
	SELECT @start_date = DATEADD(wk,@work_week-1,DATEADD(d,1-DATEPART(dw,@start_date),@start_date))
	SELECT @stop_date = DATEADD(wk,14,@start_date)
END
ELSE IF @group_by = 2
BEGIN
	DECLARE @group_id int
	SELECT @group_id = GroupID FROM LeaveRatePeriod WHERE Payroll = 1 AND PeriodID = (SELECT CurrentPayrollPeriodID FROM dbo.Constant)

	IF @group_id = 8
		SELECT @stop_date = DATEADD(m,2*14,@start_date)
	ELSE IF @group_id = 16
		SELECT @stop_date = DATEADD(m,14,@start_date)
	ELSE IF @group_id = 32
		SELECT @stop_date = DATEADD(m,14/2,@start_date)
	ELSE IF @group_id = 64
		SELECT @stop_date = DATEADD(wk,2*14,@start_date)
	ELSE IF @group_id = 128
		SELECT @stop_date = DATEADD(wk,14,@start_date)

END
ELSE IF @group_by = 3
	SELECT @stop_date = DATEADD(m,12,@start_date)


DECLARE @start_day int, @stop_day int

SELECT @start_day = DATEDIFF(d, 0, @start_date), @stop_day = DATEDIFF(d, 0, @stop_date)

SELECT EI.EmployeeID, [Work day]=dbo.GetDateFromDaysPast1900(EI.[Day past 1900]),Duration=CAST(CAST(EI.Seconds AS decimal)/3600 AS numeric(9,2)), PayrollPeriod = 0, T.TypeID 
INTO #ET 
FROM TempX X
INNER JOIN vwEmployeeLeaveUsedItemApproved EI ON X.BatchID = @batch_id AND X.[ID] = EI.EmployeeID AND (X.[X] & 1) = 1 AND EI.[Day past 1900] BETWEEN @start_day AND @stop_day
CROSS JOIN LeaveType T
WHERE (T.TypeID & EI.[Extended Type Mask]) != 0 AND EI.Seconds <> 0

DELETE TempX WHERE BatchID=@batch_id OR DATEDIFF(hour,Created,GETDATE()) > 0

CREATE INDEX ET_EmployeeID_0407 ON #ET(EmployeeID)
CREATE INDEX ET_EmployeeIDTypeID_0407 ON #ET(EmployeeID,TypeID)

SELECT EmployeeID, TypeID INTO #Y FROM #ET GROUP BY EmployeeID, TypeID

CREATE INDEX Y_EmployeeID_0407 ON #Y(EmployeeID)
CREATE INDEX Y_EmployeeIDTypeID_0407 ON #Y(EmployeeID,TypeID)

SELECT EmployeeID, Types=ISNULL((SELECT COUNT(*) FROM #Y Y2 WHERE #Y.EmployeeID=Y2.EmployeeID ), 0)
INTO #E FROM #Y GROUP BY EmployeeID


-- SUM the duration of the work day that has 2 or more entries depending on the group by
IF @group_by = 0
-- day
BEGIN
	SELECT P.PersonID, Employee=P.[List As],
		Day0 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND DATEDIFF(dd, @start_date, #ET.[Work day]) = 0), 0),
		Day1 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND DATEDIFF(dd, @start_date, #ET.[Work day]) = 1), 0),
		Day2 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND DATEDIFF(dd, @start_date, #ET.[Work day]) = 2), 0),
		Day3 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND DATEDIFF(dd, @start_date, #ET.[Work day]) = 3), 0),
		Day4 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND DATEDIFF(dd, @start_date, #ET.[Work day]) = 4), 0),
		Day5 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND DATEDIFF(dd, @start_date, #ET.[Work day]) = 5), 0),
		Day6 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND DATEDIFF(dd, @start_date, #ET.[Work day]) = 6), 0),
		Day7 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND DATEDIFF(dd, @start_date, #ET.[Work day]) = 7), 0),
		Day8 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND DATEDIFF(dd, @start_date, #ET.[Work day]) = 8), 0),
		Day9 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND DATEDIFF(dd, @start_date, #ET.[Work day]) = 9), 0),
		Day10 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND DATEDIFF(dd, @start_date, #ET.[Work day]) = 10), 0),
		Day11 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND DATEDIFF(dd, @start_date, #ET.[Work day]) = 11), 0),
		Day12 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND DATEDIFF(dd, @start_date, #ET.[Work day]) = 12), 0),
		Day13 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND DATEDIFF(dd, @start_date, #ET.[Work day]) = 13), 0),
		Total = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID), 0),
	Type = 'Total', TypeID = 0, [Order] = -2147483648
	FROM #E INNER JOIN dbo.vwPersonListAs P ON P.PersonID=#E.EmployeeID AND #E.Types > 1

	UNION

	SELECT P.PersonID, Employee=P.[List As],
		Day0 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND DATEDIFF(dd, @start_date, #ET.[Work day]) = 0 AND #ET.TypeID = LT.TypeID),0) ,
		Day1 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND DATEDIFF(dd, @start_date, #ET.[Work day]) = 1 AND #ET.TypeID = LT.TypeID),0) ,
		Day2 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND DATEDIFF(dd, @start_date, #ET.[Work day]) = 2 AND #ET.TypeID = LT.TypeID),0) ,
		Day3 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND DATEDIFF(dd, @start_date, #ET.[Work day]) = 3 AND #ET.TypeID = LT.TypeID),0) ,
		Day4 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND DATEDIFF(dd, @start_date, #ET.[Work day]) = 4 AND #ET.TypeID = LT.TypeID),0) ,
		Day5 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND DATEDIFF(dd, @start_date, #ET.[Work day]) = 5 AND #ET.TypeID = LT.TypeID),0) ,
		Day6 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND DATEDIFF(dd, @start_date, #ET.[Work day]) = 6 AND #ET.TypeID = LT.TypeID),0) ,
		Day7 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND DATEDIFF(dd, @start_date, #ET.[Work day]) = 7 AND #ET.TypeID = LT.TypeID),0) ,
		Day8 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND DATEDIFF(dd, @start_date, #ET.[Work day]) = 8 AND #ET.TypeID = LT.TypeID),0) ,
		Day9 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND DATEDIFF(dd, @start_date, #ET.[Work day]) = 9 AND #ET.TypeID = LT.TypeID),0) ,
		Day10 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND DATEDIFF(dd, @start_date, #ET.[Work day]) = 10 AND #ET.TypeID = LT.TypeID),0) ,
		Day11 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND DATEDIFF(dd, @start_date, #ET.[Work day]) = 11 AND #ET.TypeID = LT.TypeID),0) ,
		Day12 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND DATEDIFF(dd, @start_date, #ET.[Work day]) = 12 AND #ET.TypeID = LT.TypeID),0) ,
		Day13 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND DATEDIFF(dd, @start_date, #ET.[Work day]) = 13 AND #ET.TypeID = LT.TypeID),0) ,
		Total = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND #ET.TypeID = LT.TypeID),0) ,
	LT.Abbreviation, LT.TypeID, LT.[Order]
	FROM #Y INNER JOIN dbo.vwPersonListAs P ON P.PersonID=#Y.EmployeeID
	INNER JOIN LeaveType LT ON #Y.TypeId=LT.TypeID ORDER BY Employee, PersonID, [Order]

END

ELSE IF @group_by = 1
-- Work week
BEGIN
	UPDATE #ET SET [Work day]=DATEADD(d,1-DATEPART(dw,[work day]),[work day])

	DECLARE @first_ww datetime
	SELECT @first_ww = CAST('01/01/' + CAST(@work_week_year as varchar(50)) AS datetime)
	SELECT @first_ww = DATEADD(wk,@work_week,@first_ww)
	SELECT @first_ww = DATEADD(d, 1 - DATEPART(dw,@first_ww),@first_ww)
	IF DAY(@first_ww) <> 1 SELECT @first_ww = DATEADD(d, -7,@first_ww)



	SELECT P.PersonID, Employee=P.[List As],
		WW0 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND DATEDIFF(d, @first_ww, #ET.[Work day]) BETWEEN 0 AND 6), 0),
		WW1 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND DATEDIFF(d, @first_ww, #ET.[Work day]) BETWEEN 7 AND 13), 0),
		WW2 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND DATEDIFF(d, @first_ww, #ET.[Work day]) BETWEEN 14 AND 20), 0),
		WW3 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND DATEDIFF(d, @first_ww, #ET.[Work day]) BETWEEN 21 AND 27), 0),
		WW4 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND DATEDIFF(d, @first_ww, #ET.[Work day]) BETWEEN 28 AND 34), 0),
		WW5 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND DATEDIFF(d, @first_ww, #ET.[Work day]) BETWEEN 35 AND 41), 0),
		WW6 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND DATEDIFF(d, @first_ww, #ET.[Work day]) BETWEEN 42 AND 48), 0),
		WW7 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND DATEDIFF(d, @first_ww, #ET.[Work day]) BETWEEN 49 AND 55), 0),
		WW8 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND DATEDIFF(d, @first_ww, #ET.[Work day]) BETWEEN 56 AND 62), 0),
		WW9 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND DATEDIFF(d, @first_ww, #ET.[Work day]) BETWEEN 63 AND 69), 0),
		WW10 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND DATEDIFF(d, @first_ww, #ET.[Work day]) BETWEEN 70 AND 76), 0),
		WW11 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND DATEDIFF(d, @first_ww, #ET.[Work day]) BETWEEN 77 AND 83), 0),
		WW12 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND DATEDIFF(d, @first_ww, #ET.[Work day]) BETWEEN 84 AND 90), 0),
		WW13 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND DATEDIFF(d, @first_ww, #ET.[Work day]) BETWEEN 91 AND 97), 0),
		Total = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID), 0),
	Type = 'Total', TypeID = 0, [Order] = -2147483648
	FROM #E INNER JOIN dbo.vwPersonListAs P ON P.PersonID=#E.EmployeeID AND #E.Types > 1

	UNION

	SELECT P.PersonID, Employee=P.[List As],
		WW0 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND DATEDIFF(d, @first_ww, #ET.[Work day]) BETWEEN 0 AND 6 AND #ET.TypeID = LT.TypeID), 0),
		WW1 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND DATEDIFF(d, @first_ww, #ET.[Work day]) BETWEEN 7 AND 13 AND #ET.TypeID = LT.TypeID), 0),
		WW2 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND DATEDIFF(d, @first_ww, #ET.[Work day]) BETWEEN 14 AND 20 AND #ET.TypeID = LT.TypeID), 0),
		WW3 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND DATEDIFF(d, @first_ww, #ET.[Work day]) BETWEEN 21 AND 27 AND #ET.TypeID = LT.TypeID), 0),
		WW4 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND DATEDIFF(d, @first_ww, #ET.[Work day]) BETWEEN 28 AND 34 AND #ET.TypeID = LT.TypeID), 0),
		WW5 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND DATEDIFF(d, @first_ww, #ET.[Work day]) BETWEEN 35 AND 41 AND #ET.TypeID = LT.TypeID), 0),
		WW6 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND DATEDIFF(d, @first_ww, #ET.[Work day]) BETWEEN 42 AND 48 AND #ET.TypeID = LT.TypeID), 0),
		WW7 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND DATEDIFF(d, @first_ww, #ET.[Work day]) BETWEEN 49 AND 55 AND #ET.TypeID = LT.TypeID), 0),
		WW8 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND DATEDIFF(d, @first_ww, #ET.[Work day]) BETWEEN 56 AND 62 AND #ET.TypeID = LT.TypeID), 0),
		WW9 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND DATEDIFF(d, @first_ww, #ET.[Work day]) BETWEEN 63 AND 69 AND #ET.TypeID = LT.TypeID), 0),
		WW10 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND DATEDIFF(d, @first_ww, #ET.[Work day]) BETWEEN 70 AND 76 AND #ET.TypeID = LT.TypeID), 0),
		WW11 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND DATEDIFF(d, @first_ww, #ET.[Work day]) BETWEEN 77 AND 83 AND #ET.TypeID = LT.TypeID), 0),
		WW12 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND DATEDIFF(d, @first_ww, #ET.[Work day]) BETWEEN 84 AND 90 AND #ET.TypeID = LT.TypeID), 0),
		WW13 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND DATEDIFF(d, @first_ww, #ET.[Work day]) BETWEEN 91 AND 97 AND #ET.TypeID = LT.TypeID), 0),
		Total = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND #ET.TypeID = LT.TypeID), 0),
	LT.Abbreviation, LT.TypeID, LT.[Order]
	FROM #Y INNER JOIN dbo.vwPersonListAs P ON P.PersonID=#Y.EmployeeID
	INNER JOIN LeaveType LT ON #Y.TypeId=LT.TypeID ORDER BY Employee, PersonID, [Order]
END

ELSE IF @group_by = 2
-- payroll
BEGIN
	DECLARE @first_payroll_period int
	SELECT @first_payroll_period = dbo.GetPayrollPeriodNumber(@start_date)
	UPDATE #ET SET [PayrollPeriod]=dbo.GetPayrollPeriodNumber(#ET.[Work day])

	SELECT P.PersonID, Employee=P.[List As],
		Payroll0 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND #ET.[PayrollPeriod] - @first_payroll_period = 0),0),
		Payroll1 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND #ET.[PayrollPeriod] - @first_payroll_period = 1),0),
		Payroll2 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND #ET.[PayrollPeriod] - @first_payroll_period = 2),0),
		Payroll3 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND #ET.[PayrollPeriod] - @first_payroll_period = 3),0),
		Payroll4 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND #ET.[PayrollPeriod] - @first_payroll_period = 4),0),
		Payroll5 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND #ET.[PayrollPeriod] - @first_payroll_period = 5),0),
		Payroll6 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND #ET.[PayrollPeriod] - @first_payroll_period = 6),0),
		Payroll7 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND #ET.[PayrollPeriod] - @first_payroll_period = 7),0),
		Payroll8 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND #ET.[PayrollPeriod] - @first_payroll_period = 8),0),
		Payroll9 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND #ET.[PayrollPeriod] - @first_payroll_period = 9),0),
		Payroll10 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND #ET.[PayrollPeriod] - @first_payroll_period = 10),0),
		Payroll11 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND #ET.[PayrollPeriod] - @first_payroll_period = 11),0),
		Payroll12 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND #ET.[PayrollPeriod] - @first_payroll_period = 12),0),
		Payroll13 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND #ET.[PayrollPeriod] - @first_payroll_period = 13),0),
		Total = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID),0),
	Type = 'Total', TypeID = 0, [Order] = -2147483648
	FROM #E INNER JOIN dbo.vwPersonListAs P ON P.PersonID=#E.EmployeeID AND #E.Types > 1

	UNION

	SELECT P.PersonID, Employee=P.[List As],
		Payroll0 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND #ET.[PayrollPeriod] - @first_payroll_period = 0 AND #ET.TypeID = LT.TypeID),0),
		Payroll1 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND #ET.[PayrollPeriod] - @first_payroll_period = 1 AND #ET.TypeID = LT.TypeID),0),
		Payroll2 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND #ET.[PayrollPeriod] - @first_payroll_period = 2 AND #ET.TypeID = LT.TypeID),0),
		Payroll3 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND #ET.[PayrollPeriod] - @first_payroll_period = 3 AND #ET.TypeID = LT.TypeID),0),
		Payroll4 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND #ET.[PayrollPeriod] - @first_payroll_period = 4 AND #ET.TypeID = LT.TypeID),0),
		Payroll5 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND #ET.[PayrollPeriod] - @first_payroll_period = 5 AND #ET.TypeID = LT.TypeID),0),
		Payroll6 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND #ET.[PayrollPeriod] - @first_payroll_period = 6 AND #ET.TypeID = LT.TypeID),0),
		Payroll7 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND #ET.[PayrollPeriod] - @first_payroll_period = 7 AND #ET.TypeID = LT.TypeID),0),
		Payroll8 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND #ET.[PayrollPeriod] - @first_payroll_period = 8 AND #ET.TypeID = LT.TypeID),0),
		Payroll9 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND #ET.[PayrollPeriod] - @first_payroll_period = 9 AND #ET.TypeID = LT.TypeID),0),
		Payroll10 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND #ET.[PayrollPeriod] - @first_payroll_period = 10 AND #ET.TypeID = LT.TypeID),0),
		Payroll11 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND #ET.[PayrollPeriod] - @first_payroll_period = 11 AND #ET.TypeID = LT.TypeID),0),
		Payroll12 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND #ET.[PayrollPeriod] - @first_payroll_period = 12 AND #ET.TypeID = LT.TypeID),0),
		Payroll13 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND #ET.[PayrollPeriod] - @first_payroll_period = 13 AND #ET.TypeID = LT.TypeID),0),
		Total = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND #ET.TypeID = LT.TypeID),0),
	LT.Abbreviation, LT.TypeID, LT.[Order]
	FROM #Y INNER JOIN dbo.vwPersonListAs P ON P.PersonID=#Y.EmployeeID
	INNER JOIN LeaveType LT ON #Y.TypeId=LT.TypeID ORDER BY Employee, PersonID, [Order]
END

ELSE IF @group_by = 3
-- month
BEGIN
	UPDATE #ET SET [Work day]=DATEADD(d,1-DAY([Work day]),[Work day])

	SELECT P.PersonID, Employee=P.[List As],
		Month0 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND DATEDIFF(m, @start_date, #ET.[Work day]) = 0), 0),
		Month1 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND DATEDIFF(m, @start_date, #ET.[Work day]) = 1), 0),
		Month2 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND DATEDIFF(m, @start_date, #ET.[Work day]) = 2), 0),
		Month3 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND DATEDIFF(m, @start_date, #ET.[Work day]) = 3), 0),
		Month4 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND DATEDIFF(m, @start_date, #ET.[Work day]) = 4), 0),
		Month5 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND DATEDIFF(m, @start_date, #ET.[Work day]) = 5), 0),
		Month6 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND DATEDIFF(m, @start_date, #ET.[Work day]) = 6), 0),
		Month7 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND DATEDIFF(m, @start_date, #ET.[Work day]) = 7), 0),
		Month8 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND DATEDIFF(m, @start_date, #ET.[Work day]) = 8), 0),
		Month9 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND DATEDIFF(m, @start_date, #ET.[Work day]) = 9), 0),
		Month10 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND DATEDIFF(m, @start_date, #ET.[Work day]) = 10), 0),
		Month11 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND DATEDIFF(m, @start_date, #ET.[Work day]) = 11), 0),
		Total = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID), 0),
	Type = 'Total', TypeID = 0, [Order] = -2147483648
	FROM #E INNER JOIN dbo.vwPersonListAs P ON P.PersonID=#E.EmployeeID AND #E.Types > 1

	UNION

	SELECT P.PersonID, Employee=P.[List As],
		Month0 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND DATEDIFF(m, @start_date, #ET.[Work day]) = 0 AND #ET.TypeID = LT.TypeID), 0),
		Month1 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND DATEDIFF(m, @start_date, #ET.[Work day]) = 1 AND #ET.TypeID = LT.TypeID), 0),
		Month2 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND DATEDIFF(m, @start_date, #ET.[Work day]) = 2 AND #ET.TypeID = LT.TypeID), 0),
		Month3 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND DATEDIFF(m, @start_date, #ET.[Work day]) = 3 AND #ET.TypeID = LT.TypeID), 0),
		Month4 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND DATEDIFF(m, @start_date, #ET.[Work day]) = 4 AND #ET.TypeID = LT.TypeID), 0),
		Month5 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND DATEDIFF(m, @start_date, #ET.[Work day]) = 5 AND #ET.TypeID = LT.TypeID), 0),
		Month6 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND DATEDIFF(m, @start_date, #ET.[Work day]) = 6 AND #ET.TypeID = LT.TypeID), 0),
		Month7 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND DATEDIFF(m, @start_date, #ET.[Work day]) = 7 AND #ET.TypeID = LT.TypeID), 0),
		Month8 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND DATEDIFF(m, @start_date, #ET.[Work day]) = 8 AND #ET.TypeID = LT.TypeID), 0),
		Month9 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND DATEDIFF(m, @start_date, #ET.[Work day]) = 9 AND #ET.TypeID = LT.TypeID), 0),
		Month10 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND DATEDIFF(m, @start_date, #ET.[Work day]) = 10 AND #ET.TypeID = LT.TypeID), 0),
		Month11 = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID AND DATEDIFF(m, @start_date, #ET.[Work day]) = 11 AND #ET.TypeID = LT.TypeID), 0),
		Total = ISNULL((SELECT SUM(Duration) FROM #ET WHERE #ET.EmployeeID = P.PersonID), 0),

	LT.Abbreviation, LT.TypeID, LT.[Order]
	FROM #Y INNER JOIN dbo.vwPersonListAs P ON P.PersonID=#Y.EmployeeID
	INNER JOIN LeaveType LT ON #Y.TypeId=LT.TypeID ORDER BY Employee, PersonID, [Order]
END
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spEmployeeSelectOrg', 1
GO
ALTER PROC dbo.spEmployeeSelectOrg
	@employee_id int
AS
DECLARE @authorized bit

SET NOCOUNT ON

EXEC dbo.spPermissionInsureForCurrentUserOnPerson @employee_id, 8, 1, @authorized out
IF @authorized = 1 SELECT * FROM dbo.vwEmployeeOrg WHERE EmployeeID = @employee_id
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spInOutStatusGetFirst', 1
GO
ALTER PROC dbo.spInOutStatusGetFirst
	@in bit,
	@status_id int OUT
AS
SET @status_id = NULL
SELECT TOP 1 @status_id=StatusID FROM dbo.InOutStatus WHERE [In] = @in ORDER BY [Order]
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spInOutStatusStraighten', 1
GO
-- Ensures that InOutStatus.Order is unique
ALTER PROC dbo.spInOutStatusStraighten
AS
DECLARE @status_id int

SET NOCOUNT ON

SELECT TOP 1 @status_id = MIN(StatusID) FROM dbo.InOutStatus GROUP BY [Order] HAVING COUNT(*) > 1
WHILE @@ROWCOUNT > 0
BEGIN
	UPDATE [InOutStatus] SET [Order] = [Order] + 1 WHERE StatusID = @status_id
	SELECT TOP 1 @status_id = MIN(StatusID) FROM dbo.InOutStatus GROUP BY [Order] HAVING COUNT(*) > 1
END
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spInOutStatusMoveDown', 1
GO
ALTER PROC dbo.spInOutStatusMoveDown
	@status_id int
AS
DECLARE @next_Status_id int
DECLARE @order int, @next_order int

SET NOCOUNT ON

SELECT @order = [Order] FROM InOutStatus WHERE StatusID = @status_id
SELECT TOP 1 @next_Status_id = StatusID FROM dbo.InOutStatus WHERE [Order] > @order ORDER BY [Order]
SELECT @next_order = [Order] FROM dbo.InOutStatus WHERE StatusID = @next_Status_id

IF @next_order IS NOT NULL
BEGIN
	UPDATE dbo.InOutStatus SET [Order] = @next_order WHERE StatusID = @status_id
	UPDATE dbo.InOutStatus SET [Order] = @order WHERE StatusID = @next_Status_id
END
EXEC dbo.spInOutStatusStraighten
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spInOutStatusMoveUp', 1
GO
ALTER PROC dbo.spInOutStatusMoveUp
	@status_id int
AS
DECLARE @previous_requirement_id int
DECLARE @order int, @previous_order int

SET NOCOUNT ON

SELECT @order = [Order] FROM InOutStatus WHERE StatusID = @status_id
SELECT TOP 1 @previous_requirement_id = StatusID FROM InOutStatus WHERE [Order] < @order ORDER BY [Order] DESC
SELECT @previous_order = [Order] FROM InOutStatus WHERE StatusID = @previous_requirement_id

IF @previous_order IS NOT NULL
BEGIN
	UPDATE InOutStatus SET [Order] = @previous_order WHERE StatusID = @status_id
	UPDATE InOutStatus SET [Order] = @order WHERE StatusID = @previous_requirement_id
END
EXEC dbo.spInOutStatusStraighten
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spInOutStatusDelete', 1
GO
ALTER PROC dbo.spInOutStatusDelete @status_id int AS DELETE InOutStatus WHERE StatusID=@status_id
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spInOutStatusInsert', 1
GO
ALTER PROC dbo.spInOutStatusInsert
	@status varchar(50),
	@in bit,
	@color int,
	@status_id int OUT
AS
DECLARE @order int
SET @order = ISNULL((SELECT MAX([Order]) FROM InOutStatus), 0) + 1
INSERT dbo.InOutStatus(Status,[In],Color,[Order]) VALUES(@status,@in,@color,@order)
SELECT @status_id=SCOPE_IDENTITY()
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spInOutStatusUpdate', 1
GO
ALTER PROC dbo.spInOutStatusUpdate
	@status varchar(50),
	@in bit,
	@color int,
	@status_id int
AS
UPDATE dbo.InOutStatus SET [Status]=@status,[In]=@in,Color=@color WHERE StatusID=@status_id
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spInOutStatusList', 1
GO
ALTER PROC dbo.spInOutStatusList AS SET NOCOUNT ON SELECT * FROM dbo.vwInOutStatus ORDER BY [Order]
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spInOutStatusSelect', 1
GO
ALTER PROC dbo.spInOutStatusSelect @status_id int AS SET NOCOUNT ON SELECT * FROM dbo.vwInOutStatus WHERE StatusID=@status_id
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spSubfolderInsert', 0
GO
ALTER PROC dbo.spSubfolderInsert @subfolder varchar(50), @subfolder_id int OUT, @options int=0, @attribute_id int=NULL AS
INSERT Subfolder(Subfolder,Options,AttributeID) VALUES(@subfolder,@options,@attribute_id) SELECT @subfolder_id = SubfolderID FROM Subfolder
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spSubfolderUpdate', 0
GO
ALTER PROC dbo.spSubfolderUpdate @subfolder varchar(50), @subfolder_id int, @options int=NULL, @attribute_id int=NULL AS
UPDATE Subfolder SET Subfolder = @subfolder, 
Options=CASE WHEN @options IS NULL THEN Options ELSE @options END,
AttributeID=CASE WHEN @attribute_id IS NULL AND @options IS NULL THEN AttributeID ELSE @attribute_id END
WHERE SubfolderID = @subfolder_id
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spPermissionListAttributes', 1
GO
ALTER PROC dbo.spPermissionListAttributes @flags int=0 AS
SET NOCOUNT ON
SELECT AttributeID, Attribute FROM dbo.PermissionAttribute WHERE 
((@flags & 1) = 0 OR Attribute LIKE 'Folder%')
ORDER BY Attribute
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spEmployeeUserFieldItemInsert'
GO
ALTER PROC dbo.spEmployeeUserFieldItemInsert @employee_id int, @item_id int, @eitem_id int out AS
DECLARE @authorized bit
EXEC dbo.spPermissionInsureForCurrentUserOnPerson @employee_id, 8, 2, @authorized out
IF @authorized=1 INSERT dbo.EmployeeUserFieldItem(EmployeeID,ItemID) SELECT @employee_id, @item_id SET @eitem_id=SCOPE_IDENTITY()
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spEmployeeUserFieldItemUpdate'
GO
ALTER PROC dbo.spEmployeeUserFieldItemUpdate @item_id int, @eitem_id int AS
DECLARE @employee_id int, @authorized bit
SELECT @employee_id=EmployeeID FROM dbo.EmployeeUserFieldItem WHERE EItemID=@eitem_id
EXEC dbo.spPermissionInsureForCurrentUserOnPerson @employee_id, 8, 2, @authorized out
IF @authorized=1 UPDATE dbo.EmployeeUserFieldItem SET ItemID=@item_id WHERE EItemID=@eitem_id
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spEmployeeUserFieldItemDelete'
GO
ALTER PROC dbo.spEmployeeUserFieldItemDelete @eitem_id int AS 
DECLARE @employee_id int, @authorized bit
SELECT @employee_id=EmployeeID FROM dbo.EmployeeUserFieldItem WHERE EItemID=@eitem_id
EXEC dbo.spPermissionInsureForCurrentUserOnPerson @employee_id, 8, 2, @authorized out
IF @authorized=1 DELETE dbo.EmployeeUserFieldItem WHERE EItemID=@eitem_id
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spEmployeeUserFieldItemList'
GO
ALTER PROC dbo.spEmployeeUserFieldItemList @employee_id int = NULL, @eitem_id int = NULL AS 
IF (@employee_id IS NOT NULL AND @eitem_id IS NOT NULL) OR (@employee_id IS NULL AND @eitem_id IS NULL)
BEGIN
	RAISERROR('spEmployeeUserFieldItemList requires one non-null parameter: @employee_id or @eitem_id', 16,1)
	RETURN
END
SET NOCOUNT ON
DECLARE @authorized bit
IF @eitem_id IS NOT NULL SELECT @employee_id=EmployeeID FROM dbo.EmployeeUserFieldItem WHERE EItemID=@eitem_id
EXEC dbo.spPermissionInsureForCurrentUserOnPerson @employee_id, 8, 1, @authorized out

IF @authorized=1 SELECT EI.EItemID, EI.EmployeeID, EI.ItemID, P.[List As], I.Item, I.FieldID
FROM dbo.EmployeeUserFieldItem EI
INNER JOIN dbo.vwPersonListAs P ON EI.EmployeeID=P.PersonID AND
EI.EmployeeID=@employee_id AND -- @employee_id will allows be non-null after parameter check above
(@eitem_id IS NULL OR EI.EItemID=@eitem_id)
INNER JOIN dbo.UserFieldItem I ON EI.ItemID = I.ItemID
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spEmployeeListActive', 0
GO
-- Returns list of scopes that apply to a user for a given employee
ALTER PROC dbo.spEmployeeListActive AS 
SELECT EmployeeID, P.[List As] 
FROM dbo.Employee E
INNER JOIN dbo.vwPersonListAs P ON E.EmployeeID=P.PersonID AND [Active Employee]=1
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spPermissionListScopesForUserEmployee'
GO
-- Returns list of scopes that apply to a user for a given employee
ALTER PROC dbo.spPermissionListScopesForUserEmployee
	@user_sid varbinary(85), @employee_id int
AS
DECLARE @user_employee_id int, @user_division_id int, @user_department_id int, @user_location_id int, @user_org int, @user_manager_id int
DECLARE @employee_delegated_manager_id int, @employee_division_id int, @employee_department_id int, @employee_location_id int, @employee_org int, @employee_active int
DECLARE @dept_lkid int, @div_lkid int

SELECT @user_employee_id = EmployeeID,
@user_division_id = DivisionID,
@user_department_id = DepartmentID,
@user_org = OrgUserField1,
@user_manager_id = ManagerID
FROM dbo.Employee WHERE [SID]=@user_sid

SELECT
@employee_division_id = DivisionID,
@employee_department_id = DepartmentID,
@employee_org = OrgUserField1,
@employee_active = [Active Employee],
@employee_delegated_manager_id = DelegatedManagerID
FROM dbo.Employee WHERE EmployeeID = @employee_id

SELECT @dept_lkid = LeaveKeeperID FROM dbo.Department WHERE DepartmentID = @employee_department_id
SELECT @div_lkid = LeaveKeeperID FROM dbo.Division WHERE DivisionID = @employee_division_id

CREATE TABLE #Scopes(ScopeID int)

-- Employee
IF @user_employee_id IS NOT NULL
INSERT #Scopes(ScopeID) SELECT 2

-- Self
IF @user_employee_id = @employee_id 
INSERT #Scopes(ScopeID) SELECT 4

-- Subordinates
IF EXISTS(SELECT * FROM dbo.EmployeeSuperior WHERE EmployeeID=@employee_id AND SuperiorID=@user_employee_id)
INSERT #Scopes(ScopeID) SELECT 8

-- Division
IF @user_division_id = @employee_division_id
INSERT #Scopes(ScopeID) SELECT 16

-- Department
IF @user_department_id = @employee_department_id
INSERT #Scopes(ScopeID) SELECT 32

-- Location
IF @user_location_id = @employee_location_id
INSERT #Scopes(ScopeID) SELECT 64

-- Delegated Subordinate
IF @user_employee_id = @employee_delegated_manager_id
INSERT #Scopes(ScopeID) SELECT 256

-- Manager
IF @user_manager_id = @employee_id
INSERT #Scopes(ScopeID) SELECT 512

-- 1024 not implemented


-- Manager's Subordinates
IF EXISTS(SELECT * FROM dbo.EmployeeSuperior WHERE EmployeeID=@employee_id AND SuperiorID=@user_manager_id)
INSERT #Scopes(ScopeID) SELECT 2048

-- Custom Org
IF @user_org = @employee_org OR EXISTS(
	SELECT * FROM dbo.EmployeeUserFieldItem WHERE EmployeeID=@user_employee_id AND ItemID=@employee_org
)
INSERT #Scopes(ScopeID) SELECT 4096

-- Inactive Employees
IF @employee_active = 0
INSERT #Scopes(ScopeID) SELECT 8192

-- Leave Keeper
IF @user_employee_id IN (@dept_lkid, @div_lkid) SELECT 16384

SELECT * FROM #Scopes
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spPermissionListWindowsGroupsForAttribute'
GO
-- Returns list of permissions and group names that affect attribute
ALTER PROC dbo.spPermissionListWindowsGroupsForAttribute
	@attribute_id int
AS
SELECT AttributeID,PSA.[Permission Mask], PSA.[Deny Mask], ScopeID, U.[UID], U.[name]
FROM dbo.PermissionScopeAttribute PSA
INNER JOIN dbo.sysusers U ON PSA.AttributeID=@attribute_id AND PSA.UID=U.UID AND U.isntgroup=1

UNION

-- Windows groups nested in roles
SELECT AttributeID,PSA.[Permission Mask], PSA.[Deny Mask], ScopeID, U.[UID], U.[name]
FROM dbo.PermissionScopeAttribute PSA
INNER JOIN dbo.sysmembers M ON PSA.AttributeID=@attribute_id AND PSA.UID=M.groupuid
INNER JOIN dbo.sysusers U ON M.memberuid = U.uid  AND U.isntgroup=1
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spSubfolderSelect'
GO
ALTER PROC dbo.spSubfolderSelect @subfolder_id int AS
SET NOCOUNT ON SELECT * FROM dbo.Subfolder WHERE SubfolderID = @subfolder_id
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spSubfolderList'
GO
ALTER PROC dbo.spSubfolderList @options_mask int=0 AS
SET NOCOUNT ON SELECT SubfolderID, Subfolder, Options, AttributeID FROM dbo.Subfolder WHERE (@options_mask=0 OR (Options & @options_mask) != 0) ORDER BY Subfolder
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spEmployeeDelete', 0
GO
-- Lets user delete any employee
ALTER PROC dbo.spEmployeeDelete
	@employee_id int
AS
SET NOCOUNT ON

BEGIN TRAN

EXEC dbo.spPersonDeletePrepare @employee_id
DELETE dbo.Employee WHERE EmployeeID = @employee_id

DELETE X
FROM dbo.PersonX X
INNER JOIN dbo.Person P ON (P.[Role Mask] & 2) = 0 AND X.PersonID = P.PersonID AND P.PersonID = @employee_id

COMMIT TRAN
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spEmployeeDelete2', 1
GO
-- Checks delete permission
ALTER PROC dbo.spEmployeeDelete2
	@employee_id int
AS
SET NOCOUNT ON

DECLARE @authorized bit
EXEC dbo.spPermissionInsureForCurrentUserOnPerson @employee_id, 12, 8, @authorized out
IF @authorized = 1 EXEC dbo.spEmployeeDelete @employee_id
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spExecuteSQLBigForSQL2000'
GO
-- Backward compatibility. We used to support SQL Server 2000 but no longer do. Really, calls to spExecuteSQLBigForSQL2000 should be replaced by calls to spAdminExecuteSqlAsDBO
ALTER PROC dbo.spExecuteSQLBigForSQL2000 WITH EXEC AS 'dbo'
AS
IF CAST(SERVERPROPERTY('productversion') AS varchar(50)) NOT LIKE '[0-8].%'
BEGIN
	EXEC sp_executesql N'DECLARE @sql nvarchar(MAX) SELECT @sql = [SQL] FROM #BigSQLStatement EXEC sp_executesql @sql'
END
ELSE
BEGIN
	DECLARE @t1 nvarchar(4000), @t2 nvarchar(4000), @t3 nvarchar(4000), @t4 nvarchar(4000), @t5 nvarchar(4000), @t6 nvarchar(4000), @t7 nvarchar(4000), @t8 nvarchar(4000), @t9 nvarchar(4000), @t10 nvarchar(4000)
	DECLARE @t11 nvarchar(4000), @t12 nvarchar(4000), @t13 nvarchar(4000), @t14 nvarchar(4000), @t15 nvarchar(4000), @t16 nvarchar(4000), @t17 nvarchar(4000), @t18 nvarchar(4000), @t19 nvarchar(4000), @t20 nvarchar(4000)

	SELECT @t1 = REPLACE(SUBSTRING([SQL],1,3000), '''', '''''') FROM #BigSQLStatement
	SELECT @t2 = REPLACE(SUBSTRING([SQL],3001,3000), '''', '''''') FROM #BigSQLStatement
	SELECT @t3 = REPLACE(SUBSTRING([SQL],6001,3000), '''', '''''') FROM #BigSQLStatement
	SELECT @t4 = REPLACE(SUBSTRING([SQL],9001,3000), '''', '''''') FROM #BigSQLStatement
	SELECT @t5 = REPLACE(SUBSTRING([SQL],12001,3000), '''', '''''') FROM #BigSQLStatement
	SELECT @t6 = REPLACE(SUBSTRING([SQL],15001,3000), '''', '''''') FROM #BigSQLStatement
	SELECT @t7 = REPLACE(SUBSTRING([SQL],18001,3000), '''', '''''') FROM #BigSQLStatement
	SELECT @t8 = REPLACE(SUBSTRING([SQL],21001,3000), '''', '''''') FROM #BigSQLStatement
	SELECT @t9 = REPLACE(SUBSTRING([SQL],24001,3000), '''', '''''') FROM #BigSQLStatement
	SELECT @t10 = REPLACE(SUBSTRING([SQL],27001,3000), '''', '''''') FROM #BigSQLStatement
	SELECT @t11 = REPLACE(SUBSTRING([SQL],30001,3000), '''', '''''') FROM #BigSQLStatement
	SELECT @t12 = REPLACE(SUBSTRING([SQL],33001,3000), '''', '''''') FROM #BigSQLStatement
	SELECT @t13 = REPLACE(SUBSTRING([SQL],36001,3000), '''', '''''') FROM #BigSQLStatement
	SELECT @t14 = REPLACE(SUBSTRING([SQL],39001,3000), '''', '''''') FROM #BigSQLStatement
	SELECT @t15 = REPLACE(SUBSTRING([SQL],42001,3000), '''', '''''') FROM #BigSQLStatement
	SELECT @t16 = REPLACE(SUBSTRING([SQL],45001,3000), '''', '''''') FROM #BigSQLStatement
	SELECT @t17 = REPLACE(SUBSTRING([SQL],48001,3000), '''', '''''') FROM #BigSQLStatement
	SELECT @t18 = REPLACE(SUBSTRING([SQL],51001,3000), '''', '''''') FROM #BigSQLStatement
	SELECT @t19 = REPLACE(SUBSTRING([SQL],54001,3000), '''', '''''') FROM #BigSQLStatement
	SELECT @t20 = REPLACE(SUBSTRING([SQL],57001,3000), '''', '''''') FROM #BigSQLStatement

	-- Since [SQL] field is ntext, it uses 2 bytes per char -- max DATALENGTH = 60000 * 2
	IF EXISTS(SELECT * FROM #BigSQLStatement WHERE DATALENGTH([SQL]) > 120000) RAISERROR('SQL statement for SQL Server 2000 sp_executesql command contained more than 60000 characters. Upgrade your server to SQL Server 2005 or newer, or contact Apex support for help.',16,1)
	ELSE exec (N'sp_executesql N''' + @t1 + @t2 + @t3 + @t4 + @t5 + @t6 + @t7 + @t8 + @t9 + @t10 + @t11 + @t12 + @t13 + @t14 + @t15 + @t16 + @t17 + @t18 + @t19 + @t20 + N'''')
END
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spEmployeeTimeChangeOTtoComp', 0
GO
ALTER PROC dbo.spEmployeeTimeChangeOTtoComp
	@employee_id int = NULL,
	@start_day int,
	@stop_day int,
	@seconds_changed int = 0 out,
	@batch_id int = NULL,
	@authorized bit = 0
AS
DECLARE @abort bit, @date_first int, @week_start_day int, @week_stop_day int, @last_week_day int, @s int
SELECT @date_first = DatePartDW FROM dbo.vwDateFirst
SELECT @week_start_day = DATEDIFF(d,0,dbo.GetWeekStart(@date_first, @start_day))
SELECT @last_week_day = DATEDIFF(d,0,dbo.GetWeekStart(@date_first, @stop_day)) + 6

SET @seconds_changed = 0

IF @batch_id IS NULL
BEGIN
	EXEC dbo.spAdminGetNextRandom @batch_id out
	INSERT dbo.TempX(BatchID,[ID]) SELECT @batch_id,@employee_id
END
ELSE
BEGIN
	-- Removes employees without OT basis = 40
	DELETE dbo.TempX WHERE BatchID=@batch_id AND [ID] NOT IN (
		SELECT EmployeeID FROM dbo.Employee WHERE [OT Basis]=1
	)
END

-- Return immediately if no comp type is defined
SELECT TypeID = MIN(TypeID), [Comp Rate]
INTO #CompType
FROM dbo.TimeType
WHERE CompLeaveTypeID IS NOT NULL
GROUP BY [Comp Rate]

SELECT @employee_id = NULL, @authorized = 1, @abort = 0

IF NOT EXISTS(SELECT * FROM #CompType)
BEGIN
	RAISERROR(N'No time types are linked to comp leave types. Click "Timecards > Types of Time", open at least one comp time type, and associate it with a comp leave type.',16,1)
	SET @abort = 1
END

-- Return immediately if user does not have write\create permissions on employee's approved timecard
EXEC dbo.spPermissionGetOnPeopleForCurrentUser2 @batch_id, 262145
SELECT TOP 1 @employee_id = [ID] FROM dbo.TempX WHERE BatchID=@batch_id AND X & 4 = 0
IF @abort = 0 AND @employee_id IS NOT NULL
BEGIN
	EXEC dbo.spErrorRaiseNoPermission 262145, 4, @employee_id
	SELECT @authorized = 0, @abort = 1
END

SELECT TOP 1 @employee_id = [ID] FROM dbo.TempX WHERE BatchID=@batch_id AND X & 2 = 0
IF @abort = 0 AND @employee_id IS NOT NULL
BEGIN
	EXEC dbo.spErrorRaiseNoPermission 262145, 2, @employee_id
	SELECT @authorized = 0, @abort = 1
END

IF @abort = 0
BEGIN
	-- Approve time so that ot can automatically calculate if needed
	UPDATE ET SET StatusID=1 
	FROM dbo.EmployeeTime ET
	INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID]=ET.EmployeeID AND
	StatusID=8 AND DATEDIFF(d,0,[In]) BETWEEN @week_start_day AND @last_week_day
	
	-- Calculate OT
	CREATE TABLE #EMPLOYEE_TIME_ROUNDED(
		TempItemID int NOT NULL IDENTITY(1,1) PRIMARY KEY,
		EmployeeID int NOT NULL,
		OriginalTypeID int NOT NULL, 
		CalculatedTypeID int NOT NULL,
		[In Day past 1900] int NOT NULL, 
		[OT Eligible] bit NOT NULL,
		[OT Disable] bit NOT NULL,
		[Pay Rate] money NOT NULL,
		[Fixed Pay] money NOT NULL DEFAULT(0),
		[Fixed Items] int DEFAULT(0),
		Regular bit DEFAULT(0),
		[In Seconds] int NOT NULL,
		[Out Seconds] int NOT NULL,
		TimeSchemaID int NOT NULL,
		ShiftDiffItemID int NULL,
		TempShiftDiffSeconds int NULL,
		TempShiftDiffItemID int NULL,
		OriginalTimeItemID int NULL,
		CopyTimeItemID int NULL,
		[Time Seconds] int NOT NULL DEFAULT(0),
		[Holiday Seconds] int NOT NULL DEFAULT(0),
		[OT Seconds] int NOT NULL DEFAULT(0),
		Flags int NOT NULL DEFAULT(0),
		[Actual In] datetime NULL,
		[Actual Out] datetime NULL,
		[Base Seconds] int NOT NULL DEFAULT(0),
		[X2 Seconds] int NOT NULL DEFAULT(0),
		
		_CompTypeID int NULL,
		_Rate smallmoney
	)

	-- DECLARE @comp_seconds_remaining int
	-- TempX.X = comp_secnds_remaing
	-- UPDATE dbo.TempX SET X=0 WHERE BatchID=@batch_id

	EXEC dbo.spEmployeeTimeRoundAndCalcOT @batch_id, 0, @week_start_day, @last_week_day, null, null, @authorized OUT, null /*@pending_type_id OUT*/, null /*@denied_type_id OUT*/

	UPDATE ET
	SET _CompTypeID = CT.TypeID, _Rate = TT.[PayRateM]
	FROM #EMPLOYEE_TIME_ROUNDED ET
	INNER JOIN dbo.TimeType TT ON ET.CalculatedTypeID = TT.TypeID
	INNER JOIN #CompType CT ON CT.[Comp Rate] = TT.[PayRateM]


	UPDATE ET
	SET _CompTypeID = (SELECT TypeID FROM #CompType WHERE [Comp Rate] = 1), _Rate = 1
	FROM #EMPLOYEE_TIME_ROUNDED ET
	WHERE _CompTypeID IS NULL

	-- Breaks credits up by week
	WHILE @week_start_day <= @last_week_day
	BEGIN
		SET @week_stop_day = @week_start_day + 6
		EXEC spEmployeeTimeChangeOTtoComp2 @batch_id, @week_start_day, @week_stop_day, @s out
		SELECT @seconds_changed = @seconds_changed + @s, @week_start_day = @week_start_day + 7
	END
END

DELETE dbo.TempX WHERE BatchID=@batch_id OR DATEDIFF(hour,Created,GETDATE()) > 1
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spEmployeeTimeChangeOTtoComp2', 0
GO
ALTER PROC dbo.spEmployeeTimeChangeOTtoComp2
	@batch_id int,
	@start_day int,
	@stop_day int,
	@seconds_changed int out
AS
UPDATE X SET X.X = ISNULL((
	SELECT SUM([Out Seconds] - [In Seconds])
	FROM #EMPLOYEE_TIME_ROUNDED ET
	INNER JOIN dbo.TimeType TT ON X.[ID]=ET.EmployeeID AND ET.CalculatedTypeID = TT.TypeID AND TT.CompLeaveTypeID IS NULL AND ET.[In day past 1900] BETWEEN @start_day AND @stop_day
), 0) -(@stop_day - @start_day + 1) / 7 * 40 * 3600
FROM dbo.TempX X WHERE BatchID=@batch_id

-- Consider comp eligible leave
UPDATE X SET X.X = X.X - Seconds FROM dbo.TempX X
INNER JOIN dbo.EmployeeLeaveEarned E ON X.BatchID=@batch_id AND E.EmployeeID=X.[ID] AND E.[Day past 1900] BETWEEN @start_day AND @stop_day AND E.Seconds < 0
INNER JOIN dbo.LeaveType T ON E.TypeID=T.TypeID AND T.[Comp Eligible]=1

UPDATE X SET X.X = X.X + I.Seconds FROM dbo.TempX X
INNER JOIN dbo.EmployeeLeaveUsed U ON X.BatchID=@batch_id AND X.[ID]=U.EmployeeID
INNER JOIN dbo.EmployeeLeaveUsedItem I ON U.LeaveID=I.LeaveID AND I.[Day past 1900] BETWEEN @start_day AND @stop_day AND I.Seconds > 0
INNER JOIN dbo.LeaveType T ON I.TypeID = T.TypeID AND T.[Comp Eligible]=1

SELECT @seconds_changed = ISNULL(SUM(X.X), 0) FROM dbo.TempX X WHERE BatchID=@batch_id AND X.X > 0

-- Return immediately if no eligible comp
IF @seconds_changed = 0 RETURN

DECLARE @comp_type_id int, @in_seconds int, @out_seconds int, @original_item_id int, @copy_item_id int, @original_type_id int, @day int, @rate smallmoney, @regular bit

DECLARE time_entries_cursor CURSOR LOCAL FORWARD_ONLY STATIC FOR 
SELECT EmployeeID, _CompTypeID, [In Day past 1900], [In Seconds], [Out Seconds], OriginalTimeItemID, CopyTimeItemID, OriginalTypeID, _Rate, Regular
FROM #EMPLOYEE_TIME_ROUNDED WHERE OriginalTimeItemID IS NOT NULL
UNION
SELECT EmployeeID, _CompTypeID, [In Day past 1900], [In Seconds], [Out Seconds], OriginalTimeItemID, CopyTimeItemID, OriginalTypeID, _Rate, Regular
FROM #EMPLOYEE_TIME_ROUNDED WHERE OriginalTimeItemID IS NULL 
ORDER BY _Rate DESC, Regular DESC, [In Day past 1900] DESC, [Out Seconds] DESC

DECLARE @employee_id int

BEGIN TRAN

OPEN time_entries_cursor
FETCH time_entries_cursor INTO @employee_id, @comp_type_id, @day, @in_seconds, @out_seconds, @original_item_id, @copy_item_id, @original_type_id, @rate, @regular
WHILE @@FETCH_STATUS = 0
BEGIN
	DECLARE @cmp_seconds_remaining int
	SELECT @cmp_seconds_remaining = X FROM dbo.TempX WHERE BatchID=@batch_id AND [ID]=@employee_id
	IF @cmp_seconds_remaining > 0
	BEGIN
		SET @cmp_seconds_remaining = @cmp_seconds_remaining + @in_seconds - @out_seconds
		UPDATE dbo.TempX SET X = @cmp_seconds_remaining WHERE BatchID=@batch_id AND [ID]=@employee_id
		
		DECLARE @in_time datetime
		SELECT @in_time = DATEADD(second, @in_seconds, DATEADD(d,0,@day))
		
		-- Virtual entry
		IF @original_item_id IS NULL
		BEGIN

		-- Case 1: OT entry is whole and ot_seconds didn't go negative
		--IF @comp_seconds_remaining >= 0
		--BEGIN
			-- Create new entry with comp type
			INSERT dbo.EmployeeTime(EmployeeID, [In], Seconds, TypeID, [Manager Comment], ProjectID, TaskID, StatusID, [Employee Comment], [Pay Rate], [Billing Rate], [Odometer Start], [Odometer Stop], [Created Day past 1900], [Fixed Billing], [Fixed Pay], SourceIn, SourceOut, [PPE day past 1900], [GMT+Hours], [Time Flags])
			SELECT EmployeeID, @in_time, @out_seconds - @in_seconds, @comp_type_id, 'Changed to comp (auto)', ProjectID, TaskID, StatusID, [Employee Comment], [Pay Rate], [Billing Rate], [Odometer Start], [Odometer Stop], [Created Day past 1900], [Fixed Billing], [Fixed Pay], SourceIn, SourceOut, [PPE day past 1900], [GMT+Hours], [Time Flags]
			FROM dbo.EmployeeTime WHERE ItemID=@copy_item_id
			
			-- Change time out on original entry (out = @in_seconds)
			UPDATE dbo.EmployeeTime SET Seconds = Seconds - @out_seconds + @in_seconds WHERE ItemID = @copy_item_id
		--END
		-- Case 3: OT entry is whole and ot_seconds went negative
		--ELSE --IF @original_item_id IS NOT NULL AND @comp_seconds_remaining <= 0
		--BEGIN		
			-- Create new entry with comp type
		--	INSERT dbo.EmployeeTime(EmployeeID, [In], Seconds, TypeID, [Manager Comment], ProjectID, TaskID, StatusID, [Employee Comment], [Pay Rate], [Billing Rate], [Odometer Start], [Odometer Stop], [Created Day past 1900], [Fixed Billing], [Fixed Pay], SourceIn, SourceOut, [PPE day past 1900], [GMT+Hours], [Time Flags])
		--	SELECT EmployeeID, DATEADD(second,  -@comp_seconds_remaining, [In]), Seconds+@comp_seconds_remaining, @comp_type_id, 'Changed to comp (split)', ProjectID, TaskID, StatusID, [Employee Comment], [Pay Rate], [Billing Rate], [Odometer Start], [Odometer Stop], [Created Day past 1900], [Fixed Billing], [Fixed Pay], SourceIn, SourceOut, [PPE day past 1900], [GMT+Hours], [Time Flags]
		--	FROM dbo.EmployeeTime WHERE ItemID=@original_item_id
			
			-- Change time out on original entry (out = @in_seconds)
		--	UPDATE dbo.EmployeeTime SET Seconds = @out_seconds - @in_seconds WHERE ItemID = @copy_item_id
		--END
		
		END
		ELSE
		-- Physical entry
		BEGIN
			-- Case 2: OT entry is whole and ot_seconds didn't go negative
			IF @cmp_seconds_remaining >= 0
			BEGIN
				UPDATE dbo.EmployeeTime 
				SET [Manager Comment] = 'Changed to comp', TypeID = @comp_type_id
				WHERE ItemID = @original_item_id
			END
			-- Case 3: OT entry is whole and ot_seconds went negative
			ELSE --IF @original_item_id IS NOT NULL AND @comp_seconds_remaining <= 0
			BEGIN		
				-- Create new entry with comp type
				INSERT dbo.EmployeeTime(EmployeeID, [In], Seconds, TypeID, [Manager Comment], ProjectID, TaskID, StatusID, [Employee Comment], [Pay Rate], [Billing Rate], [Odometer Start], [Odometer Stop], [Created Day past 1900], [Fixed Billing], [Fixed Pay], SourceIn, SourceOut, [PPE day past 1900], [GMT+Hours], [Time Flags])
				SELECT EmployeeID, DATEADD(second,  -@cmp_seconds_remaining, [In]), Seconds+@cmp_seconds_remaining, @comp_type_id, 'Changed to comp (split)', ProjectID, TaskID, StatusID, [Employee Comment], [Pay Rate], [Billing Rate], [Odometer Start], [Odometer Stop], [Created Day past 1900], [Fixed Billing], [Fixed Pay], SourceIn, SourceOut, [PPE day past 1900], [GMT+Hours], [Time Flags]
				FROM dbo.EmployeeTime WHERE ItemID=@original_item_id
				
				-- Change time out on original entry (out = @in_seconds)
				UPDATE ET SET Seconds = -@cmp_seconds_remaining
				FROM dbo.EmployeeTime ET WHERE ET.ItemID = @original_item_id
			END
		END
	END

	FETCH time_entries_cursor INTO @employee_id, @comp_type_id, @day, @in_seconds, @out_seconds, @original_item_id, @copy_item_id, @original_type_id, @rate, @regular
END

CLOSE time_entries_cursor
DEALLOCATE time_entries_cursor

COMMIT TRAN
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spLeaveTypeGetTypeID'
GO
ALTER PROC dbo.spLeaveTypeGetTypeID
	@type varchar(50),
	@advanced bit,
	@type_id int out,
	@advanced_type_mask int = 0 out,
	@time_type_id int = NULL out
AS
SELECT @type = RTRIM(LTRIM(@type)), @type_id=NULL, @advanced_type_mask=0, @time_type_id=NULL

SELECT @type_id = LeaveTypeID, @advanced_type_mask = [Advanced Type Mask], @time_type_id = TimeTypeID FROM dbo.LeaveTypeExternal WHERE [Code] = @type
IF @@ROWCOUNT = 0
BEGIN
	IF ISNUMERIC(@type)=1 SELECT @type_id=TypeID FROM LeaveType WHERE TypeID=CAST(@type AS int) AND (@advanced IS NULL OR Advanced=@advanced)
	IF @type_id IS NULL SELECT @type_id=TypeID FROM LeaveType WHERE Abbreviation=@type AND (@advanced IS NULL OR Advanced=@advanced)
	IF @type_id IS NULL SELECT @type_id=TypeID FROM LeaveType WHERE Type=@type AND (@advanced IS NULL OR Advanced=@advanced)
END
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spEmployeeLeaveEarnSuspend'
GO
ALTER PROC dbo.spEmployeeLeaveEarnSuspend
	@employee_id int,
	@type_id int,
	@full_start datetime,
	@full_stop datetime,
	@partial_start datetime,
	@partial_stop datetime,
	@eligible_start datetime,
	@credit_day int,
	@credit_seconds int,
	@rounding_seconds int,
	@note varchar(50),
	@ineligible_seconds int out
--WITH EXECUTE AS 'dbo'
AS
IF @partial_start < @full_start SET @partial_start = @full_start
IF @partial_stop > @full_stop SET @partial_stop = @full_stop

DECLARE @adjusted_note varchar(50), @partial_start_day int, @partial_stop_day int, @suspend_days numeric(19,4), @adjusted_credit int
SELECT @partial_start_day = DATEDIFF(d,0,@partial_start), @partial_stop_day = DATEDIFF(d,0,@partial_stop), @adjusted_note = @note

SELECT @suspend_days = ISNULL(SUM(
	CASE WHEN ELP.[Seconds in Day] = 0 OR ELP.FTE = 0 THEN 0
	ELSE 1.0 * I.Seconds / ELP.[Seconds in Day] / ISNULL(ELP.FTE, 1.0) END
), 0)
FROM dbo.EmployeeLeaveUsedItem I 
INNER JOIN dbo.EmployeeLeaveUsed U ON U.EmployeeID=@employee_id AND U.LeaveID=I.LeaveID AND  I.[Day past 1900] BETWEEN @partial_start_day AND @partial_stop_day
INNER JOIN dbo.LeaveType T ON I.TypeID=T.TypeID AND T.[Suspend Accrual]=1
LEFT JOIN dbo.EmployeeLeavePlan ELP ON U.EmployeeID = ELP.EmployeeID AND I.[Day past 1900] >= ELP.[Start Day past 1900] AND (ELP.[Stop Day past 1900] IS NULL OR I.[Day past 1900] <= ELP.[Stop Day past 1900])


SELECT @suspend_days = @suspend_days - ISNULL(SUM(1.0 * E.Seconds / ELP.[Seconds in Day] / ISNULL(ELP.FTE, 1.0)), 0)
FROM dbo.EmployeeLeaveEarned E  
INNER JOIN dbo.LeaveType T ON E.Seconds < 0 AND E.[Auto] = 0 AND E.EmployeeID=@employee_id AND E.[Day past 1900] BETWEEN @partial_start_day AND @partial_stop_day AND E.TypeID=T.TypeID AND T.[Suspend Accrual]=1
LEFT JOIN dbo.EmployeeLeavePlan ELP ON E.EmployeeID = ELP.EmployeeID AND E.[Day past 1900] >= ELP.[Start Day past 1900] AND (ELP.[Stop Day past 1900] IS NULL OR E.[Day past 1900] <= ELP.[Stop Day past 1900])

IF @suspend_days <= 0 AND @full_start = @partial_start AND @full_stop = @partial_stop SET @adjusted_credit = @credit_seconds
ELSE
BEGIN
	DECLARE @full_work_days numeric(34,12), @partial_work_days numeric(34,12)
	
	EXEC dbo.spAdminGetWorkDays @full_start, @full_stop, @full_work_days out
	EXEC dbo.spAdminGetWorkDays @partial_start, @partial_stop, @partial_work_days out
	
	DECLARE @rate numeric(34,12)
	
	-- EXECUTE AS USER = 'dbo'
	
		IF OBJECT_ID('dbo.fnCustom_GetFullWorkDaysForLeaveProrating') IS NOT NULL
		BEGIN
			EXEC sp_executesql N'SELECT @full_work_days=dbo.fnCustom_GetFullWorkDaysForLeaveProrating(@full_work_days)', N'@full_work_days numeric(34,12) OUT', @full_work_days=@full_work_days OUT
		END

		IF OBJECT_ID('dbo.fnCustom_GetPartialWorkDaysForLeaveProrating') IS NOT NULL
		BEGIN
			EXEC sp_executesql N'SELECT @partial_work_days=dbo.fnCustom_GetPartialWorkDaysForLeaveProrating(@partial_work_days)', N'@partial_work_days numeric(34,12) OUT', @partial_work_days=@partial_work_days  OUT
		END
	
	-- REVERT
	
	SET @rate = (@partial_work_days - @suspend_days) / @full_work_days
	
	SET @adjusted_credit = CASE WHEN @rate < 0 THEN 0 WHEN @rate >=1 THEN @credit_seconds ELSE @credit_seconds * @rate END
	SET @rate = 1.0 / @rounding_seconds
	IF @rounding_seconds <> 1 SET @adjusted_credit = ROUND(@adjusted_credit * @rate, 0) * @rounding_seconds -- round to nearest .25 hours (900 seconds)

	IF @suspend_days > 0 SET @adjusted_note = 'Adjusted accrual (' + CAST(CAST(@suspend_days AS numeric(19,1)) AS varchar(50)) + ' days no accrual)'

	ELSE IF @credit_seconds <> @adjusted_credit SELECT @adjusted_note = 'Prorated accrual'
END

IF @credit_day < DATEDIFF(d,0,@eligible_start)
BEGIN
	SET @ineligible_seconds = @ineligible_seconds + @adjusted_credit
END
ELSE IF @ineligible_seconds > 0
BEGIN
	INSERT dbo.EmployeeLeaveEarned(EmployeeID, TypeID, Seconds, [Day past 1900], [PPE Day past 1900], Note, [Auto]) 
	VALUES (@employee_id, @type_id, @ineligible_seconds + @adjusted_credit, @credit_day, @credit_day, @adjusted_note, 1)
	SET @ineligible_seconds = 0
END
ELSE IF @adjusted_credit > 0
BEGIN
	INSERT dbo.EmployeeLeaveEarned(EmployeeID, TypeID, Seconds, [Day past 1900], [PPE Day past 1900], Note, [Auto]) 
	VALUES (@employee_id, @type_id, @adjusted_credit, @credit_day, @credit_day, @adjusted_note, 1)
END
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spVisaStatusDelete'
GO
ALTER PROC dbo.spVisaStatusDelete @status_id int AS DELETE VisaStatus WHERE StatusID = @status_id
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spVisaStatusInsert'
GO
ALTER PROC dbo.spVisaStatusInsert @status varchar(50), @status_id int OUT AS INSERT VisaStatus(Status) VALUES(@status) SELECT @status_id = SCOPE_IDENTITY()
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spVisaStatusUpdate'
GO
ALTER PROC dbo.spVisaStatusUpdate @status varchar(50), @status_id int AS UPDATE VisaStatus SET Status = @status WHERE StatusID = @status_id
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spVisaStatusList'
GO
ALTER PROC dbo.spVisaStatusList @status_id int = NULL AS
SET NOCOUNT ON SELECT StatusID, [Status] FROM VisaStatus WHERE @status_id IS NULL OR StatusID=@status_id ORDER BY Status
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spEmployeeGetNextNumber'
GO
-- Gets the next employee number based on the number for the last entered employee
-- Ex)  If the last employee number was 13A002 then the next number would be 13A003
ALTER PROC dbo.spEmployeeGetNextNumber
	@number varchar(50) out, @prefix varchar(50) = ''
AS
DECLARE @last_number varchar(50)
DECLARE @pos int
DECLARE @digits varchar(50)
DECLARE @c char(1)
DECLARE @digit bit
DECLARE @pattern varchar(50)

SET NOCOUNT ON

SELECT @number = '', @pattern = @prefix + '%'
SELECT TOP 1 @last_number =[Employee Number] FROM Employee 
WHERE LEN([Employee Number]) > 0 AND [Employee Number] LIKE @pattern
ORDER BY EmployeeNumberNumeric DESC, [Employee Number] DESC


IF @@ROWCOUNT = 1
BEGIN
	SELECT @digits = '', @pos = LEN(@last_number), @digit = 1

	WHILE @pos > 0 AND @digit = 1
	BEGIN
		SELECT @c = SUBSTRING(@last_number, @pos, 1)
		SELECT @digit = CASE WHEN @c BETWEEN '0' AND '9' THEN 1 ELSE 0 END

		IF @digit = 1 SELECT @pos = @pos - 1, @digits = @digits + @c
	END

	IF LEN(@digits) > 0 
	BEGIN
		SELECT @number = SUBSTRING(@last_number, 1, @pos), @pos = LEN(@digits), @digits = CAST(REVERSE(@digits) AS bigint) + 1
		SELECT @pos = @pos - LEN(@digits)

		WHILE @pos > 0 SELECT @digits = '0' + @digits, @pos = @pos - 1

		SELECT @number = @number + @digits
	END
END

IF EXISTS(SELECT * FROM Employee WHERE [Employee Number] = @number) SET @number = ''
GO
IF OBJECT_id('dbo.spPersonListSecondaryText') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spPersonListSecondaryText AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spPersonListSecondaryText TO public'
END
GO
ALTER PROC dbo.spPersonListSecondaryText
	@batch_id int
AS
DECLARE @permission_batch_id int

SET NOCOUNT ON

SELECT @permission_batch_id = RAND() * 2147483647

SELECT DISTINCT AttributeID = PermissionAttributeID INTO #A FROM dbo.CustomField

INSERT dbo.TempPersonPermission(BatchID,PersonID,AttributeID)
SELECT @permission_batch_id,X.[ID],#A.AttributeID
FROM dbo.TempX X
CROSS JOIN #A
WHERE X.BatchID=@batch_id

EXEC dbo.spPermissionGetOnPeopleForCurrentUser @permission_batch_id

SELECT TypeID=1, PF.FieldID, Permission=X.[Permission Mask], Value = CASE WHEN (X.[Permission Mask] & 1)=1 THEN PF.Value ELSE '' END
FROM dbo.PersonCustomField PF
INNER JOIN dbo.CustomField F ON PF.FieldID=F.FieldID
INNER JOIN dbo.TempPersonPermission X ON X.BatchID=@permission_batch_id AND X.PersonID=PF.PersonID AND X.AttributeID=F.PermissionAttributeID

DELETE dbo.TempPersonPermission WHERE BatchID=@permission_batch_id OR DATEDIFF(hour,[Created],GETDATE())> 1
GO
IF OBJECT_id('dbo.spPersonCustomFieldUpdate') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spPersonCustomFieldUpdate AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spPersonCustomFieldUpdate TO public'
END
GO
ALTER PROC dbo.spPersonCustomFieldUpdate
	@person_id int,	
	@field_id int,
	@value sql_variant
AS
DECLARE @authorized bit, @attribute_id int

SELECT @attribute_id = PermissionAttributeID FROM dbo.CustomField WHERE FieldID=@field_id
EXEC dbo.spPermissionInsureForCurrentUserOnPerson @person_id, @attribute_id, 2, @authorized out

IF @authorized = 1
BEGIN
	DECLARE @type_id int
	SELECT @type_id=TypeID FROM CustomField WHERE FieldID=@field_id

	IF @type_id=1 UPDATE dbo.PersonCustomField SET Value = CAST(@value AS int) WHERE PersonID = @person_id AND FieldID = @field_id
	ELSE IF @type_id=2
	BEGIN
		DECLARE @t varchar(50)
		SET @t = CAST(@value AS varchar(50))
		IF @t LIKE '%,%%%' SET @t = REPLACE(CAST(@t AS varchar(50)), ',', '')
		UPDATE dbo.PersonCustomField SET Value = CAST(@t AS decimal(29,6)) WHERE PersonID = @person_id AND FieldID = @field_id
	END
	ELSE IF @type_id=3
	BEGIN
		IF @value IS NULL SET @value = 0
		UPDATE dbo.PersonCustomField SET Value = CAST(@value AS bit) WHERE PersonID = @person_id AND FieldID = @field_id
	END
	ELSE IF @type_id=5 UPDATE dbo.PersonCustomField SET Value = CAST(CAST(@value AS char(11)) AS datetime) WHERE PersonID = @person_id AND FieldID = @field_id
	ELSE UPDATE dbo.PersonCustomField SET Value = CAST(@value AS varchar(4000)) WHERE PersonID = @person_id AND FieldID = @field_id

	
END
GO
IF OBJECT_id('dbo.spCustomFieldUpdate') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spCustomFieldUpdate AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spCustomFieldUpdate TO public'
END
GO
ALTER PROC dbo.spCustomFieldUpdate
	@field varchar(50),
	@textarea bit=NULL,
	@rolemask int,
	@field_id int OUT,
	@type_id int=167,
	@location_id int=0,
	@attributes int=0,
	@copy_field_id int = NULL,
	@attribute_id int = NULL
AS
IF @textarea IS NOT NULL AND @type_id=167 SELECT @attributes=@textarea
DECLARE @error int, @old_type_id int
SET @error = 0
SELECT @old_type_id = TypeID FROM CustomField WHERE FieldID=@field_id

BEGIN TRAN

IF @old_type_id <> @type_id
BEGIN
	IF @type_id=1 UPDATE PersonCustomField SET Value=CAST([Value] AS int) FROM PersonCustomField WHERE FieldID=@field_id
	ELSE IF @type_id=2 UPDATE PersonCustomField SET Value=CAST([Value] AS decimal(29,6)) FROM PersonCustomField WHERE FieldID=@field_id
	ELSE IF @type_id=3 UPDATE PersonCustomField SET Value=CAST([Value] AS bit) FROM PersonCustomField WHERE FieldID=@field_id
	ELSE IF @type_id=5 UPDATE PersonCustomField SET Value=CAST([Value] AS datetime) FROM PersonCustomField WHERE FieldID=@field_id
	ELSE UPDATE PersonCustomField SET Value=CAST([Value] AS varchar(4000)) FROM PersonCustomField WHERE FieldID=@field_id
	SET @error=@@ERROR

	IF @error = 0
	BEGIN
		DECLARE @type varchar(50), @colValue varchar(50), @sql nvarchar(4000)
		SELECT @type = dbo.fnGetTypeNameForCustomFieldType(@type_id)

		SELECT @colValue = 'CF_' + CAST(@field_id AS varchar(50)) + N'_XValue'

		SET @sql = 'ALTER TABLE dbo.PersonCustomFieldFlat ALTER COLUMN ' + @colValue + ' ' + @type + ' NULL'
		EXEC dbo.spExecSQLAsDBO @sql
		SET @error=@@ERROR
	END
END

IF @error=0
BEGIN
	UPDATE CustomField SET Field=@field, Attributes=@attributes, [Role Mask]=@rolemask, TypeID=@type_id, LocationID=@location_id, CopyItemsFromFieldID=@copy_field_id, PermissionAttributeID = CASE WHEN @attribute_id IS NULL THEN PermissionAttributeID ELSE @attribute_id END WHERE FieldID=@field_id
	SET @error=@@ERROR
END

IF @error = 0 COMMIT TRAN
ELSE IF @@TRANCOUNT>0 ROLLBACK TRAN
GO
IF OBJECT_id('dbo.spCustomFieldInsert') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spCustomFieldInsert AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spCustomFieldInsert TO public'
END
GO
ALTER PROC dbo.spCustomFieldInsert
	@field varchar(50),
	@textarea bit=NULL,
	@rolemask int = 0x7FFFFFFF,
	@field_id int = 0 OUT,
	@type_id int=167,
	@location_id int=0,
	@attributes int=0,
	@copy_field_id int=NULL,
	@attribute_id int=4194304
AS
IF @textarea IS NOT NULL SET @attributes=@textarea

DECLARE @order int

SELECT @order = ISNULL(MAX([Order]), 0) + 1 FROM CustomField WHERE FieldID=@field_id
INSERT CustomField(Field, Attributes, [Role Mask], TypeID, LocationID, [Order], CopyItemsFromFieldID,PermissionAttributeID)
VALUES(@field,@attributes,@rolemask,@type_id,@location_id,@order,@copy_field_id,@attribute_id)

SELECT @field_id = SCOPE_IDENTITY()
GO
IF OBJECT_id('dbo.spEmployeeBenefitEstimate') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEmployeeBenefitEstimate AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spEmployeeBenefitEstimate TO public'
END
GO
ALTER PROC dbo.spEmployeeBenefitEstimate
	@start_day int, @stop_day int, @benefit_id int, @authorized bit out
AS
DECLARE @days_in_period numeric(9,3)

SELECT @days_in_period = P.Seconds / 20571.00
FROM dbo.Constant C
INNER JOIN dbo.Period P ON C.BenefitPremiumPeriodID = P.PeriodID

SELECT 
EmployeeID,
EmployeeBenefitID,
[Start] = CASE
	WHEN [First Enrolled Day past 1900] IS NULL THEN [Last Enrolled Day past 1900]
	WHEN [Last Enrolled Day past 1900] IS NULL THEN [First Enrolled Day past 1900]
	WHEN [First Enrolled Day past 1900] < [Last Enrolled Day past 1900] THEN [First Enrolled Day past 1900]
	ELSE [Last Enrolled Day past 1900]
END, [Stop] = NULL, [Days] = 0, [Benefit Periods] = 0
INTO #EB
FROM dbo.EmployeeBenefit EB 
WHERE @benefit_id IS NULL OR BenefitID = @benefit_id

DELETE #EB WHERE dbo.fnPermissionGetOnPersonForCurrentUser(EmployeeID, 536870912) & 1 = 0
SELECT @authorized = CASE WHEN @@ROWCOUNT > 0 THEN 1 ELSE 0 END

UPDATE #EB SET 
[Start] = CASE
	WHEN #EB.[Start] IS NULL THEN NULL
	WHEN #EB.[Start] > @stop_day THEN NULL
	WHEN #EB.[Start] < @start_day THEN @start_day
	ELSE #EB.[Start]
END FROM #EB

UPDATE #EB SET 
[Stop] = CASE
	WHEN [Start] IS NULL THEN NULL
	WHEN EB.[Declined Day past 1900] IS NULL THEN @stop_day
	WHEN EB.[Declined Day past 1900] < @start_day THEN NULL
	WHEN EB.[Declined Day past 1900] > @stop_day THEN @stop_day
	ELSE EB.[Declined Day past 1900]
END
FROM #EB
INNER JOIN dbo.EmployeeBenefit EB ON #EB.EmployeeBenefitID = EB.EmployeeBenefitID

UPDATE #EB SET [Days] = ISNULL(#EB.[Stop] - #EB.[Start] + 1, 0)
UPDATE #EB SET [Benefit Periods] = ([Days] + 3) / @days_in_period 

SELECT
[Employee] = P.[List As],
B.Benefit,
E.[Employee Number],
D.Department,
V.Division,
[Start] = dbo.GetDateFromDaysPast1900(#EB.[Start]),
[Stop] = dbo.GetDateFromDaysPast1900(#EB.[Stop]),
#EB.[Days],
#EB.[Benefit Periods],
[Employee Premium] = EB.[Employee Premium] * #EB.[Benefit Periods],
[Employer Premium] = EB.[Employer Premium] * #EB.[Benefit Periods]
FROM #EB
INNER JOIN dbo.EmployeeBenefit EB ON #EB.EmployeeBenefitID = EB.EmployeeBenefitID AND #EB.[Days] > 0
INNER JOIN dbo.Employee E ON EB.EmployeeID = E.EmployeeID
INNER JOIN dbo.vwPersonListAs P ON E.EmployeeID = P.PersonID
INNER JOIN dbo.Department D ON D.DepartmentID = E.DepartmentID
INNER JOIN dbo.Division V ON V.DivisionID = E.DivisionID
INNER JOIN dbo.Benefit B ON EB.BenefitID = B.BenefitID
ORDER BY P.[List As], B.Benefit
GO
IF OBJECT_id('dbo.spTempXYZInsert') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spTempXYZInsert AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spTempXYZInsert TO public'
END
GO
ALTER PROC dbo.spTempXYZInsert @batch_id int, @id int, @x int, @y int = NULL, @z int = NULL
AS INSERT TempXYZ(BatchID, [ID], X, Y, Z) VALUES(@batch_id, @id, @x, @y, @z)
GO
IF OBJECT_ID('dbo.spEmployeeTimeCalculateFilterInverse') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEmployeeTimeCalculateFilterInverse AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spEmployeeTimeCalculateFilterInverse TO public'
END
GO
-- Returns @rows rows that correspond to the payroll period stored in Constant.CurrentPayrollPeriodID
ALTER PROC dbo.spEmployeeTimeCalculateFilterInverse
	@date datetime,
	@rows int,
	@period_id int = NULL
AS
SET NOCOUNT ON

DECLARE @error_message varchar(100), @start datetime, @next datetime, @rows_original int



--DECLARE @period_id int
IF @period_id IS NULL SELECT @period_id = CurrentPayrollPeriodID FROM dbo.Constant
SELECT @rows_original = @rows, @error_message = 'spEmployeeTimeCalculateFilterInverse does not handle PeriodID ' + CAST(@period_id AS varchar(100)) + '.'

-- Buck
IF EXISTS(SELECT * FROM PayrollPeriodException) SET @rows = @rows + 1

-- Trims seconds\minutes\ms from @date
SELECT @date = CAST(@date as char(11))
	
DECLARE @temp TABLE (StartDate datetime, StopDate datetime)

-- Weekly and Biweekly **********************************************************************
IF (@period_id & 192) != 0
BEGIN
	DECLARE @step int
	
	DECLARE @weekday int -- Sun = 1, M = 2, T = 3, W = 4, Th = 5, F= 6, Sat = 7
	DECLARE @payday int -- weekday is current week day. payday is week day that we get paid.

	SELECT @step = CASE WHEN (@period_id & 64) = 64 THEN 2 ELSE 1 END
	SELECT @weekday = DATEPART(dw, @date)
	
	

	-- Maps period_id to a payday (Sun = 1)
	SELECT @payday = CASE WHEN @period_id IN (200768, 215104, 258176) THEN 1
		WHEN @period_id IN (202816, 217152, 260224) THEN 2
		WHEN @period_id IN (204864, 219200, 262272) THEN 3
		WHEN @period_id IN (206912, 221248, 264320) THEN 4
		WHEN @period_id IN (208960, 223296, 266368) THEN 5
		WHEN @period_id IN (211008, 225344, 268416) THEN 6
		WHEN @period_id IN (213056, 227392, 270464) THEN 7 
	END

	IF @@ROWCOUNT = 0 RAISERROR(@error_message, 16, 1)


	DECLARE @periods int, @wk0 datetime

	-- Shift for 1st biweekly set of periods
	If (@period_id & 64) != 0
	BEGIN
		SELECT @wk0 = CASE WHEN @period_id >= 215104 THEN '01/04/04' ELSE '01/11/04' END
		SELECT @periods = DATEDIFF(day, @wk0, @date) / 14
		SET @start = DATEADD(d, @periods * 14 + @payday, @wk0)
		IF @start > @date SELECT @start = DATEADD(wk, -2, @start)
	END
	ELSE
	BEGIN
		DECLARE @lastsat datetime
		SELECT @lastsat = DATEADD(d, -@weekday, @date)
		SELECT @start = DATEADD(d, CASE WHEN @weekday > @payday THEN @payday + 1 ELSE @payday - 6 END, @lastsat)
	END

	WHILE @rows > 0
	BEGIN
		SELECT @next = DATEADD(wk, @step, @start)
		INSERT INTO @temp VALUES (@start, DATEADD(d, -1, @next))
		SELECT @start = @next, @rows = @rows - 1
	END
END
ELSE 
BEGIN
	DECLARE @month int
	DECLARE @dayOfMonth int
	DECLARE @year int
	DECLARE @yesterday datetime, @tomorrow datetime
	DECLARE @yearless int

	SELECT @year = YEAR(@date), @month = DATEPART(m, @date), @dayOfMonth = DATEPART(d, @date)
	SELECT @tomorrow = DATEADD(d, 1, @date), @yesterday = DATEADD(d, -1, @date), @yearless = @month * 100 + @dayOfMonth

	-- Bimonthly **********************************************************************
	IF @period_id & 8 = 8
	BEGIN
		-- Bimonthly ending 1/1, 3/1
		IF @period_id = 90120
		BEGIN
			IF @dayOfMonth = 1 AND @month % 2 = 1 SELECT @start = DATEADD(m, -2, @tomorrow)
			ELSE IF @month % 2 = 0 SELECT @start = dbo.GetDateFROMMDY(@month - 1, 2, @year)
			ELSE SELECT @start = dbo.GetDateFromMDY(@month, 2, @year)
		END

		-- Bimonthly ending 2/28|29, 4/30
		ELSE IF @period_id = 92168
		BEGIN
			IF @month >= 11 SELECT @start = dbo.GetDateFromMDY(11, 1, @year)
			ELSE SELECT @start = dbo.GetDateFromMDY(@month - 1 + @month % 2, 1, @year)
		
		END
		ELSE RAISERROR(@error_message, 16, 1)

		WHILE @rows > 0
		BEGIN
			SELECT @next = DATEADD(m, 2, @start)
			INSERT INTO @temp VALUES (@start, DATEADD(d, -1, @next))
			SELECT @start = @next, @rows = @rows - 1
		END
	END

	-- Monthly **********************************************************************
	ELSE IF @period_id & 16 = 16
	BEGIN
		-- Ends First Day of Each Month
		IF @period_id = 126992
		BEGIN
			IF @yearless = 101 SELECT @start = dbo.GetDateFromMDY(12, 2, @year - 1)
			ELSE IF @dayOfMonth = 1 SELECt @start = dbo.GetDateFromMDY(@month - 1, 2, @year)
			ELSE SELECT @start = dbo.GetDateFromMDY(@month, 2, @year)
		END
		-- Ends Last Day of Each Month
		ELSE IF @period_id = 129040
		BEGIN
			SELECT @start = dbo.GetDateFromMDY(@month, 1, @year)
		END

		-- Ends 28th of each month
		ELSE IF @period_id = 131088
		BEGIN
			IF @dayOfMonth >= 29 SELECT @start = dbo.GetDateFromMDY(@month, 29, @year)
			ELSE IF @month = 1 SELECT @start = dbo.GetDateFromMDY(12, 29, @year - 1)
			ELSE SELECT @start = dbo.GetDateFromMDY(@month - 1, 29, @year) 
		END

		-- Ends 15th of each month
		ELSE IF @period_id = 141328
		BEGIN
			IF @dayOfMonth >= 16 SELECT @start = dbo.GetDateFromMDY(@month, 16, @year)
			ELSE IF @month = 1 SELECT @start = dbo.GetDateFromMDY(12, 16, @year - 1)
			ELSE SELECT @start = dbo.GetDateFromMDY(@month - 1, 16, @year) 
		END

		-- Ends 16h of each month
		ELSE IF @period_id = 143376
		BEGIN
			IF @dayOfMonth >= 17 SELECT @start = dbo.GetDateFromMDY(@month, 17, @year)
			ELSE IF @month = 1 SELECT @start = dbo.GetDateFromMDY(12, 17, @year - 1)
			ELSE SELECT @start = dbo.GetDateFromMDY(@month - 1, 17, @year) 
		END

		-- Ends 30th of each month
		ELSE IF @period_id = 145424
		BEGIN
			IF @dayOfMonth >= 31 SELECT @start = dbo.GetDateFromMDY(@month, 31, @year)
			ELSE IF @month = 1 SELECT @start = dbo.GetDateFromMDY(12, 31, @year - 1)
			ELSE SELECT @start = dbo.GetDateFromMDY(@month, 0, @year) -- Last day of last month
		END


		ELSE RAISERROR(@error_message, 16, 1)
		
		WHILE @rows > 0
		BEGIN
			SELECT @next = DATEADD(m, 1, @start)
			INSERT INTO @temp VALUES (@start, DATEADD(d, -1, @next))
			SELECT @start = @next, @rows = @rows - 1
		END
	END

	-- Ends 1st and 15th of each month
	ELSE IF @period_id = 163872
	BEGIN
		IF @dayOfMonth = 1 SELECT @start = dbo.GetDateFromMDY(@month - 1, 16, @year)
		ELSE IF @dayOfMonth <= 15 SELECT @start = dbo.GetDateFromMDY(@month, 2, @year)
		ELSE SELECT @start = dbo.GetDateFromMDY(@month, 16, @year)

		WHILE @rows > 0
		BEGIN
			IF DATEPART(d, @start) = 2 SELECT @next = DATEADD(d, 14, @start)
			ELSE SELECT @next = DATEADD(d, -14, DATEADD(m, 1, @start))

			INSERT INTO @temp VALUES (@start, DATEADD(d, -1, @next))
			SELECT @start = @next, @rows = @rows - 1
		END
	END
	
	-- Ends 5th and 20th of each month
	ELSE IF @period_id = 176160
	BEGIN
		IF @dayOfMonth <= 5 SELECT @start = dbo.GetDateFromMDY(@month - 1, 21, @year)
		ELSE IF @dayOfMonth <= 20 SELECT @start = dbo.GetDateFromMDY(@month, 6, @year)
		ELSE SELECT @start = dbo.GetDateFromMDY(@month, 21, @year)

		WHILE @rows > 0
		BEGIN
			IF DATEPART(d, @start) = 6 SET @next = dbo.GetDateFromMDY(MONTH(@start), 21, YEAR(@start))
			ELSE IF DATEPART(d, @start) >= 21 SET @next = dbo.GetDateFromMDY(MONTH(@start) + 1, 6, YEAR(@start))
			ELSE SET @next = dbo.GetDateFromMDY(MONTH(@start), 6, YEAR(@start))

			INSERT INTO @temp VALUES (@start, DATEADD(d, -1, @next))
			SELECT @start = @next, @rows = @rows - 1
		END
	END
	
	-- 10th and 25th
	ELSE IF @period_id = 178208
	BEGIN
		IF @dayOfMonth <= 10 SELECT @start = dbo.GetDateFromMDY(@month - 1, 26, @year)
		ELSE IF @dayOfMonth <= 25 SELECT @start = dbo.GetDateFromMDY(@month, 11, @year)
		ELSE SELECT @start = dbo.GetDateFromMDY(@month, 26, @year)

		WHILE @rows > 0
		BEGIN
			IF DATEPART(d, @start) = 11 SET @next = dbo.GetDateFromMDY(MONTH(@start), 26, YEAR(@start))
			ELSE IF DATEPART(d, @start) >= 26 SET @next = dbo.GetDateFromMDY(MONTH(@start) + 1, 11, YEAR(@start))
			ELSE SET @next = dbo.GetDateFromMDY(MONTH(@start), 11, YEAR(@start))

			INSERT INTO @temp VALUES (@start, DATEADD(d, -1, @next))
			SELECT @start = @next, @rows = @rows - 1
		END
	END

	-- 11th and 27th
	ELSE IF @period_id = 180256
	BEGIN
		IF @dayOfMonth <= 11 SELECT @start = dbo.GetDateFromMDY(@month - 1, 28, @year)
		ELSE IF @dayOfMonth <= 27 SELECT @start = dbo.GetDateFromMDY(@month, 12, @year)
		ELSE SELECT @start = dbo.GetDateFromMDY(@month, 26, @year)

		WHILE @rows > 0
		BEGIN
			IF DATEPART(d, @start) = 12 SET @next = dbo.GetDateFromMDY(MONTH(@start), 28, YEAR(@start))
			ELSE IF DATEPART(d, @start) >= 28 SET @next = dbo.GetDateFromMDY(MONTH(@start) + 1, 12, YEAR(@start))
			ELSE SET @next = dbo.GetDateFromMDY(MONTH(@start), 11, YEAR(@start))

			INSERT INTO @temp VALUES (@start, DATEADD(d, -1, @next))
			SELECT @start = @next, @rows = @rows - 1
		END
	END

	-- Ends 1st and 16th of each month
	ELSE IF @period_id = 165920
	BEGIN
		IF @dayOfMonth = 1 SELECT @start = dbo.GetDateFromMDY(@month - 1, 17, @year)
		ELSE IF @dayOfMonth <= 16 SELECT @start = dbo.GetDateFromMDY(@month, 2, @year)
		ELSE SELECT @start = dbo.GetDateFromMDY(@month, 17, @year)

		WHILE @rows > 0
		BEGIN
			IF DATEPART(d, @start) = 2 SELECT @next = dbo.GetDateFromMDY(MONTH(@start), 17, YEAR(@start))
			ELSE SELECT @next = dbo.GetDateFromMDY(MONTH(@start) + 1, 2, YEAR(@start))

			INSERT INTO @temp VALUES (@start, DATEADD(d, -1, @next))
			SELECT @start = @next, @rows = @rows - 1
		END
	END

	-- Ends 14th and 28th of each month
	ELSE IF @period_id = 167968
	BEGIN
		IF @dayOfMonth <= 14 SELECT @start = dbo.GetDateFromMDY(@month - 1, 29, @year)
		ELSE IF @dayOfMonth <= 28 SELECt @start = dbo.GetDateFromMDY(@month, 15, @year)
		ELSE SELECT @start = dbo.GetDateFromMDY(@month, 29, @year)
		
		WHILE @rows > 0
		BEGIN
			IF DATEPART(d, @start) = 15 SET @next = dbo.GetDateFromMDY(MONTH(@start), 29, YEAR(@start))
			ELSE IF DATEPART(d, @start) >= 29 SET @next = dbo.GetDateFromMDY(MONTH(@start) + 1, 15, YEAR(@start))
			ELSE SET @next = dbo.GetDateFromMDY(MONTH(@start), 15, YEAR(@start))

			INSERT INTO @temp VALUES (@start, DATEADD(d, -1, @next))
			SELECT @start = @next, @rows = @rows - 1
		END
	END

	-- Ends 15th and 28th of each month
	ELSE IF @period_id = 170016
	BEGIN
		IF @dayOfMonth <= 15 SELECT @start = dbo.GetDateFromMDY(@month - 1, 29, @year)
		ELSE IF @dayOfMonth <= 28 SELECt @start = dbo.GetDateFromMDY(@month, 16, @year)
		ELSE SELECT @start = dbo.GetDateFromMDY(@month, 29, @year)
		
		WHILE @rows > 0
		BEGIN
			IF DATEPART(d, @start) = 16 SET @next = dbo.GetDateFromMDY(MONTH(@start), 29, YEAR(@start))
			ELSE IF DATEPART(d, @start) >= 29 SET @next = dbo.GetDateFromMDY(MONTH(@start) + 1, 16, YEAR(@start))
			ELSE SET @next = dbo.GetDateFromMDY(MONTH(@start), 16, YEAR(@start))


			INSERT INTO @temp VALUES (@start, DATEADD(d, -1, @next))
			SELECT @start = @next, @rows = @rows - 1
		END
	END

	-- Ends 15th and 30th of each month
	ELSE IF @period_id = 172064
	BEGIN
		IF @dayOfMonth <= 15 AND @month IN (2, 4, 6, 9, 11) SELECT @start = dbo.GetDateFromMDY(@month - 1, 31, @year)
		ELSE IF @dayOfMonth <= 15 SELECT @start = dbo.GetDateFromMDY(@month, 1, @year)
		ELSE IF @dayOfMonth <= 30 SELECt @start = dbo.GetDateFromMDY(@month, 16, @year)
		ELSE SELECT @start = dbo.GetDateFromMDY(@month, 31, @year)
		
		WHILE @rows > 0
		BEGIN
			IF DATEPART(d, @start) = 16 AND MONTH(@start) IN (2, 4, 6, 9, 11) SET @next = dbo.GetDateFromMDY(MONTH(@start) + 1, 1, YEAR(@start))
			ELSE IF DATEPART(d, @start) = 16 SET @next = dbo.GetDateFromMDY(MONTH(@start), 31, YEAR(@start))
			ELSE IF DATEPART(d, @start) >= 31 SET @next = dbo.GetDateFromMDY(MONTH(@start) + 1, 16, YEAR(@start))
			ELSE SET @next = dbo.GetDateFromMDY(MONTH(@start), 16, YEAR(@start))


			INSERT INTO @temp VALUES (@start, DATEADD(d, -1, @next))
			SELECT @start = @next, @rows = @rows - 1
		END
	END

	-- Ends 15th and last of each month
	ELSE IF @period_id = 174112
	BEGIN
		IF @dayOfMonth <= 15 SELECT @start = dbo.GetDateFromMDY(@month, 1, @year)
		ELSE SELECT @start = dbo.GetDateFromMDY(@month, 16, @year)
		
		WHILE @rows > 0
		BEGIN
			IF DATEPART(d, @start) = 16 SET @next = dbo.GetDateFromMDY(MONTH(@start) + 1, 1, YEAR(@start))
			ELSE SET @next = dbo.GetDateFromMDY(MONTH(@start), 16, YEAR(@start))

			INSERT INTO @temp VALUES (@start, DATEADD(d, -1, @next))
			SELECT @start = @next, @rows = @rows - 1
		END
	END

	ELSE 
	BEGIN
		RAISERROR(@error_message, 16, 1)
	END
END

-- Buck
IF EXISTS(SELECT * FROM PayrollPeriodException)
BEGIN
	UPDATE T SET StartDate = DATEADD(d,0,NewStartDay), StopDate = DATEADD(d,0,NewStopDay)
	FROM @temp T INNER JOIN PayrollPeriodException PPX ON T.StartDate = DATEADD(d,0,PPX.OldStartDay)

	SET ROWCOUNT @rows_original
	SELECT * FROM @temp WHERE [StopDate] >= @date
END
ELSE
BEGIN
	SELECT * FROM @temp
END
GO
IF OBJECT_ID('dbo.spRTWItemInsert') IS NULL
EXEC sp_executesql N'CREATE PROC dbo.spRTWItemInsert AS'
GO
ALTER PROC dbo.spRTWItemInsert @item varchar(50), @item_id int out AS
DECLARE @batch_id int, @order int
SET @batch_id=RAND() * 2147483647
INSERT TempX(BatchID,[ID],X) SELECT @batch_id,ItemID,[Order] FROM dbo.RTWItem
EXEC dbo.spBitFindNextOpenID @batch_id, 50006, @item_id OUT, @order OUT
IF @item_id IS NOT NULL 
INSERT dbo.RTWItem(ItemID,Item) SELECT @item_id, @item
DELETE dbo.TempX WHERE BatchID=@batch_id OR DATEDIFF(minute,Created,GETDATE()) > 30
GO
IF OBJECT_ID('dbo.spRTWItemUpdate') IS NULL
EXEC sp_executesql N'CREATE PROC dbo.spRTWItemUpdate AS'
GO
ALTER PROC dbo.spRTWItemUpdate @item varchar(50), @item_id int AS
UPDATE dbo.RTWItem SET Item=@item WHERE ItemID=@item_id
GO
IF OBJECT_ID('dbo.spRTWItemDelete') IS NULL
EXEC sp_executesql N'CREATE PROC dbo.spRTWItemDelete AS'
GO
ALTER PROC dbo.spRTWItemDelete @item_id int AS
DELETE dbo.RTWItem WHERE ItemID=@item_id
GO
IF OBJECT_ID('dbo.spRTWItemMoveDown') IS NULL
EXEC sp_executesql N'CREATE PROC dbo.spRTWItemMoveDown AS'
GO
ALTER PROC dbo.spRTWItemMoveDown
	@item_id int
AS
DECLARE @next_type_id int, @order int, @next_order int, @batch_id int
SET @batch_id = RAND() * 2147483647
INSERT TempX(BatchID,[ID],X) SELECT @batch_id,ItemID,[Order] FROM dbo.RTWItem
EXEC dbo.spBitMoveDown @batch_id, @item_id
UPDATE T SET [Order]=X.X FROM RTWItem T
INNER JOIN TempX X ON X.BatchID=@batch_id AND X.[ID]=T.ItemID AND X.X<>T.[Order]
DELETE dbo.TempX WHERE BatchID=@batch_id OR DATEDIFF(minute,Created,GETDATE()) > 30
GO
IF OBJECT_ID('dbo.spRTWItemMoveUp') IS NULL
EXEC sp_executesql N'CREATE PROC dbo.spRTWItemMoveUp AS'
GO
ALTER PROC dbo.spRTWItemMoveUp
	@item_id int
AS
DECLARE @next_type_id int, @order int, @next_order int, @batch_id int
SET @batch_id = RAND() * 2147483647
INSERT TempX(BatchID,[ID],X) SELECT @batch_id,ItemID,[Order] FROM dbo.RTWItem
EXEC dbo.spBitMoveUp @batch_id, @item_id
UPDATE T SET [Order]=X.X FROM RTWItem T
INNER JOIN TempX X ON X.BatchID=@batch_id AND X.[ID]=T.ItemID AND X.X<>T.[Order]
DELETE dbo.TempX WHERE BatchID=@batch_id OR DATEDIFF(minute,Created,GETDATE()) > 30
GO
IF OBJECT_ID('dbo.spRTWItemList') IS NULL
EXEC sp_executesql N'CREATE PROC dbo.spRTWItemList AS'
GO
GRANT EXEC ON dbo.spRTWItemList TO public
GO
ALTER PROC dbo.spRTWItemList @item_id int = NULL AS SELECT Item,ItemID,[Order] FROM dbo.RTWItem WHERE @item_id IS NULL OR ItemID=@item_id ORDER BY [Order]
GO
IF OBJECT_id('dbo.spLeaveStats') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spLeaveStats AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spLeaveStats TO public'
END
GO
ALTER PROC dbo.spLeaveStats
	@employee_id int,
	@requested_day int,
	@location_size int out,
	@employment_days int out,
	@seconds_worked_status int out,
	@seconds_worked_time_cards int out
AS
DECLARE @location_id int
DECLARE @authorized bit, @year_ago int
DECLARE @now int, @employment_seconds int
DECLARE @requested datetime

SET NOCOUNT ON

SELECT @location_id = 0, @location_size = 0
SELECT @requested = dbo.GetDateFromDaysPast1900(@requested_day)
SELECT @employment_days = 0, @seconds_worked_status = 0
SELECT @seconds_worked_time_cards = 0
SELECT @year_ago = DATEDIFF(d,0,DATEADD(yy,-1,@requested))

EXEC dbo.spPermissionInsureForCurrentUserOnPerson @employee_id, 10003, 1, @authorized out
IF @authorized = 1 
BEGIN
	SELECT @location_id = LocationID FROM Employee WHERE EmployeeID = @employee_id
	SELECT @location_size = COUNT(*) FROM Employee WHERE LocationID = @location_id AND [Active Employee] = 1
	SELECT @employment_days = ISNULL(SUM(
		CASE 
			WHEN [Stop Day past 1900] > @requested_day THEN @requested_day 
			WHEN [Stop Day past 1900] IS NULL THEN @requested_day
			ELSE [Stop Day past 1900] 
		END - [Start Day past 1900] + 1
	), (SELECT @requested_day - [Seniority Begins Day past 1900] FROM Employee WHERE EmployeeID = @employee_id))
	FROM dbo.EmployeeCompensation C WHERE EmployeeID = @employee_id AND [Start Day past 1900] <= @requested_day
	
	SELECT @employment_seconds = SUM(
			P.[Seconds per Week] / 7 * (
			1 +
			CASE 
				WHEN [Stop Day past 1900] > @requested_day THEN @requested_day 
				WHEN [Stop Day past 1900] IS NULL THEN @requested_day
				ELSE [Stop Day past 1900] 
			END - 
			CASE
				WHEN [Start Day past 1900] < @year_ago THEN  @year_ago
				ELSE [Start Day past 1900]
			END
		)
	)
	FROM dbo.EmployeeCompensation C
	INNER JOIN dbo.Position P ON C.PositionID=P.PositionID AND C.EmployeeID = @employee_id AND C.[Start Day past 1900] < @requested_day AND (C.[Stop Day past 1900] IS NULL OR C.[Stop Day past 1900] >= @year_ago)

	IF @employment_seconds IS NULL SET @employment_seconds = 
		(SELECT  S.[Seconds per Day] / (S.[Days On] + S.[Days Off]) * S.[Days On] * (@requested_day - 
			CASE
				WHEN E.[Seniority Begins Day past 1900] < @year_ago THEN @year_ago
				ELSE E.[Seniority Begins Day past 1900]
			END
		) FROM dbo.Employee E INNER JOIN dbo.Shift S ON E.ShiftID = S.ShiftID AND E.EmployeeID = @employee_id)
	
	
	SELECT @seconds_worked_time_cards =  ISNULL(SUM(Seconds), 0) FROM EmployeeTime WHERE EmployeeID = @employee_id AND (StatusID & 1) = 1 AND [In] BETWEEN DATEADD(yy,-1,@requested) AND @requested
	SELECT @seconds_worked_status = @employment_seconds + ISNULL(SUM(L.Seconds), 0) FROM dbo.vwEmployeeLeaveApproved L
	INNER JOIN dbo.vwLeaveType T ON L.Seconds < 0 AND L.EmployeeID = @employee_id AND (L.[Date] BETWEEN DATEADD(yy,-1,@requested) AND @requested) AND L.TypeID = T.TypeID AND T.Paid = 0 AND L.Seconds < 0
END
GO
IF OBJECT_id('dbo.spCompanyUpdateCarryover') IS NULL
EXEC sp_executesql N'CREATE PROC dbo.spCompanyUpdateCarryover AS'
GO
ALTER PROC dbo.spCompanyUpdateCarryover
	@source_type_id int,
	@target_type_id int,
	@limit_seconds int = 2147483647,
	@multiplier numeric(9,8) = 1,
	@offset int = 0
AS
SET NOCOUNT ON

UPDATE dbo.Constant SET CarryoverSourceLeaveTypeID = @source_type_id, CarryoverTargetLeaveTypeID = @target_type_id, [Carryover Multiplier] = @multiplier, [Carryover Offset Days] = @offset

UPDATE dbo.LeaveType SET CarryoverTargetLeaveTypeID = @target_type_id,
[Carryover Limit Seconds] = @limit_seconds,
[Carryover Multiplier] = @multiplier,
[Carryover Offset Days] = @offset
WHERE TypeID = @source_type_id

UPDATE dbo.LeaveLimit SET CarryoverTargetLeaveTypeID = @target_type_id,
[Carryover Limit Seconds] = @limit_seconds,
[Carryover Multiplier] = @multiplier,
[Carryover Offset Days] = @offset
WHERE TypeID = @source_type_id
GO
IF OBJECT_id('dbo.spEmployeeGetLeaveKeeperEmails') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEmployeeGetLeaveKeeperEmails AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spEmployeeGetLeaveKeeperEmails TO public'
END
GO
ALTER PROC dbo.spEmployeeGetLeaveKeeperEmails @employee_id int, @leave_keeper_emails varchar(400) OUT AS
DECLARE @division_leave_keeper varchar(50)
SELECT @leave_keeper_emails = '', @division_leave_keeper = ''

SELECT @division_leave_keeper = P.[Work E-mail] FROM dbo.Employee E 
INNER JOIN dbo.Division D ON E.EmployeeID = @employee_id AND E.DivisionID = D.DivisionID
INNER JOIN dbo.Person P ON D.LeaveKeeperID = P.PersonID

SELECT @leave_keeper_emails = P.[Work E-mail] FROM dbo.Employee E 
INNER JOIN dbo.Department D ON E.EmployeeID = @employee_id AND E.DepartmentID = D.DepartmentID
INNER JOIN dbo.Person P ON D.LeaveKeeperID = P.PersonID

IF @division_leave_keeper != '' AND @leave_keeper_emails != '' SET @leave_keeper_emails = @leave_keeper_emails + ';'
SET @leave_keeper_emails = @leave_keeper_emails + @division_leave_keeper
GO
IF OBJECT_id('dbo.spTaskSelect') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spTaskSelect AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spTaskSelect TO public'
END
GO
ALTER PROC dbo.spTaskSelect
	@task_id int
AS
DECLARE @owner_id int
DECLARE @authorized bit

SET NOCOUNT ON

SELECT @owner_id = OwnerEmployeeID FROM Task WHERE TaskID = @task_id
EXEC dbo.spPermissionInsureForCurrentUserOnPerson @owner_id, 10005, 1, @authorized out

IF @authorized = 1 
SELECT R.TaskID, R.CreatorEmployeeID, R.OwnerEmployeeID, R.RegardingPersonID, R.[Created Day after 1900], [Text] = R.Task, R.Urgent, [Owner Initials] = O.Initials, [Creator Initials] = C.Initials, [Regarding Initials] = ISNULL(G.Initials, ''), [Owner] = O.[List As], [Creator] = C.[List As], [Regarding] = G.[List As], [Regarding Employee Number] = ISNULL(E.[Employee Number], ''), E.EmployeeNumberNumeric
FROM Task R
INNER JOIN vwPersonCalculated C ON R.TaskID = @task_id AND R.CreatorEmployeeID = C.PersonID
INNER JOIN vwPersonCalculated O ON R.OwnerEmployeeID = O.PersonID
LEFT JOIN vwPersonCalculated G ON R.RegardingPersonID = G.PersonID
LEFT JOIN dbo.Employee E ON R.RegardingPersonID = E.EmployeeID
GO
IF OBJECT_id('dbo.spEmployeeListManagerSIDs') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEmployeeListManagerSIDs AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spEmployeeListManagerSIDs TO public'
END
GO
ALTER PROC dbo.spEmployeeListManagerSIDs @employee_id int AS
SELECT M.[SID] FROM EmployeeSuperior S
INNER JOIN Employee M ON S.EmployeeID=@employee_id AND S.SuperiorID=M.employeeID AND M.[SID] IS NOT NULL
GO
IF OBJECT_id('dbo.spEmployeeWouldSeniorityChangeAffectAccrual') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEmployeeWouldSeniorityChangeAffectAccrual AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spEmployeeWouldSeniorityChangeAffectAccrual TO public'
END
GO
ALTER PROC dbo.spEmployeeWouldSeniorityChangeAffectAccrual
	@employee_id int,
	@seniority_day int,
	@would_affect bit OUT
AS
SET NOCOUNT ON
SELECT @would_affect = CASE WHEN EXISTS(
	SELECT * FROM dbo.EmployeeLeaveEarned
	WHERE EmployeeID=@employee_id AND [Day past 1900] < @seniority_day AND [Auto] > 0
) THEN 1 ELSE 0 END
GO
IF OBJECT_id('dbo.spEmployeeLockInAccrualBeforeSeniorityChange') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEmployeeLockInAccrualBeforeSeniorityChange AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spEmployeeLockInAccrualBeforeSeniorityChange TO public'
END
GO
ALTER PROC dbo.spEmployeeLockInAccrualBeforeSeniorityChange
	@employee_id int,
	@seniority_day int
AS
DECLARE @authorized bit
SET NOCOUNT ON
EXEC dbo.spPermissionInsureForCurrentUserOnPerson @employee_id, 10013, 2, @authorized out
IF @authorized=1 UPDATE dbo.EmployeeLeaveEarned SET [Auto]=0 WHERE EmployeeID=@employee_id AND [Day past 1900] < @seniority_day AND [Auto] > 0
GO
IF OBJECT_id('dbo.spEmployeeLeaveCalcForType') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEmployeeLeaveCalcForType AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spEmployeeLeaveCalcForType TO public'
END
GO
ALTER PROC dbo.spEmployeeLeaveCalcForType
	@type_id int
AS
DECLARE @employee_id int

DECLARE e_cursor CURSOR LOCAL FORWARD_ONLY STATIC FOR 
SELECT E.EmployeeID FROM Employee E WHERE E.EmployeeID IN 
(SELECT U.EmployeeID FROM EmployeeLeaveUsed U WHERE ((U.[Type Mask] | U.[Advanced Type Mask]) & @type_id) != 0) OR E.EmployeeID IN
(SELECT U.EmployeeID FROM EmployeeLeaveUsedItem I INNER JOIN EmployeeLeaveUsed U ON I.LeaveID=U.LeaveID AND I.TypeID=@type_id) OR
E.EmployeeID IN 
(SELECT E.EmployeeID FROM EmployeeLeaveEarned E WHERE (TypeID & @type_id) != 0) OR @type_id IN (
SELECT DISTINCT CompLeaveTypeID FROM dbo.TimeType WHERE CompLeaveTypeID IS NOT NULL
)


OPEN e_cursor
FETCH e_cursor INTO @employee_id
WHILE @@FETCH_STATUS = 0
BEGIN
	EXEC dbo.spEmployeeLeaveCalcForEmployeeType @employee_id, @type_id, -2147483648

	FETCH e_cursor INTO @employee_id
END
GO
IF OBJECT_id('dbo.spDivisionList') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spDivisionList AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spDivisionList TO public'
END
GO
ALTER PROC dbo.spDivisionList @division_id int = NULL, @employee_id int = NULL, @exclude_empty bit = 0
AS
SET NOCOUNT ON
SELECT D.DivisionID, D.Division, D.LeaveKeeperID,
[Leave Keeper] = CASE WHEN D.LeaveKeeperID IS NULL THEN '' ELSE dbo.fnGetListAs([First Name], [Middle Name], [Last Name], Suffix) END
FROM dbo.Division D
LEFT JOIN dbo.Person P ON D.LeaveKeeperID = P.PersonID
WHERE (@division_id IS NULL OR D.DivisionID = @division_id) AND (@employee_id IS NULL OR D.DivisionID IN (
	SELECT DivisionID FROM dbo.Employee WHERE EmployeeID=@employee_id
)) AND (@exclude_empty = 0 OR D.DivisionID IN (
	SELECT DivisionID FROM dbo.Employee
))
ORDER BY D.Division
GO
IF OBJECT_id('dbo.spDivisionSelectForEmployee') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spDivisionSelectForEmployee AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spDivisionSelectForEmployee TO public'
END
GO
ALTER PROC dbo.spDivisionSelectForEmployee @employee_id int AS EXEC dbo.spDivisionList @employee_id=@employee_id
GO
IF OBJECT_id('dbo.spDivisionListAsListItems') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spDivisionListAsListItems AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spDivisionListAsListItems TO public'
END
GO
ALTER PROC dbo.spDivisionListAsListItems @exclude_empty bit = 0 AS EXEC dbo.spDivisionList @exclude_empty=@exclude_empty
GO
IF OBJECT_id('dbo.spDivisionSelect') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spDivisionSelect AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spDivisionSelect TO public'
END
GO
ALTER PROC dbo.spDivisionSelect @division_id int AS EXEC dbo.spDivisionList @division_id=@division_id
GO
IF OBJECT_id('dbo.spDivisionInsert') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spDivisionInsert AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spDivisionInsert TO public'
END
GO
ALTER PROC dbo.spDivisionInsert
	@division varchar(50),
	@leave_keeper_id int = NULL,
	@division_id int OUT
AS
INSERT Division(Division, LeaveKeeperID) VALUES(@division,@leave_keeper_id)
SELECT @division_id = SCOPE_IDENTITY()
GO
IF OBJECT_id('dbo.spDivisionUpdate') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spDivisionUpdate AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spDivisionUpdate TO public'
END
GO
ALTER PROC dbo.spDivisionUpdate
	@division varchar(50),
	@division_id int,
	@leave_keeper_id int = NULL
AS
UPDATE Division SET Division = @division, LeaveKeeperID = @leave_keeper_id WHERE DivisionID = @division_id
GO
IF OBJECT_id('dbo.spEmployeeLeaveUsedLinkInsert') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEmployeeLeaveUsedLinkInsert AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spEmployeeLeaveUsedLinkInsert TO public'
END
GO
ALTER PROC dbo.spEmployeeLeaveUsedLinkInsert
	@leave_id int,
	@type_id int,
	@employee_id int,
	@item_id int out
AS
INSERT dbo.EmployeeLeaveUsedLink(LeaveID,TypeID,EmployeeID) VALUES(@leave_id,@type_id,@employee_id)
SET @item_id=SCOPE_IDENTITY()
GO
IF OBJECT_id('dbo.spEmployeeLeaveUsedLinkUpdate') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEmployeeLeaveUsedLinkUpdate AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spEmployeeLeaveUsedLinkUpdate TO public'
END
GO
ALTER PROC dbo.spEmployeeLeaveUsedLinkUpdate
	@leave_id int,
	@type_id int,
	@employee_id int,
	@item_id int out
AS
UPDATE dbo.EmployeeLeaveUsedLink SET LeaveID=@leave_id,TypeID=@type_id,EmployeeID=@employee_id WHERE ItemID=@item_id
GO
IF OBJECT_id('dbo.spEmployeeLeaveUsedLinkDelete') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEmployeeLeaveUsedLinkDelete AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spEmployeeLeaveUsedLinkDelete TO public'
END
GO
ALTER PROC dbo.spEmployeeLeaveUsedLinkDelete
	@item_id int
AS
DELETE dbo.EmployeeLeaveUsedLink WHERE ItemID=@item_id
GO
IF OBJECT_id('dbo.spEmployeeLeaveUsedLinkList') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEmployeeLeaveUsedLinkList AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spEmployeeLeaveUsedLinkList TO public'
END
GO
ALTER PROC dbo.spEmployeeLeaveUsedLinkList
	@leave_id int = NULL, @item_id int = NULL, @employee_id int = NULL, @type_id int = NULL
AS
SET NOCOUNT ON
SELECT LeaveID,TypeID,EmployeeID,ItemID FROM dbo.EmployeeLeaveUsedLink WHERE (@item_id IS NULL OR ItemID=@item_id) AND (@leave_id IS NULL OR LeaveID=@leave_id) AND (@employee_id IS NULL OR EmployeeID=@employee_id) AND (@type_id IS NULL OR TypeID=@type_id)
ORDER BY LeaveID, EmployeeID, TypeID
GO
ALTER PROC dbo.spLeaveTypeDelete
	@type_id int,
	@new_type_id int
AS
DECLARE @error int, @source_type_id int

SELECT @error = 0, @source_type_id = NULL

BEGIN TRAN


SELECT @source_type_id=TypeID FROM dbo.LeaveType WHERE CarryoverTargetLeaveTypeID=@type_id
IF @@ROWCOUNT = 0 SELECT @source_type_id=CarryoverSourceLeaveTypeID FROM dbo.Constant WHERE CarryoverTargetLeaveTypeID=@type_id

UPDATE dbo.LeaveLimit SET CarryoverTargetLeaveTypeID=@new_type_id WHERE CarryoverTargetLeaveTypeID=@type_id
UPDATE dbo.LeaveType SET CarryoverTargetLeaveTypeID=@new_type_id WHERE CarryoverTargetLeaveTypeID=@type_id
UPDATE Constant SET CarryoverSourceLeaveTypeID = NULL, CarryoverTargetLeaveTypeID = NULL WHERE @type_id IN (CarryoverSourceLeaveTypeID, CarryoverTargetLeaveTypeID)
DELETE LeaveRate WHERE @type_id = TypeID
--DELETE EmployeeLeaveUsedCompCost WHERE @type_id = TypeID
DELETE EmployeeLeaveUnused WHERE @type_id = TypeID
DELETE EmployeeLeaveEarned WHERE @type_id = TypeID
DELETE LeaveLimit WHERE @type_id = TypeID

IF @new_type_id IS NULL 
BEGIN
	DELETE EmployeeLeaveUsedItem WHERE @type_id = TypeID
	DELETE U FROM EmployeeLeaveUsed U WHERE ((U.[Type Mask] | U.[Advanced Type Mask]) & @type_id) != 0 AND
	(SELECT COUNT(*) FROM EmployeeLeaveUsedItem I WHERE I.LeaveID=U.LeaveID) = 0
	EXEC dbo.spEmployeeLeaveCalcForType @type_id

	UPDATE L SET 
	[Advanced Type Mask] = [Advanced Type Mask] & ~@type_id,
	[Type Mask] = ISNULL((SELECT SUM(I.TypeID) FROM vwEmployeeLeaveUsedItemDistinctTypes I WHERE I.LeaveID = L.LeaveID), 0),
	Seconds = ISNULL((
		SELECT SUM(Seconds) FROM EmployeeLeaveUsedItem I WHERE I.LeaveID = L.LeaveID
	), 0)
	FROM EmployeeLeaveUsed L WHERE ((L.[Type Mask] | L.[Advanced Type Mask]) & @type_id) != 0
END
ELSE
BEGIN
	UPDATE EmployeeLeaveUsedItem SET TypeID = @new_type_id WHERE TypeID = @type_id
	UPDATE EmployeeLeaveUsed SET 
	[Advanced Type Mask] = ([Advanced Type Mask] | @new_type_id) & ~@type_id,
	[Type Mask] = ([Type Mask] | @new_type_id) & ~@type_id
	WHERE (([Type Mask] | [Advanced Type Mask]) &  @type_id) != 0
	
	EXEC dbo.spEmployeeLeaveCalcForType @new_type_id
END

UPDATE dbo.Constant SET OTTimeTypeID=@new_type_id WHERE OTTimeTypeID=@type_id
UPDATE dbo.Constant SET DTTimeTypeID=@new_type_id WHERE DTTimeTypeID=@type_id

DELETE LeaveType WHERE @type_id = TypeID
IF @source_type_id IS NOT NULL EXEC dbo.spEmployeeLeaveCalcForType @source_type_id

COMMIT TRAN
GO
IF OBJECT_id('dbo.spEmployeeLeaveUsedSelect') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spEmployeeLeaveUsedSelect AS'
GO
EXEC sp_executesql N'GRANT EXEC ON dbo.spEmployeeLeaveUsedSelect TO public'
GO
ALTER PROC dbo.spEmployeeLeaveUsedSelect
	@leave_id int
AS
DECLARE @employee_id int
DECLARE @authorized bit

SET NOCOUNT ON

SELECT @employee_id = EmployeeID FROM EmployeeLeaveUsed WHERE LeaveID = @leave_id
IF @@ROWCOUNT = 0 SET @authorized = 1
ELSE EXEC dbo.spPermissionInsureForCurrentUserOnPerson @employee_id, 10001, 1, @authorized out
IF @authorized = 1 SELECT * FROM dbo.vwEmployeeLeaveUsed WHERE LOALeaveID = @leave_id
GO
ALTER PROC dbo.spLeaveTypeSelectPrimary
AS
SET NOCOUNT ON

DECLARE @type_id int

SET @type_id = NULL

SELECT TOP 1 @type_id = TypeID FROM LeaveType T
WHERE TypeID IN
(
	SELECT DISTINCT TypeID FROM LeaveRate
)
ORDER BY T.[Order]

IF @type_id IS NULL SELECT TOP 1 @type_id = TypeID FROM LeaveType WHERE Advanced = 1 ORDER BY [Order]
IF @type_id IS NULL SELECT TOP 1 @type_id = TypeID FROM LeaveType ORDER BY [Order]

SELECT * FROM dbo.vwLeaveType WHERE TypeID = @type_id
GO
IF OBJECT_ID('dbo.spLeaveTestOverlap') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spLeaveTestOverlap AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spLeaveTestOverlap TO public'
END
GO
ALTER PROC dbo.spLeaveTestOverlap
	@leave_id int, -- Leave to check
	@flags int,
	@result varchar(4000) out
AS
DECLARE @employee_id int, @d varchar(50), @t varchar(50), @x int

SET @result = ''
SELECT @employee_id=EmployeeID FROM dbo.EmployeeLeaveUsed WHERE LeaveID=@leave_id AND [Status] <> 4

IF @@ROWCOUNT=0 RETURN

DECLARE l_cursor CURSOR LOCAL FORWARD_ONLY STATIC FOR 
SELECT DISTINCT I.[Day past 1900], D=CAST(dbo.GetDateFromDaysPast1900(I.[Day past 1900]) AS varchar(11)), I=T.[Type] FROM dbo.EmployeeLeaveUsedItem I
INNER JOIN dbo.EmployeeLeaveUsed L2 ON I.LeaveID=@leave_id AND L2.EmployeeID=@employee_id AND L2.LeaveID <> @leave_id AND L2.[Status] <> 4
INNER JOIN dbo.EmployeeLeaveUsedItem I2 ON L2.LeaveID=I2.LeaveID AND I.TypeID=I2.TypeID AND I.[Day past 1900]=I2.[Day past 1900]
INNER JOIN dbo.LeaveType T ON I.TypeID=T.TypeID
ORDER BY I.[Day past 1900]


OPEN l_cursor
FETCH l_cursor INTO @x, @d, @t
WHILE @@FETCH_STATUS=0
BEGIN
	IF @result <> '' SET @result = @result + ','
	SET @result = @result + @d + ' ' + @t
	FETCH l_cursor INTO @x, @d, @t
END

CLOSE l_cursor
DEALLOCATE l_cursor

IF @result <> '' SET @result = 'Leave overlaps with another request: ' + @result
GO
IF OBJECT_id('dbo.spEmployeeUpdateAccount2') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEmployeeUpdateAccount2 AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spEmployeeUpdateAccount2 TO public'
END
GO
ALTER PROC dbo.spEmployeeUpdateAccount2
	@employee_id int,
	@sid varbinary(85)
AS
DECLARE @authorized bit

SET NOCOUNT ON

-- Avoid all these checks if the sid is already set
IF EXISTS(SELECT * FROM Employee WHERE EmployeeID=@employee_id AND [SID]=@sid) RETURN
IF @sid IS NULL AND EXISTS(SELECT * FROM Employee WHERE EmployeeID=@employee_id AND [SID] IS NULL) RETURN

EXEC dbo.spPermissionInsureForCurrentUserOnPerson @employee_id, 0x20, 2, @authorized out

IF @authorized = 1 AND @sid IS NOT NULL
BEGIN
	DECLARE @old_employee_id int

	SELECT @old_employee_id = EmployeeID FROM Employee WHERE SID = @sid
	IF @@ROWCOUNT = 1 AND @old_employee_id <> @employee_id
	BEGIN
		EXEC spPermissionGetOnPersonForCurrentUser2 @old_employee_id, 0x20, 2, @authorized out
		IF @authorized = 1 UPDATE Employee SET SID = NULL WHERE EmployeeID = @old_employee_id
		ELSE
		BEGIN
			DECLARE @message varchar(400)

			SELECT @message = [Full Name] + ' is assigned this login, and you do not have permission to clear his login.' FROM vwPersonCalculated WHERE PersonID = @old_employee_id
			RAISERROR (@message, 16, 1)
		END
	END
END

IF @authorized = 1 UPDATE Employee SET SID = @sid WHERE EmployeeID = @employee_id
GO
IF OBJECT_id('dbo.spPersonUpdateValue') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spPersonUpdateValue AS'
GO
-- Requires dbo permissions. Updates any person,personx,employee column
ALTER PROC dbo.spPersonUpdateValue @column sysname, @v nvarchar(4000), @person_id int AS
DECLARE @sql nvarchar(4000), @t sysname, @k sysname
SELECT @t=object_name(id) from syscolumns where [name]=@column and [id] in (object_id('Person'), object_id('PersonX'), object_id('Employee'))
IF @@ROWCOUNT=0
BEGIN
	SET @sql = N'Column ' + @column + ' does not exist.'
	RAISERROR (@sql, 16, 1)
END
ELSE
BEGIN
	IF @t='Employee' SET @k='EmployeeID'
	ELSE SET @k='PersonID'
	
	IF @v IS NULL
	BEGIN
		SET @sql = 'UPDATE ' + @t + ' SET [' + @column + ']=NULL WHERE ' + @k + '=@id AND [' + @column +'] IS NOT NULL'
		EXEC sp_executesql @sql, N'@id int', @person_id
	END
	ELSE
	BEGIN
		SET @sql = 'UPDATE ' + @t + ' SET [' + @column + ']=@p1 WHERE ' + @k + '=@id AND ([' + @column +'] IS NULL OR [' + @column +']!=@p1)'
		EXEC sp_executesql @sql, N'@id int,@p1 nvarchar(4000)', @person_id,@v

	END
END
GO
IF OBJECT_id('dbo.spEmployeeUpdateManager') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEmployeeUpdateManager AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spEmployeeUpdateManager TO public'
END
GO
ALTER PROC dbo.spEmployeeUpdateManager @employee_id int, @manager_id int
AS  DECLARE @authorized bit
IF @manager_id IS NULL AND EXISTS(SELECT * FROM dbo.Employee WHERE EmployeeID=@employee_id AND ManagerID IS NULL) RETURN
IF EXISTS(SELECT * FROM dbo.Employee WHERE EmployeeID=@employee_id AND ManagerID=@manager_id) RETURN
EXEC dbo.spPermissionInsureForCurrentUserOnPerson @employee_id, 8, 2, @authorized out
IF @authorized = 1 UPDATE Employee SET ManagerID=@manager_id WHERE EmployeeID=@employee_id
GO
IF OBJECT_ID('dbo.spEmployeeBatchCustom') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEmployeeBatchCustom AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spEmployeeBatchCustom TO public'
END
GO
ALTER PROC dbo.spEmployeeBatchCustom
	@batch_id int,
	@custom int -- 1: classified, 2: prof standard, 3: prof flex
AS
IF @custom IN (1,2,3)
BEGIN
	CREATE TABLE #P_20110620(PlanID int PRIMARY KEY) -- Contains the leave plans to EXCLUDE
	IF @custom=1 INSERT #P_20110620(PlanID) SELECT PlanID FROM dbo.LeavePlan WHERE [Plan] NOT LIKE '%Class%'
	ELSE INSERT #P_20110620(PlanID) SELECT PlanID FROM dbo.LeavePlan WHERE [Plan] LIKE '%Class%'

	-- Finds last EmployeeLeavePlan
	UPDATE X SET Y = (
		SELECT TOP 1 ELP.PlanID FROM dbo.EmployeeLeavePlan ELP WHERE ELP.EmployeeID=X.[ID] ORDER BY ELP.[Start Day past 1900] DESC
	) FROM dbo.TempX X WHERE X.BatchID=@batch_id
	
	-- Deletes employees from the list who do not have the selected classification
	DELETE X
	FROM dbo.TempX X 
	INNER JOIN #P_20110620 P ON X.BatchID=@batch_id AND X.Y=P.PlanID
	
	IF @custom=1 RETURN
	
	DELETE #P_20110620
	IF @custom=2 INSERT #P_20110620(PlanID) SELECT ShiftID FROM dbo.Shift WHERE [Days On] != 5
	ELSE INSERT #P_20110620(PlanID) SELECT ShiftID FROM dbo.Shift WHERE [Days On] = 5

	DELETE X
	FROM dbo.TempX X 
	INNER JOIN dbo.Employee E ON X.BatchID=@batch_id AND X.[ID]=E.EmployeeID
	INNER JOIN #P_20110620 ON E.ShiftID = #P_20110620.PlanID
END
ELSE RAISERROR('Custom filter not implemented',16,1)
GO
IF OBJECT_ID('dbo.spEmployeeLeaveUsedListUnpaid') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEmployeeLeaveUsedListUnpaid AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spEmployeeLeaveUsedListUnpaid TO public'
END
GO
ALTER PROC dbo.spEmployeeLeaveUsedListUnpaid
	@batch_id int,
	@start int,
	@stop int,
	@flags int =0,
	@authorized bit out
AS
SET NOCOUNT ON

EXEC dbo.spPermissionGetOnPeopleForCurrentUser2 @batch_id, 10001
DELETE dbo.TempX WHERE BatchID=@batch_id AND (X&1)=0
SET @authorized = CASE WHEN @@ROWCOUNT=0 THEN 1 ELSE 0 END

SELECT
E.EmployeeID,
E.[Employee Number],
Employee = dbo.fnGetListAs(P.[First Name], P.[Middle Name], P.[Last Name], P.Suffix),
[Date]=dbo.GetDateFromDaysPast1900(UI.[Day past 1900]),
[Hours]=SUM(UI.Seconds) / 3600.0
FROM  dbo.EmployeeLeaveUsedItem UI
INNER JOIN dbo.LeaveType T ON UI.TypeID=T.TypeID AND T.[Paid] = 0 AND UI.[Day past 1900] BETWEEN @start AND @stop
INNER JOIN dbo.EmployeeLeaveUsed U ON UI.LeaveID=U.LeaveID
INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID]=U.EmployeeID
INNER JOIN dbo.Employee E ON U.EmployeeID=E.EmployeeID
INNER JOIN dbo.Person P ON E.EmployeeID=P.PersonID
GROUP BY E.EmployeeID, E.[Employee Number], P.[First Name], P.[Middle Name], P.[Last Name], P.Suffix, UI.[Day past 1900]
ORDER BY P.[Last Name], P.[First Name], E.EmployeeID, [Date]

DELETE dbo.TempX WHERE BatchID=@batch_id OR DATEDIFF(hour,0,Created)>0
GO
IF OBJECT_ID('dbo.spDepartmentList') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spDepartmentList AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spDepartmentList TO public'
END
GO
ALTER PROC dbo.spDepartmentList @department_id int = NULL, @employee_id int = NULL
AS
SET NOCOUNT ON
SELECT D.DepartmentID, D.Department, D.LeaveKeeperID,
[Leave Keeper] = CASE WHEN D.LeaveKeeperID IS NULL THEN '' ELSE dbo.fnGetListAs([First Name], [Middle Name], [Last Name], Suffix) END
FROM dbo.Department D
LEFT JOIN dbo.Person P ON D.LeaveKeeperID = P.PersonID
WHERE (@department_id IS NULL OR D.DepartmentID = @department_id) AND (@employee_id IS NULL OR D.DepartmentID IN (
	SELECT DepartmentID FROM dbo.Employee WHERE EmployeeID=@employee_id
))
ORDER BY D.Department
GO
IF OBJECT_ID('dbo.spDepartmentSelect') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spDepartmentSelect AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spDepartmentSelect TO public'
END
GO
ALTER PROC dbo.spDepartmentSelect @department_id int AS SET NOCOUNT ON EXEC dbo.spDepartmentList @department_id=@department_id
GO
IF OBJECT_ID('dbo.spDepartmentSelectForEmployee') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spDepartmentSelectForEmployee AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spDepartmentSelectForEmployee TO public'
END
GO
ALTER PROC dbo.spDepartmentSelectForEmployee @employee_id int AS SET NOCOUNT ON EXEC dbo.spDepartmentList @employee_id=@employee_id
GO
IF OBJECT_ID('dbo.spDepartmentUpdate') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spDepartmentUpdate AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spDepartmentUpdate TO public'
END
GO
ALTER PROC dbo.spDepartmentUpdate
	@department varchar(50),
	@department_id int,
	@leave_keeper_id int = NULL,
	@flags int = 0 -- 1: Set leave keeper
AS
UPDATE dbo.Department SET Department = LTRIM(RTRIM(@department)), LeaveKeeperID = CASE WHEN (@flags & 1) = 0 THEN LeaveKeeperID ELSE @leave_keeper_id END
WHERE DepartmentID = @department_id
GO
IF OBJECT_ID('dbo.spDepartmentInsert') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spDepartmentInsert AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spDepartmentInsert TO public'
END
GO
ALTER PROC dbo.spDepartmentInsert
	@department varchar(50),
	@leave_keeper_id int = NULL,
	@department_id int OUT
AS
INSERT Department(Department, LeaveKeeperID) 
VALUES(LTRIM(RTRIM(@department)), @leave_keeper_id)
SELECT @department_id = SCOPE_IDENTITY()
GO
IF OBJECT_ID('dbo.spPermissionGetOptimisticForCurrentUser') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spPermissionGetOptimisticForCurrentUser AS'
	GRANT EXEC ON dbo.spPermissionGetOptimisticForCurrentUser TO public
END
GO
-- Returns the best-case most optimistic permissions for the current user on several attributes
-- Fill TempX with a random BatchID, the attributes in question (ID), X=0, Y=0
-- TempX.X will return the most optimistic effective permissions
ALTER PROC dbo.spPermissionGetOptimisticForCurrentUser
	@batch_id int,
	@flags int -- 1: exclude self
AS
DECLARE @is_manager int, @is_delegated_manager int, @has_manager int, @is_delegated_manger_self int, @self int
DECLARE @employee_id int, @department_id int, @division_id int, @location_id int, @uid int
DECLARE @sid varbinary(85)

SET NOCOUNT ON

IF IS_MEMBER('db_owner') = 1
	UPDATE TempX SET X = 0x7FFFFFFF WHERE BatchID = @batch_id
ELSE
BEGIN
	SELECT @sid = SUSER_SID()
	SELECT @employee_id = EmployeeID, @division_id = DivisionID, @department_id = DepartmentID, @location_id = LocationID FROM Employee WHERE SID = @sid
	SELECT @has_manager = CASE WHEN EXISTS(SELECT * FROM dbo.Employee WHERE ManagerID=@employee_id) THEN 512 ELSE 0 END
	SELECT @is_manager = CASE WHEN EXISTS(SELECT * FROM dbo.Employee WHERE ManagerID=@employee_id AND [Active Employee]=1) THEN 8 ELSE 0 END
	SELECT @is_delegated_manager = CASE WHEN EXISTS(SELECT * FROM dbo.Employee WHERE DelegatedManagerID=@employee_id) THEN 256 ELSE 0 END
	SELECT @is_delegated_manger_self = CASE WHEN @is_delegated_manager = 0 THEN 0 ELSE 1024 END
	SELECT @self = CASE WHEN (@flags & 1) = 1 THEN 0 ELSE 4 END
	DECLARE user_cursor CURSOR LOCAL FORWARD_ONLY STATIC FOR 
	SELECT U.uid
	FROM sysusers U WHERE U.SID = @sid OR IS_MEMBER(U.[name]) = 1

	-- Loops for every user\account\role to which the current user belongs
	OPEN user_cursor
	FETCH NEXT FROM user_cursor INTO @uid
	WHILE @@FETCH_STATUS = 0
	BEGIN
		-- Merge permissions on all people
		UPDATE TPP SET X = TPP.X | P.[Permission Mask], Y = Y | P.[Deny Mask]
		FROM TempX TPP
		INNER JOIN PermissionScopeAttribute P ON TPP.BatchID = @batch_id AND P.ScopeID = 1 AND P.AttributeID = TPP.[ID] AND P.UID = @uid

		-- Merge permissions on applicants
		UPDATE TPP SET X = TPP.X | P.[Permission Mask], Y = Y | P.[Deny Mask]
		FROM TempX TPP
		INNER JOIN PermissionScopeAttribute P ON TPP.BatchID = @batch_id AND P.ScopeID = 128 AND P.AttributeID = TPP.[ID] AND P.UID = @uid
		
		-- Merge permissions on employees / self / division / department / location / manager / delegated subordinates / delegated self
		UPDATE TPP SET X = TPP.X | P.[Permission Mask], Y = TPP.Y | P.[Deny Mask]
		FROM TempX TPP
		INNER JOIN PermissionScopeAttribute P ON TPP.BatchID = @batch_id AND P.AttributeID = TPP.[ID] AND P.UID = @uid AND
			P.ScopeID IN (4096, 2, 16, 32, 64, @is_manager, @is_delegated_manager, @has_manager, @is_delegated_manger_self, @self)

		FETCH NEXT FROM user_cursor INTO @uid
	END
	CLOSE user_cursor
	DEALLOCATE user_cursor
	
	-- Any deny overrides every grant
	UPDATE TempX SET X = X & (Y ^ 0x7FFFFFFF) WHERE BatchID = @batch_id
END
DELETE TempPersonPermission WHERE DATEDIFF(hour,Created,GETDATE()) > 1
GO
IF OBJECT_ID('dbo.spTempPersonPermissionBatch') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spTempPersonPermissionBatch AS'
	GRANT EXEC ON dbo.spTempPersonPermissionBatch TO public
END
GO
ALTER PROC dbo.spTempPersonPermissionBatch
	@batch_in_id int,
	@attribute_id int,
	@flags int,
	@batch_out_id int out
AS
SELECT @batch_out_id = (RAND() - 0.5) * 4294967294.0
INSERT dbo.TempPersonPermission(BatchID,PersonID,AttributeID)
SELECT @batch_out_id, [ID], @attribute_id FROM dbo.TempX WHERE BatchID=@batch_in_id

IF @flags & 1 = 1 DELETE dbo.TempX WHERE BatchID=@batch_in_id OR DATEDIFF(hour,Created,GETDATE()) > 1
GO
IF OBJECT_ID('dbo.spTempPersonPermissionList') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spTempPersonPermissionList AS'
	GRANT EXEC ON dbo.spTempPersonPermissionList TO public
END
GO
ALTER PROC dbo.spTempPersonPermissionList @batch_id int, @flags int AS
SET NOCOUNT ON
SELECT * FROM dbo.TempPersonPermission WHERE BatchID=@batch_id
IF @flags & 1 = 1 DELETE dbo.TempPersonPermission WHERE BatchID=@batch_id OR DATEDIFF(hour,Created,GETDATE()) > 1
GO
IF OBJECT_ID('dbo.spPermissionSummarizeCommon') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spPermissionSummarizeCommon AS'
	GRANT EXEC ON dbo.spPermissionSummarizeCommon TO public
END
GO
-- Set bits based on commonly used permission information
ALTER PROC dbo.spPermissionSummarizeCommon
	@employee_id int out,
	@flags int out -- 1: db_owner, 2: add_employee, 4: delete_employee, 8: has subordinates, 0x10: has indirect subordinates, 0x20: can approve time, 0x40: can approve leave, 0x80: identified user, 0x100: has direct subordinates, 0x200: has effective subordinates, 0x400: expenses approved, 0x800: has manager, 0x1000: can add approved leave for self, CanOnlySeeLeaveForSelf = 0x2000, HasAnyKindOfSubordinates: 0x318, IsSysAdmin: 0x4000, CanEditEmployee: 0x8000

AS
SELECT @flags = CASE WHEN IS_MEMBER('db_owner')=1 THEN 0x9461 ELSE 0 END
SELECT @flags = @flags | 0x4000 WHERE IS_SRVROLEMEMBER('sysadmin')=1

DECLARE @permission_mask int
EXEC dbo.spPermissionGetOnObjectForCurrentUser  22, @permission_mask out
SELECT @flags = @flags | 2 WHERE @permission_mask & 4 = 4
SELECT @flags = @flags | 4 WHERE @permission_mask & 8 = 8

SELECT @employee_id = EmployeeID FROM dbo.Employee WHERE [SID] = SUSER_SID()
IF @employee_id IS NOT NULL
BEGIN
	SELECT @flags = @flags | 0x80
	SELECT @flags = @flags | 8 WHERE EXISTS (SELECT * FROM dbo.EmployeeSuperior WHERE SuperiorID=@employee_id) -- subordinates
	SELECT @flags = @flags | 0x10 WHERE EXISTS (SELECT * FROM dbo.EmployeeSuperior S INNER JOIN dbo.Employee E ON S.EmployeeID = E.EmployeeID AND SuperiorID=@employee_id AND ManagerID != @employee_id) -- indirect subordiantes
	SELECT @flags = @flags | 0x200 WHERE EXISTS (SELECT * FROM dbo.Employee E INNER JOIN dbo.Employee M ON E.ManagerID = M.EmployeeID AND M.DelegatedManagerID=@employee_id) -- delegated subordinates
	SELECT @flags = @flags | 0x800 WHERE EXISTS (SELECT * FROM dbo.Employee E WHERE E.EmployeeID=@employee_id AND ManagerID IS NOT NULL)
END

IF @flags & 1 = 0
BEGIN
	-- Checks update permission on leave, expenses, time for all employees who are NOT the current user
	DECLARE @batch_id int
	EXEC dbo.spAdminGetNextRandom @batch_id out
	INSERT dbo.TempX(BatchID, [ID], X, Y)
	SELECT @batch_id, 10013, 0, 0 /* leave */
	UNION SELECT @batch_id, 10011, 0, 0 /* expenses */
	UNION SELECT @batch_id, 262145, 0, 0 /* time */
	UNION SELECT @batch_id, 1, 0, 0 -- Home
	UNION SELECT @batch_id, 2, 0, 0 -- Work
	UNION SELECT @batch_id, 8, 0, 0 -- Org
	UNION SELECT @batch_id, 128, 0, 0 -- Employee leave accrual
	EXEC dbo.spPermissionGetOptimisticForCurrentUser @batch_id, 1

	SELECT @flags = @flags | 0x400 WHERE EXISTS (SELECT * FROM dbo.TempX WHERE BatchID=@batch_id AND [ID]=10011 AND (X & 2) = 2) -- update expenses approved
	SELECT @flags = @flags | 0x40 WHERE EXISTS (SELECT * FROM dbo.TempX WHERE BatchID=@batch_id AND [ID]=10013 AND (X & 2) = 2) -- update leave approved
	SELECT @flags = @flags | 0x20 WHERE EXISTS (SELECT * FROM dbo.TempX WHERE BatchID=@batch_id AND [ID]=262145 AND (X & 2) = 2) -- update time approved
	SELECT @flags = @flags | 0x8000 WHERE EXISTS (SELECT * FROM dbo.TempX WHERE BatchID=@batch_id AND [ID] IN (1,2,4,8,128) AND (X & 2) = 2) -- edit employee
	SELECT @flags = @flags | 0x1000 WHERE (dbo.fnPermissionGetOnPersonForCurrentUser(@employee_id, 10013) & 4) = 4
	
	DELETE dbo.TempX WHERE BatchID=@batch_id OR DATEDIFF(hour, Created, GETDATE()) > 1
END
GO
IF OBJECT_id('dbo.spEmployeeTimeTotalApprovedSeconds') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEmployeeTimeTotalApprovedSeconds AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spEmployeeTimeTotalApprovedSeconds TO public'
END
GO
ALTER PROC dbo.spEmployeeTimeTotalApprovedSeconds
	@employee_id int,
	@start smalldatetime,
	@stop smalldatetime,
	@seconds int OUT
AS
/*DECLARE @payroll_delay int

SELECT @payroll_delay = 0 - [Payroll Delay] FROM dbo.Employee WHERE EmployeeID = @employee_id
SELECT @start = DATEADD(d,@payroll_delay,@start), @stop = DATEADD(d,@payroll_delay,@stop), */
SELECT @seconds = ISNULL(SUM(ET.Seconds), 0) FROM dbo.EmployeeTime ET WHERE [In] BETWEEN @start AND @stop
GO
IF OBJECT_id('dbo.spPersonGetFullName') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spPersonGetFullName AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spPersonGetFullName TO public'
END
GO
ALTER PROC dbo.spPersonGetFullName
	@person_id int,
	@person varchar(400) out
AS
SELECT @person = dbo.fnGetFullName([First Name], [Middle Name], [Last Name], Suffix) FROM dbo.Person WHERE PersonID = @person_id
IF @@ROWCOUNT = 0 SELECT @person = ''
GO
IF OBJECT_id('dbo.spShiftSelect') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spShiftSelect AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spShiftSelect TO public'
END
GO
ALTER PROC dbo.spShiftSelect @shift_id int AS SET NOCOUNT ON SELECT * FROM dbo.vwShift WHERE ShiftID = @shift_id
GO
IF OBJECT_id('dbo.spShiftList') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spShiftList AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spShiftList TO public'
END
GO
ALTER PROC dbo.spShiftList AS SET NOCOUNT ON SELECT * FROM dbo.vwShift ORDER BY Shift
GO
IF OBJECT_id('dbo.spLicenseUpdateURL') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spLicenseUpdateURL AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spLicenseUpdateURL TO public'
END
GO
ALTER PROC dbo.spLicenseUpdateURL @url varchar(50) AS -- obsolete stored proc that may be called by very early clients
GO
IF OBJECT_id('dbo.spDepartmentSelect') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spDepartmentSelect AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spDepartmentSelect TO public'
END
GO
ALTER PROC dbo.spDepartmentSelect @department_id int AS SET NOCOUNT ON SELECT Department, DepartmentID FROM dbo.Department WHERE DepartmentID = @department_id
GO
IF OBJECT_ID('dbo.spLeaveLimitGetTargetTypeID') IS NOT NULL DROP PROC dbo.spLeaveLimitGetTargetTypeID
GO
IF OBJECT_id('dbo.spEmployeeDeductionListReportColumns') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEmployeeDeductionListReportColumns AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spEmployeeDeductionListReportColumns TO public'
END
GO
ALTER PROC dbo.spEmployeeDeductionListReportColumns
AS
SET NOCOUNT ON

CREATE TABLE #REPORT_COLUMNS(colid int PRIMARY KEY, [Name] sysname COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL, Caption sysname COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL, [Example] varchar(50) COLLATE SQL_Latin1_General_CP1_CI_AS NULL, [Group] varchar(50) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL, Flags int NOT NULL)

INSERT #REPORT_COLUMNS
SELECT 
CColumns.colid,
[Name] = CColumns.[name], 
Caption = dbo.GetCaptionForColumnName(CColumns.[name]),
Example = dbo.GetExampleForColumnName(CColumns.[name], NULL),
[Group] = dbo.GetGroupFromColumnName(CColumns.[name], 'Other'),
Flags = 0
FROM syscolumns CColumns
WHERE [ID]=OBJECT_ID('dbo.vwEmployeeSecure') AND dbo.IsColumnVisibleOnReport(CColumns.[name]) = 1

EXEC dbo.spReportFillColumnExamples 'dbo.vwEmployeeSecure', 'EmployeeID'

INSERT #REPORT_COLUMNS(colid,[Name],Caption,Example,[Group],Flags) VALUES(-1, 'Comment', 'Comment', '', 'Deduction', 0)
INSERT #REPORT_COLUMNS(colid,[Name],Caption,Example,[Group],Flags) VALUES(-2, 'Amount', 'Amount', '10.00', 'Deduction', 0)
INSERT #REPORT_COLUMNS(colid,[Name],Caption,Example,[Group],Flags) VALUES(-4, 'Deduction', 'Deduction', 'D', 'Deduction', 0)
INSERT #REPORT_COLUMNS(colid,[Name],Caption,Example,[Group],Flags) VALUES(-5, 'Deduction Code', 'Deduction Code', 'D', 'Deduction', 0)
INSERT #REPORT_COLUMNS(colid,[Name],Caption,Example,[Group],Flags) VALUES(-6, 'List As', 'Employee', 'Doe, John', 'Deduction', 0)

SELECT * FROM #REPORT_COLUMNS ORDER BY CASE WHEN [Group] = 'Name' THEN '_' ELSE '' END + [Group], Caption
GO
IF OBJECT_id('dbo.spEmployeeReviewListReportColumns') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEmployeeReviewListReportColumns AS'
	GRANT EXEC ON dbo.spEmployeeReviewListReportColumns TO public
END
GO
ALTER PROC dbo.spEmployeeReviewListReportColumns
AS
SET NOCOUNT ON

CREATE TABLE #REPORT_COLUMNS(colid int PRIMARY KEY, [Name] sysname COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL, Caption sysname COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL, [Example] varchar(50) COLLATE SQL_Latin1_General_CP1_CI_AS NULL, [Group] varchar(50) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL, Flags int NOT NULL)

INSERT #REPORT_COLUMNS
SELECT 
CColumns.colid,
[Name] = CColumns.[name], 
Caption = dbo.GetCaptionForColumnName(CColumns.[name]),
Example = dbo.GetExampleForColumnName(CColumns.[name], NULL),
[Group] = dbo.GetGroupFromColumnName(CColumns.[name], 'Other'),
Flags = 0
FROM syscolumns CColumns
WHERE [ID]=OBJECT_ID('dbo.vwEmployeeSecure') AND dbo.IsColumnVisibleOnReport(CColumns.[name]) = 1

EXEC dbo.spReportFillColumnExamples 'dbo.vwEmployeeSecure', 'EmployeeID'
			
INSERT #REPORT_COLUMNS(colid,[Name],Caption,Example,[Group],Flags) VALUES(-1, 'Comment', 'Comment', '', 'Review', 0)
INSERT #REPORT_COLUMNS(colid,[Name],Caption,Example,[Group],Flags) VALUES(-2, 'Date', 'Date', 'Feb 2,2010', 'Review', 0)
INSERT #REPORT_COLUMNS(colid,[Name],Caption,Example,[Group],Flags) VALUES(-3, 'Changed Salary', 'Changed Salary', 'Yes', 'Review', 0)
INSERT #REPORT_COLUMNS(colid,[Name],Caption,Example,[Group],Flags) VALUES(-4, 'Type', 'Type', 'Annual', 'Review', 0)
INSERT #REPORT_COLUMNS(colid,[Name],Caption,Example,[Group],Flags) VALUES(-5, 'Rating', 'Rating', 'Satisfactory', 'Review', 0)
INSERT #REPORT_COLUMNS(colid,[Name],Caption,Example,[Group],Flags) VALUES(-6, 'Reviewed By', 'Reviewed By', 'Jones, Brad M', 'Review', 0)
INSERT #REPORT_COLUMNS(colid,[Name],Caption,Example,[Group],Flags) VALUES(-7, 'Reviewed By Initials', 'Reviewed By', 'BMJ', 'Review', 0)
INSERT #REPORT_COLUMNS(colid,[Name],Caption,Example,[Group],Flags) VALUES(-8, 'Employee', 'Employee', 'Doe, John', 'Review', 0)

SELECT * FROM #REPORT_COLUMNS ORDER BY CASE WHEN [Group] = 'Name' THEN '_' ELSE '' END + [Group], Caption
GO
IF OBJECT_id('dbo.spEmployeeReviewList2') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEmployeeReviewList2 AS'
	GRANT EXEC ON dbo.spEmployeeReviewList2 TO public
END
GO
ALTER PROC dbo.spEmployeeReviewList2
	@batch_id int,
	@start_day int,
	@stop_day int,
	@flags int, -- 1: extended join vwemployeesecure
	@authorized bit out
AS
SET NOCOUNT ON

EXEC dbo.spPermissionGetOnPeopleForCurrentUser2 @batch_id, 16384
DELETE TempX WHERE BatchID=@batch_id AND X & 1 = 0
SELECT @authorized=CASE WHEN @@ROWCOUNT=0 THEN 1 ELSE 0 END

IF (@flags & 1) = 0
BEGIN
	SELECT E.ReviewID, E.Comment, E.EmployeeID, E.[Day past 1900],
	[Date] = dbo.GetDateFromDaysPast1900(E.[Day past 1900]),
	E.TypeID, E.RatingID, E.ReviewedByEmployeeID,E.[Changed Salary],
	T.[Type], R.Rating,
	[Employee] = dbo.fnGetListAs(V.[First Name], V.[Middle Name], V.[Last Name], V.Suffix),
	[Reviewed By] = CASE WHEN RV.PersonID IS NULL THEN '' ELSE dbo.fnGetListAs(RV.[First Name], RV.[Middle Name], RV.[Last Name], RV.Suffix) END,
	[Reviewed by Initials] = CASE WHEN RV.PersonID IS NULL THEN '' ELSE dbo.fnGetInitials(RV.[First Name], RV.[Middle Name], RV.[Last Name]) END
	FROM dbo.EmployeeReview E
	INNER JOIN dbo.TempX X ON X.BatchID = @batch_id AND X.[ID] = E.EmployeeID AND E.[Day past 1900] BETWEEN @start_day AND @stop_day
	INNER JOIN dbo.Person V ON E.EmployeeID = V.PersonID
	INNER JOIN dbo.EmployeeReviewType T ON E.TypeID = T.TypeID
	INNER JOIN dbo.EmployeeReviewRating R ON E.RatingID = R.RatingID
	LEFT JOIN dbo.Person RV ON E.ReviewedByEmployeeID = RV.PersonID
END
ELSE
BEGIN
	SELECT E.ReviewID, E.Comment, E.EmployeeID, E.[Day past 1900],
	[Date] = dbo.GetDateFromDaysPast1900(E.[Day past 1900]),
	E.TypeID, E.RatingID, E.ReviewedByEmployeeID,E.[Changed Salary],
	T.[Type], R.Rating,
	[Employee] = dbo.fnGetListAs(V.[First Name], V.[Middle Name], V.[Last Name], V.Suffix),
	[Reviewed By] = CASE WHEN RV.PersonID IS NULL THEN '' ELSE dbo.fnGetListAs(RV.[First Name], RV.[Middle Name], RV.[Last Name], RV.Suffix) END,
	[Reviewed by Initials] = CASE WHEN RV.PersonID IS NULL THEN '' ELSE dbo.fnGetInitials(RV.[First Name], RV.[Middle Name], RV.[Last Name]) END,
	SECURE.*
	FROM dbo.EmployeeReview E
	INNER JOIN dbo.TempX X ON X.BatchID = @batch_id AND X.[ID] = E.EmployeeID AND E.[Day past 1900] BETWEEN @start_day AND @stop_day
	INNER JOIN dbo.Person V ON E.EmployeeID = V.PersonID
	INNER JOIN dbo.EmployeeReviewType T ON E.TypeID = T.TypeID
	INNER JOIN dbo.EmployeeReviewRating R ON E.RatingID = R.RatingID
	INNER JOIN dbo.vwEmployeeSecure SECURE ON SECURE.EID = E.EmployeeID
	LEFT JOIN dbo.Person RV ON E.ReviewedByEmployeeID = RV.PersonID
END
GO
IF OBJECT_ID('dbo.spEmployeeGetEmployeeIDFromEmployeeNumber') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEmployeeGetEmployeeIDFromEmployeeNumber AS'
	GRANT EXEC ON dbo.spEmployeeGetEmployeeIDFromEmployeeNumber TO public
END
GO
ALTER PROC dbo.spEmployeeGetEmployeeIDFromEmployeeNumber
	@number varchar(50),
	@employee_id int out
AS
SET @employee_id = NULL
SELECT @employee_id = EmployeeID FROM Employee WHERE [Employee Number] = @number

-- Removes leading zeros and tries match again
IF @employee_id IS NULL AND ISNUMERIC(@number) = 1
SELECT @employee_id = EmployeeID FROM dbo.Employee WHERE EmployeeNumberNumeric=CAST(@number AS numeric(38,6))
GO
IF OBJECT_ID('dbo.spOccurrenceLevelList') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spOccurrenceLevelList AS'
	GRANT EXEC ON dbo.spOccurrenceLevelList TO public
END
GO
ALTER PROC dbo.spOccurrenceLevelList @batch_id int, @type_id int, @day int AS
IF OBJECT_ID('dbo.spOccurrenceLevelList_Custom') IS NOT NULL EXEC sp_executesql N'EXEC dbo.spOccurrenceLevelList_Custom @batch_id, @type_id, @day', N'@batch_id int, @type_id int, @day int', @batch_id, @type_id, @day
ELSE
BEGIN
	SELECT Employee=P.[List As], [Level] = CAST('' AS varchar(50)), EmployeeID=[ID] FROM dbo.TempX X
	INNER JOIN dbo.vwPersonListAs P ON X.BatchID=@batch_id AND X.[ID]=P.PersonID
	DELETE dbo.TempX WHERE BatchID=@batch_id OR DATEDIFF(hour,Created,GETDATE()) > 1
END
GO
IF OBJECT_ID('dbo.spDocumentCacheInsert') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spDocumentCacheInsert AS'
	GRANT EXEC ON dbo.spDocumentCacheInsert TO public
END
GO
ALTER PROC dbo.spDocumentCacheInsert @employee_id int, @document sysname, @subfolder sysname, @path sysname, @document_id int OUT AS
INSERT dbo.DocumentCache(EmployeeID, Document, Subfolder, [Path]) VALUES(@employee_id, @document, @subfolder, @path)
SELECT @document_id = SCOPE_IDENTITY()
GO
IF OBJECT_ID('dbo.spDocumentCacheDelete') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spDocumentCacheDelete AS'
	GRANT EXEC ON dbo.spDocumentCacheDelete TO public
END
GO
ALTER PROC dbo.spDocumentCacheDelete @employee_id int AS
DELETE dbo.DocumentCache WHERE @employee_id IS NULL AND EmployeeID IS NULL OR (@employee_id = EmployeeID)
GO
IF OBJECT_ID('dbo.spDocumentCacheList') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spDocumentCacheList AS'
	GRANT EXEC ON dbo.spDocumentCacheList TO public
END
GO
ALTER PROC dbo.spDocumentCacheList @employee_id int AS
SELECT DocumentID, EmployeeID, Document, Subfolder, [Path], Created FROM dbo.Document WHERE (@employee_id IS NULL AND EmployeeID IS NULL) OR (@employee_id = EmployeeID) ORDER BY Subfolder, Document
GO
IF OBJECT_ID('dbo.spBatchClone') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spBatchClone AS'
	GRANT EXEC ON dbo.spBatchClone TO public
END
GO
ALTER PROC dbo.spBatchClone @old_batch_id int, @new_batch_id int out
AS
EXEC dbo.spAdminGetNextRandom @new_batch_id out
INSERT dbo.TempX(BatchID,[ID]) SELECT @new_batch_id,[ID] FROM TempX WHERE BatchID=@old_batch_id
GO
IF OBJECT_ID('dbo.spEmployeeListShifts') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEmployeeListShifts AS'
	GRANT EXEC ON dbo.spEmployeeListShifts TO public
END
GO
ALTER PROC dbo.spEmployeeListShifts @batch_id int
AS
EXEC dbo.spPermissionGetOnPeopleForCurrentUser2 @batch_id, 8
DELETE TempX WHERE BatchID = @batch_id AND (X & 1) = 0

SELECT S.ShiftID, S.Shift, S.[Seconds per Day], S.[Days On], S.[Days Off], S.[Start Day past 1900], S.FTE, S.[Start Seconds], S.DaysOn2, S.DaysOff2, Start = dbo.GetDateFromDaysPast1900(S.[Start Day past 1900]),
E.EmployeeID,
[Full Name] = dbo.fnGetFullName(P.[First Name], P.[Middle Name], P.[Last Name], P.Suffix),
[Employee] = dbo.fnGetFullName(P.[First Name], P.[Middle Name], P.[Last Name], P.Suffix),
[Initials] = dbo.fnGetInitials(P.[First Name], P.[Middle Name], P.[Last Name]),
HolidayPlanID,
S.Flags, S.[Grace Seconds], S.[Lunch Start], S.[Lunch Seconds], S.[Stop Seconds]
FROM
dbo.Employee E
INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID]=E.EmployeeID
INNER JOIN dbo.Person P ON E.EmployeeID=P.PersonID
INNER JOIN dbo.Shift S ON E.ShiftID=S.ShiftID
ORDER BY P.[Last Name], P.[First Name], P.[Middle Name]

DELETE TempX WHERE BatchID = @batch_id OR DATEDIFF(hour,Created,GETDATE()) > 1
GO
IF OBJECT_ID('dbo.spPersonListInitials') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spPersonListInitials AS'
	GRANT EXEC ON dbo.spPersonListInitials TO public
END
GO
ALTER PROC dbo.spPersonListInitials @batch_id int AS
SELECT Initials = dbo.fnGetInitials([First Name], [Middle Name], [Last Name]), PersonID FROM dbo.Person P
INNER JOIN dbo.TempX T ON T.BatchID=@batch_id AND T.[ID]=P.PersonID
GO
IF OBJECT_ID('dbo.spTrainingInsert') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spTrainingInsert AS'
GO
ALTER PROC dbo.spTrainingInsert
	@training varchar(50),
	@training_id int OUT
AS
IF NOT EXISTS(SELECT * FROM dbo.Training) AND EXISTS(SELECT * FROM dbo.EmployeeCourseEvent)
RAISERROR(N'Please close this software and install the update from http://ihrsoftware.com/ftp/apexsetup_nomsi.exe',16,1)
ELSE
BEGIN
	INSERT Training(Training) VALUES(@training)
	SELECT @training_id = @@IDENTITY
END
GO
IF OBJECT_id('dbo.spCompanyGetExtendedFeatures') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spCompanyGetExtendedFeatures AS'
GRANT EXEC ON dbo.spCompanyGetExtendedFeatures TO public
GO
ALTER PROC dbo.spCompanyGetExtendedFeatures @mask int OUT AS
SET @mask = 1
IF EXISTS(SELECT * FROM dbo.Training) SET @mask = @mask | 2
GO
IF OBJECT_id('dbo.spCourseGetName') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spCourseGetName AS'
GRANT EXEC ON dbo.spCourseGetName TO public
GO
ALTER PROC dbo.spCourseGetName
	@course_id int, @course varchar(50) out
AS
SELECT @course = Course FROM dbo.Course WHERE CourseID=@course_id
GO
IF OBJECT_id('dbo.spCourseInsert') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spCourseInsert AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spCourseInsert TO public'
END
GO
ALTER PROC dbo.spCourseInsert
	@flags int, @type_id int, @course varchar(50), @abbreviated_name varchar(12), @course_id int out, @next int = NULL
AS
INSERT dbo.Course(TypeID, Course, [Abbreviated Name], Flags, [Next Day past 1900])
VALUES (@type_id, @course, @abbreviated_name, @flags, @next)
SET @course_id = SCOPE_IDENTITY()
GO
IF OBJECT_id('dbo.spCourseUpdate') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spCourseUpdate AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spCourseUpdate TO public'
END
GO
ALTER PROC dbo.spCourseUpdate
	@flags int, @type_id int, @course varchar(50), @abbreviated_name varchar(12), @course_id int, @next int = NULL
AS
UPDATE dbo.Course SET Flags=@flags, TypeID=@type_id,Course=@course,[Abbreviated Name]=@abbreviated_name,[Next Day past 1900]=@next WHERE CourseID=@course_id
GO
IF OBJECT_id('dbo.spCourseDelete') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spCourseDelete AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spCourseDelete TO public'
END
GO
ALTER PROC dbo.spCourseDelete
	@course_id int
AS
DELETE dbo.Course WHERE CourseID=@course_id
GO
IF OBJECT_id('dbo.spCourseList') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spCourseList AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spCourseList TO public'
END
GO
ALTER PROC dbo.spCourseList
	@type_id int, @active bit, @course_id int, @or_course_id int, @type_batch_id int, @course_batch_id int,
	@flags int -- 1: don't clear types batch
AS
DECLARE @temp_course_batch_id int
SET @temp_course_batch_id = RAND() * 2147483647

IF @type_id IS NOT NULL
BEGIN
	INSERT dbo.TempX(BatchID,[ID]) SELECT @temp_course_batch_id, CourseID FROM dbo.Course C WHERE C.TypeID=@type_id
END
ELSE IF @type_batch_id IS NOT NULL
BEGIN
	INSERT dbo.TempX(BatchID,[ID]) SELECT @temp_course_batch_id, CourseID FROM dbo.Course C
	INNER JOIN dbo.TempX CTX ON CTX.BatchID = @type_batch_id AND CTX.[ID] = C.TypeID
END
ELSE IF @course_batch_id IS NULL
BEGIN
	INSERT dbo.TempX(BatchID,[ID]) SELECT @temp_course_batch_id, CourseID FROM dbo.Course C
END
ELSE
BEGIN
	SET @temp_course_batch_id = @course_batch_id
END

SELECT C.Flags,T.[Type],C.TypeID,C.Course,C.[Abbreviated Name],C.CourseID,[Next]=dbo.GetDateFromDaysPast1900([Next Day past 1900]) FROM dbo.Course C
INNER JOIN dbo.TempX X ON X.BatchID = @temp_course_batch_id AND X.[ID] = C.CourseID AND
	(@active IS NULL OR (C.Flags & 1) = @active) AND
	(@course_id IS NULL OR C.CourseID=@course_id) OR
	(@or_course_id IS NOT NULL AND @or_course_id = C.CourseID)
INNER JOIN dbo.CourseType T ON C.TypeID=T.TypeID
ORDER BY (C.Flags & 1) ^ 1, C.Course

DELETE dbo.TempX WHERE ((@flags & 1) = 0 AND BatchID IN (@course_batch_id, @type_batch_id)) OR (@course_batch_id IS NULL AND BatchID=@temp_course_batch_id) OR DATEDIFF(hour,Created,GETDATE()) > 1
GO
IF OBJECT_id('dbo.spEmployeeCourseInsert') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEmployeeCourseInsert AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spEmployeeCourseInsert TO public'
END
GO
ALTER PROC dbo.spEmployeeCourseInsert
	@employee_id int, @course_id int, @expires_day int, @flags int, @item_id int out
AS
DECLARE @authorized bit
EXEC dbo.spPermissionInsureForCurrentUserOnPerson @employee_id, 4096, 4, @authorized out

IF @authorized = 1
BEGIN
	INSERT dbo.EmployeeCourse(EmployeeID, CourseID, [Expires Day past 1900], Flags)
	VALUES (@employee_id, @course_id, @expires_day, @flags)
	SET @item_id = SCOPE_IDENTITY()
END
GO
IF OBJECT_id('dbo.spEmployeeCourseUpdate') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEmployeeCourseUpdate AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spEmployeeCourseUpdate TO public'
END
GO
ALTER PROC dbo.spEmployeeCourseUpdate
	@expires_day int, @flags int, @item_id int
AS
DECLARE @authorized bit, @employee_id int
SELECT @employee_id = EmployeeID FROM dbo.EmployeeCourse WHERE EmployeeCourseID=@item_id
EXEC dbo.spPermissionInsureForCurrentUserOnPerson @employee_id, 4096, 2, @authorized out
IF @authorized = 1 UPDATE dbo.EmployeeCourse SET [Expires Day past 1900]=@expires_day,Flags=@flags WHERE EmployeeCourseID=@item_id
GO
IF OBJECT_id('dbo.spEmployeeCourseDelete') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEmployeeCourseDelete AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spEmployeeCourseDelete TO public'
END
GO
ALTER PROC dbo.spEmployeeCourseDelete
	@item_id int
AS
DECLARE @authorized bit, @employee_id int
SELECT @employee_id = EmployeeID FROM dbo.EmployeeCourse WHERE EmployeeCourseID=@item_id
EXEC dbo.spPermissionInsureForCurrentUserOnPerson @employee_id, 4096, 8, @authorized out
IF @authorized = 1 DELETE dbo.EmployeeCourse WHERE EmployeeCourseID=@item_id
GO
IF OBJECT_id('dbo.spEmployeeCourseList') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEmployeeCourseList AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spEmployeeCourseList TO public'
END
GO
ALTER PROC dbo.spEmployeeCourseList
	@item_id int = NULL,
	
	@employee_id int = NULL,
	@employee_batch_id int = NULL,
	@active_employees bit = NULL,
	
	@course_id int = NULL,
	@course_batch_id int = NULL,
	@course_type_id int = NULL,
	@course_type_batch_id int = NULL,
	@active_courses bit = NULL,
	
	@credit_type_id int = NULL,
	@credits_less_than_equal_to numeric(9,4) = 99999.9999,
	@credits_greater_than_equal_to numeric(9,4) = -99999.9999,
	
	@status_mask int = 0x7FFFFFFF,
	@completed_start_day int = NULL,
	@completed_stop_day int = NULL,
	@expired_as_of_day int = NULL,
	@expired_reference int = NULL,
	@not_expired_as_of_day int = NULL,
	@verified bit = NULL,
	@flags int = 0, -- 1: extended (return vwEmployeeSecure for selected employees), 2: ExcludeEmployeesThatMetAllRequirements, 4: ExcludeEntriesThatMetRequirements, 8: return employee course credits, 16: ExcludeEmployeesWhoCompletedAllCourses, 32: ExcludeUnusedCourses
	@authorized bit = 1 OUT -- earlist version did not support this parameter
AS
IF @expired_reference IS NULL SET @expired_reference = DATEDIFF(d,0,GETDATE())

IF @employee_batch_id IS NULL
BEGIN
	SET @employee_batch_id = RAND() * 2147483647
	IF @item_id IS NOT NULL INSERT dbo.TempX(BatchID,[ID]) SELECT @employee_batch_id, EmployeeID FROM dbo.EmployeeCourse WHERE EmployeeCourseID=@item_id
	ELSE IF @employee_id IS NULL INSERT dbo.TempX(BatchID,[ID]) SELECT @employee_batch_id,EmployeeID FROM dbo.Employee WHERE @active_employees IS NULL OR [Active Employee]=@active_employees
	ELSE INSERT dbo.TempX(BatchID,[ID]) VALUES(@employee_batch_id, @employee_id)
END

EXEC dbo.spPermissionGetOnPeopleForCurrentUser2 @employee_batch_id, 4096
DELETE dbo.TempX WHERE BatchID=@employee_batch_id AND (X & 1) = 0
SELECT @authorized = CASE WHEN @@ROWCOUNT=0 THEN 1 ELSE 0 END

IF @course_batch_id IS NULL
BEGIN
	SET @course_batch_id = RAND() * 2147483647
	IF @item_id IS NOT NULL INSERT dbo.TempX(BatchID,[ID]) SELECT @course_batch_id, CourseID FROM dbo.EmployeeCourse WHERE EmployeeCourseID=@item_id
	ELSE IF @course_type_batch_id IS NOT NULL
	BEGIN
		INSERT dbo.TempX(BatchID,[ID]) SELECT @course_batch_id,C.CourseID FROM dbo.Course C
		INNER JOIN dbo.TempX CT ON CT.BatchID= @course_type_batch_id AND C.TypeID=CT.[ID] AND (@active_courses IS NULL OR (C.Flags & 1) = @active_courses)
	END
	ELSE
	BEGIN
		INSERT dbo.TempX(BatchID,[ID])
		SELECT @course_batch_id, C.CourseID FROM dbo.Course C WHERE (@course_id IS NULL OR C.CourseID=@course_id) AND (@course_type_id IS NULL OR C.TypeID = @course_type_id) AND (@active_courses IS NULL OR ((C.Flags & 1) = @active_courses))
	END
END


DECLARE @ec_batch_id int
SET @ec_batch_id = RAND() * 2147483647

INSERT dbo.TempXYZ(BatchID,[ID],X,Y,I,J,Z)
SELECT BatchID=@ec_batch_id, [ID_EmployeeCourseID]=EC.EmployeeCourseID, X_ExpiresDayPast1900 = EC.[Expires Day past 1900], Y_Flags = EC.Flags, I_EmployeeID = EC.EmployeeID, J_CourseID = EC.CourseID, Z__ItemIDOfLastCompletedEvent = (
	SELECT TOP 1 E.ItemID FROM dbo.EmployeeCourseEvent E WHERE E.EmployeeCourseID=EC.EmployeeCourseID  AND
		(@completed_start_day IS NULL OR E.[Completed Day past 1900] > @completed_start_day) AND
		(@completed_stop_day IS NULL OR E.[Completed Day past 1900] < @completed_stop_day) AND
		(@status_mask = 0x7FFFFFFF OR E.StatusID=@status_mask OR (E.StatusID & @status_mask) > 0) AND
		(@verified IS NULL OR (E.Flags & 1) = @verified)
	ORDER BY E.[Completed Day past 1900] DESC
)
FROM dbo.EmployeeCourse EC
INNER JOIN dbo.TempX EX ON EX.BatchID = @employee_batch_id AND EX.[ID] = EC.EmployeeID AND
	-- (@item_id IS NULL OR EC.EmployeeCourseID=@item_id) AND -- NOT NEEDED. Handled in batch filters above
	((@flags & 4) = 0 OR (EC.Flags & 1) = 1) AND -- If fullfilled requirements will be excluded, then exclude all optional courses
	(@expired_as_of_day IS NULL OR (EC.[Expires Day past 1900] IS NOT NULL AND EC.[Expires Day past 1900] <= @expired_as_of_day)) AND
	(@not_expired_as_of_day IS NULL OR EC.[Expires Day past 1900] IS NULL AND (EC.[Expires Day past 1900] IS NOT NULL AND EC.[Expires Day past 1900] > @not_expired_as_of_day))
INNER JOIN dbo.TempX CX ON CX.BatchID = @course_batch_id AND CX.[ID] = EC.CourseID

-- Exclude training that was not completed during range
IF @completed_start_day IS NOT NULL OR @completed_stop_day IS NOT NULL
DELETE XYZ FROM dbo.TempXYZ XYZ WHERE BatchID = @ec_batch_id AND Z /*ItemIDOfLastCompletedEvent*/ IS NULL

-- Exclude all entries that met requirements
IF (@flags & 4) = 4
BEGIN
	DELETE XYZ FROM dbo.TempXYZ XYZ WHERE BatchID = @ec_batch_id AND -- optional courses have already been excluded
	(
		(XYZ.X IS NULL AND Z IS NOT NULL) OR -- Expiration date is null and last completed is not null
		(XYZ.X IS NOT NULL AND XYZ.X <= @expired_reference) -- Expiration date preceeds reference
	)
END

-- Exclude people who met all requirements
IF (@flags & 2) = 2
BEGIN
	DELETE dbo.TempXYZ WHERE BatchID = @ec_batch_id AND I NOT IN (
		SELECT DISTINCT EmployeeID=X2.I FROM dbo.TempXYZ X2 WHERE BatchID = @ec_batch_id AND (X2.Y & 1) = 1 AND (X2.Z IS NULL OR (X2.X IS NOT NULL AND X2.X <= @expired_reference))
	)
END

-- Excludes courses with no people who completed them
/*IF (@flags & 32) = 32
BEGIN

	DELETE dbo.TempXYZ WHERE BatchID = @ec_batch_id AND J NOT IN (
		SELECT DISTINCT CourseID = X.J FROM dbo.TempXYZ X WHERE X.BatchID=@ec_batch_id AND X.Z IS NOT NULL
	)
END*/

-- Exclude people who completed all courses
/*IF (@flags & 16) = 16
BEGIN
	DELETE dbo.TempXYZ WHERE BatchID = @ec_batch_id AND I NOT IN (
		-- Expired courses and courses that were never completed
		SELECT DISTINCT EmployeeID=X2.I FROM dbo.TempXYZ X2 WHERE BatchID = @ec_batch_id AND (X2.Z IS NULL OR (X2.X IS NOT NULL AND X2.X <= @expired_reference))
	) AND I NOT IN
	(
		-- Employees with no course entries (in selected course list)
		SELECT DISTINCT E.[ID]
		FROM dbo.TempX E
		CROSS JOIN dbo.TempX C
		LEFT JOIN dbo.EmployeeCourse EC ON E.BatchID = @employee_batch_id AND C.BatchID = @course_batch_id AND EC.EmployeeID = E.[ID] AND EC.CourseID = C.[ID]
		WHERE EC.EmployeeCourseID IS NULL
	)
END*/

SELECT EC.EmployeeCourseID,EC.EmployeeID,EC.CourseID,EC.Flags,EC.[Expires Day past 1900],
Expires=dbo.GetDateFromDaysPast1900(EC.[Expires Day past 1900]),
T.[Type],C.TypeID,C.Course,C.[Abbreviated Name], [Course Flags] = C.Flags,
[Employee] = dbo.fnGetListAs(P.[First Name], P.[Middle Name], P.[Last Name], P.Suffix),
[Last Completed] = dbo.GetDateFromDaysPast1900(ECE.[Completed Day past 1900]),
[LastStatusID] = ECE.StatusID,
[LastEventFlags] = ISNULL(ECE.Flags, 0),
[Last Cost] = ISNULL(ECE.Cost, 0),
[Last Location] = ISNULL(ECE.Location, ''),
[Last Comment] = ISNULL(ECE.Comment, ''),
[Last Status] = ISNULL(S.[Status], ''),
[Last Verified] = CAST(CASE WHEN ECE.ItemID IS NULL THEN 0 ELSE (ECE.Flags & 1) END AS bit),
Required = CAST(EC.Flags & 1 AS bit)

FROM dbo.EmployeeCourse EC
INNER JOIN dbo.TempXYZ ECX ON ECX.BatchID=@ec_batch_id AND ECX.[ID]=EC.EmployeeCourseID
INNER JOIN dbo.Course C ON EC.CourseID=C.CourseID
INNER JOIN dbo.Employee E ON EC.EmployeeID = E.EmployeeID
INNER JOIN dbo.CourseType T ON C.TypeID=T.TypeID 
INNER JOIN dbo.Person P ON EC.EmployeeID = P.PersonID
LEFT JOIN dbo.EmployeeCourseEvent ECE ON ECX.Z = ECE.ItemID
LEFT JOIN dbo.EmployeeCourseEventStatus S ON ECE.StatusID = S.StatusID
ORDER BY C.Course, P.[Last Name], P.[First Name], P.[Middle Name]

IF (@flags & 1) = 1 SELECT S.* FROM dbo.vwEmployeeSecure S WHERE S.EID IN (
	SELECT I FROM dbo.TempXYZ WHERE BatchID = @ec_batch_id
)

IF (@flags & 8) = 8 
BEGIN
	SELECT DISTINCT ECC.CreditTypeID, T.[Type]
	INTO #DistinctCreditTypes
	FROM dbo.TempXYZ ECX
	INNER JOIN dbo.EmployeeCourseCredit ECC ON ECX.BatchID=@ec_batch_id AND ECX.[ID]=ECC.EmployeeCourseID
	INNER JOIN dbo.CreditType T ON ECC.CreditTypeID = T.CreditTypeID
	
	-- Credits for each employee course\credit type
	SELECT ECC.EmployeeCourseID, ECC.CreditTypeID, T.[Type], ECC.Credits, [Order] = 0
	INTO #Result
	FROM dbo.TempXYZ ECX
	INNER JOIN dbo.EmployeeCourseCredit ECC ON ECX.BatchID=@ec_batch_id AND ECX.[ID]=ECC.EmployeeCourseID
	INNER JOIN dbo.CreditType T ON ECC.CreditTypeID = T.CreditTypeID
	
	INSERT #Result
	
	-- 0 credits for each missing employee course\credittype
	SELECT EmployeeCourseID=ECX.[ID], #DistinctCreditTypes.CreditTypeID, #DistinctCreditTypes.[Type], Credits=0, [Order] = 0
	FROM dbo.TempXYZ ECX
	CROSS JOIN #DistinctCreditTypes WHERE ECX.BatchID=@ec_batch_id AND NOT EXISTS (
		SELECT * FROM dbo.EmployeeCourseCredit ECC WHERE ECC.EmployeeCourseID=ECX.[ID] AND ECC.CreditTypeID=#DistinctCreditTypes.CreditTypeID
	)
	
	
	SELECT * FROM #Result
	
	UNION ALL

	-- Total for each employee course
	SELECT EmployeeCourseID, CreditTypeID = MIN(CreditTypeID) - 1, 'Total', Credits = SUM(Credits), [Order] = 1
	FROM #Result WHERE (SELECT COUNT(DISTINCT CreditTypeID) FROM #Result) > 1
	GROUP BY EmployeeCourseID
	ORDER BY EmployeeCourseID, [Order], [Type], CreditTypeID
	
END

DELETE dbo.TempX WHERE BatchID IN (@employee_batch_id, @course_batch_id) OR DATEDIFF(hour,Created,GETDATE()) > 1
DELETE dbo.TempXYZ WHERE BatchID=@ec_batch_id OR DATEDIFF(hour,Created,GETDATE()) > 1
GO
IF OBJECT_id('dbo.spEmployeeCourseEventInsert') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEmployeeCourseEventInsert AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spEmployeeCourseEventInsert TO public'
END
GO
ALTER PROC dbo.spEmployeeCourseEventInsert
	@employee_course_id int, @cost money, @completed_day int, @location varchar(50), @comment varchar(50), @flags int, @status_id int, @item_id int out
AS
INSERT dbo.EmployeeCourseEvent(EmployeeCourseID, Cost, [Completed Day past 1900], [Location], [Comment], StatusID, Flags)
VALUES (@employee_course_id, @cost, @completed_day, @location, @comment, @status_id, @flags)
SET @item_id = SCOPE_IDENTITY()
GO
IF OBJECT_id('dbo.spEmployeeCourseEventUpdate') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEmployeeCourseEventUpdate AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spEmployeeCourseEventUpdate TO public'
END
GO
ALTER PROC dbo.spEmployeeCourseEventUpdate
	@cost money, @completed_day int, @location varchar(50), @comment varchar(50), @flags int, @status_id int, @item_id int
AS
UPDATE dbo.EmployeeCourseEvent SET Cost=@cost,[Completed Day past 1900]=@completed_day,Location=@location,Comment=@comment,Flags=@flags,StatusID=@status_id WHERE ItemID=@item_id
GO
IF OBJECT_id('dbo.spEmployeeCourseEventDelete') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEmployeeCourseEventDelete AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spEmployeeCourseEventDelete TO public'
END
GO
ALTER PROC dbo.spEmployeeCourseEventDelete
	@item_id int
AS
DELETE dbo.EmployeeCourseEvent WHERE ItemID=@item_id
GO
IF OBJECT_id('dbo.spEmployeeCourseEventList') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEmployeeCourseEventList AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spEmployeeCourseEventList TO public'
END
GO
ALTER PROC dbo.spEmployeeCourseEventList
	@item_id int = NULL,
	@employee_course_id int = NULL,
	@course_id int = NULL,
	@employee_id int = NULL,
	@completed_start int = -2147483648,
	@completed_stop int = 2147483647,
	@type_id int = NULL,
	@status_mask int = 0x7FFFFFFF,
	@verified bit = NULL
AS
SELECT 
ECE.ItemID, ECE.[Completed Day past 1900], Completed = dbo.GetDateFromDaysPast1900(ECE.[Completed Day past 1900]), ECE.Cost, ECE.Location, ECE.Comment, ECE.Flags,
ECE.StatusID, S.[Status],
EC.EmployeeCourseID,EC.EmployeeID,EC.CourseID,[Employee Course Flags] = EC.Flags,EC.[Expires Day past 1900],Expires=dbo.GetDateFromDaysPast1900(EC.[Expires Day past 1900]),
T.[Type],C.TypeID,C.Course,C.[Abbreviated Name], [Course Flags]=C.Flags,
[Employee] = dbo.fnGetListAs(P.[First Name], P.[Middle Name], P.[Last Name], P.Suffix)
FROM dbo.EmployeeCourseEvent ECE
INNER JOIN dbo.EmployeeCourseEventStatus S ON ECE.StatusID = S.StatusID AND
	(@status_mask = 0x7FFFFFFF OR ECE.StatusID=@status_mask OR (ECE.StatusID & @status_mask) > 0) AND -- filter
	(@item_id IS NULL OR ECE.ItemID=@item_id) AND -- filter
	(@employee_course_id IS NULL OR ECE.EmployeeCourseID=@employee_course_id) AND -- filter
	(@verified IS NULL OR (ECE.Flags & 1) = @verified)
INNER JOIN dbo.EmployeeCourse EC ON ECE.EmployeeCourseID = EC.EmployeeCourseID AND
	(@course_id IS NULL OR EC.CourseID=@course_id) AND -- filter
	ECE.[Completed Day past 1900] BETWEEN ISNULL(@completed_start, -2147483648) AND ISNULL(@completed_stop, 2147483647) -- filter
INNER JOIN dbo.Course C ON EC.CourseID = C.CourseID AND
	(@type_id IS NULL OR C.TypeID=@type_id) -- filter
INNER JOIN dbo.CourseType T ON C.TypeID=T.TypeID 
INNER JOIN dbo.Person P ON EC.EmployeeID = P.PersonID
ORDER BY C.Course, ECE.[Completed Day past 1900] DESC
GO
IF OBJECT_id('dbo.spEmployeeListPositions') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEmployeeListPositions AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spEmployeeListPositions TO public'
END
GO
ALTER PROC dbo.spEmployeeListPositions
	@batch_id int = NULL,
	@flags int = 0 -- 1: don't clear batch, 2: sort by employee (default is position)
AS
IF @batch_id IS NULL
BEGIN
	SET @batch_id=RAND() * 2147483647
	INSERT dbo.TempX(BatchID,[ID]) SELECT @batch_id,EmployeeID FROM dbo.Employee WHERE [Active Employee]=1
END

EXEC dbo.spPermissionGetOnPeopleForCurrentUser2 @batch_id, 8

SELECT E.EmployeeID, 
[Last Position] = CASE
	WHEN (PERMISSION.X & 1) = 0 OR P.[Job Title] IS NULL THEN ''
	ELSE P.[Job Title]
END,
Employee = dbo.fnGetListAs(PERS.[First Name], PERS.[Middle Name], PERS.[Last Name], PERS.Suffix),
Department = CASE WHEN PERMISSION.[ID] IS NULL THEN '' ELSE D.Department END,
Division = CASE WHEN PERMISSION.[ID] IS NULL THEN '' ELSE V.Division END
FROM dbo.Employee E
INNER JOIN dbo.TempX PERMISSION ON PERMISSION.BatchID=@batch_id AND E.EmployeeID = PERMISSION.[ID]
INNER JOIN dbo.Person PERS ON E.EmployeeID = PERS.PersonID AND E.[Active Employee]=1
INNER JOIN dbo.Department D ON E.DepartmentID = D.DepartmentID
INNER JOIN dbo.Division V ON E.DivisionID = V.DivisionID
LEFT JOIN dbo.EmployeeCompensation EC ON E.LastCompensationID = EC.CompensationID
LEFT JOIN dbo.Position P ON EC.PositionID = P.PositionID
ORDER BY CASE
	WHEN (@flags & 2) = 2 OR P.[Job Title] IS NULL THEN ''
	ELSE P.[Job Title]
END, PERS.[Last Name], PERS.[First Name], PERS.[Middle Name]

IF (@flags & 1) = 0 DELETE dbo.TempX WHERE BatchID=@batch_id OR DATEDIFF(hour,Created,GETDATE()) > 1
GO
IF OBJECT_id('dbo.spEmployeeCourseCreditInsert') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEmployeeCourseCreditInsert AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spEmployeeCourseCreditInsert TO public'
END
GO
ALTER PROC dbo.spEmployeeCourseCreditInsert
	@employee_course_id int, @type_id int, @credits numeric(9,4), @item_id int OUT
AS
INSERT dbo.EmployeeCourseCredit(EmployeeCourseID, CreditTypeID, Credits) VALUES(@employee_course_id, @type_id, @credits)
SET @item_id = SCOPE_IDENTITY()
GO
IF OBJECT_id('dbo.spEmployeeCourseCreditUpdate') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEmployeeCourseCreditUpdate AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spEmployeeCourseCreditUpdate TO public'
END
GO
ALTER PROC dbo.spEmployeeCourseCreditUpdate
	@credits numeric(9,4), @item_id int OUT
AS
UPDATE dbo.EmployeeCourseCredit SET Credits=@credits WHERE ItemID=@item_id
GO
IF OBJECT_id('dbo.spEmployeeCourseCreditDelete') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEmployeeCourseCreditDelete AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spEmployeeCourseCreditDelete TO public'
END
GO
ALTER PROC dbo.spEmployeeCourseCreditDelete
	@item_id int
AS
DELETE dbo.EmployeeCourseCredit WHERE ItemID=@item_id
GO
IF OBJECT_id('dbo.spEmployeeCourseCreditList') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEmployeeCourseCreditList AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spEmployeeCourseCreditList TO public'
END
GO
ALTER PROC dbo.spEmployeeCourseCreditList
	@item_id int = NULL,
	@employee_course_id int = NULL,
	@credit_type_id int = NULL
AS
SELECT 
ECC.ItemID, ECC.Credits,ECC.CreditTypeID,
[Credit Type]=CT.[Type], [Abbreviated Credit Type] = CT.[Abbreviated Type],EC.EmployeeCourseID,EC.EmployeeID,EC.CourseID,[Employee Course Flags] = EC.Flags,
C.Course,C.[Abbreviated Name], [Course Flags]=C.Flags,
[Employee] = dbo.fnGetListAs(P.[First Name], P.[Middle Name], P.[Last Name], P.Suffix)
FROM dbo.EmployeeCourseCredit ECC
INNER JOIN dbo.CreditType CT ON
	(@item_id IS NULL OR ECC.ItemID=@item_id) AND -- filter
	(@employee_course_id IS NULL OR ECC.EmployeeCourseID=@employee_course_id) AND -- filter
	(@credit_type_id IS NULL OR ECC.CreditTypeID = @credit_type_id) AND -- filter
	ECC.CreditTypeID = CT.CreditTypeID
INNER JOIN dbo.EmployeeCourse EC ON ECC.EmployeeCourseID = EC.EmployeeCourseID
INNER JOIN dbo.Course C ON EC.CourseID = C.CourseID 
INNER JOIN dbo.Person P ON EC.EmployeeID = P.PersonID
ORDER BY P.[Last Name], P.[First Name], P.[Middle Name], CT.[Type]
GO
IF OBJECT_id('dbo.spCourseCreditInsert') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spCourseCreditInsert AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spCourseCreditInsert TO public'
END
GO
ALTER PROC dbo.spCourseCreditInsert
	@course_id int, @type_id int, @credits numeric(9,4), @item_id int OUT
AS
INSERT dbo.CourseCredit(CourseID, CreditTypeID, Credits) VALUES(@course_id, @type_id, @credits)
SET @item_id = SCOPE_IDENTITY()
GO
IF OBJECT_id('dbo.spCourseCreditUpdate') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spCourseCreditUpdate AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spCourseCreditUpdate TO public'
END
GO
ALTER PROC dbo.spCourseCreditUpdate
	@credits numeric(9,4), @type_id int, @item_id int OUT
AS
UPDATE dbo.CourseCredit SET Credits=@credits, CreditTypeID=@type_id WHERE ItemID=@item_id
GO
IF OBJECT_id('dbo.spCourseCreditDelete') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spCourseCreditDelete AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spCourseCreditDelete TO public'
END
GO
ALTER PROC dbo.spCourseCreditDelete
	@item_id int
AS
DELETE dbo.CourseCredit WHERE ItemID=@item_id
GO
IF OBJECT_id('dbo.spCourseCreditList') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spCourseCreditList AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spCourseCreditList TO public'
END
GO
ALTER PROC dbo.spCourseCreditList
	@item_id int = NULL,
	@course_id int = NULL,
	@type_id int = NULL,
	@active bit = NULL,
	@flags int = 0
AS
SELECT 
CC.ItemID, CC.Credits,
Flags = 0,
CT.CreditTypeID,[Credit Type]=CT.[Type], [Abbreviated Credit Type] = CT.[Abbreviated Type],
C.CourseID,C.Course,C.[Abbreviated Name], [Course Flags]=C.Flags
FROM dbo.CourseCredit CC
INNER JOIN dbo.Course C ON CC.CourseID=C.CourseID AND
	(@active IS NULL OR (C.Flags & 1) = @active) AND -- filter
	(@item_id IS NULL OR CC.ItemID=@item_id) AND -- filter
	(@course_id IS NULL OR C.CourseID=@course_id) -- filter
INNER JOIN dbo.CreditType CT ON CC.CreditTypeID=CT.CreditTypeID AND
	(@type_id IS NULL OR CT.CreditTypeID = @type_id) -- filter
ORDER BY C.Course, CT.[Type] DESC
GO
IF OBJECT_id('dbo.spCourseTypeInsert') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spCourseTypeInsert AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spCourseTypeInsert TO public'
END
GO
ALTER PROC dbo.spCourseTypeInsert @type varchar(50), @type_id int OUT AS
INSERT dbo.CourseType([Type]) VALUES(@type)
SET @type_id = SCOPE_IDENTITY()
GO
IF OBJECT_id('dbo.spCourseTypeUpdate') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spCourseTypeUpdate AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spCourseTypeUpdate TO public'
END
GO
ALTER PROC dbo.spCourseTypeUpdate @type varchar(50), @type_id int AS
UPDATE dbo.CourseType SET [Type]=@type WHERE TypeID=@type_id
GO
IF OBJECT_id('dbo.spCourseTypeDelete') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spCourseTypeDelete AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spCourseTypeDelete TO public'
END
GO
ALTER PROC dbo.spCourseTypeDelete @type_id int, @assign_orphans_to_type_id int AS
IF @assign_orphans_to_type_id IS NOT NULL
BEGIN
	BEGIN TRAN
	UPDATE dbo.Course SET TypeID=@assign_orphans_to_type_id WHERE TypeID=@type_id
	DELETE dbo.CourseType WHERE TypeID=@type_id
	COMMIT TRAN
END
ELSE
BEGIN
	DELETE dbo.CourseType WHERE TypeID=@type_id
END
GO
IF OBJECT_id('dbo.spCourseTypeSelect') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spCourseTypeSelect AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spCourseTypeSelect TO public'
END
GO
ALTER PROC dbo.spCourseTypeSelect @type_id int AS
SELECT [Type],TypeID FROM dbo.CourseType WHERE TypeID=@type_id
GO
IF OBJECT_id('dbo.spCourseTypeList') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spCourseTypeList AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spCourseTypeList TO public'
END
GO
ALTER PROC dbo.spCourseTypeList AS
SELECT [Type],TypeID FROM dbo.CourseType ORDER BY [Type]
GO
IF OBJECT_id('dbo.spCourseTypeGetTypeFromTypeID') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spCourseTypeGetTypeFromTypeID AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spCourseTypeGetTypeFromTypeID TO public'
END
GO
ALTER PROC dbo.spCourseTypeGetTypeFromTypeID @type varchar(50) OUT, @type_id int AS
SELECT @type=[Type] FROM dbo.CourseType WHERE TypeID=@type_id
GO
IF OBJECT_id('dbo.spEmployeeCourseEventStatusList') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEmployeeCourseEventStatusList AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spEmployeeCourseEventStatusList TO public'
END
GO
ALTER PROC dbo.spEmployeeCourseEventStatusList AS SELECT [StatusID],[Status] FROM dbo.EmployeeCourseEventStatus ORDER BY [Order]
GO
IF OBJECT_id('dbo.spCreditTypeInsert') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spCreditTypeInsert AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spCreditTypeInsert TO public'
END
GO
ALTER PROC dbo.spCreditTypeInsert @type varchar(50), @abbreviation varchar(8), @type_id int OUT AS
INSERT dbo.CreditType([Type], [Abbreviated Type]) VALUES(@type, @abbreviation)
SELECT @type_id = SCOPE_IDENTITY()
GO
IF OBJECT_id('dbo.spCreditTypeUpdate') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spCreditTypeUpdate AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spCreditTypeUpdate TO public'
END
GO
ALTER PROC dbo.spCreditTypeUpdate @type varchar(50), @abbreviation varchar(8), @type_id int AS
UPDATE dbo.CreditType SET [Type]=@type, [Abbreviated Type]=@abbreviation WHERE CreditTypeID=@type_id
GO
IF OBJECT_id('dbo.spCreditTypeDelete') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spCreditTypeDelete AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spCreditTypeDelete TO public'
END
GO
ALTER PROC dbo.spCreditTypeDelete @type_id int, @assign_orphans_to_type_id int = NULL AS
IF @assign_orphans_to_type_id IS NOT NULL
BEGIN
	BEGIN TRAN
	UPDATE dbo.EmployeeCourseCredit SET CreditTypeID=@assign_orphans_to_type_id WHERE CreditTypeID=@type_id
	UPDATE dbo.CourseCredit SET CreditTypeID=@assign_orphans_to_type_id WHERE CreditTypeID=@type_id
	DELETE dbo.CreditType WHERE CreditTypeID=@type_id
	COMMIT TRAN
END
ELSE
BEGIN
	DELETE dbo.CreditType WHERE CreditTypeID=@type_id
END
GO
IF OBJECT_id('dbo.spCourseCreditPush') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spCourseCreditPush AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spCourseCreditPush TO public'
END
GO
-- Resets employee course credits to mach course defaults
ALTER PROC dbo.spCourseCreditPush @course_id int
AS
BEGIN TRAN

DELETE ECC FROM dbo.EmployeeCourseCredit ECC WHERE ECC.EmployeeCourseID IN (
	SELECT EC.EmployeeCourseID FROM dbo.EmployeeCourse EC WHERE EC.CourseID=@course_id
)
IF @@ERROR > 0 BEGIN ROLLBACK TRAN RETURN END

INSERT dbo.EmployeeCourseCredit(EmployeeCourseID, CreditTypeID, Credits)
SELECT EC.EmployeeCourseID, CC.CreditTypeID, CC.Credits 
FROM dbo.CourseCredit CC
INNER JOIN dbo.EmployeeCourse EC ON CC.CourseID = EC.CourseID AND CC.CourseID = @course_id

IF @@ERROR > 0 BEGIN ROLLBACK TRAN RETURN END

COMMIT TRAN
GO
IF OBJECT_id('dbo.spCreditTypeList') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spCreditTypeList AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spCreditTypeList TO public'
END
GO
ALTER PROC dbo.spCreditTypeList @type_id int AS
SELECT [Type],CreditTypeID,[Abbreviated Type] FROM dbo.CreditType WHERE @type_id IS NULL OR CreditTypeID=@type_id ORDER BY [Type]
GO
IF OBJECT_id('dbo.spCreditTypeGetTypeFromTypeID') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spCreditTypeGetTypeFromTypeID AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spCreditTypeGetTypeFromTypeID TO public'
END
GO
ALTER PROC dbo.spCreditTypeGetTypeFromTypeID @type varchar(50) OUT, @type_id int AS
SELECT @type=[Type] FROM dbo.CreditType WHERE CreditTypeID=@type_id
GO
IF OBJECT_id('dbo.spCreditTypeGetAbbreviationFromTypeID') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spCreditTypeGetAbbreviationFromTypeID AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spCreditTypeGetAbbreviationFromTypeID TO public'
END
GO
ALTER PROC dbo.spCreditTypeGetAbbreviationFromTypeID @abbreviation varchar(8) OUT, @type_id int AS
SELECT @abbreviation=[Abbreviated Type] FROM dbo.CreditType WHERE CreditTypeID=@type_id
GO
IF OBJECT_ID('dbo.spEmployeeCourseReportColumns') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEmployeeCourseReportColumns AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spEmployeeCourseReportColumns TO public'
END
GO
ALTER PROC dbo.spEmployeeCourseReportColumns
AS
SET NOCOUNT ON

CREATE TABLE #REPORT_COLUMNS(colid int PRIMARY KEY, [Name] sysname COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL, Caption sysname COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL, [Example] varchar(50) COLLATE SQL_Latin1_General_CP1_CI_AS NULL, [Group] varchar(50) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL, Flags int NOT NULL)

INSERT #REPORT_COLUMNS
SELECT 
CColumns.colid,
[Name] = CColumns.[name], 
Caption = dbo.GetCaptionForColumnName(CColumns.[name]),
Example = dbo.GetExampleForColumnName(CColumns.[name], NULL),
[Group] = dbo.GetGroupFromColumnName(CColumns.[name], 'Other'),
Flags = 0
FROM syscolumns CColumns
WHERE [ID]=OBJECT_ID('dbo.vwEmployeeSecure') AND dbo.IsColumnVisibleOnReport(CColumns.[name]) = 1

EXEC dbo.spReportFillColumnExamples 'dbo.vwEmployeeSecure', 'EmployeeID'

INSERT #REPORT_COLUMNS(colid,[Name],Caption,Example,[Group],Flags) VALUES(-1, 'Expires', 'Expires', 'Nov 3,2000', 'Training', 0)
INSERT #REPORT_COLUMNS(colid,[Name],Caption,Example,[Group],Flags) VALUES(-3, 'Last Completed', 'Last Completed', 'Dec 3,2000', 'Training', 0)
INSERT #REPORT_COLUMNS(colid,[Name],Caption,Example,[Group],Flags) VALUES(-4, 'Last Comment', 'Comment', '', 'Training', 0)
INSERT #REPORT_COLUMNS(colid,[Name],Caption,Example,[Group],Flags) VALUES(-5, 'Last Status', 'Status', '', 'Training', 0)
INSERT #REPORT_COLUMNS(colid,[Name],Caption,Example,[Group],Flags) VALUES(-6, 'Last Location', 'Location', '', 'Training', 0)
INSERT #REPORT_COLUMNS(colid,[Name],Caption,Example,[Group],Flags) VALUES(-7, 'Last Cost', 'Cost', '123.45', 'Training', 0)
INSERT #REPORT_COLUMNS(colid,[Name],Caption,Example,[Group],Flags) VALUES(-8, 'Course', 'Course', '', 'Training', 0)
INSERT #REPORT_COLUMNS(colid,[Name],Caption,Example,[Group],Flags) VALUES(-9, 'Type', 'Course Type', '', 'Training', 0)
INSERT #REPORT_COLUMNS(colid,[Name],Caption,Example,[Group],Flags) VALUES(-10, '__Credits_*', 'Credits', '', 'Training', 0)
INSERT #REPORT_COLUMNS(colid,[Name],Caption,Example,[Group],Flags) VALUES(-11, 'Employee', 'Employee', '', 'Training', 0)
INSERT #REPORT_COLUMNS(colid,[Name],Caption,Example,[Group],Flags) VALUES(-12, 'Last Verified', 'Verified', '', 'Training', 0)
INSERT #REPORT_COLUMNS(colid,[Name],Caption,Example,[Group],Flags) VALUES(-13, 'Required', 'Required', '', 'Training', 0)

SELECT * FROM #REPORT_COLUMNS ORDER BY CASE WHEN [Group] = 'Name' THEN '_' ELSE '' END + [Group], Caption
GO
IF OBJECT_id('dbo.spEmployeeLeaveCalcForEmployeeType') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEmployeeLeaveCalcForEmployeeType AS'
	GRANT EXEC ON dbo.spEmployeeLeaveCalcForEmployeeType TO public
END
GO
ALTER PROC dbo.spEmployeeLeaveCalcForEmployeeType
	@employee_id int,
	@type_id int,
	@start int = -2147483648
AS
-- If accrual has an ineligible period or prorating or first incident then accrual will have to be calculated further back to the beginning of the accrual period
IF @start > -2147483648 AND EXISTS(
	SELECT * FROM dbo.EmployeeLeavePlan ELP
	INNER JOIN dbo.LeaveRate R ON ELP.EmployeeID=@employee_id AND ELP.PlanID=R.PlanID AND R.TypeID=@type_id AND @start BETWEEN ELP.[Start Day past 1900] AND ISNULL(ELP.[Stop Day past 1900],2147483647) AND
	(
		(
			(R.Flags & 15) > 0
		) OR (
			R.[Ineligible Months] > 0 AND (@start < ELP.[Start Day past 1900] + R.[Ineligible Months] * 31 + 31) 
		) OR R.PeriodID = 49154 -- First incident
	)
) 
BEGIN
	SELECT @start = MIN([Start Day past 1900]) FROM dbo.EmployeeLeavePlan ELP WHERE ELP.EmployeeID=@employee_id AND @start BETWEEN ELP.[Start Day past 1900] AND ISNULL(ELP.[Stop Day past 1900],2147483647) 
END

-- Carryover may affect the leave limits on another type
CREATE TABLE #CarryoverTypes(TypeID int)

INSERT #CarryoverTypes SELECT DISTINCT CarryoverTargetLeaveTypeID FROM dbo.LeaveLimit LL INNER JOIN dbo.EmployeeLeavePlan ELP ON ELP.EmployeeID=@employee_id AND LL.PlanID=ELP.PlanID AND LL.TypeID=@type_id AND CarryoverTargetLeaveTypeID IS NOT NULL
INSERT #CarryoverTypes SELECT DISTINCT CarryoverTargetLeaveTypeID FROM dbo.LeaveType WHERE TypeID = @type_id AND CarryoverTargetLeaveTypeID IS NOT NULL
INSERT #CarryoverTypes SELECT CarryoverTargetLeaveTypeID FROM dbo.Constant WHERE CarryoverSourceLeaveTypeID = @type_id AND CarryoverTargetLeaveTypeID IS NOT NULL

DELETE E
FROM dbo.EmployeeLeaveEarned E
INNER JOIN  #CarryoverTypes T ON E.[Auto] = 3 AND E.[Day past 1900] >= @start AND E.EmployeeID = @employee_id AND E.TypeID = T.TypeID

EXEC dbo.spEmployeeLeaveAccrue @employee_id, @type_id, @start
EXEC dbo.spEmployeeLeaveUnusedBuild @employee_id, @type_id, @start

DECLARE t_cursor CURSOR LOCAL FORWARD_ONLY STATIC FOR SELECT DISTINCT TypeID FROM #CarryoverTypes

OPEN t_cursor
DECLARE @target_type_id int
FETCH t_cursor INTO @target_type_id
WHILE @@FETCH_STATUS = 0
BEGIN
	EXEC dbo.spEmployeeLeaveUnusedBuild @employee_id, @target_type_id, @start
	FETCH t_cursor INTO @target_type_id
END
CLOSE t_cursor
DEALLOCATE t_cursor
GO
IF OBJECT_id('dbo.spEmployeeLeaveCalcForEmployee') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEmployeeLeaveCalcForEmployee AS'
	GRANT EXEC ON dbo.spEmployeeLeaveCalcForEmployee TO public
END
GO
ALTER PROC dbo.spEmployeeLeaveCalcForEmployee
	@employee_id int,
	@start int = -2147483648
AS
-- Orders the leave types so that the carryover types are calculated last
SELECT TypeID=CarryoverTargetLeaveTypeID, Carryover = CAST (1 AS bit) INTO #C FROM dbo.LeaveType WHERE CarryoverTargetLeaveTypeID IS NOT NULL
INSERT #C SELECT CarryoverTargetLeaveTypeID, 1 FROM dbo.LeaveLimit WHERE CarryoverTargetLeaveTypeID IS NOT NULL AND CarryoverTargetLeaveTypeID NOT IN (SELECT TypeID FROM #C)
INSERT #C SELECT CarryoverTargetLeaveTypeID, 1 FROM dbo.Constant WHERE CarryoverTargetLeaveTypeID IS NOT NULL AND CarryoverTargetLeaveTypeID NOT IN (SELECT TypeID FROM #C)
INSERT #C SELECT T.TypeID, 0 FROM dbo.LeaveType T LEFT JOIN #C ON T.TypeID = #C.TypeID WHERE #C.TypeID IS NULL

-- Fixes an issue where old carryover calculations linger after carryover is turned off for a given leave type
IF @start = -2147483648 OR NOT EXISTS(SELECT * FROM #C WHERE Carryover=1)
DELETE dbo.EmployeeLeaveEarned WHERE EmployeeID=@employee_id AND [Auto]=3

DECLARE t_cursor CURSOR LOCAL FORWARD_ONLY STATIC FOR SELECT TypeID FROM #C ORDER BY Carryover

OPEN t_cursor
DECLARE @type_id int
FETCH t_cursor INTO @type_id
WHILE @@FETCH_STATUS = 0
BEGIN
	EXEC dbo.spEmployeeLeaveCalcForEmployeeType @employee_id, @type_id, @start
	FETCH t_cursor INTO @type_id
END
CLOSE t_cursor
DEALLOCATE t_cursor
GO

IF NOT EXISTS(SELECT * FROM syscolumns WHERE [ID] = OBJECT_id('dbo.Constant') AND [name] = 'Reminder E-mail Suppress Days')
BEGIN
	ALTER TABLE dbo.Constant ADD [Reminder E-mail Suppress Days] int NULL
	ALTER TABLE dbo.Constant ADD [Reminder E-mail Subject] varchar(50) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL DEFAULT('Reminders')
	ALTER TABLE dbo.Constant ADD [Reminder E-mail Sender] varchar(4000) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL DEFAULT('')
	ALTER TABLE dbo.Constant ADD [Reminder E-mail Last Result] varchar(50) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL DEFAULT('Never e-mailed')
	ALTER TABLE dbo.Constant ADD [Reminder E-mail Repeat Days] int NOT NULL DEFAULT(7)
	ALTER TABLE dbo.Constant ADD [Reminder E-mail Ignore Days] int NOT NULL DEFAULT(14)
END
GO
IF OBJECT_id('dbo.spPersonListPrepareBatch3') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spPersonListPrepareBatch3 AS'
	GRANT EXEC ON dbo.spPersonListPrepareBatch3 TO public
END
GO
ALTER PROC dbo.spPersonListPrepareBatch3
	@batch_id int,
	@active bit,
	@flags int = 0 -- 1: must be manager
AS
INSERT TempX(BatchID, [ID]) SELECT @batch_id, E.EmployeeID FROM Employee E WHERE 
(@active IS NULL OR [Active Employee] = @active) AND
(
	@flags = 0 OR
	(@flags & 1) = 1 AND EXISTS(SELECT * FROM Employee M WHERE M.ManagerID = E.EmployeeID)
)
GO
IF OBJECT_id('dbo.spSSNClean') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spSSNClean AS'
	GRANT EXEC ON dbo.spSSNClean TO public
END
GO
ALTER PROC dbo.spSSNClean
	@ssn varchar(50) OUTPUT,
	@error int = 50004
AS
IF NOT EXISTS(SELECT * FROM dbo.ColumnGrid WHERE [Field]='SSN' AND [Label]='SSN') OR OBJECT_ID('CK_PersonX_FormatSSNLike000-00-0000') IS NULL
BEGIN
	SET @ssn = LTRIM(RTRIM(@ssn))
	RETURN 0
END

DECLARE @digits varchar(50)
DECLARE @char char
DECLARE @char_index tinyint
DECLARE @area_code char(3)

SET @char_index = 1
SET @digits = ''
WHILE @char_index <= LEN(@ssn)
BEGIN
	SET @char = SUBSTRING (@ssn, @char_index, 1)
	IF @char LIKE '[0-9]' SET @digits = @digits + @char
	SET @char_index = @char_index + 1
END

IF @digits = '' SET @ssn = ''
ELSE 
BEGIN
	IF LEN(@digits) <> 9 RETURN @error
	SET @ssn =SUBSTRING (@digits, 1, 3) + '-' + SUBSTRING (@digits, 4, 2) + '-' + SUBSTRING (@digits, 6, 4)
END

RETURN @@ERROR
GO
IF OBJECT_id('dbo.spEquipmentListDistinctIssuers') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEquipmentListDistinctIssuers AS'
	GRANT EXEC ON dbo.spEquipmentListDistinctIssuers TO public
END
GO
ALTER PROC dbo.spEquipmentListDistinctIssuers @type_id int AS SET NOCOUNT ON SELECT DISTINCT E.Issuer FROM dbo.Equipment E WHERE E.TypeID=@type_id AND E.Issuer <> '' ORDER BY E.Issuer
GO
IF OBJECT_id('dbo.spEquipmentAccessoryUpdate') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEquipmentAccessoryUpdate AS'
	GRANT EXEC ON dbo.spEquipmentAccessoryUpdate TO public
END
GO
ALTER PROC dbo.spEquipmentAccessoryUpdate @equipment_id int, @accessory_id int, @item_id int AS
UPDATE dbo.EquipmentAccessory SET EquipmentID=@equipment_id, AccessoryID=@accessory_id WHERE ItemId=@item_id
GO
IF OBJECT_id('dbo.spEquipmentTypeAccessoryInsert') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEquipmentTypeAccessoryInsert AS'
	GRANT EXEC ON dbo.spEquipmentTypeAccessoryInsert TO public
END
GO
ALTER PROC dbo.spEquipmentTypeAccessoryInsert @type_id int, @accessory varchar(50), @accessory_id int OUT AS
INSERT dbo.EquipmentTypeAccessory(TypeID,Accessory) VALUES(@type_id,@accessory) SELECT @accessory_id=SCOPE_IDENTITY()
GO
IF OBJECT_id('dbo.spEquipmentTypeAccessoryUpdate') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEquipmentTypeAccessoryUpdate AS'
	GRANT EXEC ON dbo.spEquipmentTypeAccessoryUpdate TO public
END
GO
ALTER PROC dbo.spEquipmentTypeAccessoryUpdate @type_id int, @accessory varchar(50), @accessory_id int AS
UPDATE dbo.EquipmentTypeAccessory SET TypeID=@type_id,Accessory=@accessory WHERE AccessoryID=@accessory_id
GO
IF OBJECT_id('dbo.spEquipmentTypeAccessoryDelete') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEquipmentTypeAccessoryDelete AS'
	GRANT EXEC ON dbo.spEquipmentTypeAccessoryDelete TO public
END
GO
ALTER PROC dbo.spEquipmentTypeAccessoryDelete @accessory_id int AS
DELETE dbo.EquipmentTypeAccessory WHERE AccessoryID=@accessory_id
GO
IF OBJECT_id('dbo.spEquipmentTypeAccessoryList') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEquipmentTypeAccessoryList AS'
	GRANT EXEC ON dbo.spEquipmentTypeAccessoryList TO public
END
GO
ALTER PROC dbo.spEquipmentTypeAccessoryList @accessory_id int=NULL, @type_id int=NULL AS SET NOCOUNT ON
SELECT
ETA.AccessoryID, ETA.TypeID, ETA.Accessory, T.[Type]
FROM dbo.EquipmentTypeAccessory ETA 
INNER JOIN dbo.EquipmentType T ON ETA.TypeID=T.TypeID AND 
(@accessory_id IS NULL OR ETA.AccessoryID=@accessory_id) AND
(@type_id IS NULL OR ETA.TypeID=@type_id)
ORDER BY ETA.TypeID,ETA.Accessory
GO
IF OBJECT_id('dbo.spEquipmentAccessoryInsert') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEquipmentAccessoryInsert AS'
	GRANT EXEC ON dbo.spEquipmentAccessoryInsert TO public
END
GO
ALTER PROC dbo.spEquipmentAccessoryInsert @equipment_id int, @accessory_id int, @item_id int OUT AS -- @item_id is null if equipmentid\accessoryid already exists
INSERT dbo.EquipmentAccessory(EquipmentID,AccessoryID) VALUES(@equipment_id,@accessory_id) SELECT @item_id=SCOPE_IDENTITY()
GO
IF OBJECT_id('dbo.spEquipmentAccessoryDelete') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEquipmentAccessoryDelete AS'
	GRANT EXEC ON dbo.spEquipmentAccessoryDelete TO public
END
GO
ALTER PROC dbo.spEquipmentAccessoryDelete @item_id int AS
DELETE dbo.EquipmentAccessory WHERE ItemID=@item_id
GO
IF OBJECT_id('dbo.spEquipmentAccessoryDelete2') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEquipmentAccessoryDelete2 AS'
	GRANT EXEC ON dbo.spEquipmentAccessoryDelete2 TO public
END
GO
ALTER PROC dbo.spEquipmentAccessoryDelete2 @equipment_id int, @accessory_id int AS
DELETE dbo.EquipmentAccessory WHERE EquipmentID=@equipment_id AND AccessoryID=@accessory_id
GO
IF OBJECT_id('dbo.spEquipmentAccessoryList') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEquipmentAccessoryList AS'
	GRANT EXEC ON dbo.spEquipmentAccessoryList TO public
END
GO
ALTER PROC dbo.spEquipmentAccessoryList @item_id int = NULL, @equipment_id int = NULL AS SET NOCOUNT ON
SELECT EA.ItemID,EA.EquipmentID,EA.AccessoryID,A.Accessory FROM dbo.EquipmentAccessory EA
INNER JOIN dbo.EquipmentTypeAccessory A ON EA.AccessoryID=A.AccessoryID AND (@item_id IS NULL OR EA.ItemID=@item_id) AND (@equipment_id IS NULL OR EA.EquipmentID=@equipment_id)
ORDER BY EA.EquipmentID,A.Accessory
GO
IF OBJECT_id('dbo.spEquipmentRecalc') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEquipmentRecalc AS'
	GRANT EXEC ON dbo.spEquipmentRecalc TO public
END
GO
-- Updates calculated accessories field for one peice of equipment. Should be called after a changes to EquipmentAccessory. Can pass null and update accessories field for all equipment, but implementation for bulk update is inefficient and slow so should only be called manually for administrative reasons
ALTER PROC dbo.spEquipmentRecalc @equipment_id int = NULL AS
DECLARE @accessories varchar(400), @accessory varchar(50)
SET @accessories=''
DECLARE a_cursor CURSOR LOCAL FORWARD_ONLY STATIC FOR SELECT A.Accessory FROM dbo.EquipmentAccessory EA INNER JOIN dbo.EquipmentTypeAccessory A ON (@equipment_id IS NULL OR EA.EquipmentID=@equipment_id) AND EA.AccessoryID=A.AccessoryID ORDER BY A.Accessory
OPEN a_cursor
FETCH NEXT FROM a_cursor INTO @accessory
WHILE @@FETCH_STATUS=0
BEGIN
	IF LEN(@accessories) BETWEEN 1 AND 399 SET @accessories=@accessories+','
	SET @accessories = SUBSTRING(@accessories + @accessory,1,400)
	FETCH NEXT FROM a_cursor INTO @accessory
END
CLOSE a_cursor
DEALLOCATE a_cursor
UPDATE dbo.Equipment SET Accessories=@accessories WHERE EquipmentID=@equipment_id
GO
IF OBJECT_id('dbo.spEquipmentUpdate') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spEquipmentUpdate AS'
GO
ALTER PROC dbo.spEquipmentUpdate
	@equipment_id int,
	@description varchar(50),
	@manufacturer varchar(50),
	@serial_number varchar(50),
	@model varchar(50),
	@make varchar(50),
	@service_tag varchar(50),
	@last_serviced_day_past_1900 int,
	@note varchar(4000),
	@purchase_day_past_1900 int,
	@purchase_price money,
	@employee_id int,
	@checked_out_day_past_1900 int,
	@due_day_past_1900 int,
	@last_price money = NULL, -- v58
	@last_price_day_past_1900 int = NULL, -- v58
	@returned_by_employee_id int = NULL, -- v58
	@checked_out_by_employee_id int = NULL, -- v58
	@returned_day_past_1900 int = NULL, -- v58
	@pin varchar(50) = NULL, -- v173
	@simm varchar(50) = NULL, -- v173
	@imei varchar(50) = NULL, -- v173
	@service varchar(50) = NULL, -- v173
	@service_start int = NULL, -- v173
	@expiration int = NULL, -- v173
	@type_id int = NULL, -- v173
	@issuer varchar(50) = NULL, -- v173
	@name_on_card varchar(50) = NULL, -- v173
	@number varchar(50) = NULL, -- v173
	@cvv varchar(50) = NULL, -- v173
	@purchase_limit money = NULL, -- v173
	@daily_limit money = NULL, -- v173
	@total_limit money = NULL, -- v173
	@billing_address varchar(50) = NULL, -- v173
	@billing_address2 varchar(50) = NULL, -- v173
	@billing_city varchar(50) = NULL, -- v173
	@billing_state varchar(50) = NULL, -- v173
	@billing_zip varchar(50) = NULL, -- v173
	@vin varchar(50) = NULL, -- v173
	@year int = NULL ,-- v173
	@ip varchar(50) = NULL, -- v184
	--@applications varchar(400) = NULL,
	@os varchar(50) = NULL,
	@cpu varchar(50) = NULL,
	@ram varchar(50) = NULL,
	@hd varchar(50) = NULL,
	@hd2 varchar(50) = NULL,
	@role varchar(50) = NULL,
	@service_pack varchar(50) = NULL,
	@location varchar(50) = NULL,
	@serial_number_2 varchar(50) = NULL,
	@uicc varchar(50) = NULL,
	@provider varchar(50) = NULL,
	@product_key varchar(50) = NULL,
	@user1 varchar(50) = NULL,
	@user2 varchar(50) = NULL,
	@user3 varchar(50) = NULL,
	@user4 varchar(50) = NULL,
	@user5 varchar(50) = NULL,
	@user6 varchar(50) = NULL,
	@user7 varchar(50) = NULL,
	@user8 varchar(50) = NULL,
	@user9 varchar(50) = NULL
AS
UPDATE Equipment SET
[Description]=@description,
Manufacturer=@manufacturer,
[Serial Number]=@serial_number,
Model=@model,
Make=@make,
[Service Tag]=@service_tag,
[Last Serviced Day past 1900]=@last_serviced_day_past_1900,
Note=@note,
[Purchase Day past 1900]=@purchase_day_past_1900,
[Purchase Price]=@purchase_price,
EmployeeID=@employee_id,
[Checked Out Day past 1900]=@checked_out_day_past_1900,
[Due Day past 1900]=@due_day_past_1900,
[Last Price] = @last_price,
[Last Price Day past 1900] = @last_price_day_past_1900,
[ReturnedByEmployeeID] = @returned_by_employee_id,
[Returned Day past 1900] = @returned_day_past_1900,
[CheckedOutByEmployeeID] = @checked_out_by_employee_id,
Pin = CASE WHEN @pin IS NULL THEN [Pin] ELSE @pin END,
SIMM = CASE WHEN @simm IS NULL THEN SIMM ELSE @simm END,
IMEI = CASE WHEN @imei IS NULL THEN IMEI ELSE @imei END,
[Service] = CASE WHEN @service IS NULL THEN [Service] ELSE @service END,
[Service Start Day past 1900] = CASE WHEN @service IS NULL THEN [Service Start Day past 1900] ELSE @service_start END,
[Expiration Day past 1900] = CASE WHEN @service IS NULL THEN [Expiration Day past 1900] ELSE @expiration END,
TypeID = CASE WHEN @type_id IS NULL THEN TypeID ELSE @type_id END,
Issuer = CASE WHEN @issuer IS NULL THEN Issuer ELSE @issuer END,
[Name on Card] = CASE WHEN @name_on_card IS NULL THEN [Name on Card] ELSE @name_on_card END,
[Number] = CASE WHEN @number IS NULL THEN [Number] ELSE @number END,
CVV = CASE WHEN @cvv IS NULL THEN CVV ELSE @cvv END,
[Purchase Limit] = CASE WHEN @cvv IS NULL THEN [Purchase Limit] ELSE @purchase_limit END,
[Daily Limit] = CASE WHEN @cvv IS NULL THEN [Daily Limit] ELSE @daily_limit END,
[Total Limit] = CASE WHEN @cvv IS NULL THEN [Total Limit] ELSE @total_limit END,
[Billing Address] = CASE WHEN @billing_address IS NULL THEN [Billing Address] ELSE @billing_address END,
[Billing Address (cont.)] = CASE WHEN @billing_address2 IS NULL THEN [Billing Address (cont.)] ELSE @billing_address2 END,
[Billing City] = CASE WHEN @billing_city IS NULL THEN [Billing City] ELSE @billing_city END,
[Billing State / Region] = CASE WHEN @billing_state IS NULL THEN [Billing State / Region] ELSE @billing_state END,
[Billing ZIP / Postal Code] = CASE WHEN @billing_zip IS NULL THEN [Billing ZIP / Postal Code] ELSE @billing_zip END,
VIN = CASE WHEN @vin IS NULL THEN VIN ELSE @vin END,
[Year] = CASE WHEN @vin IS NULL AND @year IS NULL THEN [Year] ELSE @year END,
IP = CASE WHEN @ip IS NULL THEN IP ELSE @ip END,
--Applications = CASE WHEN @applications IS NULL THEN Applications ELSE @applications END,
OS = CASE WHEN @os IS NULL THEN OS ELSE @os END,
CPU = CASE WHEN @cpu IS NULL THEN CPU ELSE @cpu END,
RAM = CASE WHEN @ram IS NULL THEN RAM ELSE @ram END,
HD = CASE WHEN @hd IS NULL THEN HD ELSE @hd END,
HD2 = CASE WHEN @hd2 IS NULL THEN HD2 ELSE @hd2 END,
[Role] = CASE WHEN @role IS NULL THEN [Role] ELSE @role END,
[Service Pack] = CASE WHEN @service_pack IS NULL THEN [Service Pack] ELSE @service_pack END,
Location = CASE WHEN @location IS NULL THEN Location ELSE @location END,
[Serial Number (2)] = CASE WHEN @serial_number_2 IS NULL THEN [Serial Number (2)] ELSE @serial_number_2 END,
UICC = CASE WHEN @uicc IS NULL THEN UICC ELSE @uicc END,
Provider = CASE WHEN @provider IS NULL THEN Provider ELSE @provider END,
[Product Key] = CASE WHEN @product_key IS NULL THEN [Product Key] ELSE @product_key END,
User1 = CASE WHEN @user1 IS NULL THEN User1 ELSE @user1 END,
User2 = CASE WHEN @user2 IS NULL THEN User2 ELSE @user2 END,
User3 = CASE WHEN @user3 IS NULL THEN User3 ELSE @user3 END,
User4 = CASE WHEN @user4 IS NULL THEN User4 ELSE @user4 END,
User5 = CASE WHEN @user5 IS NULL THEN User5 ELSE @user5 END,
User6 = CASE WHEN @user6 IS NULL THEN User6 ELSE @user6 END,
User7 = CASE WHEN @user7 IS NULL THEN User7 ELSE @user7 END,
User8 = CASE WHEN @user8 IS NULL THEN User8 ELSE @user8 END,
User9 = CASE WHEN @user9 IS NULL THEN User9 ELSE @user9 END
WHERE EquipmentID = @equipment_id
GO
IF OBJECT_id('dbo.spEquipmentInsert') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spEquipmentInsert AS'
GO
ALTER PROC dbo.spEquipmentInsert
	@description varchar(50),
	@manufacturer varchar(50),
	@serial_number varchar(50),
	@model varchar(50),
	@make varchar(50),
	@service_tag varchar(50),
	@last_serviced_day_past_1900 int,
	@note varchar(4000),
	@purchase_day_past_1900 int,
	@purchase_price money,
	@employee_id int,
	@checked_out_day_past_1900 int,
	@due_day_past_1900 int,
	@last_price money = NULL, -- v58
	@last_price_day_past_1900 int = NULL, -- v58
	@returned_by_employee_id int = NULL, -- v58
	@checked_out_by_employee_id int = NULL, -- v58
	@returned_day_past_1900 int = NULL, -- v58
	@pin varchar(50) = '', -- v173
	@simm varchar(50) = '', -- v173
	@imei varchar(50) = '', -- v173
	@service varchar(50) = '', -- v173
	@service_start int = NULL, -- v173
	@expiration int = NULL, -- v173
	@type_id int = NULL, -- v173
	@issuer varchar(60) = '', --v173
	@name_on_card varchar(50) = '', -- v173
	@number varchar(50) = '', -- v173
	@cvv varchar(50) = '', -- v173
	@purchase_limit money = NULL, -- v173
	@daily_limit money = NULL, -- v173
	@total_limit money = NULL, -- v173
	@billing_address varchar(50) = '', -- v173
	@billing_address2 varchar(50) = '', -- v173
	@billing_city varchar(50) = '', -- v173
	@billing_state varchar(50) = '', -- v173
	@billing_zip varchar(50) = '', -- v173
	@vin varchar(50) = '', -- v173
	@year int = NULL,
	@ip varchar(50) = '', -- v184
	-- @applications varchar(400) = '',
	@os varchar(50) = '',
	@cpu varchar(50) = '',
	@ram varchar(50) = '',
	@hd varchar(50) = '',
	@hd2 varchar(50) = '',
	@role varchar(50) = '',
	@service_pack varchar(50) = '',
	@location varchar(50) = '',
	@serial_number_2 varchar(50) = '',
	@uicc varchar(50) = '',
	@provider varchar(50) = '',
	@product_key varchar(50) = '',
	@user1 varchar(50) = '',
	@user2 varchar(50) = '',
	@user3 varchar(50) = '',
	@user4 varchar(50) = '',
	@user5 varchar(50) = '',
	@user6 varchar(50) = '',
	@user7 varchar(50) = '',
	@user8 varchar(50) = '',
	@user9 varchar(50) = '',
	@equipment_id int OUT
AS
IF @type_id IS NULL SELECT TOP 1 @type_id = TypeID FROM dbo.EquipmentType

INSERT Equipment([Description],Manufacturer,[Serial Number],Model,Make,[Service Tag],[Last Serviced Day past 1900],Note,
[Purchase Day past 1900],[Purchase Price],EmployeeID,[Checked Out Day past 1900],[Due Day past 1900],
[Last Price],[Last Price Day past 1900],[ReturnedByEmployeeID],[CheckedOutByEmployeeID],[Returned Day past 1900],
Pin, SIMM, IMEI, [Service], [Service Start Day past 1900], [Expiration Day past 1900], TypeID,
Issuer,[Name on Card],Number,CVV,[Purchase Limit],[Daily Limit],[Total Limit],[Billing Address],[Billing Address (cont.)],[Billing City],[Billing State / Region],[Billing Zip / Postal Code],
[Year], VIN,
IP,OS,CPU,RAM,HD,HD2,[Role],[Service Pack],Location,[Serial Number (2)],UICC,Provider,[Product Key],User1,User2,User3,User4,User5,User6,User7,User8,User9)
VALUES (@description,@manufacturer,@serial_number,@model,@make,@service_tag,@last_serviced_day_past_1900,@note,
@purchase_day_past_1900,@purchase_price,@employee_id,@checked_out_day_past_1900,@due_day_past_1900,
@last_price,@last_price_day_past_1900,@returned_by_employee_id,@checked_out_by_employee_id,@returned_day_past_1900,
@pin, @simm, @imei, @service, @service_start, @expiration, @type_id,
@issuer,@name_on_card,@number,@cvv,@purchase_limit,@daily_limit,@total_limit,@billing_address,@billing_address2,@billing_city,@billing_state,@billing_zip,
@year, @vin,
@ip,@os,@cpu,@ram,@hd,@hd2,@role,@service_pack,@location,@serial_number_2,@uicc,@provider,@product_key,@user1,@user2,@user3,@user4,@user5,@user6,@user7,@user8,@user9)
SELECT @equipment_id = SCOPE_IDENTITY()
GO
IF OBJECT_id('dbo.spEquipmentList') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spEquipmentList AS'
GO
ALTER PROC dbo.spEquipmentList
	@employee_id int = NULL,
	@employee_is_null bit = NULL,
	@type_id int = NULL,
	@equipment_id int = NULL,
	@text varchar(50) = NULL
AS
SET NOCOUNT ON

SELECT * FROM dbo.vwEquipment WHERE
(@equipment_id IS NULL OR EquipmentID = @equipment_id) AND
(@employee_id IS NULL OR EmployeeID = @employee_id) AND
(@employee_is_null IS NULL OR (@employee_is_null = 1) AND EmployeeID IS NULL OR (@employee_is_null = 0) AND EmployeeID IS NOT NULL) AND
(@type_id IS NULL OR TypeID = @type_id)
ORDER BY [Type], [Description]
GO
IF OBJECT_id('dbo.spEquipmentSelect') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spEquipmentSelect AS'
GO
ALTER PROC dbo.spEquipmentSelect @equipment_id int AS EXEC dbo.spEquipmentList @equipment_id=@equipment_id
GO
IF OBJECT_id('dbo.spEquipmentTypeList') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spEquipmentTypeList AS'
GRANT EXEC ON dbo.spEquipmentTypeList TO public
GO
ALTER PROC dbo.spEquipmentTypeList @type_id int = NULL AS SET NOCOUNT ON SELECT [Type], TypeID, [Column Mask], [Flags] FROM dbo.EquipmentType WHERE @type_id IS NULL OR TypeID=@type_id ORDER BY [Type]
GO
IF OBJECT_id('dbo.spEquipmentTypeUpdate') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spEquipmentTypeUpdate AS'
GO
ALTER PROC dbo.spEquipmentTypeUpdate @type_id int, @type varchar(50), @column_mask int, @flags int AS UPDATE dbo.EquipmentType SET [Type]=@type, [Column Mask]=@column_mask, Flags=@flags WHERE TypeID=@type_id
GO
IF OBJECT_id('dbo.spEquipmentTypeDelete') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spEquipmentTypeDelete AS'
GO
ALTER PROC dbo.spEquipmentTypeDelete @type_id int AS DELETE dbo.EquipmentType WHERE TypeID=@type_id
GO
IF OBJECT_id('dbo.spEquipmentTypeInsert') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spEquipmentTypeInsert AS'
GO
ALTER PROC dbo.spEquipmentTypeInsert @type_id int OUT, @type varchar(50), @column_mask int, @flags int AS INSERT dbo.EquipmentType([Type], [Column Mask], Flags) VALUES(@type,@column_mask,@flags) SET @type_id=SCOPE_IDENTITY()
GO
IF OBJECT_id('dbo.spEquipmentTypeGetColumnMask') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spEquipmentTypeGetColumnMask AS'
GRANT EXEC ON dbo.spEquipmentTypeGetColumnMask TO public
GO
ALTER PROC dbo.spEquipmentTypeGetColumnMask @type_id int, @column_mask int OUT AS SELECT @column_mask=[Column Mask] FROM dbo.EquipmentType WHERE TypeID=@type_id
GO
IF OBJECT_id('dbo.spEquipmentTypeGetFirstTypeID') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spEquipmentTypeGetFirstTypeID AS'
GRANT EXEC ON dbo.spEquipmentTypeGetFirstTypeID TO public
GO
ALTER PROC dbo.spEquipmentTypeGetFirstTypeID @type_id int OUT AS SELECT TOP 1 @type_id=TypeID FROM dbo.EquipmentType
GO
IF OBJECT_id('dbo.spEquipmentTypeGetName') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spEquipmentTypeGetName AS'
GRANT EXEC ON dbo.spEquipmentTypeGetName TO public
GO
ALTER PROC dbo.spEquipmentTypeGetName @type_id int, @type varchar(50) OUT AS SELECT @type=[Type] FROM dbo.EquipmentType WHERE TypeID=@type_id
GO
IF OBJECT_ID('dbo.spEmployeeBenefitListReportColumns') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spEmployeeBenefitListReportColumns AS'
GRANT EXEC ON dbo.spEmployeeBenefitListReportColumns TO public
GO
ALTER PROC dbo.spEmployeeBenefitListReportColumns
AS
SET NOCOUNT ON

CREATE TABLE #REPORT_COLUMNS(colid int PRIMARY KEY, [Name] sysname COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL, Caption sysname COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL, [Example] varchar(50) COLLATE SQL_Latin1_General_CP1_CI_AS NULL, [Group] varchar(50) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL, Flags int NOT NULL)

INSERT #REPORT_COLUMNS
SELECT 
CColumns.colid,
[Name] = CColumns.[name], 
Caption = dbo.GetCaptionForColumnName(CColumns.[name]),
Example = dbo.GetExampleForColumnName(CColumns.[name], NULL),
[Group] = dbo.GetGroupFromColumnName(CColumns.[name], 'Benefits'),
Flags = 0
FROM syscolumns CColumns
WHERE [ID]=OBJECT_ID('dbo.vwEmployeeBenefitFlat2') AND dbo.IsColumnVisibleOnReport(CColumns.[name]) = 1

EXEC dbo.spReportFillColumnExamples 'vwEmployeeBenefitFlat2', 'ItemID'

DECLARE @i int
SET @i=1
SELECT * FROM #REPORT_COLUMNS ORDER BY CASE WHEN [Group] = 'Name' THEN '_' ELSE '' END + [Group], Caption
GO
IF OBJECT_ID('dbo.spEmployeeDeductionListReportColumns') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spEmployeeBenefitListReportColumns AS'
GRANT EXEC ON dbo.spEmployeeDeductionListReportColumns TO public
GO
ALTER PROC dbo.spEmployeeDeductionListReportColumns
AS
SET NOCOUNT ON

CREATE TABLE #REPORT_COLUMNS(colid int PRIMARY KEY, [Name] sysname COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL, Caption sysname COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL, [Example] varchar(50) COLLATE SQL_Latin1_General_CP1_CI_AS NULL, [Group] varchar(50) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL, Flags int NOT NULL)

INSERT #REPORT_COLUMNS
SELECT 
CColumns.colid,
[Name] = CColumns.[name], 
Caption = dbo.GetCaptionForColumnName(CColumns.[name]),
Example = dbo.GetExampleForColumnName(CColumns.[name], NULL),
[Group] = dbo.GetGroupFromColumnName(CColumns.[name], 'Deductions'),
Flags = 0
FROM syscolumns CColumns
WHERE [ID]=OBJECT_ID('dbo.vwEmployeeDeductionFlat') AND dbo.IsColumnVisibleOnReport(CColumns.[name]) = 1

EXEC dbo.spReportFillColumnExamples 'vwEmployeeDeductionFlat', 'ItemID'

DECLARE @i int
SET @i=1
SELECT * FROM #REPORT_COLUMNS ORDER BY CASE WHEN [Group] = 'Name' THEN '_' ELSE '' END + [Group], Caption
GO
IF OBJECT_id('dbo.spEmployeeBenefitPivot') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spEmployeeBenefitPivot AS'
GRANT EXEC ON dbo.spEmployeeBenefitPivot TO public
GO
ALTER PROC dbo.spEmployeeBenefitPivot
	@x_group int, 
/* 1 location   2 division  3 dept  4 mngr  5 ins  6 zip  7 group# 8 Provider 9 Plan 10 coverage  
	11 gender  12 position   13 race */
	@y_group int,
	@xy_function int, -- 1 sum  2 avg  3 min  4 max  5 count
	@xy_data int, -- 1 employee premium  2 employer premium  3 total
	@as_of int,
	@batch_id int,
	@authorized bit OUT
AS
SET NOCOUNT ON

IF @x_group NOT BETWEEN 1 AND 13 RAISERROR('@x_group must be between 1 and 13',16,1)
IF @y_group NOT BETWEEN 1 AND 13 RAISERROR('@y_group must be between 1 and 13',16,1)
IF @xy_function NOT BETWEEN 1 AND 5 RAISERROR('@xy_function must be between 1 and 5',16,1)
IF @xy_data NOT BETWEEN 1 AND 3 RAISERROR('@xy_data must be between 1 and 3',16,1)

EXEC dbo.spPermissionGetOnPeopleForCurrentUser2 @batch_id, 536870912
DELETE TempX WHERE BatchID=@batch_id AND X & 1 = 0
SELECT @authorized=CASE WHEN @@ROWCOUNT=0 THEN 1 ELSE 0 END

SELECT 
X=CASE @x_group
	WHEN 1 THEN L.[List As]
	WHEN 2 THEN DIV.Division
	WHEN 3 THEN DEPT.Department
	WHEN 4 THEN ISNULL(M.[List As],'')
	WHEN 5 THEN B.Benefit
	WHEN 6 THEN P.[Home ZIP]
	WHEN 7 THEN EB.[Group Policy Number]
	WHEN 8 THEN EB.Provider
	WHEN 9 THEN EB.[Plan]
	WHEN 10 THEN EB.Coverage
	WHEN 11 THEN CASE WHEN P.[Male]=1 THEN 'Male' ELSE 'Female' END
	WHEN 12 THEN ISNULL(C.[Job Title],'')
	WHEN 13 THEN R.Race
END,
Y=CASE @y_group
	WHEN 1 THEN L.[List As]
	WHEN 2 THEN DIV.Division
	WHEN 3 THEN DEPT.Department
	WHEN 4 THEN ISNULL(M.[List As],'')
	WHEN 5 THEN B.Benefit
	WHEN 6 THEN P.[Home ZIP]
	WHEN 7 THEN EB.[Group Policy Number]
	WHEN 8 THEN EB.Provider
	WHEN 9 THEN EB.[Plan]
	WHEN 10 THEN EB.Coverage
	WHEN 11 THEN CASE WHEN P.[Male]=1 THEN 'Male' ELSE 'Female' END
	WHEN 12 THEN ISNULL(C.[Job Title],'')
	WHEN 13 THEN R.Race
END,
XY=CASE WHEN @xy_function=5 THEN 1.0 ELSE
	CASE @xy_data
		WHEN 1 THEN EB.[Employee Premium]
		WHEN 2 THEN EB.[Employer Premium]
		WHEN 3 THEN EB.[Employee Premium] + EB.[Employer Premium]
	END
END
INTO #XY
FROM EmployeeBenefit EB
INNER JOIN TempX X ON X.BatchID=@batch_id AND X.ID=EB.EmployeeID AND
(
	(EB.[Declined Day past 1900] IS NULL OR EB.[Declined Day past 1900] > @as_of) AND
	(
		(EB.[First Enrolled Day past 1900] <= @as_of OR EB.[Last Enrolled Day past 1900] <= @as_of)
		AND (EB.[Expires Day past 1900] IS NULL OR EB.[Expires Day past 1900] > @as_of)
	)
)
INNER JOIN Employee E ON EB.EmployeeID=E.EmployeeID
INNER JOIN Benefit B ON EB.BenefitID=B.BenefitID
INNER JOIN Person P ON E.EmployeeID=P.PersonID
INNER JOIN PersonX PERS ON E.EmployeeID=PERS.PersonID
INNER JOIN Race R ON PERS.RaceID=R.RaceID
INNER JOIN Location L ON E.LocationID=L.LocationID
INNER JOIN Division DIV ON E.DivisionID=DIV.DivisionID
INNER JOIN Department DEPT ON E.DepartmentID=DEPT.DepartmentID
LEFT JOIN vwEmployeeLastCompensation C ON E.EmployeeID=C.EmployeeID
LEFT JOIN dbo.vwPersonListAs M ON E.ManagerID=M.PersonID

DELETE dbo.TempX WHERE BatchID=@batch_id OR DATEDIFF(minute, Created, GETDATE()) > 30

SELECT DISTINCT OX=0, X INTO #X FROM #XY UNION ALL SELECT 1, 'All'
SELECT DISTINCT OY=0, Y INTO #Y FROM #XY UNION ALL SELECT 1, 'All'

SELECT X, Y,
XY=CASE @xy_function
	WHEN 2 THEN 
		CASE 
			WHEN #X.OX=1 AND #Y.OY=1 THEN ISNULL((SELECT AVG(XY) FROM #XY),0)
			WHEN #X.OX=1 THEN ISNULL((SELECT AVG(XY) FROM #XY WHERE #XY.Y=#Y.Y),0)
			WHEN #Y.OY=1 THEN ISNULL((SELECT AVG(XY) FROM #XY WHERE #XY.X=#X.X),0)
			ELSE ISNULL((SELECT AVG(XY) FROM #XY WHERE #XY.X=#X.X AND #XY.Y=#Y.Y),0)
		END
	WHEN 3 THEN
		CASE 
			WHEN #X.OX=1 AND #Y.OY=1 THEN ISNULL((SELECT MIN(XY) FROM #XY),0)
			WHEN #X.OX=1 THEN ISNULL((SELECT MIN(XY) FROM #XY WHERE #XY.Y=#Y.Y),0)
			WHEN #Y.OY=1 THEN ISNULL((SELECT MIN(XY) FROM #XY WHERE #XY.X=#X.X),0)
			ELSE ISNULL((SELECT MIN(XY) FROM #XY WHERE #XY.X=#X.X AND #XY.Y=#Y.Y),0)
		END
	WHEN 4 THEN
		CASE 
			WHEN #X.OX=1 AND #Y.OY=1 THEN ISNULL((SELECT MAX(XY) FROM #XY),0)
			WHEN #X.OX=1 THEN ISNULL((SELECT MAX(XY) FROM #XY WHERE #XY.Y=#Y.Y),0)
			WHEN #Y.OY=1 THEN ISNULL((SELECT MAX(XY) FROM #XY WHERE #XY.X=#X.X),0)
			ELSE ISNULL((SELECT MAX(XY) FROM #XY WHERE #XY.X=#X.X AND #XY.Y=#Y.Y),0)
		END
	ELSE
		CASE 
			WHEN #X.OX=1 AND #Y.OY=1 THEN ISNULL((SELECT SUM(XY) FROM #XY),0)
			WHEN #X.OX=1 THEN ISNULL((SELECT SUM(XY) FROM #XY WHERE #XY.Y=#Y.Y),0)
			WHEN #Y.OY=1 THEN ISNULL((SELECT SUM(XY) FROM #XY WHERE #XY.X=#X.X),0)
			ELSE ISNULL((SELECT SUM(XY) FROM #XY WHERE #XY.X=#X.X AND #XY.Y=#Y.Y),0)
		END
END
FROM #X
CROSS JOIN #Y
ORDER BY #Y.OY, #Y.Y, #X.OX, #X.X
GO
IF OBJECT_id('dbo.spEmployeeBeneftFilter') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spEmployeeBeneftFilter AS'
GRANT EXEC ON dbo.spEmployeeBeneftFilter TO public
GO
-- Fills TempXYZ with all of the matching employeeids/benefitids
ALTER PROC dbo.spEmployeeBeneftFilter
	@eligible_start int, @eligible_stop int, @eligible_null bit,
	@enrolled_start int, @enrolled_stop int, @enrolled_null bit,
	@wait_listed bit,
	@exclude_inactive bit,
	@employee_id int, @employee_batch_id int,
	@benefit_id int, @benefit_batch_id int,
	@plan varchar(50),
	@provider varchar(50),
	@coverage varchar(50),
	@zip varchar(50),
	@dob_start int, @dob_stop int,
	@eb_batch_id int,
	@enrollment_id int,
	@count int OUT,
	
	-- Added v111
	@terminated_start int = -2147483648, @terminated_stop int = 2147483647, @terminated_null bit = null,
	@all_advance_pay bit = 0, @all_cobra bit = 0
AS
DECLARE @all_employees bit, @all_benefits bit

SELECT @all_employees = 0, @all_benefits = 0
IF @employee_batch_id IS NULL AND @employee_id IS NULL SET @all_employees = 1
IF @benefit_batch_id IS NULL AND @benefit_id IS NULL SET @all_benefits = 1

IF @employee_batch_id IS NULL SET @employee_batch_id = RAND() * 2147483647
IF @benefit_batch_id IS NULL SET @benefit_batch_id = RAND() * 2147483647

IF @employee_id IS NOT NULL INSERT TempX(BatchID,[ID]) VALUES(@employee_batch_id, @employee_id)
IF @benefit_id IS NOT NULL INSERT TempX(BatchID,[ID]) VALUES(@benefit_batch_id, @benefit_id)

IF @all_employees=1 INSERT TempX(BatchID,[ID]) SELECT @employee_batch_id,EmployeeID FROM Employee
IF @all_benefits=1 INSERT TempX(BatchID,[ID]) SELECT @benefit_batch_id,BenefitID FROM Benefit

INSERT TempXYZ(BatchID,[ID],X)
SELECT @eb_batch_id,E.[ID],B.[ID]
FROM dbo.TempX E
INNER JOIN dbo.TempX B ON E.BatchID = @employee_batch_id AND B.BatchID = @benefit_batch_id
INNER JOIN dbo.PersonX PX ON E.[ID] = PX.PersonID
INNER JOIN dbo.Person P ON E.[ID] = P.PersonID
INNER JOIN dbo.Employee ON E.[ID] = Employee.EmployeeID
INNER JOIN dbo.vwEmployeeBenefit EB ON EB.EmployeeID=E.[ID] AND EB.BenefitID=B.[ID] AND

(
	(@all_advance_pay = 1 AND Employee.[Advance Pay] = 1) OR
	(@all_cobra = 1 AND EB.[COBRA Is Enrolled]=1) OR
	(
		(@wait_listed IS NULL OR EB.[Wait Listed] = @wait_listed) AND
		(PX.[DOB Day past 1900] IS NULL OR PX.[DOB Day past 1900] BETWEEN @dob_start AND @dob_stop) AND
		(@enrollment_id IS NULL OR dbo.fnGetEnrollmentID(GETDATE(), EB.[Declined Day past 1900],EB.[Expires Day past 1900],EB.[First Enrolled Day past 1900],EB.[Last Enrolled Day past 1900],EB.[Eligible Day past 1900],EB.[Notified Day past 1900]) = @enrollment_id) AND
		(
			(@eligible_null IS NULL) OR
			(@eligible_null=1 AND EB.[Eligible Day past 1900] IS NULL) OR
			(@eligible_null=0 AND EB.[Eligible Day past 1900] BETWEEN @eligible_start AND @eligible_stop)
		) AND
		(
			(@terminated_null IS NULL) OR
			(@terminated_null=1 AND EB.[Declined Day past 1900] IS NULL) OR
			(@terminated_null=0 AND EB.[Declined Day past 1900] BETWEEN @terminated_start AND @terminated_stop)
		) AND
		(
			(@enrolled_null IS NULL) OR
			(@enrolled_null=1 AND EB.[First Enrolled Day past 1900] IS NULL AND EB.[Last Enrolled Day past 1900] IS NULL) OR
			(@enrolled_null=0 AND
				(
					(EB.[First Enrolled Day past 1900] IS NOT NULL OR EB.[Last Enrolled Day past 1900] IS NOT NULL) AND
					(
						(EB.[First Enrolled Day past 1900] IS NULL OR EB.[First Enrolled Day past 1900] BETWEEN @enrolled_start AND @enrolled_stop) OR
						(EB.[Last Enrolled Day past 1900] IS NULL OR EB.[Last Enrolled Day past 1900] BETWEEN @enrolled_start AND @enrolled_stop)
					)
				)
			)
		)
		AND
		(LEN(@zip) = 0 OR P.[Home ZIP] = @zip) AND
		(LEN(@coverage) = 0 OR EB.Coverage = @coverage) AND
		(LEN(@provider) = 0 OR EB.Provider = @provider) AND
		(LEN(@plan) = 0 OR EB.[Plan] = @plan) AND
		(@exclude_inactive = 0 OR EB.Active = 1)
	)
)

SELECT @count = @@ROWCOUNT
GO
IF OBJECT_id('dbo.spEmployeeCompensationAdjustmentUpdate') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spEmployeeCompensationAdjustmentUpdate AS'
GRANT EXEC ON dbo.spEmployeeCompensationAdjustmentUpdate TO public
GO
ALTER PROC dbo.spEmployeeCompensationAdjustmentUpdate
	@compensation_id int,	
	@adjustment_id int,
	@max money,
	@min money
AS
DECLARE @employee_id int
DECLARE @authorized bit
DECLARE @was_null bit

SET NOCOUNT ON

-- Requires permission to change adjustment for employee
SELECT @employee_id = EmployeeID FROM EmployeeCompensation WHERE CompensationID = @compensation_id
EXEC dbo.spPermissionInsureForCurrentUserOnPerson @employee_id, 1024, 2, @authorized out

IF @authorized = 1
BEGIN
	SELECT @was_null = 0 FROM EmployeeCompensationAdjustment WHERE CompensationID = @compensation_id AND AdjustmentID = @adjustment_id
	IF @@ROWCOUNT = 0 SELECT @was_null = 1

	IF @was_null = 1 
	BEGIN
		IF @max != 0 OR @min != 0
		INSERT EmployeeCompensationAdjustment (CompensationID, AdjustmentID, [Minimum Adjustment], [Maximum Adjustment])
		VALUES (@compensation_id, @adjustment_id, @min, @max)
	END
	ELSE IF @max = 0 AND @min = 0
		DELETE EmployeeCompensationAdjustment WHERE CompensationID = @compensation_id AND AdjustmentID = @adjustment_id
	ELSE
		UPDATE EmployeeCompensationAdjustment SET [Minimum Adjustment] = @min, [Maximum Adjustment] = @max
		WHERE CompensationID = @compensation_id AND AdjustmentID = @adjustment_id
END
GO
IF OBJECT_id('dbo.spEmployeeBenefitList3') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spEmployeeBenefitList3 AS'
GRANT EXEC ON dbo.spEmployeeBenefitList3 TO public
GO
ALTER PROC dbo.spEmployeeBenefitList3
	@batch_id int -- TempXYZ, ID=employeeID, x=benefitID
AS
SET NOCOUNT ON
EXEC dbo.spCustomFieldClean
SELECT EB.*
FROM dbo.vwEmployeeBenefitFlat2 EB
INNER JOIN dbo.TempXYZ ON TempXYZ.BatchID = @batch_id AND TempXYZ.[ID] = EB.EmployeeID AND TempXYZ.X = EB.BenefitID                                                                                                                                                                                         

DELETE TempXYZ WHERE BatchID = @batch_id OR DATEDIFF(hh, Created, GETDATE()) > 1
DELETE TempX WHERE BatchID = @batch_id OR DATEDIFF(hh, Created, GETDATE()) > 1
GO
IF OBJECT_id('dbo.spEmployeeBenefitList2') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spEmployeeBenefitList2 AS'
GRANT EXEC ON dbo.spEmployeeBenefitList2 TO public
GO
ALTER PROC dbo.spEmployeeBenefitList2
	@batch_id int, -- TempXYZ, ID=employeeID, x=benefitID
	@authorized bit = 1 OUT
AS
SET NOCOUNT ON

SET @authorized = 1

SELECT EB.*
FROM dbo.vwEmployeeBenefitSecure EB
INNER JOIN dbo.TempXYZ ON TempXYZ.BatchID = @batch_id AND TempXYZ.[ID] = EB.EmployeeID AND TempXYZ.X = EB.BenefitID
ORDER BY EB.[List As], EB.EmployeeID, EB.Benefit, EB.BenefitID                                                                                                                                                                                           

DELETE dbo.TempXYZ WHERE BatchID = @batch_id OR DATEDIFF(hh, Created, GETDATE()) > 1
GO
IF OBJECT_id('dbo.spBenefitPremiumPush') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spBenefitPremiumPush AS'
GO
ALTER PROC dbo.spBenefitPremiumPush
	@benefit_id int,
	@provider varchar(50),
	@plan varchar(50),
	@coverage varchar(50),
	@home_zip varchar(50),
	@employee_premium money,
	@employer_premium money,
	@batch_id int = NULL,
	@affected int=0 OUT
AS
UPDATE EB SET
[Employee Premium]=@employee_premium,
[Employer Premium]=@employer_premium
FROM EmployeeBenefit EB
INNER JOIN Person P ON EB.EmployeeID=P.PersonID AND
EB.BenefitID=@benefit_id AND
(EB.[Provider]=@provider OR @provider='') AND
(EB.[Plan]=@plan OR @plan='') AND
(EB.Coverage=@coverage OR @coverage='') AND
(P.[Home ZIP]=@home_zip OR @home_zip='')
SELECT @affected=@@ROWCOUNT
GO
IF OBJECT_id('dbo.spBenefitPremiumDelete') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spBenefitPremiumDelete AS'
GO
ALTER PROC dbo.spBenefitPremiumDelete @premium_id int AS DELETE BenefitPremium WHERE PremiumID = @premium_id
GO
IF OBJECT_id('dbo.spBenefitPremiumUpdate') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spBenefitPremiumUpdate AS'
GO
ALTER PROC dbo.spBenefitPremiumUpdate
	@provider varchar(50),
	@plan varchar(50),
	@coverage varchar(50),
	@home_zip varchar(50),
	@employee_premium money,
	@employer_premium money,
	@premium_id int
AS
UPDATE BenefitPremium
SET Provider = @provider,
[Plan] = @plan,
Coverage = @coverage,
[Home ZIP] = @home_zip,
[Employee Premium] = @employee_premium,
[Employer Premium] = @employer_premium
WHERE PremiumID = @premium_id
GO
IF OBJECT_id('dbo.spBenefitPremiumInsert') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spBenefitPremiumInsert AS'
GO
ALTER PROC dbo.spBenefitPremiumInsert
	@benefit_id int,
	@provider varchar(50),
	@plan varchar(50),
	@coverage varchar(50),
	@home_zip varchar(50),
	@employee_premium money,
	@employer_premium money,
	@premium_id int OUT
AS
INSERT BenefitPremium(BenefitID, Provider, [Plan], Coverage, [Home ZIP], [Employee Premium], [Employer Premium])
SELECT @benefit_id, @provider, @plan, @coverage, @home_zip, @employee_premium, @employer_premium

SET @premium_id = SCOPE_IDENTITY()
GO
IF OBJECT_id('dbo.spCompensationAdjustmentList') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spCompensationAdjustmentList AS'
GRANT EXEC ON dbo.spCompensationAdjustmentList TO public
GO
ALTER PROC dbo.spCompensationAdjustmentList
	@one_time bit
AS
SELECT * FROM vwCompensationAdjustment 
WHERE (@one_time IS NULL) OR (@one_time = 0 AND PeriodID IS NOT NULL) OR (@one_time = 1 AND PeriodID IS NULL)
ORDER BY Adjustment
GO
IF OBJECT_id('dbo.spEmployeeCompensationAdjustmentSelect') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spEmployeeCompensationAdjustmentSelect AS'
GRANT EXEC ON dbo.spEmployeeCompensationAdjustmentSelect TO public
GO
ALTER PROC dbo.spEmployeeCompensationAdjustmentSelect
	@item_id int
AS
DECLARE @authorized bit, @employee_id int

SET NOCOUNT ON

SELECT @employee_id = C.EmployeeID FROM EmployeeCompensationAdjustment A
INNER JOIN EmployeeCompensation C ON A.ItemID = @item_id AND A.CompensationID = C.CompensationID
EXEC dbo.spPermissionInsureForCurrentUserOnPerson @employee_id, 1024, 1, @authorized out

IF @authorized = 1
SELECT * FROM vwEmployeeCompensationAdjustment WHERE ItemID = @item_id
GO
IF OBJECT_id('dbo.spEmployeeCompensationAdjustmentList') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spEmployeeCompensationAdjustmentList AS'
GRANT EXEC ON dbo.spEmployeeCompensationAdjustmentList TO public
GO
ALTER PROC dbo.spEmployeeCompensationAdjustmentList
	@compensation_id int
AS
DECLARE @authorized bit, @employee_id int

SET NOCOUNT ON

SELECT @employee_id = EmployeeID FROM EmployeeCompensation WHERE CompensationID = @compensation_id
EXEC dbo.spPermissionInsureForCurrentUserOnPerson @employee_id, 1024, 1, @authorized out

IF @authorized = 1
SELECT C.CompensationID, -- Nullable
A.AdjustmentID,
[Minimum Adjustment] = ISNULL(C.[Minimum Adjustment], 0),
[Maximum Adjustment] = ISNULL(C.[Maximum Adjustment], 0),
A.Adjustment,
A.PeriodID,
Period = ISNULL(C.Period,''),
[List As] = ISNULL(C.[List As], '')
FROM CompensationAdjustment A
LEFT JOIN dbo.vwEmployeeCompensationAdjustment C ON C.CompensationID = @compensation_id AND A.AdjustmentID = C.AdjustmentID
ORDER BY A.[Adjustment]
GO
IF OBJECT_id('dbo.spConstantUpdateLastResult') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spConstantUpdateLastResult AS'
GO
ALTER PROC dbo.spConstantUpdateLastResult
	@result varchar(4000)
AS
SET NOCOUNT ON

UPDATE Constant SET [Reminder E-mail Last Result] = @result
GO
GRANT EXEC ON dbo.spConstantUpdateLastResult TO public
GO
IF OBJECT_id('dbo.spConstantUpdateReminderEmail') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spConstantUpdateReminderEmail AS'
GO
ALTER PROC dbo.spConstantUpdateReminderEmail
	@suppress_days int,
	@subject varchar(50),
	@sender varchar(50),
	@repeat_days int,
	@ignore_days int
AS
SET NOCOUNT ON

UPDATE Constant SET [Reminder E-mail Suppress Days] = @suppress_days,
[Reminder E-mail Subject] = @subject,
[Reminder E-mail Sender] = @sender,
[Reminder E-mail Repeat Days] = @repeat_days,
[Reminder E-mail Ignore Days] = @ignore_days
GO
IF OBJECT_id('dbo.spCompensationAdjustmentInsert') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spCompensationAdjustmentInsert AS'
GO
ALTER PROC dbo.spCompensationAdjustmentInsert
	@adjustment varchar(50),
	@period_id int,
	@adjustment_id int OUT
AS
INSERT CompensationAdjustment(Adjustment, PeriodID)
VALUES (@adjustment, @period_id)
SET @adjustment_id = SCOPE_IDENTITY()
GO
IF OBJECT_id('dbo.spCompensationAdjustmentUpdate') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spCompensationAdjustmentUpdate AS'
GO
ALTER PROC dbo.spCompensationAdjustmentUpdate
	@adjustment varchar(50),
	@period_id int,
	@adjustment_id int
AS
UPDATE CompensationAdjustment
SET Adjustment = @adjustment, PeriodID = @period_id WHERE AdjustmentID = @adjustment_id
GO
IF OBJECT_id('dbo.spCompensationAdjustmentDelete') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spCompensationAdjustmentDelete AS'
GO
ALTER PROC dbo.spCompensationAdjustmentDelete
	@adjustment_id int
AS
DELETE CompensationAdjustment WHERE AdjustmentID = @adjustment_id
GO
IF OBJECT_id('dbo.spCompensationAdjustmentSelect') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spCompensationAdjustmentSelect AS'
GO
ALTER PROC dbo.spCompensationAdjustmentSelect
	@adjustment_id int
AS
SELECT * FROM CompensationAdjustment WHERE AdjustmentID = @adjustment_id
GO
GRANT EXEC ON dbo.spCompensationAdjustmentSelect TO public
IF OBJECT_id('dbo.spBenefitGetBenefitFromBenefitID') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spBenefitGetBenefitFromBenefitID AS'
GO
ALTER PROC dbo.spBenefitGetBenefitFromBenefitID
	@benefit_id int,
	@benefit varchar(50) OUT
AS
SELECT @benefit = NULL
SELECT @benefit = Benefit FROM Benefit WHERE BenefitID = @benefit_id
GO
GRANT EXEC ON dbo.spBenefitGetBenefitFromBenefitID TO public
GO
IF OBJECT_id('dbo.spEmployeeExpenseBatchReimburse') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEmployeeExpenseBatchReimburse AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spEmployeeExpenseBatchReimburse TO public'
END
GO
ALTER PROC dbo.spEmployeeExpenseBatchReimburse
	@approve bit, @day int, @stop_day int, @first_check varchar(50) 
AS
DECLARE @i int, @l int

SET @l = LEN(@first_check)
SET @i = @l

WHILE @i > 0
BEGIN
	IF SUBSTRING(@first_check, @i, 1) NOT LIKE '[0123456789]' BREAK
	SET @i = @i - 1
END
	

	
IF @i = @l
BEGIN
	DECLARE @m nvarchar(400)
	SET @m = N'The first check, ' + cast(@approve as varchar(50)) + N', must end in a number.'
	RAISERROR (@m, 16, 1)
END
ELSE
BEGIN
	DECLARE @item_id int, @check_number int, @check_prefix varchar(50), @last_employee_id int, @employee_id int
	SELECT @check_prefix = SUBSTRING(@first_check, 1, @i), @check_number = SUBSTRING(@first_check, @i + 1, @l - @i), @last_employee_id = NULL
	
	DECLARE e_cursor CURSOR LOCAL FORWARD_ONLY STATIC FOR SELECT ItemID, EmployeeID FROM dbo.EmployeeExpense WHERE [Day Reimbursed] IS NULL AND (StatusID IN (1,5) OR (@approve = 1 AND StatusID = 8)) ORDER BY EmployeeID
	OPEN e_cursor
	
	BEGIN TRAN

	FETCH e_cursor INTO @item_id, @employee_id
	WHILE @@FETCH_STATUS=0
	BEGIN
		UPDATE dbo.EmployeeExpense SET [Reimbursed Check Number]= @check_prefix + CAST(@check_number AS varchar(50)), [Day Reimbursed] = @day, StatusID = CASE WHEN StatusID IN (1,5) THEN StatusID ELSE 1 END WHERE ItemID=@item_id
		IF @@ERROR <> 0 BEGIN
			ROLLBACK
			RETURN
		END
		
		SELECT @last_employee_id = @employee_id
		FETCH e_cursor INTO @item_id, @employee_id
		IF @last_employee_id <> @employee_id SET @check_number = @check_number + 1
	END
	
	COMMIT TRAN
	
	CLOSE e_cursor
	DEALLOCATE e_cursor
END
GO
IF OBJECT_id('dbo.spEmployeeLeavePlanSelectLast') IS NULL 
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEmployeeLeavePlanSelectLast AS'
	GRANT EXEC ON dbo.spEmployeeLeavePlanSelectLast TO public
END
GO
ALTER PROC dbo.spEmployeeLeavePlanSelectLast
	@employee_id int,
	@count int out
AS
DECLARE @authorized bit

SET NOCOUNT ON

SELECT @count = COUNT(ItemID) FROM dbo.EmployeeLeavePlan WHERE EmployeeID = @employee_id

EXEC dbo.spPermissionInsureForCurrentUserOnPerson @employee_id, 128, 1, @authorized out
IF @authorized = 1 SELECT TOP 1 * FROM dbo.vwEmployeeLeavePlan WHERE EmployeeID = @employee_id
ORDER BY [Start Day past 1900] DESC
GO
IF OBJECT_id('dbo.spEmployeeLeaveApplyLimits') IS NULL 
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEmployeeLeaveApplyLimits AS'
	GRANT EXEC ON dbo.spEmployeeLeaveApplyLimits TO public
END
GO
ALTER PROC dbo.spEmployeeLeaveApplyLimits
	@employee_id int,
	@type_id int, -- type of leave (not type of limit)
	@start_day int,
	@stop_day int,
	@period_id int, -- 0 to 4
	@month int,
	@day int,
	@enable_after_months int,
	@max_seconds int,
	@multiply_limit_by_fte bit,
	@fte numeric(9,4)
AS
DECLARE @seconds int,
	@year int,
	@unused int,
	@adjustment int,
	@leave_id int,
	@seniority_day int,
	@rows int,
	@current datetime,
	@target_type_id int,
	@start datetime, 
	@stop datetime,
	@current_day int,
	@enable_start_day int,
	@enable_start datetime

SET NOCOUNT ON


SELECT @target_type_id = NULL

DECLARE @lam numeric(9,4), @carryover_multipler numeric(9,8), @carryover_offset_days int, @carryover_limit int



SELECT @lam = CASE WHEN @multiply_limit_by_fte=1 THEN @fte ELSE 1.0 END * [Leave Accrual Multiplier] FROM Employee WHERE EmployeeID = @employee_id

IF @lam <= 1 SELECT @max_seconds = @max_seconds * @lam
ELSE
BEGIN
	DECLARE @infinity int
	SELECT @infinity = 2147483647 / @lam
	IF @max_seconds <= @infinity SET @max_seconds = 2147483647
	ELSE SET @max_seconds = @max_seconds * @lam
END

SELECT @seniority_day = [Seniority Begins Day past 1900] FROM Employee WHERE EmployeeID = @employee_id

-- Carryover through the LeaveLimit settings needs to be fixed. Currently applies limit if any of the employee's plans specify a carryover.
SELECT TOP 1 @carryover_offset_days = [Carryover Offset Days], @carryover_limit = [Carryover Limit Seconds], @target_type_id = CarryoverTargetLeaveTypeID, @carryover_multipler = [Carryover Multiplier] FROM dbo.LeaveLimit LL INNER JOIN dbo.EmployeeLeavePlan ELP ON ELP.EmployeeID=@employee_id AND ELP.PlanID=LL.PlanID AND LL.TypeID = @type_id AND LL.CarryoverTargetLeaveTypeID IS NOT NULL AND @start_day BETWEEN ELP.[Start Day past 1900] AND ISNULL(ELP.[Stop Day past 1900], 2147483647)
IF @target_type_id IS NULL SELECT @carryover_offset_days = [Carryover Offset Days], @carryover_limit = [Carryover Limit Seconds], @target_type_id = CarryoverTargetLeaveTypeID, @carryover_multipler = [Carryover Multiplier] FROM dbo.LeaveType WHERE TypeID = @type_id AND CarryoverTargetLeaveTypeID IS NOT NULL
IF @target_type_id IS NULL SELECT @carryover_offset_days = [Carryover Offset Days], @carryover_limit = 2147483647, @target_type_id = CarryoverTargetLeaveTypeID, @carryover_multipler = [Carryover Multiplier] FROM dbo.Constant WHERE CarryoverSourceLeaveTypeID = @type_id

SELECT @start = dbo.GetDateFromDaysPast1900(@start_day), @stop = dbo.GetDateFromDaysPast1900(@stop_day)
SELECT @enable_start = DATEADD(month, @enable_after_months, dbo.GetDateFromDaysPast1900(@seniority_day))
SELECT @enable_start_day = DATEDIFF(d, 0, @enable_start)

IF (@period_id = 0)
BEGIN
	IF @enable_start_day > @start_day SET @start_day = @enable_start_day
	SELECT @rows = 1

	WHILE @rows > 0
	BEGIN
		SELECT TOP 1 @day = [Day past 1900], @unused = Unused FROM dbo.EmployeeLeaveUnused 
		WHERE EmployeeID = @employee_id AND TypeID = @type_id AND Unused > @max_seconds AND [Day past 1900] BETWEEN @start_day AND @stop_day ORDER BY [Day past 1900]
		SELECT @rows = @@ROWCOUNT

		IF @rows > 0
		BEGIN
			SELECT @adjustment = @max_seconds - @unused
			EXEC dbo.spEmployeeLeaveInsertAdjustment @employee_id, @type_id, @adjustment, @day, @target_type_id, @carryover_multipler, @carryover_offset_days, @carryover_limit
		END
	END
END
ELSE IF (@period_id = 4)
BEGIN
	SELECT @month = MONTH(@start), @year = YEAR(@start)
	--SELECT @day = [Day] FROM LeaveLimit WHERE TypeID = @type_id AND LimitID = @limit_id

	IF @day < DAY(@start) SET @month = @month + 1

	SET @start = dbo.AddMonthsToDY(@month, @day, @year)

	WHILE @start <= @stop
	BEGIN
		IF @start >= @enable_start
		BEGIN
			SET @current_day = DATEDIFF(dd, 0, @start)
			SELECT TOP 1 @unused = Unused FROM EmployeeLeaveUnused WHERE EmployeeID = @employee_id AND TypeID = @type_id AND [Day past 1900] <= @current_day ORDER BY [Day past 1900] DESC
		
			IF @unused > @max_seconds
			BEGIN
				SELECT @adjustment = @max_seconds - @unused
				EXEC dbo.spEmployeeLeaveInsertAdjustment @employee_id, @type_id, @adjustment, @current_day, @target_type_id, @carryover_multipler, @carryover_offset_days, @carryover_limit
			END
		END

		SET @month = @month + 1
		SET @start = dbo.AddMonthsToDY(@month, @day, @year)
	END
END
ELSE
BEGIN
	DECLARE @use_year_start bit, @use_year_stop bit
	SELECT @use_year_start = 0, @use_year_stop = 0

	IF (@period_id = 1)
	BEGIN
		--SELECT @day = [Day], @month = [Month] FROM LeaveLimit WHERE TypeID = @type_id AND LimitID = @limit_id

		IF @day=1 AND @month=1 SET @use_year_start = 1
		ELSE IF @day=31 AND @month=12 SET @use_year_stop = 1
	END

	ELSE IF (@period_id = 2 OR @period_id = 3)
	BEGIN
		IF @period_id = 3 SET @seniority_day = @seniority_day - 1

		SET @day = DAY(@seniority_day)
		SET @month = MONTH(@seniority_day)
	END

	DECLARE @stop_year int

	SELECT @start = dbo.GetDateFromDaysPast1900(@start_day), @stop = dbo.GetDateFromDaysPast1900(@stop_day)
	SELECT @year = YEAR(@start), @stop_year = YEAR(@stop)

	if DAY(@start) + MONTH(@start) * 31 > @day + @month * 31 SELECT @year = @year  + 1

	if DAY(@stop) + MONTH(@stop) * 31 < @day + @month * 31 SELECT @stop_year = @stop_year  - 1


	WHILE @year <= @stop_year
	BEGIN
		IF @use_year_start = 1 SET @current = dbo.GetYearStart(@year)
		ELSE IF @use_year_stop = 1 SET @current = DATEADD(d,-1,dbo.GetYearStart(@year + 1))
		ELSE SET @current = dbo.GetDateFromMDY2(@month, @day, @year,1)
		
		IF @current >= @enable_start AND @current >= @start
		BEGIN
			SELECT @current_day = DATEDIFF(dd, 0, @current)

			SELECT TOP 1 @unused = Unused FROM dbo.EmployeeLeaveUnused WHERE EmployeeID = @employee_id AND TypeID = @type_id AND [Day past 1900] <= @current_day ORDER BY [Day past 1900] DESC

			IF @unused > @max_seconds
			BEGIN
				SELECT @adjustment = @max_seconds - @unused
				EXEC dbo.spEmployeeLeaveInsertAdjustment @employee_id, @type_id, @adjustment, @current_day, @target_type_id, @carryover_multipler, @carryover_offset_days, @carryover_limit
			END
		END
		
		SET @year = @year + 1
	END
END
GO
IF OBJECT_id('dbo.spEmployeeLeaveLimit') IS NULL 
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEmployeeLeaveLimit AS'
	GRANT EXEC ON dbo.spEmployeeLeaveLimit TO public
END
GO
ALTER PROC dbo.spEmployeeLeaveLimit
	@employee_id int,
	@type_id int,
	@start_day int
AS
DECLARE @plan_id int
DECLARE @effective_start datetime
DECLARE @effective_stop datetime
DECLARE @infinity datetime
DECLARE @infinity_day int
DECLARE @seniority_day int, @seniority datetime
DECLARE @start2 datetime, @stop datetime, @start datetime
DECLARE @start2_day int, @stop_day int
DECLARE @max_year int
DECLARE @fte numeric(9,4)
DECLARE @multiply_limit_by_fte bit
DECLARE @month int, @day int, @period_id int, @max_seconds int, @enable_after_months int

SET NOCOUNT ON

SELECT @max_year = [Leave Seer Years] FROM dbo.Constant
SELECT @infinity = DATEADD(yy, @max_year, GETDATE()), @start = dbo.GetDateFromDaysPast1900(@start_day)
SELECT @seniority = dbo.GetDateFromDaysPast1900(@seniority_day), @infinity_day = DATEDIFF(d, 0, @infinity)

DECLARE emplan_cursor CURSOR LOCAL STATIC
FOR SELECT EP.PlanID,
		[Effective Start] = dbo.GetDateFromDaysPast1900(EP.[Start Day past 1900]),
		[Effective Stop] = ISNULL(dbo.GetDateFromDaysPast1900(EP.[Stop Day past 1900]), @infinity),
		EP.FTE,
		LL.Flags & 1,
		LL.[Month],
		LL.[Day],
		LL.[Enable after Months],
		LL.[Max Seconds],
		LL.PeriodID
	FROM dbo.EmployeeLeavePlan EP 
	INNER JOIN dbo.LeaveLimit LL ON
		EP.EmployeeID = @employee_id AND EP.[Start Day past 1900] <= @infinity_day AND (EP.[Stop Day past 1900] IS NULL OR EP.[Stop Day past 1900] >= @start) AND
		LL.PlanID = EP.PlanID AND LL.TypeID = @type_id 
		
UNION

SELECT EP.PlanID,
	[Effective Start] = CASE
		WHEN DATEADD(month,LR.[Start Month],dbo.GetDateFromDaysPast1900(E.[Seniority Begins Day past 1900])) > dbo.GetDateFromDaysPast1900(EP.[Start Day past 1900]) THEN DATEADD(month,LR.[Start Month],dbo.GetDateFromDaysPast1900(E.[Seniority Begins Day past 1900]))
		ELSE dbo.GetDateFromDaysPast1900(EP.[Start Day past 1900])
	END,
	[Effective Stop] = CASE
		WHEN EP.[Stop Day past 1900] IS NULL AND LR.[Stop Month] = 2147483647 THEN @infinity
		WHEN EP.[Stop Day past 1900] IS NULL THEN DATEADD(d,-1,DATEADD(month,LR.[Stop Month]+1,dbo.GetDateFromDaysPast1900(E.[Seniority Begins Day past 1900])))
		WHEN LR.[Stop Month] < 2147483647 AND DATEADD(month,LR.[Stop Month]+1,dbo.GetDateFromDaysPast1900(E.[Seniority Begins Day past 1900])) <= dbo.GetDateFromDaysPast1900(EP.[Stop Day past 1900]) THEN DATEADD(d,-1,DATEADD(month,LR.[Stop Month]+1,dbo.GetDateFromDaysPast1900(E.[Seniority Begins Day past 1900])))
		ELSE dbo.GetDateFromDaysPast1900(EP.[Stop Day past 1900])
	END,
	EP.FTE,
	PL.Flags & 1, -- multiply limit by fte
	LR.[Limit Month],
	LR.[Limit Day],
	0, -- enable after months
	LR.[Limit Max Seconds],
	LR.LimitPeriodID
FROM dbo.EmployeeLeavePlan EP 
INNER JOIN dbo.Employee E ON EP.EmployeeID = E.EmployeeID
INNER JOIN dbo.LeaveRate LR ON
EP.EmployeeID = @employee_id AND EP.[Start Day past 1900] <= @infinity_day AND (EP.[Stop Day past 1900] IS NULL OR EP.[Stop Day past 1900] >= @start) AND
LR.PlanID = EP.PlanID AND LR.TypeID = @type_id AND LR.[Limit Max Seconds] < 2147483647 AND 
dbo.DoRaysIntersect(
	EP.[Start Day past 1900],
	CASE WHEN EP.[Stop Day past 1900] IS NULL THEN DATEDIFF(d,0,@infinity) ELSE EP.[Stop Day past 1900] END,
	DATEDIFF(d,0,DATEADD(month,LR.[Start Month],E.[Seniority Begins Day past 1900])),
	DATEDIFF(d,0,CASE WHEN LR.[Stop Month] = 2147483647 THEN @infinity ELSE DATEADD(month,LR.[Stop Month],E.[Seniority Begins Day past 1900]) END)
) = 1
INNER JOIN dbo.LeavePlan PL ON EP.PlanID = PL.PlanID
ORDER BY [Effective Start]

OPEN emplan_cursor
FETCH NEXT FROM emplan_cursor INTO @plan_id, @effective_start, @effective_stop, @fte, @multiply_limit_by_fte, @month, @day, @enable_after_months, @max_seconds, @period_id
WHILE @@FETCH_STATUS = 0
BEGIN
	SELECT @start2 = @effective_start
	SELECT @stop =  @effective_stop
	
	IF @start2 < @start SELECT @start2 = @start
	IF @stop > @infinity SELECT @stop = @infinity

	SELECT @start2_day = DATEDIFF(dd, 0, @start2), @stop_day = DATEDIFF(dd, 0, @stop)
	
	IF @stop_day >= @start2_day
	BEGIN
		EXEC dbo.spEmployeeLeaveApplyLimits
			@employee_id,
			@type_id,
			@start2_day,
			@stop_day, 
			@period_id, @month, @day, @enable_after_months, @max_seconds, @multiply_limit_by_fte,
			@fte
	END
	
	FETCH NEXT FROM emplan_cursor INTO @plan_id, @effective_start, @effective_stop, @fte, @multiply_limit_by_fte, @month, @day, @enable_after_months, @max_seconds, @period_id
END
CLOSE emplan_cursor
DEALLOCATE emplan_cursor
GO
IF OBJECT_id('dbo.spEmployeeLeavePlanUpdate') IS NULL 
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEmployeeLeavePlanUpdate AS'
	GRANT EXEC ON dbo.spEmployeeLeavePlanUpdate TO public
END
GO
ALTER PROC dbo.spEmployeeLeavePlanUpdate
	@item_id int,
	@plan_id int,
	@start int,
	@stop int,
	@fte numeric(9,4) = NULL
AS
DECLARE @employee_id int
DECLARE @authorized bit

SET NOCOUNT ON

SELECT @employee_id = EmployeeID FROM EmployeeLeavePlan WHERE ItemID = @item_id

EXEC dbo.spPermissionInsureForCurrentUserOnPerson @employee_id, 128, 2, @authorized out
IF @authorized = 1 UPDATE EmployeeLeavePlan SET PlanID = @plan_id, [Start Day past 1900] = @start, [Stop Day past 1900]= @stop, FTE = CASE WHEN @fte IS NULL THEN FTE ELSE @fte END
WHERE ItemID = @item_id
GO
IF OBJECT_id('dbo.spEmployeeLeaveSummarizeLAPEnrollment') IS NULL 
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEmployeeLeaveSummarizeLAPEnrollment AS'
	GRANT EXEC ON dbo.spEmployeeLeaveSummarizeLAPEnrollment TO public
END
GO
ALTER PROC dbo.spEmployeeLeaveSummarizeLAPEnrollment
	@batch_id int
AS
SET NOCOUNT ON

EXEC dbo.spPermissionGetOnPeopleForCurrentUser2 @batch_id, 128

SELECT
EmployeeID = X.[ID],
Enrollment = CAST('' AS varchar(4000)),
[Next Day past 1900] = CASE WHEN (X.X & 1) = 1 THEN -2147483648 ELSE 2147483647 END
INTO #LAP112604
FROM TempX X WHERE X.BatchID = @batch_id

DECLARE @rows int
SELECT @rows = 1
WHILE @rows > 0
BEGIN
	UPDATE #L
	SET [Next Day past 1900] = ISNULL((
		SELECT MIN(EP.[Start Day past 1900])
		FROM dbo.EmployeeLeavePlan EP WHERE EP.EmployeeID = #L.EmployeeID AND EP.[Start Day past 1900] > #L.[Next Day past 1900]
	), 2147483647)
	FROM #LAP112604 #L WHERE #L.[Next Day past 1900] < 2147483647
	SELECT @rows = @@ROWCOUNT

	IF @rows > 0
	UPDATE #L
	SET Enrollment = SUBSTRING(Enrollment +
		CASE WHEN LEN(#L.Enrollment) = 0 THEN '' ELSE ' : ' END +
		P.[Plan] + 
		' (' + 
		CAST(dbo.GetDateFromDaysPast1900(EP.[Start Day past 1900]) AS char(11)) + 
		CASE WHEN EP.[Stop Day past 1900] IS NULL THEN '' ELSE ' to ' + CAST(dbo.GetDateFromDaysPast1900(EP.[Stop Day past 1900]) AS varchar(11)) END +
		CASE WHEN EP.FTE=1 THEN '' ELSE ' ' + CAST(EP.FTE AS varchar(50)) + ' FTE' END +
		')'
	,1,4000)

	FROM #LAP112604 #L
	INNER JOIN dbo.EmployeeLeavePlan EP ON EP.EmployeeID = #L.EmployeeID AND EP.[Start Day past 1900] = #L.[Next Day past 1900]
	INNER JOIN dbo.LeavePlan P ON EP.PlanID = P.PlanID
END

SELECT #L.EmployeeID, Employee = P.[List As], #L.Enrollment
FROM #LAP112604 #L
INNER JOIN vwPersonListAs P ON #L.EmployeeID = P.PersonID
ORDER BY P.[List As]

DELETE TempX WHERE BatchID = @batch_id OR DATEDIFF(hh, Created, GETDATE()) > 1
GO
IF OBJECT_id('dbo.spEmployeeLeavePlanInsertOrUpdateFirst') IS NULL 
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEmployeeLeavePlanInsertOrUpdateFirst AS'
	GRANT EXEC ON dbo.spEmployeeLeavePlanInsertOrUpdateFirst TO public
END
GO
ALTER PROC dbo.spEmployeeLeavePlanInsertOrUpdateFirst
	@employee_id int,
	@plan_id int,
	@start int,
	@stop int,
	@fte numeric(9,4) = NULL,
	@item_id int OUT
AS
SET NOCOUNT ON

SELECT TOP 1 @item_id = ItemID FROM EmployeeLeavePlan WHERE EmployeeID = @employee_id ORDER BY [Start Day past 1900]

IF @item_id IS NULL
BEGIN
	IF @fte IS NULL SET @fte = 1
	INSERT INTO EmployeeLeavePlan (EmployeeID,PlanId,[Start Day past 1900],[Stop Day past 1900],FTE)
	VALUES (@employee_id,@plan_id,@start,@stop,@fte)

	SELECT @item_id =  SCOPE_IDENTITY()
END
ELSE
	UPDATE dbo.EmployeeLeavePlan SET
	[Start Day past 1900] = @start,
	[Stop Day past 1900] = @stop,
	PlanID = @plan_id,
	FTE = CASE WHEN @fte IS NULL THEN FTE ELSE @fte END
	WHERE ItemID = @item_id
GO
IF OBJECT_id('dbo.spEmployeeLeavePlanInsert') IS NULL 
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEmployeeLeavePlanInsert AS'
	GRANT EXEC ON dbo.spEmployeeLeavePlanInsert TO public
END
GO
ALTER PROC dbo.spEmployeeLeavePlanInsert
	@employee_id int,
	@plan_id int,
	@start int,
	@stop int,
	@item_id int OUT,
	@fte numeric(9,4) = 1
AS
DECLARE @authorized bit

SET NOCOUNT ON

EXEC dbo.spPermissionInsureForCurrentUserOnPerson @employee_id, 128, 2, @authorized out

IF @authorized = 1
BEGIN
	INSERT dbo.EmployeeLeavePlan (EmployeeID,PlanId,[Start Day past 1900],[Stop Day past 1900],FTE)
	VALUES (@employee_id,@plan_id,@start,@stop,@fte)

	SELECT @item_id = SCOPE_IDENTITY()
END
GO
IF OBJECT_id('dbo.spExpenseCanUserApproveExpenses') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spExpenseCanUserApproveExpenses AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spExpenseCanUserApproveExpenses TO public'
END
GO
-- Returns bit mask that summarizes which expenses the current user can approve (write permissions on approved expenses)
ALTER PROC dbo.spExpenseCanUserApproveExpenses
	@result_mask int = 0 out, -- 1: self, 2: subordinates, 4: nonsubordinates, 8: others (not self), 16: all, 32: approved unreimbursed expenses exist, 64: pending reimburse expenses exist
	@yes bit =0 out -- depricated. provided for backward compatibility
AS
DECLARE @batch_id int
SET @batch_id = RAND() * 2147483647
SELECT @result_mask = 0, @yes = 0

IF IS_MEMBER('db_owner')=1 SELECT @result_mask = 31, @yes = 1
ELSE
BEGIN
	DECLARE @employee_id int
	SELECT TOP 1 @employee_id = EmployeeID FROM dbo.Employee WHERE [SID]=SUSER_SID()

	INSERT dbo.TempX(BatchID,[ID])
	SELECT @batch_id, EmployeeID FROM dbo.Employee WHERE [Active Employee]=1

	EXEC dbo.spPermissionGetOnPeopleForCurrentUser2 @batch_id, 10011

	-- 1: Self
	IF EXISTS(SELECT * FROM dbo.TempX WHERE BatchID=@batch_id AND [ID] = @employee_id AND (X&2)=2) SET @result_mask = @result_mask | 1
	
	-- 2: Subordinates (actually at least one subordinate)
	IF EXISTS(
		SELECT * FROM dbo.TempX X
		INNER JOIN dbo.Employee S ON X.BatchID=@batch_id AND X.[ID]=S.EmployeeID AND S.ManagerID=@employee_id AND (X&2) = 2
	) SET @result_mask = @result_mask | 2
	
	-- 4: Non-Subordinates
	IF EXISTS(
		SELECT * FROM dbo.TempX X
		INNER JOIN dbo.Employee S ON X.BatchID=@batch_id AND X.[ID]=S.EmployeeID AND X.[ID] != @employee_id AND S.ManagerID != @employee_id AND (X.X&2) = 2
	) SET @result_mask = @result_mask | 4
	
	-- 8: Others (regardless of org chart)
	IF EXISTS(SELECT * FROM dbo.TempX WHERE BatchID=@batch_id AND [ID] != @employee_id AND (X&2)=2) SET @result_mask = @result_mask | 8
	
	-- 16: All
	IF NOT EXISTS(SELECT * FROM dbo.TempX WHERE BatchID=@batch_id AND [ID] != @employee_id AND (X&2)=0) SET @result_mask = @result_mask | 16

	IF @result_mask > 0 SET @yes = 1
END

-- 32: Approved unreimbursed expenses exist
IF EXISTS(SELECT * FROM dbo.EmployeeExpense WHERE (StatusID & 1) =1 AND [Day Reimbursed] IS NULL) SET @result_mask = @result_mask | 32

-- 64: Pending unreimbursed expenses exist
IF EXISTS(SELECT * FROM dbo.EmployeeExpense WHERE StatusID = 8 AND [Day Reimbursed] IS NULL) SET @result_mask = @result_mask | 64

GO
IF OBJECT_ID('dbo.spEmployeeExpenseSummarizeApprovedUnreimbursed') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEmployeeExpenseSummarizeApprovedUnreimbursed AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spEmployeeExpenseSummarizeApprovedUnreimbursed TO public'
END
GO
-- Summarizes expenses by check
ALTER PROC dbo.spEmployeeExpenseSummarizeApprovedUnreimbursed
	@batch_id int, @authorized bit out
AS
SET NOCOUNT ON

EXEC dbo.spPermissionGetOnPeopleForCurrentUser2 @batch_id, 10010
DELETE TempX WHERE BatchID=@batch_id AND (X&1)=0
SELECT @authorized= CASE WHEN @@ROWCOUNT=0 THEN 1 ELSE 0 END

EXEC dbo.spPermissionGetOnPeopleForCurrentUser2 @batch_id, 10011

CREATE TABLE #T(EmployeeID int, [Start] int, [Stop] int)
CREATE UNIQUE INDEX T_EmployeeID ON #T(EmployeeID)

INSERT #T(EmployeeID, [Start], [Stop]) 
SELECT [ID], 
(SELECT MIN(XP.[Day past 1900]) FROM dbo.EmployeeExpense XP WHERE XP.EmployeeID=X.[ID] AND XP.StatusID IN (1,5) AND XP.[Day Reimbursed] IS NULL),
(SELECT MAX(XP.[Day past 1900]) FROM dbo.EmployeeExpense XP WHERE XP.EmployeeID=X.[ID] AND XP.StatusID IN (1,5) AND XP.[Day Reimbursed] IS NULL)
FROM dbo.TempX X WHERE X.BatchID=@batch_id


SELECT
E.EmployeeID,
D.Department,
Employee = V.[List As],
Manager = ISNULL(M.[List As],''),
[Beginning] = dbo.GetDateFromDaysPast1900(#T.[Start]),
[Ending] = dbo.GetDateFromDaysPast1900(#T.[Stop]),
[Previous Pending] = ISNULL((
	SELECT SUM(E.Amount) FROM dbo.EmployeeExpense E WHERE E.EmployeeID=X.[ID] AND E.[Day past 1900] < #T.[Start] AND E.StatusID = 8
), 0),
Pending = ISNULL((
	SELECT SUM(E.Amount) FROM dbo.EmployeeExpense E WHERE E.EmployeeID=X.[ID] AND E.[Day past 1900] BETWEEN #T.[Start] AND #T.[Stop] AND E.StatusID = 8
), 0),
[Approved Unreimbursed] = ISNULL((
	SELECT SUM(E.Amount) FROM dbo.EmployeeExpense E WHERE E.EmployeeID=X.[ID] AND E.[Day past 1900] BETWEEN #T.[Start] AND #T.[Stop] AND E.StatusID IN (1,5) AND E.[Day Reimbursed] IS NULL
), 0),
[Reimbursed] = ISNULL((
	SELECT SUM(E.Amount) FROM dbo.EmployeeExpense E WHERE E.EmployeeID=X.[ID] AND E.[Day past 1900] BETWEEN #T.[Start] AND #T.[Stop] AND E.[Day Reimbursed] IS NOT NULL
), 0),
Denied = ISNULL((
	SELECT SUM(E.Amount) FROM dbo.EmployeeExpense E WHERE E.EmployeeID=X.[ID] AND E.[Day past 1900] BETWEEN #T.[Start] AND #T.[Stop] AND E.StatusID = 2
), 0),
Total = ISNULL((
	SELECT SUM(E.Amount) FROM dbo.EmployeeExpense E WHERE E.EmployeeID=X.[ID] AND E.[Day past 1900] BETWEEN #T.[Start] AND #T.[Stop]
), 0),
[Permissions] = X.X
FROM dbo.TempX X
INNER JOIN #T ON X.BatchID = @batch_id AND #T.EmployeeID = X.[ID] AND #T.[Start] IS NOT NULL
INNER JOIN dbo.Employee E ON #T.EmployeeID = E.EmployeeID
INNER JOIN dbo.Department D ON E.DepartmentID = D.DepartmentID
INNER JOIN dbo.vwPersonListAs V ON E.EmployeeID = V.PersonID
LEFT JOIN dbo.vwPersonListAs M ON E.ManagerID = M.PersonID
ORDER BY D.Department, V.[List As]

DELETE TempX WHERE BatchID=@batch_id
GO
IF OBJECT_ID('dbo.spEmployeeExpenseSummarizeAllUnreimbursed') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEmployeeExpenseSummarizeAllUnreimbursed AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spEmployeeExpenseSummarizeAllUnreimbursed TO public'
END
GO
-- Summarizes expenses by check
ALTER PROC dbo.spEmployeeExpenseSummarizeAllUnreimbursed
	@batch_id int, @stop_day int, @authorized bit out
AS
SET NOCOUNT ON

EXEC dbo.spPermissionGetOnPeopleForCurrentUser2 @batch_id, 10010
DELETE TempX WHERE BatchID=@batch_id AND (X&1)=0
SELECT @authorized= CASE WHEN @@ROWCOUNT=0 THEN 1 ELSE 0 END

EXEC dbo.spPermissionGetOnPeopleForCurrentUser2 @batch_id, 10011

CREATE TABLE #T(EmployeeID int, [Start] int)
CREATE UNIQUE INDEX T_EmployeeID ON #T(EmployeeID)

INSERT #T(EmployeeID, [Start]) 
SELECT [ID], 
(SELECT MIN(XP.[Day past 1900]) FROM dbo.EmployeeExpense XP WHERE XP.EmployeeID=X.[ID] AND XP.StatusID != 2 AND XP.[Day Reimbursed] IS NULL)
FROM dbo.TempX X WHERE X.BatchID=@batch_id

SELECT
E.EmployeeID,
D.Department,
Employee = V.[List As],
Manager = ISNULL(M.[List As],''),
[First Unreimbursed] = dbo.GetDateFromDaysPast1900(#T.[Start]),
[Previous Pending] = ISNULL((
	SELECT SUM(E.Amount) FROM dbo.EmployeeExpense E WHERE E.EmployeeID=X.[ID] AND E.[Day past 1900] < #T.[Start] AND E.StatusID = 8
), 0),
Pending = ISNULL((
	SELECT SUM(E.Amount) FROM dbo.EmployeeExpense E WHERE E.EmployeeID=X.[ID] AND E.[Day past 1900] BETWEEN #T.[Start] AND @stop_day AND E.StatusID = 8
), 0),
[Unreimbursed] = ISNULL((
	SELECT SUM(E.Amount) FROM dbo.EmployeeExpense E WHERE E.EmployeeID=X.[ID] AND E.[Day past 1900] BETWEEN #T.[Start] AND @stop_day AND E.StatusID != 2 AND E.[Day Reimbursed] IS NULL
), 0),
[Reimbursed] = ISNULL((
	SELECT SUM(E.Amount) FROM dbo.EmployeeExpense E WHERE E.EmployeeID=X.[ID] AND E.[Day past 1900] BETWEEN #T.[Start] AND @stop_day AND E.[Day Reimbursed] IS NOT NULL
), 0),
Denied = ISNULL((
	SELECT SUM(E.Amount) FROM dbo.EmployeeExpense E WHERE E.EmployeeID=X.[ID] AND E.[Day past 1900] BETWEEN #T.[Start] AND @stop_day AND E.StatusID = 2
), 0),
Total = ISNULL((
	SELECT SUM(E.Amount) FROM dbo.EmployeeExpense E WHERE E.EmployeeID=X.[ID] AND E.[Day past 1900] BETWEEN #T.[Start] AND @stop_day
), 0),
[Permissions] = X.X
FROM dbo.TempX X
INNER JOIN #T ON X.BatchID = @batch_id AND #T.EmployeeID = X.[ID] AND #T.[Start] IS NOT NULL
INNER JOIN dbo.Employee E ON #T.EmployeeID = E.EmployeeID
INNER JOIN dbo.Department D ON E.DepartmentID = D.DepartmentID
INNER JOIN dbo.vwPersonListAs V ON E.EmployeeID = V.PersonID
LEFT JOIN dbo.vwPersonListAs M ON E.ManagerID = M.PersonID
ORDER BY D.Department, V.[List As]

DELETE TempX WHERE BatchID=@batch_id
GO
IF OBJECT_id('dbo.spLeaveLimitUpdate') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spLeaveLimitUpdate AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spLeaveLimitUpdate TO public'
END
GO
ALTER PROC dbo.spLeaveLimitUpdate
	@type_id int,
	@plan_id int,
	@day tinyint,
	@month tinyint,
	@max_seconds int,
	@period_id int,
	@enable_after_months int = NULL,
	@carryover_limit_seconds int = NULL,
	@carryover_offset_days int = NULL,
	@carryover_multiplier numeric(9,8) = NULL,
	@carryover_target_leave_type_id int = NULL
AS
DECLARE @existed bit

SELECT @existed = 0
SELECT @existed = 1 FROM LeaveLimit WHERE PlanID = @plan_id AND TypeID = @type_id

IF @existed = 1 AND @max_seconds IS NOT NULL
	UPDATE LeaveLimit SET [Max Seconds] = @max_seconds, [Day] = @day, [Month] = @month, PeriodID = @period_id, [Enable After Months] = CASE WHEN @enable_after_months IS NULL THEN [Enable After Months] ELSE @enable_after_months END WHERE PlanID = @plan_id AND TypeID = @type_id
ELSE IF @existed = 1 AND @max_seconds IS NULL
	DELETE LeaveLimit WHERE PlanID = @plan_id AND TypeID = @type_id
ELSE IF @existed = 0 AND @max_seconds IS NOT NULL
	INSERT LeaveLimit([Max Seconds], [Day], [Month], PeriodID,TypeID,PlanID,[Enable After Months])
	VALUES (@max_seconds, @day, @month, @period_id,@type_id,@plan_id,ISNULL(@enable_after_months,0))

IF @carryover_limit_seconds IS NOT NULL UPDATE LeaveLimit SET [Carryover Limit Seconds]=@carryover_limit_seconds, [Carryover Offset Days]=@carryover_offset_days, [Carryover Multiplier]=@carryover_multiplier, CarryoverTargetLeaveTypeID = @carryover_target_leave_type_id WHERE PlanID = @plan_id AND TypeID = @type_id
GO
IF OBJECT_id('dbo.spGetYearStart') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spGetYearStart AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spGetYearStart TO public'
END
GO
ALTER PROC dbo.spGetYearStart @year int, @month int out, @day int out
AS
SET NOCOUNT ON
DECLARE @jan1 datetime
SELECT @jan1 = dbo.GetYearStart(@year)
SELECT @month = MONTH(@jan1), @day = DAY(@jan1)
GO
IF OBJECT_id('dbo.spGetYearStop') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spGetYearStop AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spGetYearStop TO public'
END
GO
ALTER PROC dbo.spGetYearStop @year int, @month int out, @day int out
AS
SET NOCOUNT ON
DECLARE @dec31 datetime
SELECT @dec31 = DATEADD(d,-1,dbo.GetYearStart(@year + 1))
SELECT @month = MONTH(@dec31), @day = DAY(@dec31)
GO		
IF OBJECT_id('dbo.spPermissionTestOnPersonForCurrentUser') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spPermissionTestOnPersonForCurrentUser AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spPermissionTestOnPersonForCurrentUser TO public'
END
GO
ALTER PROC dbo.spPermissionTestOnPersonForCurrentUser

@person_id int,
@attribute_id int
AS

-- Returns the permission on a given attribute 
-- on a given person (employee\applicant...) for the current user
DECLARE @user_employee_id int
DECLARE @user_department_id int, @employee_department_id int
DECLARE @user_division_id int, @employee_division_id int
DECLARE @user_location_id int, @employee_location_id int
DECLARE @user_manager_id int, @employee_delegated_manager_id int
DECLARE @user_org_user_field_1 int, @employee_org_user_field_1 int
DECLARE @user_sid varbinary(85), @employee_active bit
DECLARE @employee_dept_lkid int, @employee_div_lkid int

IF IS_MEMBER('db_owner') = 1
	SELECT 'db_owner has full permission'
ELSE
BEGIN
	SELECT @user_sid = SUSER_SID()

	SELECT @user_org_user_field_1 = OrgUserField1, @user_manager_id = ManagerID, @user_employee_id = EmployeeID, @user_division_id = DivisionID, @user_department_id = DepartmentID, @user_location_id = LocationID FROM dbo.Employee WHERE [SID] = @user_sid
	SELECT @employee_active = [Active Employee], @employee_org_user_field_1 = OrgUserField1, @employee_delegated_manager_id = DelegatedManagerID, @employee_department_id = DepartmentID, @employee_division_id = DivisionID, @employee_location_id = LocationID FROM dbo.Employee WHERE EmployeeID = @person_id
	SELECT @employee_dept_lkid = LeaveKeeperID FROM dbo.Department WHERE DepartmentID = @employee_department_id
	SELECT @employee_div_lkid = LeaveKeeperID FROM dbo.Division WHERE DivisionID = @employee_division_id

	SELECT [Group] = U.[name], S.Scope, P.[Permission Mask], P.[Deny Mask]
	FROM dbo.PermissionScopeAttribute P
	INNER JOIN dbo.PermissionScope S ON P.ScopeID = S.ScopeID
	INNER JOIN dbo.sysusers U ON P.ScopeID = 1 AND P.AttributeID = @attribute_id AND P.UID = U.uid AND (U.SID = @user_sid OR IS_MEMBER(U.[name]) = 1)

	UNION

	-- Select employee-level permissions
	SELECT [Group] = U.[name], S.Scope, P.[Permission Mask], P.[Deny Mask]
	FROM dbo.PermissionScopeAttribute P 
	INNER JOIN dbo.PermissionScope S ON P.ScopeID = S.ScopeID
	INNER JOIN dbo.sysusers U ON  P.AttributeID = @attribute_id AND P.UID = U.uid AND (U.SID = @user_sid OR IS_MEMBER(U.[name]) = 1)
		AND (
			(P.ScopeID = 2) OR					-- All employees								
			(P.ScopeID = 4 AND @user_employee_id = @person_id) OR			-- Self
			(P.ScopeID = 16 AND @employee_division_id = @user_division_id) OR	-- Employees in same division
			(P.ScopeID = 32 AND @employee_department_id = @user_department_id) OR	-- Employees in same department
			(P.ScopeID = 64 AND @employee_location_id = @user_location_id) OR	-- Employees in same location
			(P.ScopeID = 8 AND EXISTS(				-- Subordinates
				SELECT * FROM dbo.EmployeeSuperior S WHERE S.EmployeeID = @person_id AND S.SuperiorID = @user_employee_id
			)) OR
			(P.ScopeID = 256 AND EXISTS(		-- Delegated subordinates
				SELECT * FROM dbo.EmployeeSuperior S INNER JOIN dbo.Employee DM ON S.EmployeeID = @person_id AND S.SuperiorID = DM.EmployeeID AND DM.DelegatedManagerID = @user_employee_id
			)) OR
			(P.ScopeID = 512 AND @person_id = @user_manager_id) OR -- Manager
			(P.ScopeID = 1024 AND @employee_delegated_manager_id = @user_employee_id) OR -- Delegated self
			(P.ScopeID = 2048 AND EXISTS(				-- Manager's subordinates
				SELECT * FROM dbo.EmployeeSuperior S WHERE S.EmployeeID = @person_id AND S.SuperiorID = @user_manager_id
			)) OR
			(P.ScopeID = 4096 AND (
				(@user_org_user_field_1 IS NOT NULL AND @employee_org_user_field_1 = @user_org_user_field_1) OR 
				EXISTS(SELECT * FROM EmployeeUserFieldItem WHERE EmployeeID=@user_employee_id AND ItemID=@employee_org_user_field_1)
			)) OR -- Employees in same user org
			(P.ScopeID = 8192 AND @employee_active = 0) OR										-- Inactive employees
			(P.ScopeID = 16384 AND @user_employee_id IN (@employee_div_lkid, @employee_dept_lkid))	-- Leave keeper
		)
END
GO
IF OBJECT_id('dbo.spEmployeeTimeBoundRange') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEmployeeTimeBoundRange AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spEmployeeTimeBoundRange TO public'
END
GO
ALTER PROC dbo.spEmployeeTimeBoundRange
	@batch_id int,
	@start_day int,
	@stop_day int,
	@min_entry int out,
	@max_entry int out
AS
CREATE TABLE #BoundCheck(MinDay int, MaxDay int)

INSERT #BoundCheck SELECT MIN(DATEDIFF(d,0,T.[In])), MAX(DATEDIFF(day,0,DATEADD(s, T.Seconds, T.[In]))) FROM dbo.EmployeeTime T
INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND T.EmployeeID=X.[ID] AND DATEDIFF(d,0,T.[In]) <= @stop_day + 1

INSERT #BoundCheck SELECT MIN(I.[Day past 1900]), MAX(I.[Day past 1900]) FROM dbo.EmployeeLeaveUsedItem I
INNER JOIN dbo.EmployeeLeaveUsed U ON U.LeaveID=I.LeaveID AND I.[Day past 1900] BETWEEN @start_day AND @stop_day
INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND U.EmployeeID=X.[ID]

INSERT #BoundCheck SELECT MIN(E.[Day past 1900]),MAX(E.[Day past 1900]) FROM dbo.EmployeeLeaveEarned E
INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND E.EmployeeID=X.[ID] AND E.Seconds < 0 AND E.Auto=0 AND E.[Day past 1900] BETWEEN @start_day AND @stop_day

SELECT @min_entry=MIN(MinDay) - 31 FROM #BoundCheck WHERE MinDay IS NOT NULL
SELECT @max_entry=MAX(MaxDay) + 31 FROM #BoundCheck WHERE MaxDay IS NOT NULL

IF @max_entry < @start_day SET @max_entry = @start_day
GO
IF OBJECT_id('dbo.spEmployeeTimeChangeRegToOTDaily') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spEmployeeTimeChangeRegToOTDaily AS'
GO
ALTER PROC dbo.spEmployeeTimeChangeRegToOTDaily
	@start_day int,
	@stop_day int,
	@ot_basis int,
	@limit_seconds int,
	@ot_type_id int
AS
IF @ot_type_id IS NULL RETURN
DECLARE @ot_multiplier money

SET NOCOUNT ON

SELECT @ot_multiplier = PayRateM FROM dbo.TimeType WHERE @ot_type_id = TimeType.TypeID

SELECT DISTINCT ET.EmployeeID
INTO #OT_Eligible_Employees FROM #EMPLOYEE_TIME_ROUNDED ET
INNER JOIN Employee E ON ET.[In Day past 1900] BETWEEN @start_day AND @stop_day
AND ET.EmployeeID=E.EmployeeID AND (E.[OT Basis] & @ot_basis) > 0


IF @@ROWCOUNT=0 RETURN

CREATE TABLE #OT_Changes([UID] int NOT NULL PRIMARY KEY IDENTITY(1,1), EmployeeID int, D int, Seconds int, [OT Seconds] int, CurrentItemID int, [Item Seconds] int)

DECLARE @day int
SET @day = @start_day
WHILE @day <= @stop_day
BEGIN
	INSERT #OT_Changes(EmployeeID, D, Seconds, [OT Seconds], CurrentItemID, [Item Seconds])
	SELECT EmployeeID, @day, 0, 0, NULL, 0 FROM #OT_Eligible_Employees

	SET @day = @day + 1
END



CREATE INDEX [OT_ItemID_030308] ON #OT_CHANGES(CurrentItemID) WITH FILLFACTOR = 80 ON [PRIMARY]
CREATE INDEX [OT_Employee_Day_030308] ON #OT_CHANGES(EmployeeID, D) WITH FILLFACTOR = 80 ON [PRIMARY]


UPDATE #OT_CHANGES SET Seconds=ISNULL(
	(SELECT SUM([Out Seconds] - [In Seconds]) FROM #EMPLOYEE_TIME_ROUNDED ET WHERE OT.EmployeeID=ET.EmployeeID AND ET.[OT Eligible]=1 AND ET.[In Day past 1900]=OT.D)
,0) +ISNULL(
	(SELECT SUM(0-Seconds) FROM dbo.vwEmployeeLeaveApproved L WHERE L.[Limit Adjustment]=0 AND L.[OT Eligible]=1 AND L.EmployeeID=OT.EmployeeID AND L.Seconds<0 AND L.[Day past 1900] = OT.D)
,0)
FROM #OT_CHANGES OT

UPDATE #OT_CHANGES SET [OT Seconds] = [OT Seconds] + Seconds - @limit_seconds WHERE Seconds > @limit_seconds

-- Handles entries that are less than OT Seconds
WHILE 1=1
BEGIN
	DELETE #OT_CHANGES WHERE [OT Seconds] = 0

	UPDATE #OT_CHANGES SET CurrentItemID=(
		SELECT TOP 1 TempItemID FROM #EMPLOYEE_TIME_ROUNDED ET WHERE OT.EmployeeID=ET.EmployeeID AND ET.[In Day past 1900] = OT.D AND ET.[OT Eligible]=1 AND ET.[OT Disable]=0 ORDER BY ET.[Pay Rate],ET.[Regular] DESC
	)
	FROM #OT_CHANGES OT

	UPDATE OT SET [Item Seconds] = ET.[Out Seconds] - ET.[In Seconds] FROM #OT_CHANGES OT 
	INNER JOIN #EMPLOYEE_TIME_ROUNDED ET ON OT.CurrentItemID = ET.TempItemID

	UPDATE ET SET CalculatedTypeID=@ot_type_id, [OT Eligible] = 0, [Pay Rate] = ET.[Pay Rate] * @ot_multiplier, Regular=0, [OT Seconds] = ET.[Out Seconds] - ET.[In Seconds]
	FROM #EMPLOYEE_TIME_ROUNDED ET INNER JOIN #OT_CHANGES OT ON OT.CurrentItemID = ET.TempItemID AND OT.[OT Seconds] >= OT.[Item Seconds]

	IF @@ROWCOUNT=0 BREAK

	UPDATE #OT_CHANGES SET CurrentItemID=NULL, [OT Seconds] = OT.[OT Seconds] - OT.[Item Seconds]
	FROM #OT_CHANGES OT WHERE OT.[OT Seconds] >= OT.[Item Seconds]
END



-- Handles entries that are more than OT Seconds
UPDATE #EMPLOYEE_TIME_ROUNDED SET [Out Seconds] = [In Seconds] + OT.[Item Seconds] - OT.[OT Seconds]
FROM #EMPLOYEE_TIME_ROUNDED ET INNER JOIN #OT_CHANGES OT ON OT.CurrentItemID = ET.TempItemID

INSERT #EMPLOYEE_TIME_ROUNDED( EmployeeID, TimeSchemaID, [In Day past 1900], OriginalTypeID, CalculatedTypeID, [OT Eligible], [OT Disable], [Pay Rate], [OT Seconds], CopyTimeItemID, [In Seconds], [Out Seconds])
SELECT ET.EmployeeID, ET.TimeSchemaID, OT.D, @ot_type_id, @ot_type_id, 0, 0, ET.[Pay Rate] * @ot_multiplier, OT.[OT Seconds], ET.CopyTimeItemID, [In Seconds] = ET.[Out Seconds], [Out Seconds] = ET.[Out Seconds] + OT.[OT Seconds]
FROM #EMPLOYEE_TIME_ROUNDED ET INNER JOIN #OT_CHANGES OT ON OT.CurrentItemID = ET.TempItemID
GO
IF OBJECT_id('dbo.spEmployeeTimeChangeRegToSunOT') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spEmployeeTimeChangeRegToSunOT AS'
GO
ALTER PROC dbo.spEmployeeTimeChangeRegToSunOT
	@start_day int,
	@weeks int,
	@ot_basis int,
	@ot_type_id int,
	@limit_seconds int
AS
IF @ot_type_id IS NULL RETURN
SET NOCOUNT ON

DECLARE @ot_multiplier money
SELECT @ot_multiplier = PayRateM FROM dbo.TimeType WHERE TypeID = @ot_type_id

SELECT DISTINCT ET.EmployeeID
INTO #OT_ELIGIBLE_EMPLOYEES FROM #EMPLOYEE_TIME_ROUNDED ET
INNER JOIN Employee E ON ET.[In Day past 1900] BETWEEN @start_day AND @start_day + @weeks * 7 - 1 
AND ET.EmployeeID=E.EmployeeID AND (E.[OT Basis] & @ot_basis) > 0

IF @@ROWCOUNT=0 RETURN

CREATE TABLE #OT_CHANGES([UID] int NOT NULL PRIMARY KEY IDENTITY(1,1), [Start Day] int, [Stop Day] int, EmployeeID int, Seconds int, [OT Seconds] int, CurrentItemID int, [Item Seconds] int)
WHILE @weeks > 0
BEGIN
	INSERT #OT_CHANGES([Start Day], [Stop Day], EmployeeID, Seconds, [OT Seconds], CurrentItemID, [Item Seconds])
	SELECT @start_day, @start_day + 6, EmployeeID, 0, 0, NULL, 0 FROM #OT_ELIGIBLE_EMPLOYEES

	SELECT @weeks = @weeks - 1, @start_day = @start_day + 7
END

CREATE INDEX [OT_ItemID_030308] ON #OT_CHANGES(CurrentItemID) WITH FILLFACTOR = 80 ON [PRIMARY]

UPDATE #OT_CHANGES SET Seconds=ISNULL(
	(SELECT SUM([Out Seconds] - [In Seconds]) FROM #EMPLOYEE_TIME_ROUNDED ET WHERE OT.EmployeeID=ET.EmployeeID AND ET.[OT Eligible]=1 AND ET.[In Day past 1900] = OT.[Stop Day])
,0) +ISNULL(
	(SELECT SUM(0-Seconds) FROM dbo.vwEmployeeLeaveApproved L WHERE L.[Limit Adjustment]=0 AND L.[OT Eligible]=1 AND L.EmployeeID=OT.EmployeeID AND L.Seconds<0 AND L.[Day past 1900] = OT.[Stop Day])
,0)
FROM #OT_CHANGES OT WHERE EXISTS (
	SELECT * FROM #EMPLOYEE_TIME_ROUNDED ET WHERE ET.EmployeeID=OT.EmployeeID AND ET.[In Day past 1900] = OT.[Start Day]
) AND EXISTS (
	SELECT * FROM #EMPLOYEE_TIME_ROUNDED ET WHERE ET.EmployeeID=OT.EmployeeID AND ET.[In Day past 1900] = OT.[Start Day] + 1
) AND EXISTS (
	SELECT * FROM #EMPLOYEE_TIME_ROUNDED ET WHERE ET.EmployeeID=OT.EmployeeID AND ET.[In Day past 1900] = OT.[Start Day] + 2
) AND EXISTS (
	SELECT * FROM #EMPLOYEE_TIME_ROUNDED ET WHERE ET.EmployeeID=OT.EmployeeID AND ET.[In Day past 1900] = OT.[Start Day] + 3
) AND EXISTS (
	SELECT * FROM #EMPLOYEE_TIME_ROUNDED ET WHERE ET.EmployeeID=OT.EmployeeID AND ET.[In Day past 1900] = OT.[Start Day] + 4
) AND EXISTS (
	SELECT * FROM #EMPLOYEE_TIME_ROUNDED ET WHERE ET.EmployeeID=OT.EmployeeID AND ET.[In Day past 1900] = OT.[Start Day] + 5
)

UPDATE #OT_CHANGES SET [OT Seconds] = [OT Seconds] + Seconds - @limit_seconds WHERE Seconds > @limit_seconds

-- Handles entries that are less than OT Seconds
WHILE 1=1
BEGIN
	DELETE #OT_CHANGES WHERE [OT Seconds] = 0

	UPDATE #OT_CHANGES SET CurrentItemID=(
		SELECT TOP 1 TempItemID FROM #EMPLOYEE_TIME_ROUNDED ET WHERE OT.EmployeeID=ET.EmployeeID AND ET.[In Day past 1900] BETWEEN OT.[Start Day] AND OT.[Stop Day] AND ET.[OT Eligible]=1 AND ET.[OT Disable]=0
		ORDER BY ET.[Pay Rate], ET.[Regular] DESC, ET.[In Day past 1900] DESC
	)
	FROM #OT_CHANGES OT

	UPDATE OT SET [Item Seconds] = ET.[Out Seconds] - ET.[In Seconds] FROM #OT_CHANGES OT 
	INNER JOIN #EMPLOYEE_TIME_ROUNDED ET ON OT.CurrentItemID = ET.TempItemID

	UPDATE ET SET CalculatedTypeID=@ot_type_id, [OT Eligible] = 0, [Pay Rate] = ET.[Pay Rate] * @ot_multiplier, [OT Seconds] = ET.[Out Seconds] - ET.[In Seconds]
	FROM #EMPLOYEE_TIME_ROUNDED ET INNER JOIN #OT_CHANGES OT ON OT.CurrentItemID = ET.TempItemID AND OT.[OT Seconds] >= OT.[Item Seconds]

	IF @@ROWCOUNT=0 BREAK

	UPDATE #OT_CHANGES SET CurrentItemID=NULL, [OT Seconds] = OT.[OT Seconds] - OT.[Item Seconds]
	FROM #OT_CHANGES OT WHERE OT.[OT Seconds] >= OT.[Item Seconds]
END

-- Handles entries that are more than OT Seconds
UPDATE #EMPLOYEE_TIME_ROUNDED SET [Out Seconds] = ET.[In Seconds] + OT.[Item Seconds] - OT.[OT Seconds]
FROM #EMPLOYEE_TIME_ROUNDED ET INNER JOIN #OT_CHANGES OT ON OT.CurrentItemID = ET.TempItemID

INSERT #EMPLOYEE_TIME_ROUNDED( EmployeeID, TimeSchemaID, [In Day past 1900], OriginalTypeID, CalculatedTypeID, [OT Eligible], [OT Disable], [Pay Rate], [In Seconds], [Out Seconds], Regular, CopyTimeItemID, [OT Seconds])
SELECT OT.EmployeeID, ET.TimeSchemaID, ET.[In Day past 1900], @ot_type_id, @ot_type_id, 0, 0, ET.[Pay Rate] * @ot_multiplier, [In Seconds] = ET.[Out Seconds], [Out Seconds] = ET.[Out Seconds] + OT.[OT Seconds], 0, ET.CopyTimeItemID, OT.[OT Seconds]
FROM #EMPLOYEE_TIME_ROUNDED ET INNER JOIN #OT_CHANGES OT ON OT.CurrentItemID = ET.TempItemID

DELETE #OT_CHANGES WHERE CurrentItemID IS NOT NULL
GO
IF OBJECT_id('dbo.spEmployeeTimeChangeRegToOT40') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spEmployeeTimeChangeRegToOT40 AS'
GO
ALTER PROC dbo.spEmployeeTimeChangeRegToOT40
	@start_day int,
	@weeks int,
	@ot_basis int,
	@limit_seconds int
AS
DECLARE @ot_type_id int, @ot_multiplier money

SET NOCOUNT ON

SELECT @ot_type_id = Constant.OTTimeTypeID FROM dbo.Constant
IF @ot_type_id IS NULL RETURN

SELECT @ot_multiplier = PayRateM FROM dbo.Constant INNER JOIN TimeType ON dbo.Constant.OTTimeTypeID = TimeType.TypeID

SELECT DISTINCT ET.EmployeeID
INTO #OT_ELIGIBLE_EMPLOYEES FROM #EMPLOYEE_TIME_ROUNDED ET
INNER JOIN Employee E ON ET.[In Day past 1900] BETWEEN @start_day AND @start_day + @weeks * 7 - 1 
AND ET.EmployeeID=E.EmployeeID AND (E.[OT Basis] & @ot_basis) > 0

IF @@ROWCOUNT=0 RETURN

CREATE TABLE #OT_CHANGES([UID] int NOT NULL PRIMARY KEY IDENTITY(1,1), [Start Day] int, [Stop Day] int, EmployeeID int, Seconds int, [OT Seconds] int, CurrentItemID int, [Item Seconds] int)
WHILE @weeks > 0
BEGIN
	INSERT #OT_CHANGES([Start Day], [Stop Day], EmployeeID, Seconds, [OT Seconds], CurrentItemID, [Item Seconds])
	SELECT @start_day, @start_day + 6, EmployeeID, 0, 0, NULL, 0 FROM #OT_ELIGIBLE_EMPLOYEES

	SELECT @weeks = @weeks - 1, @start_day = @start_day + 7
END

CREATE INDEX [OT_ItemID_030308] ON #OT_CHANGES(CurrentItemID) WITH FILLFACTOR = 80 ON [PRIMARY]

UPDATE #OT_CHANGES SET Seconds=ISNULL(
	(SELECT SUM([Out Seconds] - [In Seconds]) FROM #EMPLOYEE_TIME_ROUNDED ET WHERE OT.EmployeeID=ET.EmployeeID AND ET.[OT Eligible]=1 AND ET.[In Day past 1900] BETWEEN OT.[Start Day] AND OT.[Stop Day])
,0) +ISNULL(
	(SELECT SUM(0-Seconds) FROM dbo.vwEmployeeLeaveApproved L WHERE L.[Limit Adjustment]=0 AND L.[OT Eligible]=1 AND L.EmployeeID=OT.EmployeeID AND L.Seconds<0 AND L.[Day past 1900] BETWEEN OT.[Start Day] AND OT.[Stop Day])
,0)
FROM #OT_CHANGES OT

UPDATE #OT_CHANGES SET [OT Seconds] = [OT Seconds] + Seconds - @limit_seconds WHERE Seconds > @limit_seconds

-- Handles entries that are less than OT Seconds
WHILE 1=1
BEGIN
	DELETE #OT_CHANGES WHERE [OT Seconds] = 0

	UPDATE #OT_CHANGES SET CurrentItemID=(
		SELECT TOP 1 TempItemID FROM #EMPLOYEE_TIME_ROUNDED ET WHERE OT.EmployeeID=ET.EmployeeID AND ET.[In Day past 1900] BETWEEN OT.[Start Day] AND OT.[Stop Day] AND ET.[OT Eligible]=1 AND ET.[OT Disable]=0
		ORDER BY ET.[Pay Rate], ET.[Regular] DESC, ET.[In Day past 1900] DESC
	)
	FROM #OT_CHANGES OT

	UPDATE OT SET [Item Seconds] = ET.[Out Seconds] - ET.[In Seconds] FROM #OT_CHANGES OT 
	INNER JOIN #EMPLOYEE_TIME_ROUNDED ET ON OT.CurrentItemID = ET.TempItemID

	UPDATE ET SET CalculatedTypeID=@ot_type_id, [OT Eligible] = 0, [Pay Rate] = ET.[Pay Rate] * @ot_multiplier, [OT Seconds] = ET.[Out Seconds] - ET.[In Seconds]
	FROM #EMPLOYEE_TIME_ROUNDED ET INNER JOIN #OT_CHANGES OT ON OT.CurrentItemID = ET.TempItemID AND OT.[OT Seconds] >= OT.[Item Seconds]

	IF @@ROWCOUNT=0 BREAK

	UPDATE #OT_CHANGES SET CurrentItemID=NULL, [OT Seconds] = OT.[OT Seconds] - OT.[Item Seconds]
	FROM #OT_CHANGES OT WHERE OT.[OT Seconds] >= OT.[Item Seconds]
END

-- Handles entries that are more than OT Seconds
UPDATE #EMPLOYEE_TIME_ROUNDED SET [Out Seconds] = ET.[In Seconds] + OT.[Item Seconds] - OT.[OT Seconds]
FROM #EMPLOYEE_TIME_ROUNDED ET INNER JOIN #OT_CHANGES OT ON OT.CurrentItemID = ET.TempItemID

INSERT #EMPLOYEE_TIME_ROUNDED( EmployeeID, TimeSchemaID, [In Day past 1900], OriginalTypeID, CalculatedTypeID, [OT Eligible], [OT Disable], [Pay Rate], [In Seconds], [Out Seconds], Regular, CopyTimeItemID, [OT Seconds])
SELECT OT.EmployeeID, ET.TimeSchemaID, ET.[In Day past 1900], @ot_type_id, @ot_type_id, 0, 0, ET.[Pay Rate] * @ot_multiplier, [In Seconds] = ET.[Out Seconds], [Out Seconds] = ET.[Out Seconds] + OT.[OT Seconds], 0, ET.CopyTimeItemID, OT.[OT Seconds]
FROM #EMPLOYEE_TIME_ROUNDED ET INNER JOIN #OT_CHANGES OT ON OT.CurrentItemID = ET.TempItemID

DELETE #OT_CHANGES WHERE CurrentItemID IS NOT NULL
GO
IF OBJECT_id('dbo.spHolidayPlanInsert') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spHolidayPlanInsert AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spHolidayPlanInsert TO public'
END
GO
ALTER PROC dbo.spHolidayPlanInsert @plan varchar(50), @plan_id int OUT, @flags int = 0 AS
INSERT dbo.HolidayPlan([Plan], Flags) VALUES(@plan, @flags)
SELECT @plan_id = SCOPE_IDENTITY()
GO 
IF OBJECT_id('dbo.spHolidayPlanUpdate') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spHolidayPlanUpdate AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spHolidayPlanUpdate TO public'
END
GO
ALTER PROC dbo.spHolidayPlanUpdate @plan varchar(50), @plan_id int OUT, @flags int = NULL AS
UPDATE dbo.HolidayPlan SET [Plan]=@plan, Flags=ISNULL(@flags, Flags) WHERE PlanID=@plan_id
GO 
IF OBJECT_id('dbo.spHolidayPlanDelete') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spHolidayPlanDelete AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spHolidayPlanDelete TO public'
END
GO
ALTER PROC dbo.spHolidayPlanDelete @plan_id int, @new_plan_id int = NULL AS 
IF @new_plan_id IS NULL DELETE dbo.HolidayPlan WHERE PlanID=@plan_id
ELSE
BEGIN
BEGIN TRAN
	UPDATE dbo.Employee SET HolidayPlanID = @new_plan_id WHERE HolidayPlanID = @plan_id
	IF @@ERROR=0 DELETE dbo.HolidayPlan WHERE PlanID=@plan_id
COMMIT TRAN
END
GO
IF OBJECT_id('dbo.spHolidayPlanSelect') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spHolidayPlanSelect AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spHolidayPlanSelect TO public'
END
GO
ALTER PROC dbo.spHolidayPlanSelect @plan_id int AS SET NOCOUNT ON SELECT [Plan], PlanID, Flags FROM dbo.HolidayPlan WHERE PlanID=@plan_id
GO
IF OBJECT_id('dbo.spHolidayPlanList') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spHolidayPlanList AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spHolidayPlanList TO public'
END
GO
ALTER PROC dbo.spHolidayPlanList AS SET NOCOUNT ON SELECT [Plan], PlanID, Flags FROM dbo.HolidayPlan ORDER BY [Plan]
GO
IF OBJECT_id('dbo.spHolidayPlanGetPlanFromPlanID') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spHolidayPlanGetPlanFromPlanID AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spHolidayPlanGetPlanFromPlanID TO public'
END
GO
ALTER PROC dbo.spHolidayPlanGetPlanFromPlanID @plan_id int, @plan varchar(50) OUT AS SELECT @plan = [Plan] FROM dbo.HolidayPlan WHERE PlanID=@plan_id
GO
IF OBJECT_id('dbo.spHolidayList') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spHolidayList AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spHolidayList TO public'
END
GO
ALTER PROC dbo.spHolidayList @plan_id int = 1 AS
SELECT HolidayID, Holiday, [Month], [Day], [Year], PlanID, [Length] FROM dbo.Holiday WHERE PlanID=@plan_id ORDER BY Holiday
GO
IF OBJECT_id('dbo.spHolidayListForEmployee') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spHolidayListForEmployee AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spHolidayListForEmployee TO public'
END
GO
ALTER PROC dbo.spHolidayListForEmployee @employee_id int AS
SELECT H.HolidayID, H.Holiday, H.[Month], H.[Day], H.[Year], H.PlanID, H.[Length] FROM dbo.Holiday H
INNER JOIN dbo.Employee E ON E.EmployeeID = @employee_id AND E.HolidayPlanID = H.PlanID ORDER BY H.Holiday
GO
IF OBJECT_id('dbo.spHolidaySummary') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spHolidaySummary AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spHolidaySummary TO public'
END
GO
ALTER PROC dbo.spHolidaySummary
	@year int,
	@plan_id int = 1
AS
SET NOCOUNT ON

SELECT HolidayID, Holiday, [Month], [Day], [Year] = @year, PlanID=@plan_id, [Length] FROM dbo.Holiday WHERE PlanID=@plan_id AND ([Year] IS NULL OR [Year] = @year) ORDER BY [Month],[Day]
GO
IF OBJECT_id('dbo.spAdminDeleteTest') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spAdminDeleteTest AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spAdminDeleteTest TO public'
END
GO
ALTER PROC dbo.spAdminDeleteTest
	@object_id int, -- 1: location, 2: shift, 3: department, 4: division, 5: position, 6: timechema, 7: position status, 8: holiday plans
	@id int,
	@orphans varchar(400) OUT
AS
SET @orphans = ''

SET @orphans = CASE
	WHEN @object_id=1 AND EXISTS(SELECT * FROM dbo.Employee WHERE LocationID=@id) THEN 'employees, '
	WHEN @object_id=2 AND EXISTS(SELECT * FROM dbo.Employee WHERE ShiftID=@id) THEN 'employees, '
	WHEN @object_id=3 AND EXISTS(SELECT * FROM dbo.Employee WHERE DepartmentID=@id) THEN 'employees, '
	WHEN @object_id=4 AND EXISTS(SELECT * FROM dbo.Employee WHERE DivisionID=@id) THEN 'employees, '
	WHEN @object_id=5 AND EXISTS(SELECT * FROM dbo.EmployeeCompensation WHERE PositionID=@id) THEN 'employment history, '
	WHEN @object_id=6 AND EXISTS(SELECT * FROM dbo.Employee WHERE TimeSchemaID=@id) THEN 'employees, '
	WHEN @object_id=7 AND EXISTS(SELECT * FROM dbo.Position WHERE StatusID=@id) THEN 'positions, '
	WHEN @object_id=8 AND EXISTS(SELECT * FROM dbo.Employee WHERE HolidayPlanID=@id) THEN 'employees, '
	WHEN @object_id=9 AND EXISTS(SELECT * FROM dbo.Course WHERE TypeID=@id) THEN 'courses, '
	WHEN @object_id=10 AND EXISTS(SELECT * FROM dbo.CourseCredit WHERE CreditTypeID=@id) THEN 'course credits, '
	ELSE ''
END



SET @orphans = @orphans + CASE
	WHEN @object_id=1 AND EXISTS(SELECT * FROM dbo.Project WHERE LocationID=@id) THEN 'projects, '
	ELSE ''
END

SET @orphans = @orphans + CASE
	WHEN @object_id=1 AND EXISTS(SELECT * FROM dbo.Constant WHERE HeadquartersID=@id) THEN 'headquarters, '
	ELSE ''
END

SET @orphans = @orphans + CASE
	WHEN @object_id=6 AND EXISTS(SELECT * FROM dbo.Constant WHERE DefaultTimeSchemaID=@id) THEN 'employee defaults, '
	ELSE ''
END

SET @orphans = @orphans + CASE
	WHEN @object_id=8 AND EXISTS(SELECT * FROM dbo.Holiday WHERE PlanID=@id) THEN 'holidays, '
	ELSE ''
END

SET @orphans = @orphans + CASE
	WHEN @object_id=10 AND EXISTS(SELECT * FROM dbo.EmployeeCourseCredit WHERE CreditTypeID=@id) THEN 'employee course credits, '
	ELSE ''
END

IF @orphans <> '' SET @orphans = SUBSTRING(@orphans, 1, LEN(@orphans) - 2)
GO
IF OBJECT_id('dbo.spEmployeeSelectLeaveInfo') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEmployeeSelectLeaveInfo AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spEmployeeSelectLeaveInfo TO public'
END
GO
ALTER PROC dbo.spEmployeeSelectLeaveInfo @employee_id int AS
DECLARE @authorized bit
SET NOCOUNT ON
EXEC dbo.spPermissionInsureForCurrentUserOnPerson @employee_id, 10001, 1, @authorized out
IF @authorized = 1 SELECT * FROM vwEmployeeLeaveInfo WHERE EmployeeID = @employee_id
GO
IF OBJECT_id('dbo.spEmployeeUpdateLeaveInfo') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEmployeeUpdateLeaveInfo AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spEmployeeUpdateLeaveInfo TO public'
END
GO
ALTER PROC dbo.spEmployeeUpdateLeaveInfo
	@employee_id int,
	@note text,
	@ongoing bit,
	@recertify int,
	@holiday_plan_id int = NULL
AS
DECLARE @authorized bit
EXEC dbo.spPermissionInsureForCurrentUserOnPerson @employee_id, 10001, 2, @authorized out
IF @authorized = 1 UPDATE Employee SET [Leave Note] = @note, [Ongoing Condition] = @ongoing, [Recertify Condition Day past 1900] = @recertify, HolidayPlanID = ISNULL(@holiday_plan_id, HolidayPlanID) WHERE EmployeeID = @employee_id
GO
IF OBJECT_ID('dbo.spHolidayUpdate') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spHolidayUpdate AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spHolidayUpdate TO public'
END
GO
ALTER PROC dbo.spHolidayUpdate
	@holiday varchar(50),
	@month tinyint,
	@day tinyint,
	@year int,
	@holiday_id int OUT,
	@length int = NULL
AS
UPDATE Holiday SET
	Holiday = @holiday, [Month] = @month, [Day] = @day, [Year] = @year,
	[Length] = CASE WHEN @length IS NULL THEN [Length] ELSE @length END
WHERE HolidayID = @holiday_id
GO
IF OBJECT_ID('dbo.spHolidayInsert') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spHolidayInsert AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spHolidayInsert TO public'
END
GO
ALTER PROC dbo.spHolidayInsert
	@holiday varchar(50),
	@month tinyint,
	@day tinyint,
	@year int,
	@holiday_id int OUT,
	@plan_id int = 1,
	@length int = 1
AS
INSERT Holiday(Holiday, [Month], [Day], [Year], PlanID, [Length])
VALUES(@holiday,@month,@day,@year,@plan_id,@length)
SELECT @holiday_id = SCOPE_IDENTITY()
GO
EXEC dbo.spAdminCreateViewifNonexistent 'spEmployeeCompensationAdjustmentList2'
GO
ALTER PROC dbo.spEmployeeCompensationAdjustmentList2
	@effective_day int,
	@batch_id int,
	@period_id int,
	@one_time bit
AS
SET NOCOUNT ON

EXEC dbo.spPermissionGetOnPeopleForCurrentUser2 @batch_id, 1024
DELETE TempX WHERE BatchID = @batch_id AND (X & 1) = 0

DECLARE @convert_to_seconds int
IF @period_id IS NULL SET @convert_to_seconds = 1
ELSE SELECT @convert_to_seconds = Seconds FROM dbo.Period WHERE PeriodID = @period_id

SELECT C.CompensationID, -- Nullable
A.AdjustmentID,
[Minimum Adjustment] = CASE
	WHEN EA.[Minimum Adjustment] IS NULL THEN 0
	WHEN A.PeriodID IS NULL AND @period_id IS NULL THEN EA.[Minimum Adjustment]
	WHEN A.PeriodID IS NULL OR @period_id IS NULL THEN 0
	ELSE dbo.fnConvertPay2(EA.[Minimum Adjustment], /*FTE40*/ POS.[Seconds per Week] / 144000.0, C.[Employee Seconds per Week], Period.FTEM, Period.FTEB, Period.Seconds, 1, 0, @convert_to_seconds)
END,
[Maximum Adjustment] = CASE
	WHEN EA.[Maximum Adjustment] IS NULL THEN 0
	WHEN A.PeriodID IS NULL AND @period_id IS NULL THEN EA.[Maximum Adjustment]
	WHEN A.PeriodID IS NULL OR @period_id IS NULL THEN 0
	ELSE dbo.fnConvertPay2(EA.[Maximum Adjustment], /*FTE40*/ POS.[Seconds per Week] / 144000.0, C.[Employee Seconds per Week], Period.FTEM, Period.FTEB, Period.Seconds, 1, 0, @convert_to_seconds)
END,
A.Adjustment,
[List As] = E.[List As],
EmployeeID = E.PersonID,
A.PeriodID
FROM dbo.vwPersonListAs E
INNER JOIN dbo.TempX T ON T.BatchID = @batch_id AND T.[ID] = E.PersonID
CROSS JOIN dbo.CompensationAdjustment A
LEFT JOIN dbo.EmployeeCompensation C ON 
	T.BatchID = @batch_id AND T.[ID] = C.EmployeeID AND
	@effective_day >= C.[Start Day past 1900] AND (C.[Stop Day past 1900] IS NULL OR @effective_day <= C.[Stop Day past 1900])
LEFT JOIN dbo.EmployeeCompensationAdjustment EA ON 
	EA.AdjustmentID = A.AdjustmentID AND 
	EA.CompensationID = C.CompensationID
LEFT JOIN dbo.Position POS ON C.PositionID = POS.PositionID
LEFT JOIN dbo.Period ON A.PeriodID = Period.PeriodID

WHERE (@one_time IS NULL) OR (@one_time = 0 AND A.PeriodID IS NOT NULL) OR (@one_time = 1 AND A.PeriodID IS NULL)

ORDER BY E.[List As], A.[Adjustment]

DELETE TempX WHERE BatchID = @batch_id OR DATEDIFF(hh, Created, GETDATE()) > 1
GO
IF OBJECT_ID('dbo.spAdminGetNextRandom') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spAdminGetNextRandom AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spAdminGetNextRandom TO public'
END
GO
ALTER PROC dbo.spAdminGetNextRandom @r int OUT
AS
SET @r = NULL
WHILE @r IS NULL OR EXISTS(SELECT * FROM dbo.TempX WHERE BatchID = @r) OR EXISTS(SELECT * FROM dbo.TempPersonPermission WHERE BatchID = @r) SELECT @r = (0.5 - RAND()) * 4294967294.0
GO
IF OBJECT_ID('dbo.spEmployeeExpenseSummarizeForProject') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEmployeeExpenseSummarizeForProject AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spEmployeeExpenseSummarizeForProject TO public'
END
GO
-- Summarizes expenses by employee for one project
ALTER PROC dbo.spEmployeeExpenseSummarizeForProject
	@project_id int, @start int, @stop int, @authorized bit out
AS
SET NOCOUNT ON

DECLARE @batch_id int
SET @batch_id = RAND() * 2147483647

INSERT dbo.TempX(BatchID,[ID]) SELECT @batch_id, EmployeeID FROM dbo.EmployeeExpense WHERE ((ProjectID IS NULL AND @project_id IS NULL) OR ProjectID = @project_id) AND dbo.GetDateFromDaysPast1900([Day past 1900]) BETWEEN @start AND @stop

EXEC dbo.spPermissionGetOnPeopleForCurrentUser2 @batch_id, 10010
DELETE TempX WHERE BatchID=@batch_id AND (X&1)=0
SELECT @authorized= CASE WHEN @@ROWCOUNT=0 THEN 1 ELSE 0 END

EXEC dbo.spPermissionGetOnPeopleForCurrentUser2 @batch_id, 10011

SELECT
EmployeeID,
D.Department,
Employee = V.[List As],
Manager = ISNULL(M.[List As],''),
Pending = ISNULL((
	SELECT SUM(E.Amount) FROM dbo.EmployeeExpense E WHERE E.EmployeeID=X.[ID] AND dbo.GetDateFromDaysPast1900(E.[Day past 1900]) BETWEEN @start AND @stop AND E.StatusID = 8
), 0),
[Approved Unreimbursed] = ISNULL((
	SELECT SUM(E.Amount) FROM dbo.EmployeeExpense E WHERE E.EmployeeID=X.[ID] AND dbo.GetDateFromDaysPast1900(E.[Day past 1900]) BETWEEN @start AND @stop AND E.StatusID IN (1,5) AND E.[Day Reimbursed] IS NULL
), 0),
[Reimbursed] = ISNULL((
	SELECT SUM(E.Amount) FROM dbo.EmployeeExpense E WHERE E.EmployeeID=X.[ID] AND dbo.GetDateFromDaysPast1900(E.[Day past 1900]) BETWEEN @start AND @stop AND E.[Day Reimbursed] IS NOT NULL
), 0),
Denied = ISNULL((
	SELECT SUM(E.Amount) FROM dbo.EmployeeExpense E WHERE E.EmployeeID=X.[ID] AND dbo.GetDateFromDaysPast1900(E.[Day past 1900]) BETWEEN @start AND @stop AND E.StatusID = 2
), 0),
Total = ISNULL((
	SELECT SUM(E.Amount) FROM dbo.EmployeeExpense E WHERE E.EmployeeID=X.[ID] AND dbo.GetDateFromDaysPast1900(E.[Day past 1900]) BETWEEN @start AND @stop
), 0),
[Permissions] = X.X
INTO #T
FROM dbo.TempX X
INNER JOIN dbo.Employee E ON X.BatchID=@batch_id AND X.[ID] = E.EmployeeID
INNER JOIN dbo.Department D ON E.DepartmentID = D.DepartmentID
INNER JOIN dbo.vwPersonListAs V ON E.EmployeeID = V.PersonID
LEFT JOIN dbo.vwPersonListAs M ON E.ManagerID = M.PersonID


SELECT EmployeeID, Department, Manager, Employee,
Pending, Denied, [Approved Unreimbursed], [Reimbursed], Total, [Permissions], Flags = 0
FROM #T

UNION

SELECT NULL, 'Total', 'Total', 'Total',
ISNULL(SUM(Pending),0), ISNULL(SUM(Denied),0), ISNULL(SUM([Approved Unreimbursed]),0), ISNULL(SUM([Reimbursed]),0), ISNULL(SUM([Total]),0), 0, 1
FROM #T
ORDER BY Flags, Department, Employee

DELETE TempX WHERE BatchID=@batch_id
GO
IF OBJECT_ID('dbo.spProjectGetNameFromProjectID') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spProjectGetNameFromProjectID AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spProjectGetNameFromProjectID TO public'
END
GO
ALTER PROC dbo.spProjectGetNameFromProjectID
	@project_id int,
	@project varchar(50) OUT
AS
SELECT @project = [Project] FROM dbo.Project WHERE ProjectID = @project_id
GO
IF OBJECT_ID('dbo.spPermissionInsureForCurrentUserOnPerson4') IS NULL 
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spPermissionInsureForCurrentUserOnPerson4 AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spPermissionInsureForCurrentUserOnPerson4 TO public'
END
GO
-- INSERT: spPermissionInsureForCurrentUserOnPerson4 @new_employee_id, @new_status, @old_employee_id, @old_status, pending_1, pending_1000, approved_1001, @authorized out
ALTER PROC dbo.spPermissionInsureForCurrentUserOnPerson4
	@new_employee_id int,
	@new_status int,
	@old_employee_id int,
	@old_status int,
	@pending_status_id int,
	@attribute_id_when_pending int,
	@attribute_id_when_approved int,
	@authorized bit OUT
AS
IF @new_employee_id IS NULL AND @old_employee_id IS NULL
BEGIN
	RAISERROR('@new_employee_id and @old_employee_id cannot both be null',16,1)
	RETURN
END

DECLARE @new_pending bit, @old_pending bit, @attribute int

SELECT @new_pending = CASE WHEN @new_status = @pending_status_id THEN 1 ELSE 0 END, @old_pending = CASE WHEN @old_status = @pending_status_id THEN 1 ELSE 0 END

-- Delete
IF @old_employee_id IS NOT NULL AND @new_employee_id IS NULL
BEGIN
	SELECT @attribute=CASE WHEN @old_pending=1 THEN @attribute_id_when_pending ELSE @attribute_id_when_approved END
	EXEC dbo.spPermissionInsureForCurrentUserOnPerson @old_employee_id, @attribute, 8, @authorized out
END

-- Update. If employee_ids differ then checks delete permission on old employee and insert permission on new employee
ELSE IF @old_employee_id IS NOT NULL AND @new_employee_id IS NOT NULL AND @old_employee_id <> @new_employee_id
BEGIN
	SELECT @attribute=CASE WHEN @old_pending=1 THEN @attribute_id_when_pending ELSE @attribute_id_when_approved END
	EXEC dbo.spPermissionInsureForCurrentUserOnPerson @old_employee_id, @attribute, 8, @authorized out

	IF @authorized=1
	BEGIN
		SELECT @attribute=CASE WHEN @new_pending=1 THEN @attribute_id_when_pending ELSE @attribute_id_when_approved END
		EXEC dbo.spPermissionInsureForCurrentUserOnPerson @new_employee_id, @attribute, 4, @authorized out
	END
END


-- Update when employee_ids match
ELSE IF @old_employee_id IS NOT NULL AND @new_employee_id IS NOT NULL AND @old_employee_id = @new_employee_id
BEGIN
	SELECT @attribute=CASE WHEN @new_pending=1 AND @old_pending=1 THEN @attribute_id_when_pending ELSE @attribute_id_when_approved END
	EXEC dbo.spPermissionInsureForCurrentUserOnPerson @old_employee_id, @attribute, 2, @authorized out
END

-- Insert
ELSE
BEGIN
	SELECT @attribute=CASE WHEN @new_pending=1 THEN @attribute_id_when_pending ELSE @attribute_id_when_approved END
	EXEC dbo.spPermissionInsureForCurrentUserOnPerson @new_employee_id, @attribute, 4, @authorized out
END
GO
IF OBJECT_ID('dbo.spEmployeeExpenseSummarizeByCheck') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEmployeeExpenseSummarizeByCheck AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spEmployeeExpenseSummarizeByCheck TO public'
END
GO
-- Summarizes expenses by check
ALTER PROC [dbo].[spEmployeeExpenseSummarizeByCheck]
	@employee_id int, @start int, @stop int, @authorized bit out
AS
SET NOCOUNT ON

DECLARE @dt datetime

EXEC dbo.spPermissionInsureForCurrentUserOnPerson @employee_id, 10010, 1, @authorized out

SELECT
[Check Number] = CASE 
	WHEN E.[Day Reimbursed] IS NULL THEN '<Approved>'
	WHEN E.[Reimbursed Check Number] = '' 
	THEN '<Unspecified>' 
	ELSE E.[Reimbursed Check Number] 
END,
E.[Day Reimbursed],
Account = ISNULL(A.Account,'<Unspecified>'),
E.AccountID,
Debit = SUM(E.Amount),
Credit = 0,
-- 16: check number specified, 4: normal check\account total, 2: blank account, 1: check total, 
[Account Flags] = CASE WHEN E.AccountID IS NULL THEN 2 ELSE 4 END ,
[Check Flags] = CASE WHEN E.[Reimbursed Check Number]='' THEN 0 ELSE 16 END
INTO #Summary
FROM dbo.EmployeeExpense E
INNER JOIN dbo.ExpenseAccount A ON @authorized=1 AND E.EmployeeID = @employee_id AND E.AccountID = A.AccountID 
--AND E.[Day Reimbursed] IS NOT NULL 
AND (E.[Day Reimbursed] BETWEEN @start AND @stop OR (E.[Day Reimbursed] IS NULL AND (E.StatusID & 1) = 1))
GROUP BY E.[Reimbursed Check Number], E.[Day Reimbursed], E.AccountID, A.Account

UNION

SELECT
[Check Number] = CASE 
	WHEN E.[Day Reimbursed] IS NULL THEN '<Approved>'
	WHEN E.[Reimbursed Check Number] = '' THEN '<Unspecified>' 
	ELSE E.[Reimbursed Check Number] 
END,
E.[Day Reimbursed],
Account = 'Check Total',
AccountID = NULL,
Debit = 0,
Credit = SUM(E.Amount),
[Account Flags] = 1,
[Check Flags] = CASE WHEN E.[Reimbursed Check Number]='' THEN 0 ELSE 16 END
FROM dbo.EmployeeExpense E
INNER JOIN dbo.ExpenseAccount A ON @authorized=1 AND E.EmployeeID = @employee_id AND E.AccountID = A.AccountID 
--AND E.[Day Reimbursed] IS NOT NULL 
AND (E.[Day Reimbursed] BETWEEN @start AND @stop OR (E.[Day Reimbursed] IS NULL AND (E.StatusID & 1) = 1))
GROUP BY E.[Reimbursed Check Number], E.[Day Reimbursed]




SELECT S.[Check Number], [Date Reimbursed] = dbo.GetDateFromDaysPast1900(S.[Day Reimbursed]), S.Account, S.Debit, S.Credit,
Flags = S.[Account Flags] + S.[Check Flags]
FROM #Summary S
ORDER BY CASE WHEN [Day Reimbursed] IS NULL THEN 0 ELSE 1 END,
[Day Reimbursed] DESC, [Check Flags], [Check Number], [Account Flags], Account
GO
IF OBJECT_ID('dbo.spEmployeeExpenseSummarizeByStatus2') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEmployeeExpenseSummarizeByStatus2 AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spEmployeeExpenseSummarizeByStatus2 TO public'
END
GO
-- Summarizes expenses by status
ALTER PROC dbo.spEmployeeExpenseSummarizeByStatus2
	@batch_id int, @start int, @stop int, @authorized bit out
AS
SET NOCOUNT ON

EXEC dbo.spPermissionGetOnPeopleForCurrentUser2 @batch_id, 10010
DELETE TempX WHERE BatchID=@batch_id AND (X&1)=0
SELECT @authorized= CASE WHEN @@ROWCOUNT=0 THEN 1 ELSE 0 END

EXEC dbo.spPermissionGetOnPeopleForCurrentUser2 @batch_id, 10011

SELECT
EmployeeID,
D.Department,
Employee = V.[List As],
Manager = ISNULL(M.[List As],''),
[Previous Pending] = ISNULL((
	SELECT SUM(E.Amount) FROM dbo.EmployeeExpense E WHERE E.EmployeeID=X.[ID] AND dbo.GetDateFromDaysPast1900(E.[Day past 1900]) < @start AND E.StatusID = 8
), 0),
Pending = ISNULL((
	SELECT SUM(E.Amount) FROM dbo.EmployeeExpense E WHERE E.EmployeeID=X.[ID] AND dbo.GetDateFromDaysPast1900(E.[Day past 1900]) BETWEEN @start AND @stop AND E.StatusID = 8
), 0),
[Approved Unreimbursed] = ISNULL((
	SELECT SUM(E.Amount) FROM dbo.EmployeeExpense E WHERE E.EmployeeID=X.[ID] AND dbo.GetDateFromDaysPast1900(E.[Day past 1900]) BETWEEN @start AND @stop AND E.StatusID IN (1,5) AND E.[Day Reimbursed] IS NULL
), 0),
[Reimbursed] = ISNULL((
	SELECT SUM(E.Amount) FROM dbo.EmployeeExpense E WHERE E.EmployeeID=X.[ID] AND dbo.GetDateFromDaysPast1900(E.[Day past 1900]) BETWEEN @start AND @stop AND E.[Day Reimbursed] IS NOT NULL
), 0),
Denied = ISNULL((
	SELECT SUM(E.Amount) FROM dbo.EmployeeExpense E WHERE E.EmployeeID=X.[ID] AND dbo.GetDateFromDaysPast1900(E.[Day past 1900]) BETWEEN @start AND @stop AND E.StatusID = 2
), 0),
Total = ISNULL((
	SELECT SUM(E.Amount) FROM dbo.EmployeeExpense E WHERE E.EmployeeID=X.[ID] AND dbo.GetDateFromDaysPast1900(E.[Day past 1900]) BETWEEN @start AND @stop
), 0),
[Permissions] = X.X
FROM dbo.TempX X
INNER JOIN dbo.Employee E ON X.BatchID=@batch_id AND X.[ID] = E.EmployeeID
INNER JOIN dbo.Department D ON E.DepartmentID = D.DepartmentID
INNER JOIN dbo.vwPersonListAs V ON E.EmployeeID = V.PersonID
LEFT JOIN dbo.vwPersonListAs M ON E.ManagerID = M.PersonID
ORDER BY D.Department, V.[List As]

DELETE TempX WHERE BatchID=@batch_id
GO
IF OBJECT_ID('dbo.spEmployeeExpenseSummarizeByCheck2') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEmployeeExpenseSummarizeByCheck2 AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spEmployeeExpenseSummarizeByCheck2 TO public'
END
GO
-- Summarizes expenses by check
ALTER PROC dbo.spEmployeeExpenseSummarizeByCheck2
	@batch_id int, @start int, @stop int, @authorized bit out
AS
SET NOCOUNT ON

EXEC dbo.spPermissionGetOnPeopleForCurrentUser2 @batch_id, 10010
DELETE TempX WHERE BatchID=@batch_id AND (X&1)=0
SELECT @authorized= CASE WHEN @@ROWCOUNT=0 THEN 1 ELSE 0 END

EXEC dbo.spPermissionGetOnPeopleForCurrentUser2 @batch_id, 10011

SELECT
E.EmployeeID,
[Check Number] = CASE WHEN E.[Reimbursed Check Number] = '' THEN '<Unspecified>' ELSE E.[Reimbursed Check Number] END,
E.[Day Reimbursed],
Account = ISNULL(A.Account,'<Unspecified>'),
E.AccountID,
Debit = SUM(E.Amount),
Credit = 0,
-- 16: check number specified, 4: normal check\account total, 2: blank account, 1: check total, 
[Account Flags] = CASE WHEN E.AccountID IS NULL THEN 2 ELSE 4 END ,
[Check Flags] = CASE WHEN E.[Reimbursed Check Number]='' THEN 0 ELSE 16 END
INTO #Summary
FROM dbo.TempX X
INNER JOIN dbo.EmployeeExpense E ON X.BatchID=@batch_id AND E.EmployeeID = X.[ID]
INNER JOIN dbo.ExpenseAccount A ON E.AccountID = A.AccountID AND E.[Day Reimbursed] IS NOT NULL AND E.[Day Reimbursed] BETWEEN @start AND @stop
GROUP BY E.EmployeeID, E.[Reimbursed Check Number], E.[Day Reimbursed], E.AccountID, A.Account

UNION

SELECT
E.EmployeeID,
[Check Number] = CASE WHEN E.[Reimbursed Check Number] = '' THEN '<Unspecified>' ELSE E.[Reimbursed Check Number] END,
E.[Day Reimbursed],
Account = 'Check Total',
AccountID = NULL,
Debit = 0,
Credit = SUM(E.Amount),
[Account Flags] = 1,
[Check Flags] = CASE WHEN E.[Reimbursed Check Number]='' THEN 0 ELSE 16 END
FROM dbo.TempX X
INNER JOIN dbo.EmployeeExpense E ON X.BatchID=@batch_id AND E.EmployeeID = X.[ID]
INNER JOIN dbo.ExpenseAccount A ON E.AccountID = A.AccountID AND E.[Day Reimbursed] IS NOT NULL AND E.[Day Reimbursed] BETWEEN @start AND @stop
GROUP BY E.EmployeeID, E.[Reimbursed Check Number], E.[Day Reimbursed]

SELECT S.EmployeeID, D.Department, Employee = P.[List As], Manager = ISNULL(M.[List As],''), S.[Check Number], [Date Reimbursed] = dbo.GetDateFromDaysPast1900(S.[Day Reimbursed]), S.Account, S.Debit, S.Credit,
Flags = S.[Account Flags] + S.[Check Flags], [Permissions] = X.X
FROM #Summary S
INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID] = S.EmployeeID
INNER JOIN dbo.vwPersonListAs P ON S.EmployeeID=P.PersonID
INNER JOIN dbo.Employee E ON S.EmployeeID=E.EmployeeID
INNER JOIN dbo.Department D ON E.DepartmentID=D.DepartmentID
LEFT JOIN dbo.vwPersonListAs M ON E.ManagerID = M.PersonID
ORDER BY D.Department, P.[List As], S.[Day Reimbursed] DESC, S.[Check Flags], S.[Check Number], S.[Account Flags], S.Account

DELETE TempX WHERE BatchID=@batch_id
GO
IF OBJECT_ID('dbo.spEmployeeExpenseSummarizeByProject') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEmployeeExpenseSummarizeByProject AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spEmployeeExpenseSummarizeByProject TO public'
END
GO
-- Summarizes expenses by project
ALTER PROC dbo.spEmployeeExpenseSummarizeByProject
	@employee_id int, @asof int, @authorized bit out
AS
SET NOCOUNT ON

DECLARE @dt datetime, @m_n datetime, @m_0 datetime, @m_1 datetime, @m_2 datetime
SELECT @dt = dbo.GetDateFromDaysPast1900(@asof)
SELECT @m_0 = dbo.GetDateFromMDY(MONTH(@dt), 1, YEAR(@dt))
SELECT @m_n = DATEADD(month,1,@m_0)
SELECT @m_1 = DATEADD(month,-1,@m_0)
SELECT @m_2 = DATEADD(month,-2,@m_0)

EXEC dbo.spPermissionInsureForCurrentUserOnPerson @employee_id, 10010, 1, @authorized out

SELECT DISTINCT ProjectID INTO #Project 
FROM dbo.EmployeeExpense E WHERE E.EmployeeID=@employee_id AND E.[Day past 1900] BETWEEN @m_2 AND @m_n

SELECT
Flags = CASE WHEN P.ProjectID IS NULL THEN 1 ELSE 2 END,
Project = ISNULL(Project.Project,'<Unspecified>'),
M_2 = ISNULL((
	SELECT SUM(E.Amount) FROM dbo.EmployeeExpense E WHERE E.StatusID IN (1,5) AND E.EmployeeID=@employee_id AND E.[Day past 1900] >= @m_0 AND E.[Day past 1900] < @m_n AND ((E.ProjectID IS NULL AND P.ProjectID IS NULL) OR E.ProjectID=P.ProjectID)
), 0),
M_1 = ISNULL((
	SELECT SUM(E.Amount) FROM dbo.EmployeeExpense E WHERE E.StatusID IN (1,5) AND E.EmployeeID=@employee_id AND E.[Day past 1900] >= @m_1 AND E.[Day past 1900] < @m_0 AND ((E.ProjectID IS NULL AND P.ProjectID IS NULL) OR E.ProjectID=P.ProjectID)
), 0),
M_0 = ISNULL((
	SELECT SUM(E.Amount) FROM dbo.EmployeeExpense E WHERE E.StatusID IN (1,5) AND E.EmployeeID=@employee_id AND E.[Day past 1900] >= @m_2 AND E.[Day past 1900] < @m_1 AND ((E.ProjectID IS NULL AND P.ProjectID IS NULL) OR E.ProjectID=P.ProjectID)
), 0)

INTO #Result

FROM #Project P LEFT JOIN dbo.Project ON P.ProjectID = Project.ProjectID

UNION

SELECT
Flags = 4,
Project = 'Total Approved',
M_2 = ISNULL((
	SELECT SUM(E.Amount) FROM dbo.EmployeeExpense E WHERE E.StatusID IN (1,5) AND E.EmployeeID=@employee_id AND E.[Day past 1900] >= @m_0 AND E.[Day past 1900] < @m_n
), 0),
M_1 = ISNULL((
	SELECT SUM(E.Amount) FROM dbo.EmployeeExpense E WHERE E.StatusID IN (1,5) AND E.EmployeeID=@employee_id AND E.[Day past 1900] >= @m_1 AND E.[Day past 1900] < @m_0
), 0),
M_0 = ISNULL((
	SELECT SUM(E.Amount) FROM dbo.EmployeeExpense E WHERE E.StatusID IN (1,5) AND E.EmployeeID=@employee_id AND E.[Day past 1900] >= @m_2 AND E.[Day past 1900] < @m_1
), 0)
FROM #Project P LEFT JOIN dbo.Project ON P.ProjectID = Project.ProjectID


SELECT Project,M_2,M_1,M_0 FROM #Result ORDER BY Flags, Project
GO
IF OBJECT_ID('dbo.spEmployeeExpenseSummarizeByProject2') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEmployeeExpenseSummarizeByProject2 AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spEmployeeExpenseSummarizeByProject2 TO public'
END
GO
-- Summarizes expenses by project
ALTER PROC dbo.spEmployeeExpenseSummarizeByProject2
	@batch_id int, @start int, @stop int, @authorized bit out
AS
SET NOCOUNT ON

EXEC dbo.spPermissionGetOnPeopleForCurrentUser2 @batch_id, 10010
DELETE TempX WHERE BatchID=@batch_id AND (X&1)=0
SELECT @authorized= CASE WHEN @@ROWCOUNT=0 THEN 1 ELSE 0 END

SELECT DISTINCT ProjectID INTO #Project 
FROM dbo.EmployeeExpense E 
INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND E.EmployeeID=X.[ID] AND E.[Day past 1900] BETWEEN @start AND @stop

SELECT
Flags = CASE WHEN P.ProjectID IS NULL THEN 1 ELSE 2 END,
Project = ISNULL(Project.Project,'<Unspecified>'),
Pending = ISNULL((
	SELECT SUM(E.Amount) FROM dbo.EmployeeExpense E 
	INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID]=E.EmployeeID AND ((E.ProjectID IS NULL AND P.ProjectID IS NULL) OR E.ProjectID=P.ProjectID) AND
	E.StatusID = 8
 ), 0),
Denied = ISNULL((
	SELECT SUM(E.Amount) FROM dbo.EmployeeExpense E 
	INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID]=E.EmployeeID AND ((E.ProjectID IS NULL AND P.ProjectID IS NULL) OR E.ProjectID=P.ProjectID) AND
	E.StatusID = 2
), 0),
[Approved Unreimbursed] = ISNULL((
	SELECT SUM(E.Amount) FROM dbo.EmployeeExpense E 
	INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID]=E.EmployeeID AND ((E.ProjectID IS NULL AND P.ProjectID IS NULL) OR E.ProjectID=P.ProjectID) AND
	E.StatusID IN (1,5) AND E.[Day Reimbursed] IS NULL
), 0),
[Reimbursed] = ISNULL((
	SELECT SUM(E.Amount) FROM dbo.EmployeeExpense E 
	INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID]=E.EmployeeID AND ((E.ProjectID IS NULL AND P.ProjectID IS NULL) OR E.ProjectID=P.ProjectID) AND
	E.[Day Reimbursed] IS NOT NULL
), 0),
Total = ISNULL((
	SELECT SUM(E.Amount) FROM dbo.EmployeeExpense E 
	INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID]=E.EmployeeID AND ((E.ProjectID IS NULL AND P.ProjectID IS NULL) OR E.ProjectID=P.ProjectID)
), 0)

INTO #Result
FROM #Project P LEFT JOIN dbo.Project ON P.ProjectID = Project.ProjectID

UNION

SELECT
Flags = 4,
Project = 'Total',
Pending = ISNULL((
	SELECT SUM(E.Amount) FROM dbo.EmployeeExpense E 
	INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID]=E.EmployeeID AND
	E.StatusID = 8
 ), 0),
Denied = ISNULL((
	SELECT SUM(E.Amount) FROM dbo.EmployeeExpense E 
	INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID]=E.EmployeeID AND
	E.StatusID = 2
), 0),
[Approved Unreimbursed] = ISNULL((
	SELECT SUM(E.Amount) FROM dbo.EmployeeExpense E 
	INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID]=E.EmployeeID AND
	E.StatusID IN (1,5) AND E.[Day Reimbursed] IS NULL
), 0),
[Reimbursed] = ISNULL((
	SELECT SUM(E.Amount) FROM dbo.EmployeeExpense E 
	INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID]=E.EmployeeID AND
	E.[Day Reimbursed] IS NOT NULL
), 0),
Total = ISNULL((
	SELECT SUM(E.Amount) FROM dbo.EmployeeExpense E 
	INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID]=E.EmployeeID
), 0)

SELECT Project,Pending,Denied,[Approved Unreimbursed],[Reimbursed],Total FROM #Result ORDER BY Flags, Project
GO
IF OBJECT_id('dbo.spAttachmentTempUpload') IS NULL 
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spAttachmentTempUpload AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spAttachmentTempUpload TO public'
END
GO
ALTER PROC dbo.spAttachmentTempUpload
	@attachment image,
	@name varchar(50),
	@type varchar(50),
	@attachment_id int OUT
AS
INSERT dbo.AttachmentTemp([Attachment], [Name], [Type]) VALUES (@attachment, REPLACE(@name,',','_'), @type)
SET @attachment_id = SCOPE_IDENTITY()

DELETE dbo.AttachmentTemp WHERE DATEDIFF(minute,Created,GETDATE()) > 60
GO
IF OBJECT_id('dbo.spEmployeeExpenseAttachmentSelect') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEmployeeExpenseAttachmentSelect AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spEmployeeExpenseAttachmentSelect TO public'
END
GO
ALTER PROC dbo.spEmployeeExpenseAttachmentSelect @expense_id int AS
DECLARE @employee_id int, @authorized bit
SET NOCOUNT ON
SELECT @employee_id = EmployeeID FROM dbo.EmployeeExpense WHERE ItemID = @expense_id
EXEC dbo.spPermissionInsureForCurrentUserOnPerson @employee_id, 10010, 1, @authorized out
SELECT Attachment, [Attachment MIME Type], [Attachment Name] FROM dbo.EmployeeExpense WHERE ItemID=@expense_id
GO
IF OBJECT_ID('dbo.spEmployeeExpenseAttachmentUpdate') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEmployeeExpenseAttachmentUpdate AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spEmployeeExpenseAttachmentUpdate TO public'
END
GO
ALTER PROC dbo.spEmployeeExpenseAttachmentUpdate
	@expense_id int,
	@name varchar(50),
	@type varchar(50),
	@attachment image
AS
DECLARE @authorized bit
DECLARE @old_employee_id int, @old_status_id int

SELECT @old_employee_id = EmployeeID, @old_status_id = StatusID FROM dbo.EmployeeExpense WHERE ItemID = @expense_id
EXEC dbo.spPermissionInsureForCurrentUserOnPerson4 @old_employee_id, @old_status_id, @old_employee_id, @old_status_id, 8, 10010, 10011, @authorized OUT
IF @authorized = 1 UPDATE dbo.EmployeeExpense SET [Attachment Name] = REPLACE(@name,',','_'), Attachment = @attachment, [Attachment MIME Type] = @type WHERE ItemID = @expense_id
GO
IF OBJECT_id('dbo.spEmployeeExpenseSummarize3') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEmployeeExpenseSummarize3 AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spEmployeeExpenseSummarize3 TO public'
END
GO
ALTER PROC dbo.spEmployeeExpenseSummarize3
	@day int,
	@employee_id int,
	@account_id int
AS
DECLARE @authorized bit

SET NOCOUNT ON

-- Need read permission on pending and approved expenses to be able to summarize
EXEC dbo.spPermissionInsureForCurrentUserOnPerson @employee_id, 10010, 1, @authorized out

IF @authorized = 1 SELECT EmployeeID=P.PersonID,Employee=P.[List As],
[Sum]=ISNULL((
	SELECT SUM(A.Amount) FROM vwEmployeeExpense2 A WHERE A.EmployeeID=@employee_id AND A.AccountID=@account_id AND A.Accumulated=1 AND A.[Day past 1900]<=@day AND (A.StatusID & 1)=1
),0.0000)
,
Unreimbursed=ISNULL((
	SELECT 0-SUM(Amount) FROM vwEmployeeExpense2 A WHERE A.EmployeeID=@employee_id AND A.AccountID=@account_id AND A.Reimbursable=1 AND A.[Day past 1900]<=@day AND (A.StatusID & 1)=1 AND A.Amount<0 AND A.[Day Reimbursed] IS NULL
), 0.0000),
A.*
FROM dbo.vwPersonListAs P 
INNER JOIN dbo.vwExpenseAccount A ON P.PersonID=@employee_id AND A.AccountID= @account_id
GO
IF OBJECT_id('dbo.spEmergencyContactList2') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEmergencyContactList2 AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spEmergencyContactList2 TO public'
END
GO
ALTER PROC dbo.spEmergencyContactList2
	@batch_id int,
	@authorized bit out
AS
SET NOCOUNT ON

EXEC dbo.spPermissionGetOnPeopleForCurrentUser2 @batch_id, 134217728
DELETE TempX WHERE BatchID=@batch_id AND (X&1)=0
SELECT @authorized= CASE WHEN @@ROWCOUNT=0 THEN 1 ELSE 0 END

SELECT 
Employee = E.[List As],
L.ContactID, L.PersonID, V.[List As], V.[Full Name], P.[Work Phone],
P.[Home Phone], P.[Mobile Phone], L.Relationship
FROM EmployeeEmergencyContact L
INNER JOIN TempX X ON X.BatchID = @batch_id AND X.[ID] = L.EmployeeID
INNER JOIN dbo.vwPersonListAs E ON L.EmployeeID=E.PersonID
INNER JOIN Person P ON L.PersonID = P.PersonID
INNER JOIN vwPersonCalculated V ON P.PersonID = V.PersonID
ORDER BY E.[List As], V.[List As]
GO
IF OBJECT_id('dbo.spEmployeeExpenseInsert') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEmployeeExpenseInsert AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spEmployeeExpenseInsert TO public'
END
GO
ALTER PROC dbo.spEmployeeExpenseInsert
	@account_id int,
	@status_id int,
	@project_id int,
	@employee_id int,
	@day int,
	@reimbursed int,
	@amount money,
	@employee_comment varchar(400),
	@manager_comment varchar(400),
	@item_id int OUT,
	@reimbursed_check varchar(50) = '',
	@miles numeric(9,2) = 0,
	@attachment_id int = NULL
AS
DECLARE @authorized bit
DECLARE @attribute int

SELECT @attribute = CASE WHEN @status_id = 8 THEN 10010 ELSE 10011 END
EXEC dbo.spPermissionInsureForCurrentUserOnPerson @employee_id, @attribute, 4, @authorized out

IF @authorized = 0 RETURN
INSERT dbo.EmployeeExpense(ProjectID,[Employee Comment],[Manager Comment],[AccountID],StatusID,EmployeeID,[Day past 1900],[Day Reimbursed],Amount,[Reimbursed Check Number],Miles)
VALUES(@project_id,@employee_comment,@manager_comment,@account_id,@status_id,@employee_id,@day,@reimbursed,@amount,@reimbursed_check,@miles)
SELECT @item_id=SCOPE_IDENTITY()
IF @attachment_id IS NOT NULL
BEGIN
	UPDATE E SET Attachment = A.Attachment, [Attachment Name] = REPLACE(A.[Name],',','_'), [Attachment MIME Type] = A.[Type]  
	FROM dbo.EmployeeExpense E
	INNER JOIN dbo.AttachmentTemp A ON E.ItemID = @item_id AND A.AttachmentID = @attachment_id AND A.[SID] = SUSER_SID()

	DELETE dbo.AttachmentTemp WHERE AttachmentID = @attachment_id AND [SID] = SUSER_SID()
END
GO
IF OBJECT_id('dbo.spEmployeeExpenseUpdate') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEmployeeExpenseUpdate AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spEmployeeExpenseUpdate TO public'
END
GO
ALTER PROC dbo.spEmployeeExpenseUpdate
	@employee_id int,
	@project_id int,
	@status_id int,
	@account_id int,
	@day int,
	@reimbursed int,
	@amount money,
	@employee_comment varchar(400),
	@manager_comment varchar(400),
	@item_id int,
	@reimbursed_check varchar(50) = NULL,
	@miles numeric(9,2) = NULL
AS
DECLARE @authorized bit
DECLARE @old_employee_id int, @old_status_id int

SELECT @old_employee_id = EmployeeID, @old_status_id = StatusID FROM EmployeeExpense WHERE ItemID = @item_id
EXEC dbo.spPermissionInsureForCurrentUserOnPerson4 @employee_id, @status_id, @old_employee_id, @old_status_id, 8, 10010, 10011, @authorized OUT
IF @authorized = 0 RETURN

UPDATE EmployeeExpense SET
EmployeeID=@employee_id,
ProjectID=@project_id,
AccountID=@account_id,
StatusID=@status_id,
[Employee Comment]=@employee_comment,
[Manager Comment]=@manager_comment,
[Day past 1900]=@day,
[Day Reimbursed]=@reimbursed,
Amount=@amount,
[Reimbursed Check Number] = CASE WHEN @reimbursed_check IS NULL THEN [Reimbursed Check Number] ELSE @reimbursed_check END,
Miles = CASE WHEN @miles IS NULL THEN Miles ELSE @miles END
WHERE ItemID=@item_id
GO
IF OBJECT_ID('dbo.spEmployeeExpenseSummarize2') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEmployeeExpenseSummarize2 AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spEmployeeExpenseSummarize2 TO public'
END
GO
ALTER PROC dbo.spEmployeeExpenseSummarize2
	@day int,
	@batch_id int,
	@account_id int,
	@authorized bit OUT
AS
SET NOCOUNT ON

EXEC dbo.spPermissionGetOnPeopleForCurrentUser2 @batch_id, 10010
DELETE TempX WHERE BatchID = @batch_id AND (X & 1) = 0
SELECT @authorized = CASE WHEN @@ROWCOUNT=0 THEN 1 ELSE 0 END

SELECT EmployeeID=P.PersonID,Employee=P.[List As],
[Sum]=ISNULL((
	SELECT SUM(A.Amount) FROM vwEmployeeExpense2 A WHERE A.EmployeeID=X.[ID] AND A.AccountID=@account_id AND A.Accumulated=1 AND A.[Day past 1900]<=@day AND (A.StatusID & 1)=1
),0.0000)
,
Unreimbursed=ISNULL((
	SELECT 0-SUM(Amount) FROM vwEmployeeExpense2 A WHERE A.EmployeeID=X.[ID] AND A.AccountID=@account_id AND A.Reimbursable=1 AND A.[Day past 1900]<=@day AND (A.StatusID & 1)=1 AND A.Amount<0 AND A.[Day Reimbursed] IS NULL
), 0.0000),
A.*
FROM dbo.TempX X
INNER JOIN dbo.vwPersonListAs P ON X.BatchID=@batch_id AND X.[ID]=P.PersonID
INNER JOIN dbo.ExpenseAccount A ON A.AccountID = @account_id
ORDER BY P.[List As]

DELETE TempX WHERE BatchID=@batch_id OR DATEDIFF(hour,0,GETDATE())>1
GO
IF OBJECT_ID('dbo.spEmployeeExpenseDelete') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEmployeeExpenseDelete AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spEmployeeExpenseDelete TO public'
END
GO
ALTER PROC dbo.spEmployeeExpenseDelete @item_id int AS
DECLARE @authorized bit, @old_employee_id int, @old_status_id int
SELECT @old_employee_id = EmployeeID, @old_status_id = StatusID FROM EmployeeExpense WHERE ItemID = @item_id
EXEC dbo.spPermissionInsureForCurrentUserOnPerson4 NULL, @old_status_id, @old_employee_id, @old_status_id, 8, 10010, 10011, @authorized OUT
IF @authorized = 1 DELETE EmployeeExpense WHERE ItemID=@item_id
GO
IF OBJECT_ID('dbo.spEmployeeExpenseSelect') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEmployeeExpenseSelect AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spEmployeeExpenseSelect TO public'
END
GO
ALTER PROC dbo.spEmployeeExpenseSelect @item_id int AS
DECLARE @employee_id int, @authorized bit

SET NOCOUNT ON

SELECT @employee_id = EmployeeID FROM dbo.EmployeeExpense WHERE ItemID = @item_id
EXEC dbo.spPermissionInsureForCurrentUserOnPerson @employee_id, 10010, 1, @authorized out

IF @authorized = 1 SELECT * FROM vwEmployeeExpense WHERE ItemID=@item_id
GO
IF OBJECT_ID('dbo.spEmployeeExpenseList') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEmployeeExpenseList AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spEmployeeExpenseList TO public'
END
GO
ALTER PROC dbo.spEmployeeExpenseList
	@batch_id int,
	@day_min int,
	@day_max int,
	@project_id int,
	@project_null bit,
	@reimbursable bit,
	@reimbursed bit,
	@reimbursed_min int,
	@reimbursed_max int,
	@credit bit,
	@account_id int,
	@status_mask int,
	@authorized bit OUT,
	@extended bit = 1
AS
SET NOCOUNT ON

EXEC dbo.spPermissionGetOnPeopleForCurrentUser2 @batch_id, 10010
DELETE TempX WHERE BatchID = @batch_id AND (X & 1) = 0
SELECT @authorized = CASE WHEN @@ROWCOUNT=0 THEN 1 ELSE 0 END

IF @extended=1
BEGIN
	SELECT H.* FROM vwEmployeeExpense H -- Performs expensive summing operations to give total reimbursed and total unreimbursed columns
	INNER JOIN TempX X ON 
	X.BatchID=@batch_id AND X.[ID]=H.EmployeeID AND
	(@project_id IS NULL OR H.ProjectID=@project_id) AND
	(@project_null=0 OR (@project_null=1 AND H.ProjectID IS NULL)) AND
	((@account_id IS NULL) OR (H.AccountID = @account_id)) AND
	(H.StatusID & @status_mask) > 0 AND
	(@credit IS NULL OR (@credit=1 AND Amount>0) OR (@credit=0 AND Amount<0)) AND
	(@reimbursable IS NULL OR @reimbursable=H.[To Be Reimbursed]) AND
	(@reimbursed IS NULL OR @reimbursed=H.Reimbursed) AND
	([Day Reimbursed] IS NULL OR ([Day Reimbursed] IS NOT NULL AND [Day Reimbursed] BETWEEN @reimbursed_min AND @reimbursed_max)) AND
	H.[Day past 1900] BETWEEN @day_min AND @day_max
	ORDER BY H.Employee, H.EmployeeID, H.[Day past 1900], H.Account
END
ELSE
BEGIN
	SELECT H.* FROM vwEmployeeExpense2 H -- Skips expensive summing operations excluding total reimbursed and total unreimbursed columns
	INNER JOIN TempX X ON 
	X.BatchID=@batch_id AND X.[ID]=H.EmployeeID AND
	(@project_id IS NULL OR H.ProjectID=@project_id) AND
	(@project_null=0 OR (@project_null=1 AND H.ProjectID IS NULL)) AND
	((@account_id IS NULL) OR (H.AccountID = @account_id)) AND
	(H.StatusID & @status_mask) > 0 AND
	(@credit IS NULL OR (@credit=1 AND Amount>0) OR (@credit=0 AND Amount<0)) AND
	(@reimbursable IS NULL OR @reimbursable=H.[To Be Reimbursed]) AND
	(@reimbursed IS NULL OR @reimbursed=H.Reimbursed) AND
	([Day Reimbursed] IS NULL OR ([Day Reimbursed] IS NOT NULL AND [Day Reimbursed] BETWEEN @reimbursed_min AND @reimbursed_max)) AND
	H.[Day past 1900] BETWEEN @day_min AND @day_max
	ORDER BY H.Employee, H.EmployeeID, H.[Day past 1900], H.Account
END

DELETE TempX WHERE BatchID = @batch_id OR DATEDIFF(hour,Created,GETDATE())>1
GO
IF OBJECT_ID('dbo.spEmployeeExpenseSummarize4') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEmployeeExpenseSummarize4 AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spEmployeeExpenseSummarize4 TO public'
END
GO
ALTER PROC dbo.spEmployeeExpenseSummarize4
	@employee_id int, @asof int, @authorized bit out
AS
SET NOCOUNT ON

DECLARE @dt datetime

SELECT @dt = dbo.GetDateFromDaysPast1900(@asof)

CREATE TABLE #Period(
	PeriodID int NOT NULL PRIMARY KEY IDENTITY(1,1),
	Start datetime,
	[Stop] datetime
)

INSERT #Period SELECT DATEDIFF(d,0,dbo.GetDateFromMDY(MONTH(@dt) - 2, 1, YEAR(@dt))), DATEDIFF(d,0,dbo.GetDateFromMDY(MONTH(@dt) - 1, 0, YEAR(@dt)))
INSERT #Period SELECT DATEDIFF(d,0,dbo.GetDateFromMDY(MONTH(@dt) - 1, 1, YEAR(@dt))), DATEDIFF(d,0,dbo.GetDateFromMDY(MONTH(@dt), 0, YEAR(@dt)))
INSERT #Period SELECT DATEDIFF(d,0,dbo.GetDateFromMDY(MONTH(@dt), 1, YEAR(@dt))), DATEDIFF(d,0,dbo.GetDateFromMDY(MONTH(@dt) + 1, 0, YEAR(@dt)))

EXEC dbo.spPermissionInsureForCurrentUserOnPerson @employee_id, 10010, 1, @authorized out

SELECT
[Month] = SUBSTRING(DATENAME(month, P.Start),1,3),
Pending = ISNULL((
	SELECT SUM(E.Amount) FROM dbo.EmployeeExpense E WHERE E.EmployeeID=@employee_id AND dbo.GetDateFromDaysPast1900(E.[Day past 1900]) BETWEEN P.Start AND P.Stop AND E.StatusID = 8 AND @authorized = 1
), 0),
Denied = ISNULL((
	SELECT SUM(E.Amount) FROM dbo.EmployeeExpense E WHERE E.EmployeeID=@employee_id AND dbo.GetDateFromDaysPast1900(E.[Day past 1900]) BETWEEN P.Start AND P.Stop AND E.StatusID = 2 AND @authorized = 1
), 0),
[Approved Unreimbursed] = ISNULL((
	SELECT SUM(E.Amount) FROM dbo.EmployeeExpense E WHERE E.EmployeeID=@employee_id AND dbo.GetDateFromDaysPast1900(E.[Day past 1900]) BETWEEN P.Start AND P.Stop AND E.StatusID IN (1,5) AND E.[Day Reimbursed] IS NULL AND @authorized = 1
), 0),
[Reimbursed] = ISNULL((
	SELECT SUM(E.Amount) FROM dbo.EmployeeExpense E WHERE E.EmployeeID=@employee_id AND dbo.GetDateFromDaysPast1900(E.[Day past 1900]) BETWEEN P.Start AND P.Stop AND E.[Day Reimbursed] IS NOT NULL AND @authorized = 1
), 0),
Total = ISNULL((
	SELECT SUM(E.Amount) FROM dbo.EmployeeExpense E WHERE E.EmployeeID=@employee_id AND dbo.GetDateFromDaysPast1900(E.[Day past 1900]) BETWEEN P.Start AND P.Stop AND @authorized = 1
), 0)
FROM #Period P ORDER BY P.Start DESC
GO
IF OBJECT_id('dbo.spPersonXTrainingSummary') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spPersonXTrainingSummary AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spPersonXTrainingSummary TO public'
END
GO
ALTER PROC dbo.spPersonXTrainingSummary
	@batch_id int,
	@began_start int,
	@began_stop int,
	@exclude_incomplete bit,
	@authorized bit OUT,
	@hours_min numeric(9,4) = -99999.9999,
	@hours_max numeric(9,4) = 99999.9999,
	@extend bit = 0,
	@exclude_expired int = NULL
AS
SET NOCOUNT ON

EXEC dbo.spPermissionGetOnPeopleForCurrentUser2 @batch_id, 4096
DELETE TempX WHERE BatchID = @batch_id AND X & 1 = 0
SELECT @authorized = CASE WHEN @@ROWCOUNT = 0 THEN 1 ELSE 0 END

CREATE TABLE #PT(PersonID int, ItemID int, [Completed Day past 1900] int, Training varchar(50) COLLATE SQL_Latin1_General_CP1_CI_AS, Courses varchar(4000) COLLATE SQL_Latin1_General_CP1_CI_AS, Hours numeric(9,4))

INSERT #PT
SELECT X.[ID], NULL, NULL, '', '', 0
FROM TempX X WHERE X.BatchID = @batch_id

DELETE TempX WHERE BatchID = @batch_id OR DATEDIFF(hh, Created, GETDATE()) > 1

DECLARE @r int
SET @r = 1

-- Only works if Training.Training has a unique constraint and has a 0 length check constraint
WHILE @r > 0
BEGIN
	UPDATE #PT SET ItemID = (
		SELECT TOP 1 PT.ItemID FROM PersonXTraining PT
		INNER JOIN Training C ON 
		(PT.[Completed Day past 1900] IS NOT NULL OR @exclude_incomplete = 0) AND PT.[Began Day past 1900] BETWEEN @began_start AND @began_stop AND
		PT.PersonID = #PT.PersonID AND PT.TrainingID = C.TrainingID AND (
			ISNULL(PT.[Completed Day past 1900], 2147483647) < ISNULL(#PT.[Completed Day past 1900], 2147483647) OR 
			(ISNULL(PT.[Completed Day past 1900], 2147483647) = ISNULL(#PT.[Completed Day past 1900], 2147483647) AND C.Training > #PT.Training)
		) AND
		(
			@exclude_expired IS NULL OR PT.[Expires Day past 1900] IS NULL OR PT.[Expires Day past 1900] >= @exclude_expired
		)
		ORDER BY PT.[Completed Day past 1900] DESC, C.Training
	)

	UPDATE #PT SET Training = C.Training, [Completed Day past 1900] = PT.[Completed Day past 1900],
		Courses = SUBSTRING(
			Courses + 
			CASE WHEN LEN(#PT.Courses) = 0 THEN '' ELSE ', ' END + 
			C.Training +
			CASE WHEN PT.[Completed Day past 1900] IS NULL THEN '' ELSE ' (' + CAST(DATEADD(d, PT.[Completed Day past 1900], 0) AS char(11)) + ')' END
		, 1, 4000)
	FROM #PT 
	INNER JOIN PersonXTraining PT ON #PT.ItemID = PT.ItemID
	INNER JOIN Training C ON PT.TrainingID = C.TrainingID

	SET @r = @@ROWCOUNT
END


UPDATE #PT SET Hours = ISNULL((
	SELECT SUM(PT.Hours) FROM dbo.PersonXTraining PT WHERE PT.PersonID=#PT.PersonID AND
	(PT.[Completed Day past 1900] IS NOT NULL OR @exclude_incomplete = 0) AND PT.[Began Day past 1900] BETWEEN @began_start AND @began_stop AND
	(
		@exclude_expired IS NULL OR PT.[Expires Day past 1900] IS NULL OR PT.[Expires Day past 1900] >= @exclude_expired
	)
),0)

IF @extend = 1
BEGIN
	SELECT Person = P.[Person List As], #PT.Courses, Hours,
	P.*
	FROM #PT
	INNER JOIN dbo.vwEmployeeSecure P ON #PT.PersonID = P.EID AND LEN(#PT.Courses) > 0 AND #PT.Hours BETWEEN @hours_min AND @hours_max
	ORDER BY P.[Person List As]
END
ELSE
BEGIN
	SELECT Person = dbo.fnGetListAs([First Name], [Middle Name], [Last Name], Suffix), #PT.Courses, Hours
	FROM #PT
	INNER JOIN dbo.Person P ON #PT.PersonID = P.PersonID AND LEN(#PT.Courses) > 0 AND #PT.Hours BETWEEN @hours_min AND @hours_max
	ORDER BY P.[Last Name], P.[First Name], P.[Middle Name]
END
GO
IF OBJECT_id('dbo.spPersonXTrainingList') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spPersonXTrainingList AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spPersonXTrainingList TO public'
END
GO
ALTER PROC dbo.spPersonXTrainingList
	@person_id int
AS
DECLARE @authorized bit

SET NOCOUNT ON

EXEC dbo.spPermissionInsureForCurrentUserOnPerson @person_id, 4096, 1, @authorized out

IF @authorized = 1 SELECT * FROM vwPersonXTraining WHERE PersonID = @person_id ORDER BY [Completed Day past 1900] DESC
GO
IF OBJECT_id('dbo.spPersonXTrainingListNot') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spPersonXTrainingListNot AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spPersonXTrainingListNot TO public'
END
GO
ALTER PROC dbo.spPersonXTrainingListNot
	@batch_id int,
	@training_id int,
	@exclude_incomplete bit,
	@authorized bit OUT,
	@began_start int = -2147483648,
	@began_stop int = 2147483647,
	@exclude_expired int = NULL
AS
SET NOCOUNT ON

EXEC dbo.spPermissionGetOnPeopleForCurrentUser2 @batch_id, 4096
DELETE TempX WHERE BatchID = @batch_id AND X & 1 = 0
SELECT @authorized = CASE WHEN @@ROWCOUNT = 0 THEN 1 ELSE 0 END

CREATE TABLE #PT(PersonID int, ItemID int, [Completed Day past 1900] int, Training varchar(50) COLLATE SQL_Latin1_General_CP1_CI_AS, Courses varchar(4000) COLLATE SQL_Latin1_General_CP1_CI_AS)

INSERT #PT
SELECT X.[ID], NULL, NULL, '', ''
FROM TempX X
INNER JOIN Employee E ON X.BatchID = @batch_id AND X.[ID] = E.EmployeeID 
AND E.EmployeeID NOT IN
(
	SELECT PT.PersonID FROM PersonXTraining PT WHERE PT.TrainingID = @training_id AND (
		PT.[Completed Day past 1900] IS NOT NULL OR @exclude_incomplete = 0
	) AND PT.[Began Day past 1900] BETWEEN @began_start AND @began_stop AND (
		@exclude_expired IS NULL OR PT.[Expires Day past 1900] IS NULL OR PT.[Expires Day past 1900] >= @exclude_expired
	)
)


DELETE TempX WHERE BatchID = @batch_id OR DATEDIFF(hh, Created, GETDATE()) > 1

DECLARE @r int
SET @r = 1

-- Only works if Training.Training has a unique constraint and has a 0 length check constraint
WHILE @r > 0
BEGIN
	UPDATE #PT SET ItemID = (
		SELECT TOP 1 PT.ItemID FROM PersonXTraining PT
		INNER JOIN Training C ON 
		(PT.[Completed Day past 1900] IS NOT NULL OR @exclude_incomplete = 0) AND PT.[Began Day past 1900] BETWEEN @began_start AND @began_stop AND
		PT.PersonID = #PT.PersonID AND PT.TrainingID = C.TrainingID AND (
			ISNULL(PT.[Completed Day past 1900], -2147483648) > ISNULL(#PT.[Completed Day past 1900], -2147483648) OR 
			(ISNULL(PT.[Completed Day past 1900], -2147483648) = ISNULL(#PT.[Completed Day past 1900], -2147483648) AND C.Training > #PT.Training) AND PT.[Began Day past 1900] BETWEEN @began_start AND @began_stop
		) AND (
			@exclude_expired IS NULL OR PT.[Expires Day past 1900] IS NULL OR PT.[Expires Day past 1900] >= @exclude_expired
		)
		ORDER BY PT.[Completed Day past 1900], C.Training
	)

	UPDATE #PT SET Training = C.Training, [Completed Day past 1900] = PT.[Completed Day past 1900],
		Courses = SUBSTRING(
			Courses + 
			CASE WHEN LEN(#PT.Courses) = 0 THEN '' ELSE ', ' END + 
			C.Training +
			CASE WHEN PT.[Completed Day past 1900] IS NULL THEN '' ELSE ' (' + CAST(DATEADD(d, PT.[Completed Day past 1900], 0) AS char(11)) + ')' END
		, 1, 4000)
	FROM #PT 
	INNER JOIN PersonXTraining PT ON #PT.ItemID = PT.ItemID
	INNER JOIN Training C ON PT.TrainingID = C.TrainingID

	SET @r = @@ROWCOUNT
END

SELECT Person = P.[List As], #PT.Courses,
Hours = ISNULL((
	SELECT SUM(PT.Hours) FROM dbo.PersonXTraining PT WHERE PT.PersonID = #PT.PersonID AND
	(PT.[Completed Day past 1900] IS NOT NULL OR @exclude_incomplete = 0) AND PT.[Began Day past 1900] BETWEEN @began_start AND @began_stop
	AND (
		@exclude_expired IS NULL OR PT.[Expires Day past 1900] IS NULL OR PT.[Expires Day past 1900] >= @exclude_expired
	)
),0)
FROM #PT
INNER JOIN dbo.vwPersonListAs P ON #PT.PersonID = P.PersonID
ORDER BY P.[List As]
GO
IF OBJECT_ID('dbo.spEmployeeCompensationGetLast') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEmployeeCompensationGetLast AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spEmployeeCompensationGetLast TO public'
END
GO
ALTER PROC dbo.spEmployeeCompensationGetLast
	@employee_id int,
	@compensation_id int OUT,
	@open bit = NULL
AS
SET NOCOUNT ON

IF @open IS NULL SELECT @compensation_id = LastCompensationID FROM Employee WHERE EmployeeID = @employee_id
ELSE
BEGIN
	SET @compensation_id = NULL
	SELECT @compensation_id = E.LastCompensationID FROM dbo.Employee E
	INNER JOIN dbo.EmployeeCompensation C ON E.EmployeeID = @employee_id AND E.LastCompensationID = C.CompensationID AND (
		C.[Stop Day past 1900] IS NULL AND @open = 1 OR
		C.[Stop Day past 1900] IS NOT NULL AND @open = 0
	)
END
GO
IF OBJECT_ID('dbo.spLeaveRateInsert') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spLeaveRateInsert AS'
GO
ALTER PROC dbo.spLeaveRateInsert
	@plan_id int,
	@type_id int,
	@start_month int,
	@stop_month int,
	@seconds int,
	@period_id int,
	@rate_id int out,
	@ineligible_months int = 0,
	@flags int = 0,
	@limit_period_id int = 0,
	@limit_month int = 1,
	@limit_day int = 1,
	@limit_max_seconds int = 2147483647
AS
SET NOCOUNT ON

INSERT LeaveRate(PlanID, TypeID, [Start Month], [Stop Month], Seconds, PeriodID, [Ineligible Months], Flags, LimitPeriodID, [Limit Month], [Limit Day], [Limit Max Seconds])
VALUES(@plan_id, @type_id, @start_month, @stop_month, @seconds, @period_id, @ineligible_months, @flags, @limit_period_id, @limit_month, @limit_day, @limit_max_seconds)

SELECT @rate_id = SCOPE_IDENTITY()
GO
IF OBJECT_ID('dbo.spLeaveSummarizeAccrualForType') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spLeaveSummarizeAccrualForType AS'
GO
ALTER PROC dbo.spLeaveSummarizeAccrualForType
	@type_id int,
	@day int,
	@batch_id int
AS
SET NOCOUNT ON

EXEC dbo.spPermissionGetOnPeopleForCurrentUser2 @batch_id, 128

SELECT
E.EmployeeID,
Employee = P.[List As],
[Annualized Rate] = CAST(CASE WHEN R.Seconds IS NULL THEN 0 ELSE R.Seconds * (7488000.0 / R.[Seconds in Period]) / 12 * (12 - dbo.fnCountBits(R.ExcludeMonthMask)) END AS int),
Rate = ISNULL(R.Seconds, 0),
Period = ISNULL(R.[Group], ''),
PeriodID = R.GroupID
FROM TempX X
INNER JOIN dbo.vwPersonListAs P ON X.BatchID = @batch_id AND X.[ID] = P.PersonID AND (X.X & 1) = 1
INNER JOIN dbo.Employee E ON E.EmployeeID = P.PersonID
LEFT JOIN dbo.EmployeeLeavePlan EP ON EP.EmployeeID = E.EmployeeID AND @day >= EP.[Start Day past 1900] AND (EP.[Stop Day past 1900] IS NULL OR @day <= EP.[Stop Day past 1900])
LEFT JOIN dbo.vwLeaveRate R ON R.TypeID = @type_id AND R.PlanID = EP.PlanID AND DATEDIFF(mm, E.[Seniority Begins Day past 1900], GETDATE()) BETWEEN R.[Start Month] AND R.[Stop Month]
ORDER BY P.[List As]
GO
ALTER PROC dbo.spEmployeeUpdateOrg
	@employee_id int,
	@manager_id int,
	@shift_id int,
	@division_id int,
	@location_id int,
	@department_id int,
	@active_employee bit,
	@seniority_begins int,
	@employee_number varchar(50),
	@user_field1 int = NULL, @user_field1_defined bit = 0,
	@sync_id varchar(50) = NULL
AS
DECLARE @authorized bit

SET NOCOUNT ON

EXEC dbo.spPermissionInsureForCurrentUserOnPerson @employee_id, 8, 2, @authorized out
IF @authorized = 1 
UPDATE Employee SET 
	ManagerID = @manager_id,
	ShiftID = @shift_id,
	DivisionID = @division_id,
	LocationID = @location_id,
	DepartmentID = @department_id,
	[Active Employee] = @active_employee,
	[Seniority Begins Day past 1900] = @seniority_begins,
	[Employee Number] = @employee_number,
	OrgUserField1 = CASE WHEN @user_field1_defined=1 THEN @user_field1 ELSE OrgUserField1 END,
	SyncID = CASE WHEN @sync_id IS NULL THEN SyncID ELSE @sync_id END
WHERE EmployeeID = @employee_id AND (
	dbo.fnNullCompare(ManagerID, @manager_id) = 0 OR
	ShiftID != @shift_id OR
	DivisionID != @division_id OR
	LocationID != @location_id OR
	DepartmentID != @department_id OR
	[Active Employee] != @active_employee OR
	[Seniority Begins Day past 1900] != @seniority_begins OR
	[Employee Number] != @employee_number OR
	(@user_field1_defined=1 AND dbo.fnNullCompare(OrgUserField1, @user_field1) = 0) OR
	(@sync_id IS NOT NULL AND SyncID != @sync_id)
)
GO
IF OBJECT_ID('dbo.spUserFieldItemInsert') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spUserFieldItemInsert AS'
IF OBJECT_ID('dbo.spUserFieldItemUpdate') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spUserFieldItemUpdate AS'
IF OBJECT_ID('dbo.spUserFieldItemDelete') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spUserFieldItemDelete AS'
IF OBJECT_ID('dbo.spUserFieldItemSelect') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spUserFieldItemSelect AS'
IF OBJECT_ID('dbo.spUserFieldItemList') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spUserFieldItemList AS'
IF OBJECT_ID('dbo.spUserFieldItemGetItemFromItemID') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spUserFieldItemGetItemFromItemID AS'

IF OBJECT_ID('dbo.spUserFieldItemInsertOrg') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spUserFieldItemInsertOrg AS'
IF OBJECT_ID('dbo.spUserFieldItemUpdateOrg') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spUserFieldItemUpdateOrg AS'
IF OBJECT_ID('dbo.spUserFieldItemDeleteOrg') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spUserFieldItemDeleteOrg AS'
GO
GRANT EXEC ON dbo.spUserFieldItemInsert TO public
GRANT EXEC ON dbo.spUserFieldItemUpdate TO public
GRANT EXEC ON dbo.spUserFieldItemDelete TO public
GRANT EXEC ON dbo.spUserFieldItemSelect TO public
GRANT EXEC ON dbo.spUserFieldItemList TO public
GRANT EXEC ON dbo.spUserFieldItemGetItemFromItemID TO public
GO
IF NOT EXISTS(SELECT * FROM dbo.PermissionObject WHERE ObjectID=62)
BEGIN
	INSERT dbo.PermissionObject(ObjectID,[Object],SelectObjectID,UpdateObjectID,DeleteObjectID,InsertObjectID,[Permission Possible Mask])
	SELECT 62,'Organizational User Fields',0,OBJECT_ID('dbo.spUserFieldItemUpdateOrg'),OBJECT_ID('dbo.spUserFieldItemInsertOrg'),OBJECT_ID('dbo.spUserFieldItemDeleteOrg'),14

	GRANT EXEC ON dbo.spUserFieldItemUpdateOrg TO public 
	GRANT EXEC ON dbo.spUserFieldItemInsertOrg TO public 
	GRANT EXEC ON dbo.spUserFieldItemDeleteOrg TO public
END
GO
ALTER PROC dbo.spUserFieldItemInsertOrg @item varchar(50), @item_id int OUT AS
INSERT dbo.UserFieldItem(FieldID, Item) SELECT 1, @item
SELECT @item_id = SCOPE_IDENTITY()
GO
ALTER PROC dbo.spUserFieldItemInsert @field_id int, @item varchar(50), @item_id int OUT AS
IF @field_id=1 EXEC dbo.spDivisionInsert @item, @item_id OUT
ELSE IF @field_id=2 EXEC dbo.spUserFieldItemInsertOrg @item, @item_id OUT
ELSE RAISERROR('Unidentified field_id: 3',16,1)
GO
ALTER PROC dbo.spUserFieldItemUpdateOrg @item varchar(50), @item_id int AS
UPDATE dbo.UserFieldItem SET Item=@item WHERE ItemID=@item_id
GO
ALTER PROC dbo.spUserFieldItemUpdate @item varchar(50), @item_id int AS
DECLARE @field_id int
SELECT @field_id = FieldID FROM dbo.UserFieldItem WHERE ItemID = @item_id
IF @field_id=1 EXEC dbo.spDivisionUpdate @item, @item_id
ELSE IF @field_id=2 EXEC dbo.spUserFieldItemUpdateOrg @item, @item_id
ELSE RAISERROR('Unidentified field_id: 3',16,1)
GO
ALTER PROC dbo.spUserFieldItemDeleteOrg @item_id int, @assign_orphans_to_item_id int AS
DELETE dbo.UserFieldItem WHERE ItemID=@item_id
GO
ALTER PROC dbo.spUserFieldItemDelete @item_id int, @assign_orphans_to_item_id int AS
DECLARE @field_id int
SELECT @field_id = FieldID FROM dbo.UserFieldItem WHERE ItemID = @item_id
IF @field_id=1 EXEC dbo.spDivisionDelete @item_id, @assign_orphans_to_item_id
ELSE IF @field_id=2 EXEC dbo.spUserFieldItemDeleteOrg @item_id, @assign_orphans_to_item_id
ELSE RAISERROR('Unidentified field_id: 3',16,1)
GO
ALTER PROC dbo.spUserFieldItemSelect @item_id int AS
SELECT Item,FieldID,ItemID FROM dbo.UserFieldItem WHERE ItemID=@item_id
GO
ALTER PROC dbo.spUserFieldItemGetItemFromItemID @item_id int, @item varchar(50) OUT AS
SELECT @item=Item FROM dbo.UserFieldItem WHERE ItemID=@item_id
GO
ALTER PROC dbo.spUserFieldItemList @field_id int AS
SELECT Item,FieldID,ItemID FROM dbo.UserFieldItem WHERE FieldID=@field_id ORDER BY Item
GO
IF OBJECT_id('dbo.spPositionStatusDelete') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spPositionStatusDelete AS SELECT A=0'
GO
ALTER PROC dbo.spPositionStatusDelete
	@status_id int,
	@assign_orphans_to_status_id int = NULL
AS
DECLARE @status_count int
SELECT @status_count = (SELECT COUNT(*) FROM dbo.PositionStatus WHERE StatusID != @status_id)

IF @status_count=0 EXEC dbo.spErrorRaise 50060
ELSE
BEGIN
	BEGIN TRAN
	IF @assign_orphans_to_status_id IS NOT NULL
	BEGIN
		UPDATE dbo.Position SET StatusID = @assign_orphans_to_status_id WHERE StatusID = @status_id
	END
	DELETE dbo.PositionStatus WHERE StatusID = @status_id
	COMMIT TRAN
END
GO
IF OBJECT_id('dbo.spEmployeeCompensationGroupByPosition') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spEmployeeCompensationGroupByPosition AS SELECT A=0'
GO
ALTER PROC dbo.spEmployeeCompensationGroupByPosition
	@status_id int,
	@authorized bit OUT
AS
DECLARE @yy int
DECLARE @batch_id int

SET NOCOUNT ON

SELECT @batch_id = RAND() * 2147483647

INSERT TempX(BatchID, [ID])
SELECT @batch_id, EmployeeID FROM EmployeeCompensation GROUP BY EmployeeID

EXEC dbo.spPermissionGetOnPeopleForCurrentUser2 @batch_id, 1024
DELETE TempX WHERE BatchID = @batch_id AND (X & 1) = 0
SELECT @authorized = CASE @@ROWCOUNT WHEN 0 THEN 1 ELSE 0 END

SELECT @yy = YEAR(GETDATE())

CREATE TABLE #Y(YY int)

INSERT #Y
SELECT @yy - 4 UNION
SELECT @yy - 3 UNION
SELECT @yy - 2 UNION
SELECT @yy - 1 UNION
SELECT @yy

SELECT EC.PositionID, #Y.YY, C=COUNT(*), [Avg] = AVG(EC.[Base Pay] * (7488000 / PD.Seconds)), [Max] = MAX(EC.[Base Pay] * (7488000 / PD.Seconds)), [Min] = MIN(EC.[Base Pay] * (7488000 / PD.Seconds))
INTO #P
FROM vwEmployeeCompensation EC
INNER JOIN TempX X ON X.BatchID = @batch_id AND X.[ID] = EC.EmployeeID
INNER JOIN #Y ON #Y.YY BETWEEN YEAR(EC.Start) AND ISNULL(YEAR(EC.Stop), 9999)
INNER JOIN vwPosition P ON EC.PositionID = P.PositionID AND (P.StatusID = @status_id OR @status_id IS NULL)
INNER JOIN Period PD ON EC.PeriodID = PD.PeriodID
GROUP BY EC.PositionID, #Y.YY


SELECT P.PositionID, P.[Job Title],

A0 = ISNULL((SELECT [Avg] FROM #P WHERE #P.PositionID = P.PositionID AND #P.YY = @yy), 0),
M0 = ISNULL((SELECT [Min] FROM #P WHERE #P.PositionID = P.PositionID AND #P.YY = @yy), 0),
X0 = ISNULL((SELECT [Max] FROM #P WHERE #P.PositionID = P.PositionID AND #P.YY = @yy), 0),
C0 = ISNULL((SELECT [C] FROM #P WHERE #P.PositionID = P.PositionID AND #P.YY = @yy), 0),

A1 = ISNULL((SELECT [Avg] FROM #P WHERE #P.PositionID = P.PositionID AND #P.YY = @yy - 1), 0),
M1 = ISNULL((SELECT [Min] FROM #P WHERE #P.PositionID = P.PositionID AND #P.YY = @yy - 1), 0),
X1 = ISNULL((SELECT [Max] FROM #P WHERE #P.PositionID = P.PositionID AND #P.YY = @yy - 1), 0),
C1 = ISNULL((SELECT [C] FROM #P WHERE #P.PositionID = P.PositionID AND #P.YY = @yy - 1), 0),

A2 = ISNULL((SELECT [Avg] FROM #P WHERE #P.PositionID = P.PositionID AND #P.YY = @yy - 2), 0),
M2 = ISNULL((SELECT [Min] FROM #P WHERE #P.PositionID = P.PositionID AND #P.YY = @yy - 2), 0),
X2 = ISNULL((SELECT [Max] FROM #P WHERE #P.PositionID = P.PositionID AND #P.YY = @yy - 2), 0),
C2 = ISNULL((SELECT [C] FROM #P WHERE #P.PositionID = P.PositionID AND #P.YY = @yy - 2), 0),

A3 = ISNULL((SELECT [Avg] FROM #P WHERE #P.PositionID = P.PositionID AND #P.YY = @yy - 3), 0),
M3 = ISNULL((SELECT [Min] FROM #P WHERE #P.PositionID = P.PositionID AND #P.YY = @yy - 3), 0),
X3 = ISNULL((SELECT [Max] FROM #P WHERE #P.PositionID = P.PositionID AND #P.YY = @yy - 3), 0),
C3 = ISNULL((SELECT [C] FROM #P WHERE #P.PositionID = P.PositionID AND #P.YY = @yy - 3), 0),

A4 = ISNULL((SELECT [Avg] FROM #P WHERE #P.PositionID = P.PositionID AND #P.YY = @yy - 4), 0),
M4 = ISNULL((SELECT [Min] FROM #P WHERE #P.PositionID = P.PositionID AND #P.YY = @yy - 4), 0),
X4 = ISNULL((SELECT [Max] FROM #P WHERE #P.PositionID = P.PositionID AND #P.YY = @yy - 4), 0),
C4 = ISNULL((SELECT [C] FROM #P WHERE #P.PositionID = P.PositionID AND #P.YY = @yy - 4), 0)

FROM dbo.vwPosition P WHERE P.StatusID = @status_id OR @status_id IS NULL
ORDER BY P.[Job Title]

DELETE TempX WHERE BatchID = @batch_id OR DATEDIFF(hh, Created, GETDATE()) >1
GO
GRANT EXEC ON dbo.spEmployeeCompensationGroupByPosition TO public
GO
IF OBJECT_id('dbo.spEmployeeDependentInsert2') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spEmployeeDependentInsert2 AS'
GO
ALTER PROC dbo.spEmployeeDependentInsert2
	@employee_id int,
	@person_id int,
	@contact_id int out
AS
SET NOCOUNT ON
DECLARE @authorized bit


EXEC dbo.spPermissionInsureForCurrentUserOnPerson @employee_id, 134217728, 4, @authorized out

IF @authorized = 1
BEGIN
	BEGIN TRAN

	DECLARE @race_id int, @i9_status_id int, @marital_status_id int
	EXEC dbo.spPersonXInsertPrepare @race_id out, @i9_status_id out, @marital_status_id out

	INSERT dbo.PersonX(PersonID, RaceID, I9StatusID, MaritalStatusID)
	SELECT P.PersonID, @race_id, @i9_status_id, @marital_status_id FROM dbo.Person P
	LEFT JOIN dbo.PersonX X ON P.PersonID = X.PersonID WHERE P.PersonID = @person_id AND X.PersonID IS NULL

	INSERT dbo.EmployeeDependent(EmployeeID, PersonID)
	VALUES(@employee_id, @person_id)

	COMMIT TRAN

	SELECT @contact_id = SCOPE_IDENTITY()
END
GO
GRANT EXEC ON dbo.spEmployeeDependentInsert2 TO public
GO
IF OBJECT_id('dbo.spPositionDelete') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spPositionDelete AS'
GO
ALTER PROC dbo.spPositionDelete
	@position_id int,
	@assign_orphans_to_position_id int = NULL
AS
DECLARE @positions int
SELECT @positions = (SELECT COUNT(*) FROM Position WHERE PositionID != @position_id)

IF @positions=0 EXEC dbo.spErrorRaise 50058
ELSE
BEGIN
	BEGIN TRAN
	IF @assign_orphans_to_position_id IS NOT NULL UPDATE dbo.EmployeeCompensation SET PositionID=@assign_orphans_to_position_id WHERE PositionID=@position_id
	DELETE Position WHERE PositionID = @position_id
	COMMIT TRAN
END
GO
ALTER PROC dbo.spDepartmentDelete
	@department_id int,
	@assign_orphans_to_department_id int = NULL
AS
SET NOCOUNT ON

IF EXISTS(SELECT * FROM Department WHERE DepartmentID != @department_id)
BEGIN
	BEGIN TRAN
	IF @assign_orphans_to_department_id IS NOT NULL AND @assign_orphans_to_department_id != @department_id UPDATE dbo.Employee SET DepartmentID=@assign_orphans_to_department_id WHERE DepartmentID=@department_id
	DELETE dbo.Department WHERE DepartmentID = @department_id
	COMMIT TRAN
END
ELSE EXEC dbo.spErrorRaise 50034
GO
ALTER PROC dbo.spDivisionDelete
	@division_id int,
	@assign_orphans_to_division_id int = NULL
AS
SET NOCOUNT ON

IF EXISTS(SELECT * FROM Division WHERE DivisionID != @division_id)
BEGIN
	BEGIN TRAN
	IF @assign_orphans_to_division_id IS NOT NULL UPDATE dbo.Employee SET DivisionID=@assign_orphans_to_division_id WHERE DivisionID=@division_id
	DELETE Division WHERE DivisionID = @division_id
	COMMIT TRAN
END
ELSE EXEC dbo.spErrorRaise 50035
GO
IF OBJECT_ID('dbo.spTimeSchemaDelete') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spTimeSchemaDelete AS SELECT A=0'
GO
ALTER PROC dbo.spTimeSchemaDelete
	@schema_id int,
	@assign_orphans_to_schema_id int = NULL
AS
DECLARE @schemas int
SELECT @schemas = (SELECT COUNT(*) FROM TimeSchema WHERE TimeSchemaID != @schema_id)

IF @schemas=0 EXEC dbo.spErrorRaise 50059
ELSE
BEGIN
	BEGIN TRAN
	IF @assign_orphans_to_schema_id IS NOT NULL
	BEGIN
		UPDATE dbo.Employee SET TimeSchemaID = @assign_orphans_to_schema_id WHERE TimeSchemaID = @schema_id
		UPDATE dbo.Constant SET DefaultTimeSchemaID = @assign_orphans_to_schema_id WHERE DefaultTimeSchemaID = @schema_id
	END
	DELETE dbo.TimeSchema WHERE TimeSchemaID = @schema_id
	COMMIT TRAN
END
GO
ALTER PROC dbo.spLocationDelete
	@location_id int,
	@assign_orphans_to_location_id int = NULL
AS
DECLARE @locations int
SELECT @locations = (SELECT COUNT(*) FROM Location WHERE LocationID != @location_id)

IF @locations=0 EXEC dbo.spErrorRaise 50036
ELSE
BEGIN
	BEGIN TRAN
	IF @locations=1
	BEGIN
		DECLARE @last_location_id int
		SELECT TOP 1 @last_location_id = LocationID FROM Location WHERE LocationID != @location_id
		UPDATE dbo.Constant SET HeadquartersID=@last_location_id WHERE HeadquartersID=@location_id
		UPDATE dbo.Project SET LocationID=@last_location_id WHERE LocationID=@location_id
		UPDATE dbo.Employee SET LocationID=@last_location_id WHERE LocationID=@location_id
	END
	ELSE IF @assign_orphans_to_location_id IS NOT NULL
	BEGIN
		UPDATE dbo.Constant SET HeadquartersID=@assign_orphans_to_location_id WHERE HeadquartersID=@location_id
		UPDATE dbo.Employee SET LocationID = @assign_orphans_to_location_id WHERE LocationID=@location_id
		UPDATE dbo.Project SET LocationID = @assign_orphans_to_location_id WHERE LocationID=@location_id
	END

	DELETE Location WHERE LocationID = @location_id
	COMMIT TRAN
END
GO
ALTER PROCEDURE dbo.spShiftDelete
	@shift_id int,
	@assign_orphans_to_shift_id int = NULL
AS
SET NOCOUNT ON

IF EXISTS(SELECT * FROM Shift WHERE ShiftID != @shift_id)
BEGIN
	BEGIN TRAN
	IF @assign_orphans_to_shift_id IS NOT NULL UPDATE dbo.Employee SET ShiftID=@assign_orphans_to_shift_id WHERE ShiftID=@shift_id
	DELETE dbo.ShiftSchedule WHERE ShiftID = @shift_id
	DELETE dbo.ShiftSlant WHERE ShiftID = @shift_id
	DELETE dbo.Shift WHERE ShiftID = @shift_id
	COMMIT TRAN
END
ELSE EXEC dbo.spErrorRaise 50037
GO
IF OBJECT_id('dbo.spAdminDiagnoseError2') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spAdminDiagnoseError2 AS'
GO
-- Temporary error diagnosis code for elusive overflow error when recalculating accrual tables
ALTER PROC dbo.spAdminDiagnoseError2 @employee_id int, @message varchar(4000) out
AS
DECLARE @s varchar(4000), @i int, @j int

SELECT @message='loamin=' + CAST(MIN([Start Day past 1900]) AS varchar(50)) FROM EmployeeLeaveUsed WHERE EmployeeID=@employee_id
SELECT @message=@message+'lopamax=' + CAST(MAX([Stop Day past 1900]) AS varchar(50)) FROM EmployeeLeaveUsed WHERE EmployeeID=@employee_id

DECLARE p_cursor CURSOR LOCAL FORWARD_ONLY STATIC FOR
SELECT
M =  '--' + CAST(EP.ItemID AS varchar(50)) + ',' + 
't' + CAST(TypeID AS varchar(50)) + ',' +
'p' + CAST(PeriodID AS varchar(50)) + ',' +
CAST([Start Month] AS varchar(50)) + ',' +
CAST([Stop Month] AS varchar(50)) + ',' +
CAST(Seconds AS varchar(50))
FROM EmployeeLeavePlan EP
INNER JOIN LeavePlan P ON EP.PlanID = P.PlanID
INNER JOIN LeaveRate R ON P.PlanID = R.PlanID
WHERE EP.EmployeeID=@employee_id
ORDER BY EP.ItemID

OPEN p_cursor	

FETCH NEXT FROM p_cursor INTO @s

WHILE @@FETCH_STATUS=0
BEGIN
	SET @message = @message + @s
	FETCH NEXT FROM p_cursor INTO @s
END

CLOSE p_cursor
DEALLOCATE p_cursor
GO
GRANT EXEC ON dbo.spAdminDiagnoseError2 TO public
GO
IF OBJECT_id('dbo.spPersonXTrainingInsert') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spPersonXTrainingInsert AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spPersonXTrainingInsert TO public'
END
GO
ALTER PROC dbo.spPersonXTrainingInsert
	@person_id int,
	@training_id int,
	@began_day_past_1900 int,
	@completed_day_past_1900 int,
	@item_id int OUT,

	@expires_day_past_1900 int = NULL,
	@comments varchar(50) = '',
	@hours numeric(9,4) = 0
AS
DECLARE @authorized bit

SET NOCOUNT ON

EXEC dbo.spPermissionInsureForCurrentUserOnPerson @person_id, 4096, 4, @authorized out

IF @authorized = 1
BEGIN
	IF @comments IS NULL SET @comments = ''
	IF @hours IS NULL SET @hours = 0

	INSERT PersonXTraining(PersonID,TrainingID,[Began Day past 1900],[Completed Day past 1900],[Expires Day past 1900],Comments,Hours)
	VALUES (@person_id,@training_id,@began_day_past_1900,@completed_day_past_1900,@expires_day_past_1900,@comments,@hours)
	SELECT @item_id = SCOPE_IDENTITY()
END
GO
IF OBJECT_id('dbo.spPersonXTrainingUpdate') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spPersonXTrainingUpdate AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spPersonXTrainingUpdate TO public'
END
GO
ALTER PROC dbo.spPersonXTrainingUpdate
	@training_id int,
	@began_day_past_1900 int,
	@completed_day_past_1900 int,
	@item_id int,

	@expires_day_past_1900 int = NULL,
	@comments varchar(50) = NULL,
	@hours numeric(9,4) = NULL
AS
DECLARE @person_id int
DECLARE @authorized bit

SET NOCOUNT ON

SELECT @person_id = PersonID FROM PersonXTraining WHERE ItemID = @item_id
EXEC dbo.spPermissionInsureForCurrentUserOnPerson @person_id, 4096, 2, @authorized out

IF @authorized = 1
UPDATE PersonXTraining SET
	TrainingID = @training_id,
	[Began Day past 1900] = @began_day_past_1900,
	[Completed Day past 1900] = @completed_day_past_1900,
	Comments = CASE WHEN @comments IS NULL THEN Comments ELSE @comments END,
	[Expires Day past 1900] = CASE WHEN @expires_day_past_1900  IS NULL THEN [Expires Day past 1900] ELSE @expires_day_past_1900 END,
	Hours = CASE WHEN @hours IS NULL THEN Hours ELSE @hours END
WHERE ItemID = @item_id
GO





IF OBJECT_id('dbo.spPersonXTrainingUpdateOrInsert') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spPersonXTrainingUpdateOrInsert AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spPersonXTrainingUpdateOrInsert TO public'
END
GO
ALTER PROC dbo.spPersonXTrainingUpdateOrInsert
	@person_id int,
	@training_id int,
	@began_day_past_1900 int,
	@completed_day_past_1900 int,
	@item_id int OUT,

	@expires_day_past_1900 int = NULL,
	@comments varchar(50) = NULL,
	@hours numeric(9,4) = NULL
AS
DECLARE @authorized bit

SELECT TOP 1 @item_id = ItemID FROM PersonXTraining WHERE PersonID=@person_id AND TrainingID=@training_id ORDER BY [Completed Day past 1900] DESC
IF @@ROWCOUNT=1 EXEC dbo.spPersonXTrainingUpdate @training_id, @began_day_past_1900, @completed_day_past_1900, @item_id, @expires_day_past_1900, @comments, @hours
ELSE EXEC dbo.spPersonXTrainingInsert @person_id, @training_id, @began_day_past_1900, @completed_day_past_1900, @item_id out, @expires_day_past_1900, @comments, @hours
GO


IF OBJECT_id('dbo.spTaskEmailUpdateLastResult') IS NOT NULL DROP PROC dbo.spTaskEmailUpdateLastResult
GO
CREATE PROC dbo.spTaskEmailUpdateLastResult @result varchar(4000)
AS UPDATE Constant SET [Reminder E-mail Last Result] = @result
GO
IF OBJECT_id('dbo.spTaskEmailGetSent') IS NOT NULL DROP PROC dbo.spTaskEmailGetSent
GO
CREATE PROC dbo.spTaskEmailGetSent
	@recipient varchar(50),
	@text varchar(400),
	@sent smalldatetime  OUT
AS
SELECT @sent = Sent FROM dbo.TaskEmail WHERE Recipient = @recipient AND [Text] = @text
GO
GRANT EXEC ON dbo.spTaskEmailGetSent TO public
GO
IF OBJECT_id('dbo.spTaskEmailInsertOrUpdate') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spTaskEmailInsertOrUpdate AS'
GO
ALTER PROC dbo.spTaskEmailInsertOrUpdate
	@recipient varchar(50),
	@text varchar(400),
	@source varchar(50) = ''
AS
DECLARE @email_id int

SET NOCOUNT ON

SELECT @email_id = EmailID FROM TaskEmail WHERE Recipient = @recipient AND [Text] = @text
IF @@ROWCOUNT = 0 INSERT dbo.TaskEmail(Recipient, [Text], Source) VALUES(@recipient, @text, @source)
ELSE UPDATE TaskEmail SET Sent = GETDATE(), Source = @source WHERE EmailID = @email_id

DELETE dbo.TaskEmail WHERE Sent < DATEADD(d, -90, GETDATE())
GO
GRANT EXEC ON dbo.spTaskEmailInsertOrUpdate TO public
GO
IF OBJECT_id('dbo.spTimeSchemaSlantInsert') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spTimeSchemaSlantInsert AS'
GO
ALTER PROC dbo.spTimeSchemaSlantInsert
	@schema_id int,
	@range_start int,
	@range_stop int,
	@slant_to int,
	@in_out_mask int,
	@day_of_week_mask int = 0x7FFFFFFF,
	@slant_id int OUT
AS
INSERT dbo.TimeSchemaSlant(TimeSchemaID, [Range Start Seconds Past Midnight], [Range Stop Seconds Past Midnight], [Slant to Seconds Past Midnight], [Day of Week Mask], [In Out Mask])
VALUES (@schema_id, @range_start, @range_stop, @slant_to, @day_of_week_mask, @in_out_mask)

SELECT @slant_id = SCOPE_IDENTITY()
GO
IF OBJECT_id('dbo.spTimeSchemaSlantUpdate') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spTimeSchemaSlantUpdate AS'
GO
ALTER PROC dbo.spTimeSchemaSlantUpdate
	@schema_id int,
	@range_start int,
	@range_stop int,
	@slant_to int,
	@in_out_mask int,
	@day_of_week_mask int = NULL,
	@slant_id int
AS
UPDATE dbo.TimeSchemaSlant SET
TimeSchemaID = @schema_id,
[Range Start Seconds Past Midnight] = @range_start,
[Range Stop Seconds Past Midnight] = @range_stop,
[Slant to Seconds Past Midnight] = @slant_to,
[Day of Week Mask] = CASE WHEN @day_of_week_mask IS NULL THEN [Day of Week Mask] ELSE @day_of_week_mask END,
[In Out Mask] = @in_out_mask
WHERE SlantID = @slant_id
GO
IF OBJECT_id('dbo.spTimeSchemaSlantDelete') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spTimeSchemaSlantDelete AS'
GO
ALTER PROC dbo.spTimeSchemaSlantDelete @slant_id int AS DELETE dbo.TimeSchemaSlant WHERE SlantID = @slant_id
GO
IF OBJECT_id('dbo.spTimeSchemaSlantSelect') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spTimeSchemaSlantSelect AS'
GO
ALTER PROC dbo.spTimeSchemaSlantSelect
	@slant_id int
AS
SET NOCOUNT ON
SELECT * FROM dbo.TimeSchemaSlant WHERE SlantID=@slant_id
GO
GRANT EXEC ON dbo.spTimeSchemaSlantSelect TO public
GO
IF OBJECT_id('dbo.spTimeSchemaSlantList') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spTimeSchemaSlantList AS'
GO
ALTER PROC dbo.spTimeSchemaSlantList
	@schema_id int
AS
SET NOCOUNT ON
SELECT * FROM dbo.TimeSchemaSlant WHERE TimeSchemaID=@schema_id ORDER BY [Slant to Seconds Past Midnight]
GO
GRANT EXEC ON dbo.spTimeSchemaSlantList TO public
GO
IF OBJECT_id('dbo.spEmployeeTimeValidateLunch') IS NOT NULL DROP PROC dbo.spEmployeeTimeValidateLunch
GO
CREATE PROC dbo.spEmployeeTimeValidateLunch
	@employee_id int,
	@start_day int,
	@stop_day int,
	@ignore_under_seconds int,
	@min_lunch_seconds int,
	@max_lunch_seconds int,
	@flags int -- 1: exclude flsa exempt
AS
-- Ignore exempt employees
IF (@flags & 1) = 1 AND EXISTS(SELECT * FROM dbo.vwEmployeeLastCompensation E WHERE E.EmployeeID=@employee_id AND E.[FLSA Exempt] = 1) RETURN

-- Pending time, overtime, approved time, pending leave, approved leave
CREATE TABLE #BreaksPerEmployeeDay(
	D int NOT NULL PRIMARY KEY,
	[Time] int,
	[Min Break] int,
	[Max Break] int,
	CurrentBreak int,
	CurrentItemID int NULL,
	NextItemID int NULL
)

INSERT #BreaksPerEmployeeDay
SELECT DATEDIFF(d,0,T.[In]), -- D
SUM(T.[Seconds]), -- Time
2147483647, -- Min Break
-2147483648, -- Max Break
0, -- CurrentBreak
(SELECT TOP 1 ItemID FROM dbo.EmployeeTime T2 WHERE T2.EmployeeID=@employee_id AND DATEDIFF(d,0,T.[In])=DATEDIFF(d,0,T2.[In]) ORDER BY T2.[In], T2.Seconds DESC), -- CurrentTimeID
NULL -- NextTimeID
FROM dbo.EmployeeTime T WHERE EmployeeID=@employee_id AND DATEDIFF(d,0,[In]) BETWEEN @start_day AND @stop_day AND T.StatusID <> 2
GROUP BY DATEDIFF(d,0,[In])

CREATE INDEX Temp_IX_BreaksPerEmployeeDay_Day ON #BreaksPerEmployeeDay(D)

-- Deletes days where there's no pending time
DELETE #BreaksPerEmployeeDay WHERE D NOT IN
(
	SELECT T.[In Day past 1900] FROM dbo.vwEmployeeTime T WHERE EmployeeID=@employee_id AND T.StatusID=8
)

DECLARE @r int, @i int
SELECT @r=1, @i=0

WHILE @r > 0
BEGIN
	UPDATE #BreaksPerEmployeeDay SET NextItemID = (SELECT TOP 1 ItemID FROM dbo.EmployeeTime T2 WHERE #BreaksPerEmployeeDay.D=DATEDIFF(d,0,T2.[In]) AND T2.EmployeeID=@employee_id AND T2.[In] > DATEADD(s,T.[Seconds], T.[In]) AND T2.StatusID <> 2 ORDER BY T2.[In], T2.Seconds DESC)
	FROM #BreaksPerEmployeeDay INNER JOIN dbo.EmployeeTime T ON #BreaksPerEmployeeDay.CurrentItemID = T.ItemID
	SET @r = @@ROWCOUNT

	IF @r > 0
	BEGIN
		UPDATE #BreaksPerEmployeeDay SET CurrentBreak = DATEDIFF(s,T.[In],T2.[In]) - T.Seconds
		FROM #BreaksPerEmployeeDay
		INNER JOIN dbo.EmployeeTime T ON #BreaksPerEmployeeDay.CurrentItemID = T.ItemID
		INNER JOIN dbo.EmployeeTime T2 ON #BreaksPerEmployeeDay.NextItemID = T2.ItemID
		
		UPDATE #BreaksPerEmployeeDay SET CurrentItemID = NextItemID,
		[Min Break] = CASE WHEN CurrentBreak < [Min Break] THEN CurrentBreak ELSE [Min Break] END,
		[Max Break] = CASE WHEN CurrentBreak > [Max Break] THEN CurrentBreak ELSE [Max Break] END

	END
	SET @i = @i + 1

	IF @i > 100
	BEGIN
		RAISERROR('Livelock in spEmployeeTimeValidateLunch',16,1)
		RETURN
	END
END


DECLARE @bad_day int, @msg varchar(4000), @ignore_under_hrs varchar(4000), @min_minutes varchar(4000), @max_minutes varchar(4000), @min_break_minutes varchar(4000)
SELECT @msg = '', @ignore_under_hrs = CAST(@ignore_under_seconds / 3600.0 AS numeric(9,1)), @min_minutes = @min_lunch_seconds / 60, @max_minutes = @max_lunch_seconds / 60
SELECT TOP 1 @bad_day = D, @min_break_minutes = [Min Break] / 60 FROM #BreaksPerEmployeeDay WHERE [Min Break] < @min_lunch_seconds AND [Time] >= @ignore_under_seconds ORDER BY D

IF @@ROWCOUNT = 1
BEGIN
	SELECT @msg = 'Correct the time for ' + CAST(dbo.GetDateFromDaysPast1900(@bad_day) AS varchar(11)) + '. ' + @min_minutes + ' minute breaks must be claimed when time worked exceeds ' + @ignore_under_hrs + ' hours.'
	IF @min_break_minutes <> '0' SELECT @msg = @msg + ' (Current break is ' + @min_break_minutes + ' minutes.)'
END
ELSE
BEGIN
	SELECT TOP 1 @bad_day = D FROM #BreaksPerEmployeeDay WHERE [Max Break] > @max_lunch_seconds ORDER BY D
	IF @@ROWCOUNT = 1
	BEGIN
		SELECT @msg = 'Correct the time for ' + CAST(dbo.GetDateFromDaysPast1900(@bad_day) AS varchar(11)) + '. Breaks cannot exceed ' + @max_minutes + ' minutes when time worked exceeds ' + @ignore_under_hrs + ' hours.'
	END
END

IF @msg <> '' RAISERROR(@msg,16,1)
GO
GRANT EXEC ON dbo.spEmployeeTimeValidateLunch TO public
GO
IF OBJECT_ID('dbo.spEmployeeGetEmployeeIDForAccount') IS NOT NULL DROP PROC dbo.spEmployeeGetEmployeeIDForAccount
GO
CREATE PROC dbo.spEmployeeGetEmployeeIDForAccount @account sysname, @employee_id int OUT AS
DECLARE @sid varbinary(85), @authorized bit
EXEC dbo.spPermissionInsureForCurrentUserOnPerson @employee_id, 0x20, 1, @authorized out
SET @employee_id = NULL
IF @authorized=1
BEGIN
	SET @sid = SUSER_SID(@account)
	SELECT @employee_id = EmployeeID FROM dbo.Employee WHERE [SID] = @sid
END
GO
GRANT EXEC ON dbo.spEmployeeGetEmployeeIDForAccount TO public
GO
IF OBJECT_ID('dbo.spAdminExecuteSQLIgnoreErrors') IS NOT NULL DROP PROC dbo.spAdminExecuteSQLIgnoreErrors
GO
CREATE PROC dbo.spAdminExecuteSQLIgnoreErrors @sql nvarchar(4000) AS
IF CAST(SERVERPROPERTY('productversion') AS varchar(50)) NOT LIKE '[0-8].%'
BEGIN
	SET @sql = 'BEGIN TRY ' + @sql + ' END TRY BEGIN CATCH END CATCH'
	EXEC sp_executesql @sql
END
GO
IF OBJECT_ID('dbo.spReportFillColumnExamples') IS NOT NULL DROP PROC dbo.spReportFillColumnExamples
GO
-- Takes #REPORT_COLUMNS, a view, and it's primary key -- and fils #REPORT_COLUMNS.Example with random values from the view
CREATE PROC dbo.spReportFillColumnExamples @view sysname, @key_field sysname
AS
DECLARE @sql nvarchar(1000), @columns int, @column_index int, @id int, @column sysname, @xtype int, @scale int

SELECT @column_index = 0
SELECT @columns = COUNT(*) FROM #REPORT_COLUMNS WHERE Example IS NULL

-- Picks a different ID for each column
/*CREATE TABLE #IDs([ID] int NOT NULL PRIMARY KEY)
SELECT @sql = 'INSERT #IDs SELECT TOP ' + CAST(@columns AS sysname) + ' [' + @key_field + '] FROM ' + @view + ' ORDER BY NEWID()'
EXEC sp_executesql @sql

-- View returns no records
IF (SELECT COUNT(*) FROM #IDs) = 0 RETURN

DECLARE r_cursor CURSOR LOCAL FOR SELECT [ID] FROM #IDs
OPEN r_cursor */

DECLARE c_cursor CURSOR LOCAL FORWARD_ONLY STATIC FOR SELECT C.[name], C.xtype, C.scale FROM #REPORT_COLUMNS R
INNER JOIN syscolumns C ON c.[id]=OBJECT_ID(@view) AND C.colid = R.colid AND R.Example IS NULL
OPEN c_cursor

--FETCH r_cursor INTO @id
FETCH c_cursor INTO @column, @xtype, @scale

WHILE @@FETCH_STATUS = 0
BEGIN
	DECLARE @example varchar(50)

	/*IF @xtype = 104 SET @sql = 'SELECT @e=''Yes'''
	ELSE IF @xtype = 108 AND @scale > 4 SELECT @sql = 'SELECT @e=CAST(CAST([' + @column + '] AS numeric(38,2)) AS varchar(50)) FROM ' + @view + ' WHERE ' + @key_field + '=' + CAST(@id AS sysname)
	ELSE IF @xtype = 60 SELECT @sql = 'SELECT @e=CAST(CAST([' + @column + '] AS numeric(19,2)) AS varchar(50)) FROM ' + @view + ' WHERE ' + @key_field + '=' + CAST(@id AS sysname)
	ELSE IF @xtype = 61 SELECT @sql = 'SELECT @e=CAST([' + @column + '] AS varchar(11)) FROM ' + @view + ' WHERE ' + @key_field + '=' + CAST(@id AS sysname)
	ELSE SELECT @sql = 'SELECT @e=CAST([' + @column + '] AS varchar(50)) FROM ' + @view + ' WHERE ' + @key_field + '=' + CAST(@id AS sysname)

	EXEC sp_executesql @sql, N'@e varchar(50) OUT', @e = @example OUT

	IF @example IS NULL AND @xtype = 61 SET @example = CAST(GETDATE() AS varchar(11))
	*/

	IF @xtype=104 SET @example = 'Yes'
	ELSE IF @xtype = 108 OR @xtype = 60 SET @example = '999.99'
	ELSE IF @xtype = 61 SET @example = 'Apr 4 2000'
	ELSE SET @example = null

	UPDATE #REPORT_COLUMNS SET [Example]=@example WHERE [Name] = @column

	

/*
	FETCH r_cursor INTO @id

	-- For each column, tries to get an example from a different row. But if there are less rows than columns then we have to reuse rows.
	IF @@FETCH_STATUS <> 0
	BEGIN
		CLOSE r_cursor
		OPEN r_cursor
		FETCH r_cursor INTO @id
	END */

	FETCH c_cursor INTO @column, @xtype, @scale
END

CLOSE c_cursor
DEALLOCATE c_cursor

--CLOSE r_cursor
--DEALLOCATE r_cursor

UPDATE #REPORT_COLUMNS SET Example = '' WHERE [Example] IS NULL
GO
IF OBJECT_ID('dbo.spEmployeeLeaveList2Columns') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEmployeeLeaveList2Columns AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spEmployeeLeaveList2Columns TO public'
END
GO
ALTER PROC dbo.spEmployeeLeaveList2Columns
AS
SET NOCOUNT ON

CREATE TABLE #REPORT_COLUMNS(colid int PRIMARY KEY, [Name] sysname COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL, Caption sysname COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL, [Example] varchar(50) COLLATE SQL_Latin1_General_CP1_CI_AS NULL, [Group] varchar(50) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL, Flags int NOT NULL)

INSERT #REPORT_COLUMNS VALUES(-34, 'Available Days', 'Available Days', '60.00', 'Leave', 0)
INSERT #REPORT_COLUMNS VALUES(-33, 'Available Hours', 'Available Hours', '60.00', 'Leave', 0)
INSERT #REPORT_COLUMNS VALUES(-32, 'Note', 'LOA Note', '', 'Leave', 0)
INSERT #REPORT_COLUMNS VALUES(-31, 'Denial Reason', 'Denial Reason', 'Ineligible', 'Leave', 0)
INSERT #REPORT_COLUMNS VALUES(-30, 'Approval Type', 'Approval Type', 'Intermittent', 'Leave', 0)
INSERT #REPORT_COLUMNS VALUES(-29, 'End Date', 'End Date', 'Dec 5,2000', 'Leave', 0)
INSERT #REPORT_COLUMNS VALUES(-28, 'Approved Date', 'Approved Date', 'Jun 5,2000', 'Leave', 0)
INSERT #REPORT_COLUMNS VALUES(-27, 'Used Period Days', 'Used Period Days', '100.00', 'Leave', 0)
INSERT #REPORT_COLUMNS VALUES(-26, 'Used Period Hrs', 'Used Period Hrs', '100.00', 'Leave', 0)
INSERT #REPORT_COLUMNS VALUES(-25, 'Earned Days', 'Earned Days', '60.00', 'Leave', 0)
INSERT #REPORT_COLUMNS VALUES(-24, 'Earned Hours', 'Earned Hours', '60.00', 'Leave', 0)
INSERT #REPORT_COLUMNS VALUES(-23, 'Accumulated Days', 'Accumulated Days', '60.00', 'Leave', 0)
INSERT #REPORT_COLUMNS VALUES(-22, 'Accumulated Hours', 'Accumulated Hours', '60.00', 'Leave', 0)
INSERT #REPORT_COLUMNS VALUES(-21, 'Used Days', 'Used Days', '60.00', 'Leave', 0)
INSERT #REPORT_COLUMNS VALUES(-20, 'Requested', 'Requested', 'Feb 3,2000', 'Leave', 0)
INSERT #REPORT_COLUMNS VALUES(-19, 'Period', 'Period', 'Feb 3,2000 to Mar 4,2000', 'Leave', 0)
INSERT #REPORT_COLUMNS VALUES(-18, 'Types', 'Types', 'FMLA,PTO', 'Leave', 0)
INSERT #REPORT_COLUMNS VALUES(-17, 'Reason', 'Reason', 'Health condition', 'Leave', 0)
INSERT #REPORT_COLUMNS VALUES(-16, 'Used Hrs', 'Used Hrs', '100.00', 'Leave', 0)
INSERT #REPORT_COLUMNS VALUES(-15, 'Preapproved Employee', 'Preapproved Employee', 'Doe,John', 'Leave', 0)
INSERT #REPORT_COLUMNS VALUES(-14, 'Preaproved Date', 'Preaproved Date', 'Feb 3,2000', 'Leave', 0)
INSERT #REPORT_COLUMNS VALUES(-13, 'Status Text', 'Status', 'Approved by SF for Intermittent', 'Leave', 0)
INSERT #REPORT_COLUMNS VALUES(-12, 'Start', 'Start', 'Feb 3,2000', 'Leave', 0)
INSERT #REPORT_COLUMNS VALUES(-11, 'Stop', 'Stop', 'Mar 4,2000', 'Leave', 0)
INSERT #REPORT_COLUMNS VALUES(-10, 'Authorization Expires', 'Authorization Expires', 'Dec 4,2000', 'Leave', 0)
INSERT #REPORT_COLUMNS VALUES(-9, 'Expected Departure', 'Expected Departure', 'Apr 4,2000', 'Leave', 0)
INSERT #REPORT_COLUMNS VALUES(-8, 'Expected Return', 'Expected Return', 'Apr 4,2000', 'Leave', 0)
INSERT #REPORT_COLUMNS VALUES(-7, 'First Date Used', 'First Date Used', 'Jan 4,2000', 'Leave', 0)
INSERT #REPORT_COLUMNS VALUES(-6, 'Last Date Used', 'Last Date Used', 'Apr 5,2000', 'Leave', 0)
INSERT #REPORT_COLUMNS VALUES(-5, 'First Certified', 'First Certified', 'Apr 15,2000', 'Leave', 0)
INSERT #REPORT_COLUMNS VALUES(-4, 'Last Certified', 'Last Certified', 'Apr 19,2000', 'Leave', 0)
INSERT #REPORT_COLUMNS VALUES(-3, 'Certification Expires', 'Certification Expires', 'May 19,2000', 'Leave', 0)

INSERT #REPORT_COLUMNS
SELECT CColumns.colid, [Name] = CColumns.[name], Caption = dbo.GetCaptionForColumnName(CColumns.[name]),Example = dbo.GetExampleForColumnName(CColumns.[name], NULL),[Group] = dbo.GetGroupFromColumnName(CColumns.[name], 'Other'),Flags = 0
FROM syscolumns CColumns
WHERE [ID] = OBJECT_ID('vwEmployeeSecure') AND
[Name] NOT IN (SELECT [Name] FROM #REPORT_COLUMNS) AND dbo.IsColumnVisibleOnReport(CColumns.[name]) = 1

EXEC dbo.spReportFillColumnExamples '', ''

DECLARE @i int
SET @i=1
SELECT * FROM #REPORT_COLUMNS ORDER BY CASE WHEN [Group] IN ('Leave') THEN '_' WHEN [Group] = 'Name' THEN '__' ELSE '' END + [Group], Caption
GO
IF OBJECT_ID('dbo.spOccurrenceListReportColumns') IS NOT NULL DROP PROC dbo.spOccurrenceListReportColumns
GO
CREATE PROC dbo.spOccurrenceListReportColumns
AS
SET NOCOUNT ON

CREATE TABLE #REPORT_COLUMNS(colid int PRIMARY KEY, [Name] sysname COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL, Caption sysname COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL, [Example] varchar(50) COLLATE SQL_Latin1_General_CP1_CI_AS NULL, [Group] varchar(50) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL, Flags int NOT NULL)

INSERT #REPORT_COLUMNS
SELECT 
CColumns.colid,
[Name] = CColumns.[name], 
Caption = dbo.GetCaptionForColumnName(CColumns.[name]),
Example = dbo.GetExampleForColumnName(CColumns.[name], NULL),
[Group] = dbo.GetGroupFromColumnName(CColumns.[name], 'Other'),
Flags = 0
FROM syscolumns CColumns
WHERE [ID]=OBJECT_ID('vwEmployeeSecure') AND dbo.IsColumnVisibleOnReport(CColumns.[name]) = 1

EXEC dbo.spReportFillColumnExamples 'vwEmployeeSecure', 'EmployeeID'
			
INSERT #REPORT_COLUMNS(colid,[Name],Caption,Example,[Group],Flags) VALUES(-1, 'Type', 'Occurrence Type', 'Tardiness', 'Occurrences', 0)
INSERT #REPORT_COLUMNS(colid,[Name],Caption,Example,[Group],Flags) VALUES(-2, 'Date', 'Date', 'Feb 3, 2000', 'Occurrences', 0)
INSERT #REPORT_COLUMNS(colid,[Name],Caption,Example,[Group],Flags) VALUES(-3, 'Weight', 'Weight', '2.5', 'Occurrences', 0)
INSERT #REPORT_COLUMNS(colid,[Name],Caption,Example,[Group],Flags) VALUES(-4, 'Balance', 'Initial Balance', '5.0', 'Occurrences', 0)
INSERT #REPORT_COLUMNS(colid,[Name],Caption,Example,[Group],Flags) VALUES(-5, 'Balance3', 'Current Balance', '5.0', 'Occurrences', 0)
INSERT #REPORT_COLUMNS(colid,[Name],Caption,Example,[Group],Flags) VALUES(-6, 'Expires', 'Expires', 'Feb 3, 2000', 'Occurrences', 0)
INSERT #REPORT_COLUMNS(colid,[Name],Caption,Example,[Group],Flags) VALUES(-7, 'Balance2', 'Balance after Expiry', '5.0', 'Occurrences', 0)
INSERT #REPORT_COLUMNS(colid,[Name],Caption,Example,[Group],Flags) VALUES(-8, 'Note', 'Note', '', 'Occurrences', 0)

SELECT * FROM #REPORT_COLUMNS ORDER BY CASE WHEN [Group] = 'Name' THEN '_' ELSE '' END + [Group], Caption
GO
GRANT EXEC ON dbo.spOccurrenceListReportColumns TO public
GO
IF OBJECT_ID('dbo.spEmployeeTimeExceptionsListReportColumns') IS NOT NULL DROP PROC dbo.spEmployeeTimeExceptionsListReportColumns
GO
CREATE PROC dbo.spEmployeeTimeExceptionsListReportColumns
AS
SET NOCOUNT ON

CREATE TABLE #REPORT_COLUMNS(colid int PRIMARY KEY, [Name] sysname COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL, Caption sysname COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL, [Example] varchar(50) COLLATE SQL_Latin1_General_CP1_CI_AS NULL, [Group] varchar(50) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL, Flags int NOT NULL)

INSERT #REPORT_COLUMNS
SELECT 
CColumns.colid,
[Name] = CColumns.[name], 
Caption = dbo.GetCaptionForColumnName(CColumns.[name]),
Example = dbo.GetExampleForColumnName(CColumns.[name], NULL),
[Group] = dbo.GetGroupFromColumnName(CColumns.[name], 'Other'),
Flags = 0
FROM syscolumns CColumns
WHERE [ID]=OBJECT_ID('vwEmployeeSecure') AND dbo.IsColumnVisibleOnReport(CColumns.[name]) = 1

EXEC dbo.spReportFillColumnExamples 'vwEmployeeSecure', 'EmployeeID'

INSERT #REPORT_COLUMNS(colid,[Name],Caption,Example,[Group],Flags) VALUES(-1, 'Exception Mask', 'Exception Mask', '1005', 'Time', 0)
INSERT #REPORT_COLUMNS(colid,[Name],Caption,Example,[Group],Flags) VALUES(-2, 'Exceptions', 'Exceptions', 'Out preceeds in.', 'Time', 0)
INSERT #REPORT_COLUMNS(colid,[Name],Caption,Example,[Group],Flags) VALUES(-3, 'Actual In', 'Actual In', 'Feb 3, 2000 12:30', 'Time', 0)
INSERT #REPORT_COLUMNS(colid,[Name],Caption,Example,[Group],Flags) VALUES(-4, 'Actual Out', 'Actual Out', 'Feb 3, 2000 15:30', 'Time', 0)
INSERT #REPORT_COLUMNS(colid,[Name],Caption,Example,[Group],Flags) VALUES(-5, 'Rounded In', 'Rounded In', 'Feb 3, 2000 12:30', 'Time', 0)
INSERT #REPORT_COLUMNS(colid,[Name],Caption,Example,[Group],Flags) VALUES(-6, 'Rounded Out', 'Rounded Out', 'Feb 3, 2000 15:30', 'Time', 0)
INSERT #REPORT_COLUMNS(colid,[Name],Caption,Example,[Group],Flags) VALUES(-7, 'Date', 'Date', 'Feb 3, 2000', 'Time', 0)
INSERT #REPORT_COLUMNS(colid,[Name],Caption,Example,[Group],Flags) VALUES(-8, 'Project', 'Project', '', 'Time', 0)
INSERT #REPORT_COLUMNS(colid,[Name],Caption,Example,[Group],Flags) VALUES(-9, 'Pay Rate', 'Pay Rate', '', 'Time', 0)
INSERT #REPORT_COLUMNS(colid,[Name],Caption,Example,[Group],Flags) VALUES(-10, 'Type', 'Type', '', 'Time', 0)
INSERT #REPORT_COLUMNS(colid,[Name],Caption,Example,[Group],Flags) VALUES(-11, 'PPE', 'PPE', 'Feb 3, 2000', 'Time', 0)
INSERT #REPORT_COLUMNS(colid,[Name],Caption,Example,[Group],Flags) VALUES(-12, 'Hours', 'Hours', '7.5', 'Time', 0)

SELECT * FROM #REPORT_COLUMNS ORDER BY CASE WHEN [Group] = 'Name' THEN '_' ELSE '' END + [Group], Caption
GO
GRANT EXEC ON dbo.spEmployeeTimeExceptionsListReportColumns TO public
GO
IF OBJECT_id('dbo.spTimeTypeList') IS NOT NULL DROP PROC dbo.spTimeTypeList
GO
CREATE PROC dbo.spTimeTypeList
AS
SET NOCOUNT ON
SELECT * FROM dbo.vwTimeType ORDER BY [Order]
GO
GRANT EXEC ON dbo.spTimeTypeList TO public
GO
IF OBJECT_ID('dbo.spPermissionInsureForCurrentUserOnPerson') IS NOT NULL DROP PROC dbo.spPermissionInsureForCurrentUserOnPerson
GO
-- Raises an error if the current user does not have the required permission
-- on a given attribute for a given person (employee\applicant...)
CREATE PROC dbo.spPermissionInsureForCurrentUserOnPerson
	@person_id int,
	@attribute_id bigint,
	@permission_required int,
	@authorized bit out,
	@more_info nvarchar(MAX) = ''
AS
SET NOCOUNT ON

IF @person_id IS NULL
BEGIN
	SET @authorized = 1
	RETURN 0
END

EXEC dbo.spPermissionGetOnPersonForCurrentUser2 @person_id, @attribute_id, @permission_required, @authorized out
IF @authorized = 0
BEGIN
	EXEC dbo.spErrorRaiseNoPermission @attribute_id, @permission_required, @person_id, @more_info
	RETURN 50016
END
ELSE RETURN 0
GO
GRANT EXEC ON dbo.spPermissionInsureForCurrentUserOnPerson TO public
GO
IF OBJECT_ID('dbo.spTimeTypeGetTypeID') IS NOT NULL DROP PROC dbo.spTimeTypeGetTypeID
GO
CREATE PROC dbo.spTimeTypeGetTypeID
	@type varchar(50),
	@type_id int out
AS
SELECT @type = RTRIM(LTRIM(@type)), @type_id=NULL

IF ISNUMERIC(@type)=1 SELECT @type_id=TypeID FROM TimeType WHERE TypeID=CAST(@type AS int)
IF @type_id IS NULL SELECT @type_id=TypeID FROM TimeType WHERE Abbreviation=@type
IF @type_id IS NULL SELECT @type_id=TypeID FROM TimeType WHERE Type=@type
GO
GRANT EXEC ON dbo.spTimeTypeGetTypeID TO public
GO
ALTER PROC dbo.spEmployeeTardySelect @tardy_id int
AS
SET NOCOUNT ON
DECLARE @employee_id int, @authorized bit
SELECT @employee_id = EmployeeID FROM Occurrence WHERE OccurrenceID = @tardy_id
EXEC dbo.spPermissionInsureForCurrentUserOnPerson @employee_id, 10012, 1, @authorized out
IF @authorized=1 SELECT TardyID = OccurrenceID,
EmployeeID, [Day past 1900],
Excused = CAST(CASE WHEN TypeID=1 THEN 1 ELSE 2 END AS bit),
Note, [Date], Employee, [Employee Full Name]
FROM dbo.vwOccurrence WHERE TypeID IN (1,2) AND OccurrenceID=@tardy_id
GO
IF OBJECT_id('dbo.spOccurrenceSelect') IS NOT NULL DROP PROC dbo.spOccurrenceSelect
GO
CREATE PROC dbo.spOccurrenceSelect @occurrence_id int AS
SET NOCOUNT ON
DECLARE @employee_id int, @authorized bit
SELECT @employee_id = EmployeeID FROM Occurrence WHERE OccurrenceID = @occurrence_id
EXEC dbo.spPermissionInsureForCurrentUserOnPerson @employee_id, 10012, 1, @authorized out
IF @authorized=1 SELECT * FROM dbo.vwOccurrence WHERE OccurrenceID=@occurrence_id
GO
GRANT EXEC ON dbo.spOccurrenceSelect TO public
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spEmployeeLeaveGetAccumulated', 1
GO
ALTER PROC dbo.spEmployeeLeaveGetAccumulated
	@employee_id int,
	@type_id int,
	@day int,
	@seconds int out
AS
DECLARE @d int, @authorized bit

EXEC dbo.spPermissionInsureForCurrentUserOnPerson @employee_id, 10003, 1, @authorized out
IF @authorized = 1
BEGIN
	SELECT @d = MAX(U.[Day past 1900]) FROM dbo.EmployeeLeaveUnused U WHERE U.[Day past 1900] <= @day AND U.EmployeeID =  @employee_id AND U.TypeID = @type_id
	SELECT @seconds = 0
	SELECT @seconds = U.Unused FROM EmployeeLeaveUnused U WHERE U.EmployeeID = @employee_id AND U.TypeID = @type_id AND U.[Day past 1900] = @d
END
ELSE SET @seconds = 0
GO
ALTER PROC dbo.spEmployeeLeaveGetAvailable
	@employee_id int,
	@type_id int,
	@day int,
	@seconds int out
AS
DECLARE @d int, @accumulated int, @max int, @authorized bit

EXEC dbo.spPermissionInsureForCurrentUserOnPerson @employee_id, 10003, 1, @authorized out
IF @authorized = 1
BEGIN
	SELECT @d = MAX(U.[Day past 1900]) FROM dbo.EmployeeLeaveUnused U WHERE U.[Day past 1900] <= @day AND U.EmployeeID =  @employee_id AND U.TypeID = @type_id
	SELECT @max = ISNULL(MIN(U.[Day past 1900]), 0x7FFFFFFF) FROM dbo.EmployeeLeaveUnused U WHERE U.[Day past 1900] > @day AND U.EmployeeID = @employee_id AND U.TypeID = @type_id AND U.[Limit Adjustment] = 1
	SELECT @accumulated = 0
	SELECT @accumulated = U.Unused FROM EmployeeLeaveUnused U WhERE U.EmployeeID = @employee_id AND U.TypeID = @type_id AND U.[Day past 1900] = @d
	SELECT @seconds = MIN(U.Unused + U.[Limit Seconds]) FROM dbo.EmployeeLeaveUnused U WHERE U.[Day past 1900] BETWEEN @day AND @max AND U.EmployeeID = @employee_id AND U.TypeID = @type_id
	SELECT @seconds = @accumulated WHERE @seconds IS NULL OR @seconds > @accumulated
END
ELSE SET @seconds = 0
GO
IF OBJECT_id('dbo.spEmployeeTimeZKQProcess') IS NOT NULL DROP PROC dbo.spEmployeeTimeZKQProcess
GO
CREATE PROC dbo.spEmployeeTimeZKQProcess
AS
-- UPDATE dbo.Constant SET EmployeeTimeZKQImportEnable=0 WHERE EmployeeTimeZKQImportEnable=1
EXEC dbo.spEmployeeTimeZKQProcess2
-- UPDATE dbo.Constant SET EmployeeTimeZKQImportEnable=1 WHERE EmployeeTimeZKQImportEnable=0
GO
GRANT EXEC ON dbo.spEmployeeTimeZKQProcess TO public
GO
IF OBJECT_id('dbo.spPersonXSelectLanguages') IS NOT NULL DROP PROC dbo.spPersonXSelectLanguages
GO
CREATE PROC dbo.spPersonXSelectLanguages
	@person_id int
AS
DECLARE @authorized bit

SET NOCOUNT ON

EXEC dbo.spPermissionInsureForCurrentUserOnPerson @person_id, 10007, 1, @authorized out
IF @authorized = 1 SELECT * FROM dbo.vwPersonXLanguages WHERE PersonID = @person_id
GO
GRANT EXEC ON dbo.spPersonXSelectLanguages TO public
GO
IF OBJECT_id('dbo.spPersonXUpdateLanguages') IS NOT NULL DROP PROC dbo.spPersonXUpdateLanguages
GO
CREATE PROC dbo.spPersonXUpdateLanguages @person_id int, @primary_language_id int, @secondary_language_mask int
AS EXEC dbo.spErrorRaise 50046
GO
GRANT EXEC ON dbo.spPersonXUpdateLanguages TO public
GO
IF OBJECT_id('dbo.spPersonXListWhoSpeaks') IS NOT NULL DROP PROC dbo.spPersonXListWhoSpeaks
GO
CREATE PROC dbo.spPersonXListWhoSpeaks
	@batch_id int,
	@language_id int,
	@include_secondary bit,
	@authorized bit OUT
AS
SET NOCOUNT ON

EXEC dbo.spPermissionGetOnPeopleForCurrentUser2 @batch_id, 10007
DELETE TempX WHERE BatchID = @batch_id AND (X & 1) = 0
SELECT @authorized = CASE WHEN @@ROWCOUNT = 0 THEN 1 ELSE 0 END

SELECT
[List As] = dbo.fnGetListAs(Person.[First Name], Person.[Middle Name], Person.[Last Name], Person.Suffix),
P.PersonID,
[Primary Language] = P.PrimaryLanguages2,
[Secondary Languages] = P.SecondaryLanguages2,
[Secondary Language Mask] = 0, -- legacy
[Language Mask] = 0, -- legacy
PrimaryLanguageID = 0 -- legacy
FROM dbo.PersonX P
INNER JOIN TempX X ON X.BatchID = @batch_id AND P.PersonID = X.[ID]
INNER JOIN dbo.Person ON P.PersonID = Person.PersonID AND EXISTS(
	SELECT * FROM dbo.PersonXLanguage PL
	INNER JOIN dbo.LanguageProficiency P ON PL.PersonID=Person.PersonID AND PL.ProficiencyID=P.ProficiencyID AND PL.LanguageID=@language_id AND
	(@include_secondary = 1 OR (P.[Flags] & 1) = 1)
)
ORDER BY Person.[Last Name], Person.[First Name], Person.[Middle Name]

DELETE dbo.TempX WHERE BatchID = @batch_id OR DATEDIFF(minute, [Created], GETDATE()) > 30
GO
GRANT EXEC ON dbo.spPersonXListWhoSpeaks TO public
GO
IF OBJECT_id('dbo.spPersonXListBilingual') IS NOT NULL DROP PROC dbo.spPersonXListBilingual
GO
CREATE PROC dbo.spPersonXListBilingual
	@batch_id int,
	@authorized bit OUT
AS
SET NOCOUNT ON

EXEC dbo.spPermissionGetOnPeopleForCurrentUser2 @batch_id, 10007
DELETE dbo.TempX WHERE BatchID = @batch_id AND (X & 1) = 0
SELECT @authorized = CASE WHEN @@ROWCOUNT = 0 THEN 1 ELSE 0 END

SELECT
[List As] = dbo.fnGetListAs(Person.[First Name], Person.[Middle Name], Person.[Last Name], Person.Suffix),
P.PersonID,
[Primary Language] = P.PrimaryLanguages2,
[Secondary Languages] = P.SecondaryLanguages2,
[Secondary Language Mask] = 0, -- legacy
[Language Mask] = 0, -- legacy
PrimaryLanguageID = 0 -- legacy
FROM dbo.PersonX P
INNER JOIN dbo.Person ON P.PersonID = Person.PersonID
INNER JOIN TempX X ON X.BatchID = @batch_id AND P.PersonID = X.[ID] AND ISNULL((
	SELECT COUNT(*) FROM dbo.PersonXLanguage PL WHERE PL.PersonID = P.PersonID
),0) >= 2
ORDER BY Person.[Last Name], Person.[First Name], Person.[Middle Name]

DELETE dbo.TempX WHERE BatchID = @batch_id OR DATEDIFF(minute, [Created], GETDATE()) > 30
GO
GRANT EXEC ON dbo.spPersonXListBilingual TO public
GO
IF OBJECT_id('dbo.spAuditTrailInsert') IS NOT NULL DROP PROC dbo.spAuditTrailInsert
GO
CREATE PROC dbo.spAuditTrailInsert
	@regarding_person_id int,
	@id int,
	@object_id int,
	@event_mask int,
	@event varchar(4000),
	@table_id int
AS
DELETE AuditTrail WHERE Created < DATEADD(d,0-(SELECT [Audit Purge Days] FROM dbo.Constant),GETDATE())

INSERT AuditTrail(SID,[User],RegardingPersonID,[ID],ObjectID,[Event Mask],[Event],TableID)
VALUES (SUSER_SID(),SUSER_SNAME(),@regarding_person_id,@id,@object_id,@event_mask,@event,@table_id)
GO
IF OBJECT_ID('dbo.spLanguageProficiencyList') IS NOT NULL DROP PROC dbo.spLanguageProficiencyList
GO
CREATE PROC dbo.spLanguageProficiencyList
	@min_level int = -2147483648,
	@max_level int = 2147483647
AS
SET NOCOUNT ON
SELECT P.Proficiency, P.ProficiencyID, P.Level, P.Flags, P.AreLanguagesPrimary FROM dbo.vwLanguageProficiency P WHERE P.Level BETWEEN @min_level AND @max_level
GO
GRANT EXEC ON dbo.spLanguageProficiencyList TO public
GO
IF OBJECT_ID('dbo.spPersonXLanguage2Insert') IS NOT NULL DROP PROC dbo.spPersonXLanguage2Insert
GO
CREATE PROC dbo.spPersonXLanguage2Insert @person_id int, @language_id int, @proficiency_id int, @comment varchar(50), @item_id int out
AS 
DECLARE @authorized bit
EXEC dbo.spPermissionInsureForCurrentUserOnPerson @person_id, 10007, 4, @authorized out
IF @authorized = 1 
INSERT dbo.PersonXLanguage(PersonID, LanguageID, ProficiencyID, Comment)
SELECT @person_id, @language_id, @proficiency_id, @comment
SELECT @item_id = SCOPE_IDENTITY()
GO
IF OBJECT_ID('dbo.spPersonXLanguage2Update') IS NOT NULL DROP PROC dbo.spPersonXLanguage2Update
GO
CREATE PROC dbo.spPersonXLanguage2Update @language_id int, @proficiency_id int, @comment varchar(50), @item_id int
AS
DECLARE @authorized bit, @person_id int
SELECT @person_id = PersonID FROM PersonXLanguage WHERE ItemID=@item_id
EXEC dbo.spPermissionInsureForCurrentUserOnPerson @person_id, 10007, 2, @authorized out
IF @authorized = 1 UPDATE dbo.PersonXLanguage SET LanguageID=@language_id, ProficiencyID=@proficiency_id, Comment=@comment WHERE ItemID = @item_id
GO
IF OBJECT_ID('dbo.spPersonXLanguage2Delete') IS NOT NULL DROP PROC dbo.spPersonXLanguage2Delete
GO
CREATE PROC dbo.spPersonXLanguage2Delete @item_id int
AS
DECLARE @authorized bit, @person_id int
SELECT @person_id = PersonID FROM PersonXLanguage WHERE ItemID=@item_id
EXEC dbo.spPermissionInsureForCurrentUserOnPerson @person_id, 10007, 8, @authorized out
IF @authorized = 1 DELETE dbo.PersonXLanguage WHERE ItemID=@item_id
GO
IF OBJECT_ID('dbo.spPersonXLanguage2List') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spPersonXLanguage2List AS SELECT A=0'
GO
ALTER PROC dbo.spPersonXLanguage2List @batch_id int = NULL, @person_id int = NULL, @min_proficiency_id int = NULL, @max_proficiency_id int = NULL
AS SET NOCOUNT ON
DECLARE @min_level int, @max_level int
SELECT @min_level = ISNULL((SELECT [Level] FROM LanguageProficiency WHERE ProficiencyID = @min_proficiency_id), -2147483648)
SELECT @max_level = ISNULL((SELECT [Level] FROM LanguageProficiency WHERE ProficiencyID = @max_proficiency_id), 2147483647)

IF @batch_id IS NULL SET @batch_id = RAND() * 2147483647
IF @person_id IS NOT NULL AND NOT EXISTS(SELECT * FROM dbo.TempX WHERE BatchID=@batch_id AND [ID]=@person_id)
INSERT dbo.TempX(BatchID, [ID]) VALUES(@batch_id, @person_id)

EXEC dbo.spPermissionGetOnPeopleForCurrentUser2 @batch_id, 10007

SELECT L.* FROM dbo.vwPersonXLanguage2 L
INNER JOIN dbo.TempX X ON X.BatchID = @batch_id AND X.[ID] = L.PersonID AND (X.X & 1) = 1 AND
(L.Level BETWEEN @min_level AND @max_level)

DELETE dbo.TempX WHERE BatchID=@batch_id OR DATEDIFF(minute, Created, GETDATE()) > 30
GO
IF OBJECT_ID('dbo.spPersonXLanguage2Select') IS NOT NULL DROP PROC dbo.spPersonXLanguage2Select
GO
CREATE PROC dbo.spPersonXLanguage2Select @item_id int
AS SET NOCOUNT ON
SELECT L.* FROM dbo.vwPersonXLanguage2 L WHERE L.ItemID = @item_id
GO
GRANT EXEC ON dbo.spPersonXLanguage2Update TO public
GRANT EXEC ON dbo.spPersonXLanguage2Insert TO public
GRANT EXEC ON dbo.spPersonXLanguage2Delete TO public
GRANT EXEC ON dbo.spPersonXLanguage2List TO public
GRANT EXEC ON dbo.spPersonXLanguage2Select TO public
GO
IF OBJECT_id('dbo.spEmployeeLeaveUsedItemDeleteAll') IS NOT NULL DROP PROC dbo.spEmployeeLeaveUsedItemDeleteAll
GO
CREATE PROC dbo.spEmployeeLeaveUsedItemDeleteAll
	@leave_id int
AS
DECLARE @employee_id int
DECLARE @authorized bit, @audit_unauthorized_attempt bit, @audit_operation bit
DECLARE @hours numeric(9,2)

SELECT @hours=U.Seconds /3600.0, @employee_id = U.EmployeeID FROM EmployeeLeaveUsed U WHERE U.LeaveID=@leave_id
EXEC dbo.spPermissionInsureForCurrentUserOnPerson @employee_id, 10001, 2, @authorized out
EXEC dbo.spAuditGetOperation 10001, 8, @audit_operation OUT, @audit_unauthorized_attempt OUT

DECLARE @audit_message varchar(4000)
IF @authorized = 1
BEGIN
	DELETE EmployeeLeaveUsedItem WHERE LeaveID=@leave_id
	IF @audit_operation=1
	BEGIN
		SELECT @audit_message = 'Deleted all leave items (Hrs=' + CAST(@hours AS varchar(50)) + ')'
		EXEC dbo.spAuditTrailInsert @employee_id, @leave_id, 10001, 8, @audit_message, 10002
	END
END
ELSE IF @audit_unauthorized_attempt=1
BEGIN
	SELECT @audit_message = 'Unauthorized attempt to delete all items in LOA'
	EXEC dbo.spAuditTrailInsert @employee_id, @leave_id, 10001, 24, @audit_message, 10002
END
GO
GRANT EXEC ON dbo.spEmployeeLeaveUsedItemDeleteAll TO public
GO
IF OBJECT_id('dbo.spEmployeeProjectSelect') IS NOT NULL DROP PROC dbo.spEmployeeProjectSelect
GO
CREATE PROC dbo.spEmployeeProjectSelect
	@employee_id int,
	@project_id int,
	@day int
AS
SET NOCOUNT ON
DECLARE @authorized bit
EXEC dbo.spPermissionInsureForCurrentUserOnPerson @employee_id, 262144, 1, @authorized out

IF @authorized = 1 SELECT TOP 1 * FROM dbo.vwEmployeeProject WHERE EmployeeID = @employee_id AND ProjectID = @project_id AND dbo.DoesRayContain([Start Day past 1900], [Stop Day past 1900], @day) = 1 AND IsDefined=1
GO
GRANT EXEC ON dbo.spEmployeeProjectSelect TO public
GO
EXEC spAdminCreateSPifNonexistent 'spExportBuildStoredProc', 0
GO
-- Builds a stored procedure for use by spExportUpdateSQL and spExportInsert
-- Resulting stored procedure contains ids for all the selected people in #SelectedPeople
ALTER PROC dbo.spExportBuildStoredProc
	@sql nvarchar(MAX),
	@export_id int,
	@operation nvarchar(MAX)	-- ALTER or CREATE
AS
DECLARE @sql2 nvarchar(MAX)

SELECT @sql2 = @operation + ' PROCEDURE [dbo].[spExportX' + CAST(@export_id AS nvarchar(4000)) +']
	@batch_id int, @x_start_day_0512 int = -2147483648, @x_stop_day_0512 int = 2147483647
AS
SET NOCOUNT ON
DECLARE @x_start_0512 datetime, @x_stop_0512 datetime
SELECT @x_start_0512 = dbo.GetDateFromDaysPast1900(@x_start_day_0512), @x_stop_0512 = dbo.GetDateFromDaysPast1900(@x_stop_day_0512)
SELECT PersonID = [ID] INTO #SelectedPeople FROM TempX WHERE BatchID = @batch_id
-- Start --
' + @sql +'
-- ##Stop## --
DELETE TempX WHERE BatchID = @batch_id OR DATEDIFF(hh, Created, GETDATE()) > 1'

EXEC sp_executesql @sql2
RETURN @@ERROR
GO
EXEC spAdminCreateSPifNonexistent 'spExportInsert', 0
GO
ALTER PROC dbo.spExportInsert
	@interface varchar(50),
	@seperator char(1),
	@print_column_headers bit,
	@surround_each_field_with_quotes bit,
	@show_filter bit,
	@sql varchar(3500) = '',
	@export_id int out,
	@sql2 nvarchar(MAX) = ''
AS
DECLARE @error int

BEGIN TRAN

INSERT Export(Interface, Seperator, [Print Column Headers], [Surround Each Field with Quotes], [Show Filter])
VALUES (@interface, @seperator, @print_column_headers, @surround_each_field_with_quotes, @show_filter)
SELECT @export_id = @@IDENTITY

IF @sql2='' SET @sql2=@sql
EXEC @error=spExportBuildStoredProc @sql2, @export_id, 'CREATE'

IF @error = 0 COMMIT TRAN
ELSE ROLLBACK TRAN
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spExportUpdateSQL', 0
GO
ALTER PROCEDURE dbo.spExportUpdateSQL
	@sql varchar(3500) = '',
	@export_id int,
	@sql2 nvarchar(MAX) = ''
AS
IF @sql2 = '' SET @sql2 = @sql
EXEC spExportBuildStoredProc @sql2, @export_id, 'ALTER'
GO
IF OBJECT_ID('dbo.spPermissionListUsersWithoutDBAccess') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spPermissionListUsersWithoutDBAccess AS SELECT A=0'
GO
ALTER PROC dbo.spPermissionListUsersWithoutDBAccess
AS
SELECT L.SID, 
[Master Name] = CASE WHEN U.[name] = 'sys' AND U.uid = 4 THEN 'sa' ELSE ISNULL(L.[name],'') END,
IsNTGroup = CAST(L.IsNTGroup AS bit), 
IsNTUser = CAST(L.IsNTUser AS bit), 
IsSQLUser = CAST(CASE WHEN (L.IsNTGroup = 0) AND (L.IsNTUser = 0) THEN 1 ELSE 0 END  AS bit),
IsSA = CAST(CASE WHEN L.SID = 0x01 OR (U.[name] = 'sys' AND U.uid = 4) THEN 1 ELSE 0 END AS bit)
FROM master.dbo.syslogins L
LEFT JOIN sysusers U ON U.sid = L.sid 
WHERE U.sid IS NULL AND L.[name] <> 'BUILTIN\Administrators'
UNION
SELECT null, 'guest', CAST(0 AS bit), CAST(0 AS bit), CAST(1 AS bit), CAST(0 AS bit) WHERE NOT EXISTS (SELECT * FROM sysusers U WHERE [name] = 'guest' AND hasdbaccess = 1)
ORDER BY IsSQLUser, IsNTUser, IsNTGroup, CASE WHEN U.[name] = 'sys' AND U.uid = 4 THEN 'sa' ELSE ISNULL(L.[name],'') END
GO
GRANT EXEC ON dbo.spPermissionListUsersWithoutDBAccess TO public
GO
IF OBJECT_ID('dbo.spPermissionListUsersWithDBAccess') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spPermissionListUsersWithDBAccess AS SELECT A=0'
GO
ALTER PROC dbo.spPermissionListUsersWithDBAccess
	@exclude_system_groups bit = 0
AS
DECLARE @batch_id int

SET NOCOUNT ON

SELECT @batch_id= RAND() * 2147483647
EXEC dbo.spPermissionListUsersWithDBAccessIntoTempUser @batch_id, @exclude_system_groups

-- Selects users and describes permissions
SELECT T.*,
[Permissions] = CASE WHEN T.UID = 16384 THEN 'Special role with full access to everything' ELSE ISNULL(U.[Permissions], '') END
FROM TempUser T
LEFT JOIN UserPermissionComment U ON T.UID = U.UID
WHERE BatchID = @batch_id
ORDER BY IsSQLUser, IsNTUser, IsNTGroup, [name]

DELETE TempUser WHERE BatchID = @batch_id OR DATEDIFF(hh, Created, GETDATE()) > 1
GO
GRANT EXEC ON dbo.spPermissionListUsersWithDBAccess TO public
GO
IF OBJECT_ID('dbo.spPermissionInsureForCurrentUserOnDetail') IS NOT NULL DROP PROC dbo.spPermissionInsureForCurrentUserOnDetail
GO
CREATE PROC dbo.spPermissionInsureForCurrentUserOnDetail @object_id int, @function int, @creator varbinary(85), @created datetime, @authorized bit OUT
AS
DECLARE @permission_mask int
EXEC dbo.spPermissionGetOnObjectForCurrentUser 44, @permission_mask out

IF (@permission_mask & 2) = 2 SET @authorized=1 -- If permission to update master then can do anything to detail
ELSE IF @function=4 
BEGIN
	IF (@permission_mask & 6) = 4 -- If permission to insert master then can do anything to a recently created master
	BEGIN
		IF @creator=SUSER_SID() AND DATEDIFF(minute, @created, GETDATE()) < 5 SET @authorized=1
		ELSE SET @authorized=0
	END
	ELSE SET @authorized=1
END
ELSE IF @function=8 AND (@permission_mask & 8)=8 SET @authorized=0 -- Permission to delete master does not let you delete detail. Must delete master directly and let cascade delete all detail.
ELSE SET @authorized=0

IF @authorized=0 EXEC dbo.spErrorRaiseNoPermission2 @object_id, @function
GO
IF OBJECT_id('dbo.spTimeSchemaBreakInsert') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spTimeSchemaBreakInsert AS'
IF OBJECT_id('dbo.spTimeSchemaBreakUpdate') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spTimeSchemaBreakUpdate AS'
IF OBJECT_id('dbo.spTimeSchemaBreakDelete') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spTimeSchemaBreakDelete AS'


IF OBJECT_ID('dbo.spTimeSchemaBreakSelect') IS NOT NULL DROP PROC dbo.spTimeSchemaBreakSelect
IF OBJECT_ID('dbo.spTimeSchemaBreakList') IS NOT NULL DROP PROC dbo.spTimeSchemaBreakList
GO
ALTER PROC dbo.spTimeSchemaBreakInsert @schema_id int, @start int, @seconds int, @break_start int, @break_seconds int, @item_id int OUT
AS
DECLARE @creator varbinary(85), @created datetime, @authorized bit
SELECT @creator=Creator, @created=Created FROM dbo.TimeSchema WHERE TimeSchemaID=@schema_id
EXEC dbo.spPermissionInsureForCurrentUserOnDetail 44, 4, @creator, @created, @authorized OUT

IF @authorized=1 INSERT dbo.TimeSchemaBreak(TimeSchemaID, Start, Seconds, [Break Start], [Break Seconds])
SELECT @schema_id, @start, @seconds, @break_start, @break_seconds
SELECT @item_id = SCOPE_IDENTITY()
GO
ALTER PROC dbo.spTimeSchemaBreakUpdate @schema_id int, @start int, @seconds int, @break_start int, @break_seconds int, @item_id int
AS
DECLARE @creator varbinary(85), @created datetime, @authorized bit
SELECT @creator=Creator, @created=Created FROM dbo.TimeSchema WHERE TimeSchemaID=@schema_id
EXEC dbo.spPermissionInsureForCurrentUserOnDetail 44, 2, @creator, @created, @authorized OUT

IF @authorized=1 UPDATE dbo.TimeSchemaBreak SET TimeSchemaID=@schema_id, Start=@start, Seconds=@seconds, [Break Start]=@break_start, [Break Seconds]=@break_seconds WHERE ItemID=@item_id
GO
CREATE PROC dbo.spTimeSchemaBreakSelect @item_id int
AS
SELECT ItemID, TimeSchemaID, Start, Seconds, [Break Start], [Break Seconds] FROM dbo.TimeSchemaBreak WHERE ItemID=@item_id
GO
CREATE PROC dbo.spTimeSchemaBreakList @schema_id int
AS
SELECT ItemID, TimeSchemaID, Start, Seconds, [Break Start], [Break Seconds] FROM dbo.TimeSchemaBreak WHERE TimeSchemaID=@schema_id ORDER BY [Start], [Break Seconds]
GO
ALTER PROC dbo.spTimeSchemaBreakDelete @item_id int
AS
DELETE dbo.TimeSchemaBreak WHERE ItemID=@item_id
GO
GRANT EXEC ON dbo.spTimeSchemaBreakList TO public
GRANT EXEC ON dbo.spTimeSchemaBreakSelect TO public
GO
ALTER PROCEDURE dbo.spRaceInsert
	@race varchar(50),
	@race_id int OUT,
	@report_column int = -1
AS
INSERT Race(Race, [Report Column]) VALUES(@race, @report_column)
SELECT @race_id = SCOPE_IDENTITY()
GO
ALTER PROCEDURE dbo.spRaceList AS SET NOCOUNT ON SELECT * FROM vwRace ORDER BY Race
GO
ALTER PROCEDURE dbo.spRaceSelect @race_id int AS SELECT * FROM vwRace WHERE RaceID = @race_id
GO
ALTER PROC dbo.spRaceUpdate
	@race varchar(50),
	@race_id int,
	@report_column int = NULL
AS
UPDATE Race SET Race = @race, [Report Column]=ISNULL(@report_column, [Report Column]) WHERE RaceID = @race_id
GO
ALTER PROCEDURE dbo.spUnionInsert
	@union varchar(50),
	@union_id int OUT,
	@bu varchar(5)=''
AS
INSERT dbo.[Union]([Union],BU) VALUES(@union,@bu)
SELECT @union_id = SCOPE_IDENTITY()
GO
ALTER PROCEDURE dbo.spUnionUpdate
	@union varchar(50),
	@union_id int,
	@bu varchar(5)=''
AS
UPDATE dbo.[Union] SET [Union] = @union,BU=@bu WHERE UnionID = @union_id
GO
IF OBJECT_ID('dbo.spEmployeeTerminalListOutOfSync') IS NOT NULL DROP PROC dbo.spEmployeeTerminalListOutOfSync
GO
CREATE PROC dbo.spEmployeeTerminalListOutOfSync
AS
SELECT 
T.[Terminal Password],
T.[PID Card Number],
T.TerminalSyncFlags,
T.TerminalSyncFlags2,
T.[Enrolled Terminals Mask],
T.[Terminal Sync State Mask],
T.EmployeeID,
T.[Fingerprints Stream],
T.[Terminal Last Sync],
T.[Employee Number],
T.[Full Name],
T.[Terminal Sync Status],
T.[Active Employee],
T.EmployeeNumberT
FROM dbo.vwEmployeeTerminal T WHERE (T.[Terminal Sync State Mask] & 0x3F) != 0 AND T.[Employee Number] != '' AND (dbo.fnPermissionGetOnPersonForCurrentUser(T.EmployeeID, 10) & 1) = 1
GO
GRANT EXEC ON dbo.spEmployeeTerminalListOutOfSync TO public
GO
IF OBJECT_ID('dbo.spEmployeeTerminalListAll') IS NOT NULL DROP PROC dbo.spEmployeeTerminalListAll
GO
CREATE PROC dbo.spEmployeeTerminalListAll
AS
SELECT
T.[Terminal Password],
T.[PID Card Number],
T.TerminalSyncFlags,
T.TerminalSyncFlags2,
T.[Enrolled Terminals Mask],
T.[Terminal Sync State Mask],
T.EmployeeID,
T.[Fingerprints Stream],
T.[Terminal Last Sync],
T.[Employee Number],
T.[Full Name],
T.[Terminal Sync Status],
T.[Active Employee],
T.EmployeeNumberT
FROM dbo.vwEmployeeTerminal T WHERE T.[Employee Number] != '' AND (dbo.fnPermissionGetOnPersonForCurrentUser(T.EmployeeID, 10) & 1) = 1
GO
GRANT EXEC ON dbo.spEmployeeTerminalListAll TO public
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spEmployeeClassify'
GO
ALTER PROC dbo.spEmployeeClassify
	@person_id int,
	@shift_id int,
	@division_id int,
	@department_id int,
	@location_id int,
	@time_schema_id int,
	@salaried bit,
	@ot_pay_multiplier numeric(9,4) ,
	@holiday_pay_multiplier numeric(9,4),
	@weekend_pay_multiplier numeric(9,4) ,
	@ot_basis int,
	@default_time_type_id int,
	@terminal_sync_flags int = 0x37,
	@enrolled_terminals_mask int = 0,
	@org_user_field1 int = null
AS
DECLARE @number varchar(50)

SET NOCOUNT ON

INSERT Employee(EmployeeID, ShiftID, DivisionID, DepartmentID, LocationID, Salaried, [OT Pay Multiplier], [Holiday Pay Multiplier], [Weekend Pay Multiplier], [OT Basis], [Employee Number], TimeSchemaID, [Payroll Delay], DefaultTimeTypeID, [Direct Deposit Account Number], TerminalSyncFlags, [Enrolled Terminals Mask], OrgUserField1)
VALUES(@person_id, @shift_id, @division_id, @department_id, @location_id, @salaried, @ot_pay_multiplier, @holiday_pay_multiplier, @weekend_pay_multiplier, @ot_basis, '', @time_schema_id, 0, @default_time_type_id, '',@terminal_sync_flags, @enrolled_terminals_mask, @org_user_field1)

RETURN @@ERROR
GO
IF OBJECT_ID('dbo.spEmployeeTerminalSelect') IS NOT NULL DROP PROC dbo.spEmployeeTerminalSelect
GO
CREATE PROC dbo.spEmployeeTerminalSelect @employee_id int AS
DECLARE @authorized bit
EXEC dbo.spPermissionInsureForCurrentUserOnPerson @employee_id, 10, 1, @authorized out
IF @authorized=1 SELECT
T.[Terminal Password],
T.[PID Card Number],
T.TerminalSyncFlags,
T.TerminalSyncFlags2,
T.[Enrolled Terminals Mask],
T.[Terminal Sync State Mask],
T.EmployeeID,
T.[Fingerprints Stream],
T.[Terminal Last Sync],
T.[Employee Number],
T.EmployeeNumberT,
T.[Full Name],
T.[Terminal Sync Status],
T.[Active Employee]
FROM dbo.vwEmployeeTerminal T WHERE T.EmployeeID=@employee_id
GO
GRANT EXEC ON dbo.spEmployeeTerminalSelect TO public
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spEmployeeTerminalUpdate', 1
GO
ALTER PROC [dbo].[spEmployeeTerminalUpdate]
@employee_id int,
@password varchar(50) =NULL,
@pid_card_number varchar(50),
@flags int,
@flags2 int,
@enrolled_terminals_mask int
AS
DECLARE @authorized bit
EXEC dbo.spPermissionInsureForCurrentUserOnPerson @employee_id, 10, 2, @authorized out
IF @authorized=1 
BEGIN
	BEGIN TRAN
	UPDATE E SET
	[Terminal Password] = CASE WHEN @password IS NULL THEN [Terminal Password] ELSE @password END,
	[PID Card Number] = @pid_card_number,
	TerminalSyncFlags = @flags,
	TerminalSyncFlags2 = @flags2,
	[Enrolled Terminals Mask] = @enrolled_terminals_mask
	FROM dbo.Employee E WHERE E.EmployeeID=@employee_id

	EXEC dbo.spEmployeeTerminalUpdateCardNumber @employee_id, @pid_card_number
	COMMIT TRAN
END
GO
GO
IF OBJECT_ID('dbo.spEmployeeTerminalUpdateFPs') IS NOT NULL DROP PROC dbo.spEmployeeTerminalUpdateFPs
GO
CREATE PROC dbo.spEmployeeTerminalUpdateFPs
@employee_id int,
@fingerprints_stream image
AS
DECLARE @authorized bit
EXEC dbo.spPermissionInsureForCurrentUserOnPerson @employee_id, 10, 2, @authorized out
IF @authorized=1 UPDATE E SET [Fingerprints Stream] = @fingerprints_stream FROM dbo.Employee E WHERE E.EmployeeID=@employee_id
GO
GRANT EXEC ON dbo.spEmployeeTerminalUpdateFPs TO public
GO

EXEC dbo.spAdminCreateSPifNonexistent 'spEmployeeList2', 1
GO
ALTER PROCEDURE [dbo].[spEmployeeList2] 
AS
SET NOCOUNT ON

IF IS_MEMBER('db_owner')=1
SELECT P.PersonID, P.[List As], E.[Active Employee] FROM vwPersonListAs P
INNER JOIN Employee E ON P.PersonID = E.EmployeeID ORDER BY P.[List As]
ELSE
BEGIN
DECLARE @batch_id int
EXEC dbo.spAdminGetNextRandom @batch_id out
INSERT dbo.TempX(BatchID, [ID])
SELECT @batch_id, E.EmployeeID FROM Employee E WHERE E.[Active Employee] = 1
EXEC dbo.spPermissionGetOnPeopleForCurrentUser2 @batch_id, 2
SELECT P.PersonID, P.[List As], [Active Employee] = 1 FROM dbo.vwPersonListAs P
INNER JOIN dbo.TempX X ON X.BatchID = @batch_id AND X.[ID]= P.PersonID AND (X.X & 1) = 1
ORDER BY P.[List As]
DELETE dbo.Tempx WHERE BatchID=@batch_id
END
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spEmployeeTerminalUpdateCardNumber', 1
GO
ALTER PROC [dbo].[spEmployeeTerminalUpdateCardNumber]
@employee_id int,
@card_number varchar(50)
AS
DECLARE @authorized bit, @dup_employee nvarchar(400)
EXEC dbo.spPermissionInsureForCurrentUserOnPerson @employee_id, 10, 2, @authorized out

SELECT TOP 1 @dup_employee = P.[Full Name] FROM dbo.Employee E
INNER JOIN dbo.vwPersonCalculated P ON @card_number <> '' AND E.[PID Card Number] = @card_number AND E.EmployeeID <> @employee_id AND P.PersonID = E.EmployeeID

IF @@ROWCOUNT > 0
BEGIN
	DECLARE @m nvarchar(400)
	SET @m = N'Duplicate card number. ' + @dup_employee + ' is active and is already assigned card number ' + @card_number + '. Inactivate ' + @dup_employee + ', clear the number, or enter a different number.'
	RAISERROR(@m,16,1)
END
ELSE IF @authorized=1
BEGIN
	BEGIN TRAN
	IF @card_number <> '' UPDATE E SET [PID Card Number] = '' FROM dbo.Employee E WHERE [PID Card Number] = @card_number AND [Active Employee] = 0 AND EmployeeID <> @employee_id
	UPDATE E SET [PID Card Number] = @card_number FROM dbo.Employee E WHERE E.EmployeeID=@employee_id
	COMMIT TRAN
END
GO
IF OBJECT_ID('dbo.spEmployeeTerminalUpdateSyncState') IS NOT NULL DROP PROC dbo.spEmployeeTerminalUpdateSyncState
GO
CREATE PROC dbo.spEmployeeTerminalUpdateSyncState
@employee_id int,
@sync_state_mask int
AS
DECLARE @authorized bit
EXEC dbo.spPermissionInsureForCurrentUserOnPerson @employee_id, 10, 2, @authorized out
IF @authorized=1 UPDATE E SET [Terminal Sync State Mask] = @sync_state_mask FROM dbo.Employee E WHERE E.EmployeeID=@employee_id
GO
GRANT EXEC ON dbo.spEmployeeTerminalUpdateSyncState TO public
GO
IF OBJECT_ID('dbo.spEmployeeTerminalUpdateLastSync') IS NOT NULL DROP PROC dbo.spEmployeeTerminalUpdateLastSync
GO
CREATE PROC dbo.spEmployeeTerminalUpdateLastSync
@employee_id int
AS
DECLARE @authorized bit
EXEC dbo.spPermissionInsureForCurrentUserOnPerson @employee_id, 10, 2, @authorized out
IF @authorized=1
BEGIN
	UPDATE E SET [Terminal Last Sync] = GETDATE() FROM dbo.Employee E WHERE E.EmployeeID=@employee_id
	-- Makes sure that flags for enrolling user in all terminals and removing user from all terminals is not simoultaneously set
	UPDATE E SET
		TerminalSyncFlags = TerminalSyncFlags & 0x7FFFFFF3,
		[Enrolled Terminals Mask] = 0
	FROM dbo.Employee E WHERE E.EmployeeID=@employee_id AND (TerminalSyncFlags & 0xC) = 0xC
END
GO
GRANT EXEC ON dbo.spEmployeeTerminalUpdateLastSync TO public
GO
ALTER PROCEDURE dbo.spEmployeeListSeniority
	@start_month int,
	@stop_month int,
	@batch_id int,
	@year int,
	@seniority_mask int = 0x7FFFFFFF
AS
DECLARE @start_month2 int
DECLARE @stop_month2 int

-- Handles like November through February
IF @stop_month < @start_month
BEGIN
	SELECT @start_month2 = 1, @stop_month2 = @stop_month
	SET @stop_month = 12
END
ELSE
	SELECT @start_month2 = -1, @stop_month2 = -1

SET NOCOUNT ON

CREATE TABLE #S070507(PersonID int, Person varchar(400) COLLATE SQL_Latin1_General_CP1_CI_AS, Initials varchar(50) COLLATE SQL_Latin1_General_CP1_CI_AS, [Month] int, [Day] int, Years int)
IF @seniority_mask!=0x7FFFFFFF  CREATE INDEX S070507_Years ON #S070507(Years)

INSERT #S070507
SELECT PersonID = E.EmployeeID, Person = V.[Full Name], Initials = V.Initials, [Month] = MONTH(E.[Seniority Begins]), [Day] = DAY(E.[Seniority Begins]), Years = @year- YEAR(E.[Seniority Begins])
FROM vwEmployeeOrg E
INNER JOIN TempX T ON T.BatchID = @batch_id AND T.[ID] = E.EmployeeID AND (
	MONTH(E.[Seniority Begins]) BETWEEN @start_month AND @stop_month OR
	MONTH(E.[Seniority Begins]) BETWEEN @start_month2 AND @stop_month2
) AND (@seniority_mask=0x7FFFFFFF OR (@year- YEAR(E.[Seniority Begins])) < 32)
INNER JOIN vwPersonCalculated V ON E.EmployeeID = V.PersonID

IF @seniority_mask!=0x7FFFFFFF 
BEGIN
	DECLARE @bit int
	SELECT @bit=1, @year=0
	WHILE @bit < 32
	BEGIN
		IF (@seniority_mask & @bit)=0 DELETE #S070507 WHERE Years=@year
		SELECT @bit=@bit*2, @year=@year+1
	END
END

SELECT * FROM #S070507 ORDER BY [Month], [Day], [Person]

DELETE TempX WHERE BatchID = @batch_id OR DATEDIFF(hh, Created, GETDATE()) > 1
GO
ALTER PROC dbo.spPersonDeletePrepare
	@person_id int
AS
SET NOCOUNT ON

DELETE EmployeeProject WHERE EmployeeID=@person_id
DELETE EmployeeEmergencyContact WHERE EmployeeID = @person_id OR PersonID = @person_id
DELETE EmployeeSuccessor WHERE EmployeeID = @person_id OR SuccessorID = @person_id
DELETE Invoice WHERE EmployeeID=@person_id
UPDATE Equipment SET EmployeeID = NULL, [Checked Out Day past 1900] = NULL, [Due Day past 1900] = NULL WHERE EmployeeID = @person_id
UPDATE StandardTask SET OwnerEmployeeID = NULL, Owner = 2 WHERE OwnerEmployeeID = @person_id
UPDATE EmployeeLeaveUsed SET CoveringEmployeeID = NULL WHERE CoveringEmployeeID = @person_id
UPDATE EmployeeLeaveUsed SET PreapprovedEmployeeID = NULL WHERE PreapprovedEmployeeID = @person_id
UPDATE Employee SET ManagerID = NULL WHERE ManagerID = @person_id
UPDATE Employee SET DelegatedManagerID = NULL WHERE DelegatedManagerID = @person_id
UPDATE Task SET RegardingPersonID = NULL WHERE RegardingPersonID = @person_id
DELETE Task WHERE OwnerEmployeeID = @person_id
UPDATE ReminderType SET OwnerID = NULL WHERE OwnerID = @person_id
UPDATE Department SET LeaveKeeperID = NULL WHERE LeaveKeeperID = @person_id
UPDATE Division SET LeaveKeeperID = NULL WHERE LeaveKeeperID = @person_id

-- Works around MS bug 825021, allowing trigger to execute on EmployeeLeaveUsedItem
DELETE EmployeeLeaveUsed WHERE EmployeeID = @person_id
GO
IF OBJECT_id('dbo.spEmployeeProjectInsert') IS NOT NULL DROP PROC dbo.spEmployeeProjectInsert
IF OBJECT_id('dbo.spEmployeeProjectUpdate') IS NOT NULL DROP PROC dbo.spEmployeeProjectUpdate
GO
CREATE PROC dbo.spEmployeeProjectUpdate
	@employee_id int,
	@project_id int,
	@billing_rate smallmoney,
	@pay_rate smallmoney,
	@start_day int,
	@stop_day int,
	@item_id int,
	@percent int,
	@comment varchar(50),
	@flags int = NULL,
	@fixed_pay smallmoney = NULL,
	@fixed_billing smallmoney = NULL
AS
DECLARE @authorized bit
EXEC dbo.spPermissionInsureForCurrentUserOnPerson @employee_id, 262144, 2, @authorized out

IF @authorized=1
UPDATE EmployeeProject SET
EmployeeID = @employee_id,
ProjectID = @project_id,
[Billing Rate] = @billing_rate,
[Pay Rate] = @pay_rate,
[Start Day past 1900] = @start_day,
[Stop Day past 1900] = @stop_day,
[Percent of Time Allocated] = @percent,
Comment = LTRIM(RTRIM(@comment)),
[Fixed Billing] = @fixed_billing,
[Fixed Pay] = @fixed_pay,
Flags = CASE WHEN @flags IS NULL THEN Flags ELSE @flags END
WHERE ItemID = @item_id
GO
CREATE PROC dbo.spEmployeeProjectInsert
	@employee_id int,
	@project_id int,
	@billing_rate smallmoney,
	@pay_rate smallmoney,
	@start_day int,
	@stop_day int,
	@percent int,
	@comment varchar(50),
	@item_id int out,
	@flags int = 0,
	@fixed_pay smallmoney = NULL,
	@fixed_billing smallmoney = NULL
AS
DECLARE @authorized bit
EXEC dbo.spPermissionInsureForCurrentUserOnPerson @employee_id, 262144, 4, @authorized out

IF @authorized=1
INSERT EmployeeProject(EmployeeID, ProjectID, [Billing Rate], [Pay Rate], [Start Day past 1900], [Stop Day past 1900], [Percent of Time Allocated], Comment, [Fixed Pay], [Fixed Billing], Flags)
SELECT @employee_id, @project_id, @billing_rate, @pay_rate, @start_day, @stop_day, @percent, @comment, @fixed_pay, @fixed_billing, @flags

SELECT @item_id = SCOPE_IDENTITY()
GO
GRANT EXEC ON dbo.spEmployeeProjectUpdate TO public
GRANT EXEC ON dbo.spEmployeeProjectInsert TO public
GO
IF OBJECT_ID('dbo.spInvoiceTemplateInsert') IS NOT NULL DROP PROC dbo.spInvoiceTemplateInsert
GO
CREATE PROC dbo.spInvoiceTemplateInsert
@template varchar(50), @note varchar(1000), @sender_text varchar(1000), @remit_text varchar(1000), @template_id int OUT
AS INSERT dbo.InvoiceTemplate(Template,Note,[Sender Text],[Remit Text]) VALUES(@template,@note,@sender_text,@remit_text) SET @template_id = SCOPE_IDENTITY()
GO
GRANT EXEC ON dbo.spInvoiceTemplateInsert TO public
GO
IF OBJECT_ID('dbo.spInvoiceTemplateUpdate') IS NOT NULL DROP PROC dbo.spInvoiceTemplateUpdate
GO
CREATE PROC dbo.spInvoiceTemplateUpdate
@template varchar(50), @note varchar(1000), @sender_text varchar(1000), @remit_text varchar(1000), @template_id int
AS UPDATE dbo.InvoiceTemplate SET Template=@template,Note=@note,[Sender Text]=@sender_text,[Remit Text]=@remit_text WHERE TemplateID=@template_id
GO
GRANT EXEC ON dbo.spInvoiceTemplateUpdate TO public
GO
IF OBJECT_ID('dbo.spInvoiceTemplateDelete') IS NOT NULL DROP PROC dbo.spInvoiceTemplateDelete
GO
CREATE PROC dbo.spInvoiceTemplateDelete @template_id int
AS DELETE dbo.InvoiceTemplate WHERE TemplateID=@template_id
GO
GRANT EXEC ON dbo.spInvoiceTemplateDelete TO public
GO
IF OBJECT_ID('dbo.spInvoiceTemplateSelect') IS NOT NULL DROP PROC dbo.spInvoiceTemplateSelect
GO
CREATE PROC dbo.spInvoiceTemplateSelect @template_id int
AS SELECT * FROM dbo.InvoiceTemplate WHERE TemplateID=@template_id
GO
GRANT EXEC ON dbo.spInvoiceTemplateSelect TO public
GO
IF OBJECT_ID('dbo.spInvoiceTemplateSelect') IS NOT NULL DROP PROC dbo.spInvoiceTemplateSelect
GO
IF NOT EXISTS(SELECT * FROM dbo.LeaveRatePeriod WHERE PeriodID=293888)
INSERT dbo.LeaveRatePeriod(PeriodID,GroupID,Period,Example,Payroll,[Order],Weekday)
SELECT 293888,1024,'Quarterly III','Jan 1,Mar 1,Jul 1,Oct 1...',0,6515,0

IF NOT EXISTS(SELECT * FROM dbo.LeaveRatePeriod WHERE PeriodID=51202)
INSERT dbo.LeaveRatePeriod(PeriodID,GroupID,Period,Example,Payroll,[Order],Weekday)
SELECT 51202,2,'Seniority Anniversary V (Year 1 Credit)','If seniority starts Jan 13,2000 then credit July 13,2000',0,2055,0

/*IF NOT EXISTS(SELECT * FROM dbo.LeaveRatePeriod WHERE PeriodID=53250)
INSERT dbo.LeaveRatePeriod(PeriodID,GroupID,Period,Example,Payroll,[Order],Weekday)
SELECT 53250,2,'Seniority Anniversary VI (Year 1 Credit)','If seniority starts Jan 13,2000 then credit July 1,2000',0,2060,0*/
GO
ALTER PROC dbo.spEmployeeLeaveUsedDelete
	@leave_id int
AS
DECLARE @employee_id int, @old_status tinyint, @start int
DECLARE @authorized bit, @audit_unauthorized_attempt bit, @audit_operation bit, @hours numeric(9,2)

SELECT @start = [Start Day past 1900], @employee_id = EmployeeID, @old_status = [Status], @hours=Seconds/3600.0 FROM EmployeeLeaveUsed WHERE LeaveID = @leave_id
IF @@ROWCOUNT = 0 RETURN

EXEC dbo.spPermissionInsureForCurrentUserOnPerson4 NULL, NULL, @employee_id, @old_status, 1, 10001, 10013, @authorized out

EXEC dbo.spAuditGetOperation 10001, 8, @audit_operation OUT, @audit_unauthorized_attempt OUT

IF @authorized = 1 
BEGIN
	BEGIN TRAN
	UPDATE dbo.EmployeeLeaveUsed SET PendingDeleteLeaveID=NULL,PendingDeleteLeaveText='' WHERE PendingDeleteLeaveID = @leave_id
	DELETE dbo.EmployeeLeaveUsed WHERE LeaveID = @leave_id

	EXEC dbo.spEmployeeLeaveCalcForEmployee @employee_id, @start
	DECLARE @linked_employee_id int, @type_id int
	DECLARE linked_cursor CURSOR LOCAL FORWARD_ONLY STATIC FOR SELECT EmployeeID,TypeID FROM dbo.EmployeeLeaveUsedLink WHERE leaveID=@leave_id
	OPEN linked_cursor
	FETCH NEXT FROM linked_cursor INTO @linked_employee_id, @type_id
	WHILE @@FETCH_STATUS = 0
	BEGIN
		EXEC dbo.spEmployeeLeaveCalcForEmployeeType @linked_employee_id, @type_id, @start
		FETCH NEXT FROM emplan_cursor INTO @linked_employee_id, @type_id
	END
	CLOSE linked_cursor
	DEALLOCATE linked_cursor
	COMMIT TRAN
END
ELSE IF @audit_unauthorized_attempt=1 EXEC dbo.spAuditTrailInsert @employee_id, @leave_id, 10001, 24, 'Unauthorized attempt to delete LOA', 10001
GO
ALTER PROC dbo.spEmployeeLeaveUsedItemDelete
	@item_id int
AS
DECLARE @leave_id int, @status tinyint
DECLARE @employee_id int
DECLARE @authorized bit, @audit_unauthorized_attempt bit, @audit_operation bit
DECLARE @hours numeric(9,2)

SELECT @hours=I.Seconds /3600.0, @leave_id=I.LeaveID, @employee_id = U.EmployeeID, @status = Status FROM EmployeeLeaveUsed U INNER JOIN EmployeeLeaveUsedItem I ON I.LeaveID = U.LeaveID AND I.ItemID = @item_id
EXEC dbo.spPermissionInsureForCurrentUserOnPerson4 @employee_id, @status, @employee_id, @status, 1, 10001, 10013, @authorized out

EXEC dbo.spAuditGetOperation 10001, 2, @audit_operation OUT, @audit_unauthorized_attempt OUT

DECLARE @audit_message varchar(4000)
IF @authorized = 1
BEGIN
	DELETE EmployeeLeaveUsedItem WHERE ItemID = @item_id
	IF @audit_operation=1
	BEGIN
		SELECT @audit_message = 'Changed leave and deleted item (LeaveID=' + CAST(@leave_id AS varchar(50)) + ', Hrs=' + CAST(@hours AS varchar(50)) + ')'
		EXEC dbo.spAuditTrailInsert @employee_id, @item_id, 10001, 8, @audit_message, 10002
	END
END
ELSE IF @audit_unauthorized_attempt=1
BEGIN
	SELECT @audit_message = 'Unauthorized attempt to change leave by deleting item (LeaveID=' + CAST(@leave_id AS varchar(50)) + ')'
	EXEC dbo.spAuditTrailInsert @employee_id, @item_id, 10001, 24, @audit_message, 10002
END
GO
GRANT SELECT ON dbo.TempXYZ TO public
GRANT SELECT ON dbo.TempX TO public
GO
ALTER PROC dbo.spReasonInsert
	@reason varchar(50),
	@fmla bit,
	@reason_id int OUT
AS
SET NOCOUNT ON

INSERT Reason(Reason, FMLA) VALUES(@reason, @fmla)
SELECT @reason_id = SCOPE_IDENTITY()
GO
ALTER PROC dbo.spEmployeeReviewInsert
	@employee_id int,
	@day_past_1900 int,
	@type_id int,
	@rating_id int,
	@reviewed_by_employee_id int,
	@changed_salary bit,
	@comment varchar(400),
	@review_id int OUT
AS
DECLARE @authorized bit

SET NOCOUNT ON

EXEC dbo.spPermissionInsureForCurrentUserOnPerson @employee_id, 16384, 4, @authorized out

IF @authorized = 1 INSERT EmployeeReview(EmployeeID,[Day past 1900],TypeID,RatingID,ReviewedByEmployeeID,[Changed Salary], Comment)
VALUES (@employee_id,@day_past_1900,@type_id,@rating_id,@reviewed_by_employee_id,@changed_salary, @comment)
SELECT @review_id = SCOPE_IDENTITY()
GO
ALTER PROC dbo.spChecklistExitInterviewInsert
	@order int,
	@check varchar(50),
	@check_id int out
AS
SET NOCOUNT ON

INSERT ChecklistExitInterview([Order], [Check])
SELECT @order, @check
SELECT @check_id = SCOPE_IDENTITY()
GO
ALTER PROC dbo.spCertificationInsert
	@certification varchar(50),
	@certification_id int OUT
AS
SET NOCOUNT ON

INSERT Certification(Certification) VALUES(@certification)
SELECT @certification_id = SCOPE_IDENTITY()
GO
IF OBJECT_ID('dbo.spEmployeeLeaveUsedList') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEmployeeLeaveUsedList AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spEmployeeLeaveUsedList TO public'
END
GO
ALTER PROC dbo.spEmployeeLeaveUsedList
	@batch_id int,
	@start_day int,
	@stop_day int,
	@delete_batch bit = 1, -- obsolete
	@flags int = NULL, -- 1: delete batch, 2: include pending for user with write permission, 4: include earned entries, 8: IncludePendingIfReadAllowed, 16: Exclude leave types not in Constant.[Timecard Leave Type Mask]
	@type_mask int = 0x7FFFFFFF
AS
SET NOCOUNT ON

IF @flags IS NOT NULL SET @delete_batch = @flags & 1

CREATE TABLE #EmployeeLeaveUsedListPermissions (
	EmployeeID int NOT NULL PRIMARY KEY,
	PendingEntriesPermission int NOT NULL DEFAULT(0),
	SchedulePermission int NOT NULL DEFAULT(0),
	ApprovedEntriesPermission int NOT NULL DEFAULT(0)
)

EXEC dbo.spPermissionGetOnPeopleForCurrentUser2 @batch_id, 10001
INSERT #EmployeeLeaveUsedListPermissions(EmployeeID,PendingEntriesPermission) SELECT [ID],X FROM dbo.TempX WHERE BatchID=@batch_id
CREATE INDEX Temp_EmployeeLeaveUsedListPermissions_EmployeeID ON #EmployeeLeaveUsedListPermissions(EmployeeID)

EXEC dbo.spPermissionGetOnPeopleForCurrentUser2 @batch_id, 10002
UPDATE #EmployeeLeaveUsedListPermissions SET SchedulePermission=X.X
FROM #EmployeeLeaveUsedListPermissions
INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID]=#EmployeeLeaveUsedListPermissions.EmployeeID

EXEC dbo.spPermissionGetOnPeopleForCurrentUser2 @batch_id, 10013
UPDATE #EmployeeLeaveUsedListPermissions SET ApprovedEntriesPermission=X.X
FROM #EmployeeLeaveUsedListPermissions
INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID]=#EmployeeLeaveUsedListPermissions.EmployeeID

SELECT 
L.EmployeeID,
Person = dbo.fnGetFullName(P.[First Name], P.[Middle Name], P.[Last Name], P.Suffix),
Initials = dbo.fnGetInitials(P.[First Name], P.[Middle Name], P.[Last Name]),
[Type Mask] = I.[Advanced Type Mask] | I.TypeID,
[Month] = MONTH(I.[Day past 1900]),
[Day] = DAY(I.[Day past 1900]),
[Year] = YEAR(I.[Day past 1900]),
I.[Day past 1900], 
[Date] = dbo.GetDateFromDaysPast1900(I.[Day past 1900]),
Covering = CASE WHEN
	L.CoveringEmployeeID IS NULL THEN ''
	ELSE dbo.fnGetInitials(C.[First Name], C.[Middle Name], C.[Last Name])
END,
Reason = ISNULL(R.Reason,''),
[Type] = T.Abbreviation,
Hours = (CASE WHEN I.Seconds < S.[Effective Seconds per Day] THEN I.Seconds ELSE 0 END) / 3600.0,
L.[Status],
L.LeaveID,
[Pending Permission Mask] = X.PendingEntriesPermission,
[Approved Permission Mask] = X.ApprovedEntriesPermission,
L.[Calendar Comment],
[Seniority Begins] = dbo.GetDateFromDaysPast1900(E.[Seniority Begins Day past 1900])
FROM dbo.Constant
INNER JOIN dbo.EmployeeLeaveUsedItem I ON I.[Day past 1900] BETWEEN @start_day AND @stop_day AND (I.TypeID & @type_mask) > 0 AND ((@flags & 16) = 0 OR (I.TypeID & Constant.[Timecard Leave Type Mask]) != 0)
INNER JOIN dbo.EmployeeLeaveUsed L ON I.LeaveID = L.LeaveID
INNER JOIN #EmployeeLeaveUsedListPermissions X ON X.EmployeeID=L.EmployeeID AND (
	((@flags & 2) = 2 AND L.Status=1 AND (X.PendingEntriesPermission & 2) = 2 ) OR -- Write pending requests
	((@flags & 8) = 8 AND L.Status=1 AND (X.PendingEntriesPermission & 1) = 1 ) OR -- Read pending requests
	(L.[Status]=2 AND (X.SchedulePermission & 1) = 1 ) -- Read scheduled requests
)
INNER JOIN dbo.Person P ON L.EmployeeID = P.PersonID
INNER JOIN dbo.vwEmployeeEffectiveSecondsPerDay S ON P.PersonID = S.EmployeeID
INNER JOIN dbo.LeaveType T ON I.TypeID = T.TypeID 
INNER JOIN dbo.Employee E ON P.PersonID = E.EmployeeID
LEFT JOIN dbo.Person C ON L.CoveringEmployeeID=C.PersonID
LEFT JOIN dbo.Reason R ON R.ReasonID = L.ReasonID


UNION ALL


SELECT
E.EmployeeID,
Person = dbo.fnGetFullName(P.[First Name], P.[Middle Name], P.[Last Name], P.Suffix),
Initials = dbo.fnGetInitials(P.[First Name], P.[Middle Name], P.[Last Name]),
[Type Mask] = E.TypeID,
[Month] = MONTH(E.[Day past 1900]),
[Day] = DAY(E.[Day past 1900]),
[Year] = YEAR(E.[Day past 1900]),
E.[Day past 1900],
[Date] = dbo.GetDateFromDaysPast1900(E.[Day past 1900]),
Covering = '',
Reason = '',
[Type] = T.Abbreviation,
[Hours] = (CASE WHEN (0 - E.Seconds) < S.[Effective Seconds per Day] THEN 0 - E.Seconds ELSE 0 END) / 3600.0,
[Status] = 2,
LeaveID = NULL,
[Pending Permission Mask] = 0x7FFFFFFF,
[Approved Permission Mas] = 0x7FFFFFFF,
[Calendar Comment] = '',
[Seniority Begins] = dbo.GetDateFromDaysPast1900(EMP.[Seniority Begins Day past 1900])
FROM dbo.EmployeeLeaveEarned E
INNER JOIN dbo.Constant ON (E.TypeID & @type_mask) > 0 AND ((@flags & 16) = 0 OR (E.TypeID & Constant.[Timecard Leave Type Mask]) != 0) -- One record in Constant
INNER JOIN #EmployeeLeaveUsedListPermissions X ON (@flags & 4) = 0 AND X.EmployeeID = E.EmployeeID AND E.[Day past 1900] BETWEEN @start_day AND @stop_day AND E.Seconds < 0 AND E.Auto = 0 AND (X.SchedulePermission & 1) = 1
INNER JOIN dbo.vwEmployeeEffectiveSecondsPerDay S ON E.EmployeeID = S.EmployeeID
INNER JOIN dbo.Person P ON E.EmployeeID = P.PersonID
INNER JOIN dbo.Employee EMP ON P.PersonID = EMP.EmployeeID
INNER JOIN dbo.LeaveType T ON E.TypeID = T.TypeID

ORDER BY [Day past 1900], [Person]

IF @delete_batch = 1 DELETE TempX WHERE BatchID = @batch_id
DELETE TempX WHERE DATEDIFF(hour, Created, GETDATE()) > 1
GO
-- Raises an error if the current user does not have the required permission
-- on a given attribute for a given person (employee\applicant...)
ALTER PROCEDURE dbo.spPermissionInsureForCurrentUserOnPerson
	@person_id int,
	@attribute_id bigint,
	@permission_required int,
	@authorized bit out
AS
SET NOCOUNT ON

EXEC dbo.spPermissionGetOnPersonForCurrentUser2 @person_id, @attribute_id, @permission_required, @authorized out
IF @authorized = 0
BEGIN
	EXEC dbo.spErrorRaiseNoPermission @attribute_id, @permission_required, @person_id
	RETURN 50016
END
ELSE RETURN 0
GO
ALTER PROC dbo.spPermissionListUsersWithDBAccessIntoTempUser2
	@batch_id int,
	@exclude_system_groups bit,
	@include_only_non_public_roles bit = 0
AS
SET NOCOUNT ON

INSERT dbo.TempUser(BatchID, [Master Name], SID, UID, [Name], IsSQLUser, IsSQLRole, IsNTGroup, IsNTUser, IsSA)

SELECT @batch_id,
[Master Name] = CASE WHEN U.[name] = 'sys' AND U.uid = 4 THEN 'sa' ELSE ISNULL(L.[name], '') END,
L.SID, U.UID,
[Name] = CASE WHEN (U.[name] = 'sys' OR U.[name]='sa') AND U.uid = 4 THEN 'sa' ELSE ISNULL(U.[name], '') END,
U.IsSQLUser, U.IsSQLRole, U.IsNTGroup, U.IsNTUser,
CASE WHEN L.SID = 0x01 OR (U.[name] = 'sys' AND U.uid = 4) THEN 1 ELSE 0 END
FROM sysusers U
LEFT JOIN master.dbo.syslogins L ON U.sid = L.sid
WHERE (((U.uid > 1 AND U.uid < 16385) OR U.uid > 16393 Or U.uid = 0) AND (hasdbaccess = 1 OR U.[name] <> 'guest'))
AND (@exclude_system_groups = 0 OR U.uid NOT IN (0, 4, 16384)) 
AND (@include_only_non_public_roles = 0 OR (U.IsSQLRole = 1 AND U.uid <> 0))
GO
IF OBJECT_id('dbo.spEmployeeLeaveVerifyAvailable') IS NULL
BEGIN
	EXEC sp_Executesql N'CREATE PROC dbo.spEmployeeLeaveVerifyAvailable AS'
	EXEC sp_Executesql N'GRANT EXEC ON dbo.spEmployeeLeaveVerifyAvailable TO public'
END
GO
-- Tests a proposed leave request to see if it uses more time than is available
-- Currently does not work with rolling accruals (FMLA)
-- Insert the request in TempXYZ ( X=Type Y=Day Z=Seconds) and pass the batch_id
-- Tests a proposed leave request to see if it uses more time than is available
ALTER PROC dbo.spEmployeeLeaveVerifyAvailable
	@employee_id int,
	@batch_id int,
	@unavailable_type_id int out,
	@unavailable_seconds int out,
	@minimum_seconds int = 0,
	@subtract_leave_id int = null
--WITH EXECUTE AS 'dbo'
AS
DECLARE @d int, @accumulated int, @max int, @authorized bit

SET NOCOUNT ON

SELECT @unavailable_type_id = NULL, @unavailable_seconds = 0

EXEC dbo.spPermissionInsureForCurrentUserOnPerson @employee_id, 10003, 1, @authorized out

IF @authorized = 1
BEGIN
	-- Turns TempXYZ into #Request
	CREATE TABLE #Request(TypeID int, D int, Seconds int)
	DECLARE @type_id int, @day int, @seconds int
	
	DECLARE t_cursor CURSOR LOCAL FORWARD_ONLY STATIC FOR SELECT T.TypeID FROM LeaveType T WHERE Bank=1 AND EXISTS (
		SELECT * FROM TempXYZ X WHERE BatchID=@batch_id AND (T.TypeID & X.X) = T.TypeID
	)
	OPEN t_cursor

	FETCH t_cursor INTO @type_id
	WHILE @@FETCH_STATUS = 0
	BEGIN
		-- Subtracts out leave for @subtract_leave_id (considering update)
		INSERT #Request -- TempXYZ X=Type Y=Day Z=Seconds
		SELECT @type_id, MIN([Day past 1900]), 0-ISNULL(SUM(Seconds),0) 
		FROM dbo.vwEmployeeLeaveUsedItem WHERE LeaveID=@subtract_leave_id AND [Status]=2 AND ((TypeID | [Advanced Type Mask]) & @type_id) != 0

		INSERT #Request -- TempXYZ X=Type Y=Day Z=Seconds
		SELECT @type_id, Y, Z FROM TempXYZ WHERE BatchID=@batch_id AND ((X & @type_id) != 0) ORDER BY X, Y
		
		FETCH t_cursor INTO @type_id
	END
	
	DELETE #Request WHERE Seconds = 0

	CLOSE t_cursor
	DEALLOCATE t_cursor

	DELETE TempXYZ WHERE BatchID=@batch_id OR DATEDIFF(hh,Created,GETDATE()) > 1

	CREATE INDEX Request_TypeID_040107 ON #Request(TypeID)
	CREATE INDEX Request_TypeIDDay_040107 ON #Request(TypeID,D)


	
	CREATE TABLE #Limit(TypeID int, D int, Seconds int, Stop int, Minimum int DEFAULT(0))
	
	INSERT #Limit SELECT TypeID, MIN(R.D), 0, 2147483647, 0 FROM #Request R GROUP BY TypeID
	
	-- Finds latest non-limit adjusted balance. If that does not exist then uses latest limit-adjusted balance
	UPDATE #Limit SET D = ISNULL((
		SELECT MAX(U.[Day past 1900]) FROM EmployeeLeaveUnused U WHERE U.EmployeeID=@employee_id AND U.TypeID=#Limit.TypeID AND U.[Day past 1900]<=#Limit.D AND U.[Limit Adjustment]=0
	), ISNULL((
		SELECT MAX(U.[Day past 1900]) FROM EmployeeLeaveUnused U WHERE U.EmployeeID=@employee_id AND U.TypeID=#Limit.TypeID AND U.[Day past 1900]<=#Limit.D AND U.[Limit Adjustment]=1
	),
	D))

	UPDATE #Limit SET [Stop] = ISNULL((
		SELECT MIN(U.[Day past 1900]) FROM EmployeeLeaveUnused U WHERE U.EmployeeID=@employee_id AND U.TypeID=#Limit.TypeID AND U.[Day past 1900]>=#Limit.D AND U.[Limit Adjustment]=1
	), Stop),
	Seconds = ISNULL((
		SELECT U.[Unused] + U.[Limit Seconds] FROM EmployeeLeaveUnused U WHERE U.EmployeeID=@employee_id AND U.TypeID=#Limit.TypeID AND U.[Day past 1900]=#Limit.D
	), Seconds)

	CREATE UNIQUE INDEX L_TypeID_040107 ON #Limit(TypeID)
	
	DECLARE leave_cursor CURSOR LOCAL FORWARD_ONLY STATIC FOR 
	SELECT E.TypeID, D = E.[Day past 1900], S = E.Seconds FROM vwEmployeeLeaveEarned E 
	INNER JOIN #Limit ON E.EmployeeID=@employee_id AND E.TypeID=#Limit.TypeID AND E.[Day past 1900] > #Limit.D AND E.[Day past 1900] <= #Limit.Stop AND E.[Limit Adjustment]=0
	
	UNION ALL
	
	SELECT I.TypeID, I.[Day past 1900], S = 0 - I.Seconds
	FROM dbo.vwEmployeeLeaveUsedItem I
	INNER JOIN #Limit ON I.[Status] <> 4 AND (@subtract_leave_id IS NULL OR @subtract_leave_id != I.LeaveID) AND I.EmployeeID=@employee_id AND I.TypeID=#Limit.TypeID AND (I.[Day past 1900] > #Limit.D OR I.[Status] = 1) AND I.[Day past 1900] <= #Limit.[Stop]
	
	UNION ALL
	
	SELECT R.TypeID, R.D, S = 0 - R.Seconds FROM #Request R
	INNER JOIN #Limit ON R.TypeID=#Limit.TypeID AND R.D <= #Limit.Stop
	
	ORDER BY D, S DESC


	OPEN leave_cursor
	FETCH leave_cursor INTO @type_id, @day, @seconds
	
	WHILE @@FETCH_STATUS=0
	BEGIN
		DECLARE @running int
		SELECT @running = Seconds + @seconds FROM #Limit WHERE TypeID=@type_id
		UPDATE #Limit SET Minimum = @running WHERE TypeID=@type_id AND @running < Minimum
		UPDATE #Limit SET Seconds = @running WHERE TypeID=@type_id

		FETCH leave_cursor INTO @type_id, @day, @seconds
	END

	CLOSE leave_cursor
	DEALLOCATE leave_cursor

	SELECT @unavailable_seconds = NULL, @unavailable_type_id = NULL
	SELECT @unavailable_seconds =MIN(Minimum) FROM #Limit WHERE Minimum < @minimum_seconds
	IF @unavailable_seconds IS NULL SET @unavailable_seconds = 0
	ELSE
	BEGIN
		SELECT TOP 1 @unavailable_type_id = TypeID FROM #Limit WHERE Minimum = @unavailable_seconds
		SELECT @unavailable_seconds = 0 - @unavailable_seconds
	END
	
	-- EXECUTE AS USER = 'dbo'
	
		IF @unavailable_type_id IS NULL AND OBJECT_ID('dbo.spCustom_EmployeeLeaveVerifyAvailableAfter') IS NOT NULL
		EXEC sp_executesql N'EXEC dbo.spCustom_EmployeeLeaveVerifyAvailableAfter @employee_id,@batch_id,@unavailable_type_id,@unavailable_seconds,@minimum_seconds,@subtract_leave_id',N'@employee_id int,@batch_id int,@unavailable_type_id int out,@unavailable_seconds int out,@minimum_seconds int,@subtract_leave_id int', @employee_id,@batch_id,@unavailable_type_id out,@unavailable_seconds out,@minimum_seconds,@subtract_leave_id

	-- REVERT
END
GO
IF OBJECT_id('dbo.spEmployeeExpenseSummarize') IS NOT NULL DROP PROC dbo.spEmployeeExpenseSummarize
GO
CREATE PROC dbo.spEmployeeExpenseSummarize
	@batch_id int,
	@account_id int,
	@start int,
	@stop int,
	@authorized bit OUT
AS
SET NOCOUNT ON

EXEC dbo.spPermissionGetOnPeopleForCurrentUser2 @batch_id, 10010
DELETE TempX WHERE BatchID = @batch_id AND (X & 1) = 0
SELECT @authorized = CASE WHEN @@ROWCOUNT=0 THEN 1 ELSE 0 END

SELECT
EmployeeID=P.PersonID,
Employee=P.[List As],
[Balance Previous] = ISNULL((
	SELECT SUM(Amount) FROM EmployeeExpense E WHERE (@account_id IS NULL OR E.AccountID=@account_id) AND E.EmployeeID=P.PersonID AND E.[Day past 1900] < @start
),0),
Credits = ISNULL((
	SELECT TOP 1 SUM(E.[Amount]) FROM EmployeeExpense E WHERE (@account_id IS NULL OR E.AccountID=@account_id) AND E.EmployeeID=P.PersonID AND E.Amount > 0 AND E.[Day past 1900] BETWEEN @start AND @stop
),0),
Debits = ISNULL((
	SELECT TOP 1 SUM(0 - E.[Amount]) FROM EmployeeExpense E WHERE (@account_id IS NULL OR E.AccountID=@account_id) AND E.EmployeeID=P.PersonID AND E.Amount < 0 AND E.[Day past 1900] BETWEEN @start AND @stop
),0),
Balance = ISNULL((
	SELECT SUM(Amount) FROM EmployeeExpense E WHERE (@account_id IS NULL OR E.AccountID=@account_id) AND E.EmployeeID=P.PersonID AND E.[Day past 1900] <= @stop
),0),
[Reimbursed Previous] = ISNULL((
	SELECT TOP 1 SUM(0 - E.[Amount]) FROM vwEmployeeExpense2 E WHERE (@account_id IS NULL OR E.AccountID=@account_id) AND E.EmployeeID=P.PersonID AND E.Reimbursed=1 AND E.[Day past 1900] < @start
),0),
[Reimbursed Period] = ISNULL((
	SELECT TOP 1 SUM(0 - E.[Amount]) FROM vwEmployeeExpense2 E WHERE (@account_id IS NULL OR E.AccountID=@account_id) AND E.EmployeeID=P.PersonID AND E.Reimbursed=1 AND E.[Day past 1900] BETWEEN @start AND @stop
),0),
[Reimbursed] = ISNULL((
	SELECT TOP 1 SUM(0 - E.[Amount]) FROM vwEmployeeExpense2 E WHERE (@account_id IS NULL OR E.AccountID=@account_id) AND E.EmployeeID=P.PersonID AND E.Reimbursed=1 AND E.[Day past 1900] <= @stop
),0),
[Unreimbursed Previous] = ISNULL((
	SELECT TOP 1 SUM(0 - E.[Amount]) FROM vwEmployeeExpense2 E WHERE (@account_id IS NULL OR E.AccountID=@account_id) AND E.EmployeeID=P.PersonID AND E.[To Be Reimbursed]=1 AND E.Reimbursed=0 AND E.[Day past 1900] < @start
),0),
[Unreimbursed Period] = ISNULL((
	SELECT TOP 1 SUM(0 - E.[Amount]) FROM vwEmployeeExpense2 E WHERE (@account_id IS NULL OR E.AccountID=@account_id) AND E.EmployeeID=P.PersonID AND E.[To Be Reimbursed]=1 AND E.Reimbursed=0 AND E.[Day past 1900] BETWEEN @start AND @stop
),0),
[Unreimbursed] = ISNULL((
	SELECT TOP 1 SUM(0 - E.[Amount]) FROM vwEmployeeExpense2 E WHERE (@account_id IS NULL OR E.AccountID=@account_id) AND E.EmployeeID=P.PersonID AND E.[To Be Reimbursed]=1 AND E.Reimbursed=0 AND E.[Day past 1900] <= @stop
),0)
INTO #R
FROM dbo.vwPersonListAs P
INNER JOIN TempX X ON X.BatchID=@batch_id AND P.PersonID=X.[ID]
ORDER BY P.[List As]

DELETE #R WHERE 
[Balance Previous]=0 AND Credits=0 AND Debits=0 AND Balance=0 AND
[Reimbursed Previous]=0 AND [Reimbursed Period]=0 AND Reimbursed=0 AND
[Unreimbursed Previous]=0 AND [Unreimbursed Period]=0 AND Unreimbursed=0

IF (SELECT COUNT(*) FROM #R) < 2
BEGIN
	SELECT EmployeeID, Employee,
	[Balance Previous], Credits, Debits, Balance,
	[Reimbursed Previous], [Reimbursed Period], Reimbursed,
	[Unreimbursed Previous], [Unreimbursed Period], Unreimbursed FROM #R
END

ELSE

BEGIN
	SELECT EmployeeID, Employee,
	[Balance Previous], Credits, Debits, Balance,
	[Reimbursed Previous], [Reimbursed Period], Reimbursed,
	[Unreimbursed Previous], [Unreimbursed Period], Unreimbursed FROM #R
	UNION ALL
	SELECT NULL, 'Total',
	SUM([Balance Previous]), SUM(Credits), SUM(Debits), SUM(Balance),
	SUM([Reimbursed Previous]), SUM([Reimbursed Period]), SUM(Reimbursed),
	SUM([Unreimbursed Previous]), SUM([Unreimbursed Period]), SUM(Unreimbursed) FROM #R
END

DELETE TempX WHERE BatchID=@batch_id OR DATEDIFF(hour,Created,GETDATE())>1
GO
GRANT EXEC ON dbo.spEmployeeExpenseSummarize TO public
GO
ALTER PROC dbo.spLeaveAnalysisByManager
	@type_or_mask int,
	@manager_id int,
	@ongoing bit,
	@sort tinyint,
	@authorized bit OUT
AS
SET NOCOUNT ON

DECLARE @start int, @stop int, @batch_id int, @today smalldatetime, @null_id int

SELECT @today = GETDATE()
SELECT @stop = DATEDIFF(d, 0, @today)
SELECT @start = DATEDIFF(d, 0, DATEADD(yy, -1, @today))
SELECT @batch_id = RAND() * 2147483647
SELECT @null_id = ISNULL(MIN(EmployeeID), 0) - 1 FROM Employee

CREATE TABLE #E(EmployeeID int, ManagerID int, ShiftID int, Incidents int, [Lost Days] numeric(18,4), B numeric(18,4))

INSERT #E
SELECT E.EmployeeID, ISNULL(E.ManagerID, @null_id), E.ShiftID, 0, 0, 0
FROM Employee E WHERE [Terminated Day past 1900] IS NULL OR (@ongoing IS NULL OR E.[Ongoing Condition] = @ongoing)

UPDATE #E SET Incidents = 
	(SELECT COUNT(*) FROM EmployeeLeaveUsed U
	INNER JOIN Employee E ON U.EmployeeID = E.EmployeeID AND E.EmployeeID = #E.EmployeeID AND U.Status = 2 AND U.LeaveID IN
	(
		SELECT DISTINCT I.LeaveID FROM vwEmployeeLeaveUsedItem I WHERE I.[Day past 1900] BETWEEN @start AND @stop AND
		(@type_or_mask = 0x7FFFFFFF OR (I.[Extended Type Mask] & @type_or_mask) <> 0) AND I.Status = 2
	))
	+
	(SELECT COUNT(*) FROM EmployeeLeaveEarned E WHERE E.EmployeeID = #E.EmployeeID AND (E.[Day past 1900] BETWEEN @start AND @stop) AND (@type_or_mask = 0x7FFFFFFF OR (E.TypeID & @type_or_mask) <> 0) AND E.Seconds < 0)

,
[Lost Days] = ISNULL((
	SELECT SUM(U.Seconds /  CAST(S.[Effective Seconds per Day] AS numeric(18,4))) FROM dbo.vwEmployeeLeaveUsedItemApproved U
	INNER JOIN Employee E ON U.EmployeeID = E.EmployeeID AND U.[Day past 1900] BETWEEN @start AND @stop AND E.EmployeeID = #E.EmployeeID AND E.[Terminated Day past 1900] IS NULL AND (U.[Extended Type Mask] & @type_or_mask) <> 0
	INNER JOIN vwEmployeeEffectiveSecondsPerDay S ON E.EmployeeID = S.EmployeeID
), 0)

UPDATE #E SET B = Incidents * Incidents * [Lost Days]


CREATE TABLE #M (ManagerID int, Incidents numeric(18,4), [Lost Hours] numeric(18,4), People int, [Working Hours] numeric(18,4))

INSERT #M
SELECT EmployeeID, 0, 0, 0, 0 FROM Employee
UNION
SELECT @null_id, 0, 0, 0, 0


UPDATE #M SET Incidents = 
	(SELECT COUNT(*) FROM EmployeeLeaveUsed U
	INNER JOIN #E ON U.EmployeeID = #E.EmployeeID AND 
	#E.ManagerID = #M.ManagerID AND 
	dbo.DoRaysIntersect(U.[Start Day past 1900], U.[Stop Day past 1900], @start, @stop) = 1 AND 
	U.Status = 2 AND U.LeaveID IN
	(
		SELECT DISTINCT I.LeaveID FROM vwEmployeeLeaveUsedItem I WHERE I.[Day past 1900] BETWEEN @start AND @stop AND
		(@type_or_mask = 0x7FFFFFFF OR (I.[Extended Type Mask] & @type_or_mask) <> 0) AND I.Status = 2
	))
	+
	(SELECT COUNT(*) FROM EmployeeLeaveEarned E
	INNER JOIN #E ON E.EmployeeID = #E.EmployeeID AND
	#E.ManagerID = #M.ManagerID AND E.[Day past 1900] BETWEEN @start AND @stop)
, [Lost Hours] = ISNULL((
	SELECT SUM(U.Seconds) / 3600.0 FROM dbo.vwEmployeeLeaveUsedItemApproved U
	INNER JOIN #E ON U.EmployeeID = #E.EmployeeID AND U.[Day past 1900] BETWEEN @start AND @stop AND #E.ManagerID = #M.ManagerID AND (U.[Extended Type Mask] & @type_or_mask) <> 0
), 0),
People = ISNULL((
	SELECT COUNT(*) FROM #E WHERE #E.ManagerID = #M.ManagerID
), 0),
[Working Hours] = ISNULL((
	SELECT SUM(dbo.BoundInt(0, DATEDIFF(d, E.[Seniority Begins Day past 1900], GETDATE()) , 365) * CAST((S.[Days On] + S.DaysOn2) AS numeric(18,4)) / CAST((S.[Days On] + S.[Days Off] + S.DaysOn2 + S.DaysOff2) AS numeric(18,4)) * S.[Effective Seconds per day]  )
	FROM vwEmployeeEffectiveSecondsPerDay S INNER JOIN #E ON #E.EmployeeID = S.EmployeeID AND #E.ManagerID = #M.ManagerID
	INNER JOIN Employee E ON #E.EmployeeID = E.EmployeeID
), 0)



	
SELECT
[Order] = CASE WHEN M.PersonID IS NULL THEN -1 ELSE 0 END,
#M.ManagerID,
Manager = ISNULL(M.[List As], 'No Manager'),
[Percent Working Time Lost] = CAST(CASE WHEN [Working Hours]= 0 THEN 0 ELSE 100 * #M.[Lost Hours] / #M.[Working Hours] END AS numeric(18,4)),
[Lost Hours per Week] = CAST(#M.[Lost Hours] / 52 AS numeric(18,4)),
[Avg Hours per Incident] = CAST(CASE WHEN #M.Incidents = 0 THEN 0 ELSE #M.[Lost Hours] / #M.Incidents END AS numeric(18,4)),
[Avg Hours per Person] = CAST(CASE WHEN #M.People = 0 THEN 0 ELSE #M.[Lost Hours] / #M.People END AS numeric(18,4)),
#M.[Incidents],
[Incidents per Person] = CAST(CASE WHEN #M.People = 0 THEN 0 ELSE #M.Incidents / #M.People END AS numeric(18,4)),
[Max Bradford Factor] = ISNULL((
	SELECT MAX(#E.B) FROM #E WHERE #E.ManagerID = #M.ManagerID
), 0)
INTO #R
FROM #M
LEFT JOIN dbo.vwPersonListAs M ON #M.ManagerID = M.PersonID

INSERT #R
SELECT
1,
0,
'Total Company',
CASE WHEN SUM([Working Hours]) = 0 THEN 0 ELSE 100 * SUM([Lost Hours]) / SUM([Working Hours]) END,
SUM([Lost Hours]) / 52,
CASE WHEN SUM(Incidents) = 0 THEN 0 ELSE SUM([Lost Hours]) / SUM(Incidents) END,
CASE WHEN SUM(People) = 0 THEN 0 ELSE SUM([Lost Hours]) / SUM(People) END,
SUM(Incidents),
CASE WHEN SUM(People) = 0 THEN 0 ELSE SUM(Incidents) / SUM(People) END,
ISNULL(( SELECT MAX(#E.B) FROM #E), 0)
FROM #M

-- Weeds out managers that the user does not have permisison to see and managers that have 0 incidents
INSERT TempX(BatchID, [ID])
SELECT @batch_id, EmployeeID FROM Employee WHERE [Terminated Day past 1900] IS NULL AND (@manager_id IS NULL OR ManagerID = @manager_id)

EXEC dbo.spPermissionGetOnPeopleForCurrentUser2 @batch_id, 10003
DELETE TempX WHERE BatchID = @batch_id AND (X & 1) = 0
SELECT @authorized = CASE WHEN @@ROWCOUNT = 0 THEN 1 ELSE 0 END

SELECT Manager,
[Percent Working Time Lost],
[Lost Hours per Week],
[Avg Hours per Incident],
[Avg Hours per Person],
Incidents,
[Incidents per Person],
[Max Bradford Factor]
FROM #R
WHERE [Order] = 1 OR (Incidents != 0 AND (@manager_id IS NULL OR ManagerID = @manager_id) AND EXISTS(
	SELECT * FROM Employee E
	INNER JOIN TempX X ON X.BatchID = @batch_id AND X.[ID] = E.EmployeeID AND E.ManagerID = #R.ManagerID
))
ORDER BY [Order], CASE WHEN @sort IN (1, 2, 3) THEN '' ELSE Manager END,
CASE @sort
	WHEN 1 THEN [Lost Hours per Week]
	WHEN 2 THEN [Incidents per Person]
	WHEN 3 THEN [Max Bradford Factor]
	ELSE 0
END DESC

DELETE TempX WHERE BatchID = @batch_id OR DATEDIFF(hh, Created, GETDATE()) > 1
GO
IF OBJECT_id('dbo.spEmployeeListInOutStatus') IS NOT NULL DROP PROC dbo.spEmployeeListInOutStatus
IF OBJECT_id('dbo.spEmployeeSelectInOutStatus') IS NOT NULL DROP PROC dbo.spEmployeeSelectInOutStatus
GO
CREATE PROC dbo.spEmployeeListInOutStatus
	@batch_id int,
	@in bit
AS
SET NOCOUNT ON
EXEC dbo.spPermissionGetOnPeopleForCurrentUser2 @batch_id, 50
SELECT V.*, 
[Mobile Phone] = ISNULL(W.[Mobile Phone], ''),
[Extended Work Phone] = ISNULL(W.[Extended Work Phone], ''),
[Work Phone] = ISNULL(W.[Work Phone], ''),
Extension = ISNULL(W.Extension, '')
FROM dbo.vwEmployeeUpdateInOutStatus V
INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID] = V.EmployeeID AND (X.X & 1) = 1 AND
(@in IS NULL OR (@in IS NOT NULL AND @in = [In])) 
LEFT JOIN dbo.vwPersonWork W ON W.PersonID=V.EmployeeID AND (dbo.fnPermissionGetOnPersonForCurrentUser(W.PersonID, 2) & 1) = 1
ORDER BY V.[List As]
DELETE dbo.TempX WHERE BatchID=@batch_id OR DATEDIFF(hh,Created,GETDATE()) > 1
GO
CREATE PROC dbo.spEmployeeSelectInOutStatus
	@employee_id int
AS
SET NOCOUNT ON
DECLARE @authorized bit
EXEC dbo.spPermissionInsureForCurrentUserOnPerson @employee_id, 50, 1, @authorized out
IF @authorized = 1 SELECT V.*,
[Mobile Phone] = ISNULL(W.[Mobile Phone], ''),
[Extended Work Phone] = ISNULL(W.[Extended Work Phone], ''),
[Work Phone] = ISNULL(W.[Work Phone], ''),
[Extension] = ISNULL(W.Extension, '')
FROM dbo.vwEmployeeUpdateInOutStatus V
LEFT JOIN dbo.vwPersonWork W ON V.EmployeeID=@employee_id AND W.PersonID=V.EmployeeID AND (dbo.fnPermissionGetOnPersonForCurrentUser(W.PersonID, 2) & 1) = 1
GO
GRANT EXEC ON dbo.spEmployeeListInOutStatus TO public
GRANT EXEC ON dbo.spEmployeeSelectInOutStatus TO public
GO
IF OBJECT_id('dbo.spPositionGetPositionFromPositionID') IS NOT NULL DROP PROC dbo.spPositionGetPositionFromPositionID
GO
CREATE PROC dbo.spPositionGetPositionFromPositionID @position_id int, @position varchar(50) OUT AS
SELECT @position = ''
SELECT @position = [Job Title] FROM Position WHERE PositionID = @position_id
GO
GRANT EXEC ON dbo.spPositionGetPositionFromPositionID TO public
GO

IF OBJECT_id('dbo.spPersonListPrepareBatchBOr') IS NOT NULL DROP PROC dbo.spPersonListPrepareBatchBOr
IF OBJECT_id('dbo.spPersonListPrepareBatchBAnd') IS NOT NULL DROP PROC dbo.spPersonListPrepareBatchBAnd
GO
CREATE PROC dbo.spPersonListPrepareBatchBOr
	@batch_id int,
	@benefit_id int,
	@field_id int,
	@operation int,
	@value sql_variant,
	@limit sql_variant
AS
DECLARE @t varchar(50)
DECLARE @i int
DECLARE @f bit
DECLARE @d datetime, @d2 datetime
DECLARE @x int, @y int
DECLARE @type sysname

SELECT @type = CAST(SQL_VARIANT_PROPERTY ( @value, 'BaseType' ) AS sysname), @t = null, @i= null, @f = null, @d = null, @d2 = null, @x = null, @y = null

IF @type IN ('varchar', 'nvarchar') SELECT @t = '%' + CAST(@value AS varchar(50)) + '%'
ELSE IF @type = 'int' SELECT @i = CAST(@value AS int)
ELSE IF @type = 'bit' SELECT @f = CAST(@value AS bit)
ELSE IF @type IN ('datetime', 'smalldatetime') SELECT @d = CAST(@value AS datetime)

IF @limit IS NOT NULL SET @d2 = CAST(@limit AS datetime)

SELECT @x = DATEDIFF(d, 0, @d), @y = DATEDIFF(d, 0, @d2)

-- Coverage = 1
IF @field_id = 1 INSERT TempX(BatchID, [ID])
SELECT DISTINCT @batch_id, EmployeeID FROM EmployeeBenefit EB WHERE EB.BenefitID = @benefit_id AND (
	(@operation = 4 AND EB.Coverage LIKE @t) OR
	(@operation = 8 AND EB.Coverage NOT LIKE @t)
)

-- Plan = 3,
ELSE IF @field_id = 3 INSERT TempX(BatchID, [ID])
SELECT DISTINCT @batch_id, EmployeeID FROM EmployeeBenefit EB WHERE EB.BenefitID = @benefit_id AND (
	(@operation = 4 AND EB.[Plan] LIKE @t) OR
	(@operation = 8 AND EB.[Plan] NOT LIKE @t)
)

-- Provider = 4,
ELSE IF @field_id = 4 INSERT TempX(BatchID, [ID])
SELECT DISTINCT @batch_id, EmployeeID FROM EmployeeBenefit EB WHERE EB.BenefitID = @benefit_id AND (
	(@operation = 4 AND EB.Provider LIKE @t) OR
	(@operation = 8 AND EB.Provider NOT LIKE @t)
)

-- Declined = 97,
ELSE IF @field_id = 97 INSERT TempX(BatchID, [ID])
SELECT DISTINCT @batch_id, EmployeeID FROM EmployeeBenefit EB WHERE EB.BenefitID = @benefit_id AND (
	(@operation=1 AND EB.[Declined Day past 1900] = @x) OR 
	(@operation=2 AND EB.[Declined Day past 1900] <> @x) OR
	(@operation=0x10 AND EB.[Declined Day past 1900] BETWEEN @x AND @y) OR
	(@operation=0x80 AND EB.[Declined Day past 1900] > @x) OR
	(@operation=0x100 AND EB.[Declined Day past 1900] >= @x) OR
	(@operation=0x20 AND EB.[Declined Day past 1900] < @x) OR
	(@operation=0x40 AND EB.[Declined Day past 1900] <= @x)
)

-- Eligible = 93,
ELSE IF @field_id = 93 INSERT TempX(BatchID, [ID])
SELECT DISTINCT @batch_id, EmployeeID FROM EmployeeBenefit EB WHERE EB.BenefitID = @benefit_id AND (
	(@operation=1 AND EB.[Eligible Day past 1900] = @x) OR 
	(@operation=2 AND EB.[Eligible Day past 1900] <> @x) OR
	(@operation=0x10 AND EB.[Eligible Day past 1900] BETWEEN @x AND @y) OR
	(@operation=0x80 AND EB.[Eligible Day past 1900] > @x) OR
	(@operation=0x100 AND EB.[Eligible Day past 1900] >= @x) OR
	(@operation=0x20 AND EB.[Eligible Day past 1900] < @x) OR
	(@operation=0x40 AND EB.[Eligible Day past 1900] <= @x)
)

-- Expires = 98,
ELSE IF @field_id = 98 INSERT TempX(BatchID, [ID])
SELECT DISTINCT @batch_id, EmployeeID FROM EmployeeBenefit EB WHERE EB.BenefitID = @benefit_id AND (
	(@operation=1 AND EB.[Expires Day past 1900] = @x) OR 
	(@operation=2 AND EB.[Expires Day past 1900] <> @x) OR
	(@operation=0x10 AND EB.[Expires Day past 1900] BETWEEN @x AND @y) OR
	(@operation=0x80 AND EB.[Expires Day past 1900] > @x) OR
	(@operation=0x100 AND EB.[Expires Day past 1900] >= @x) OR
	(@operation=0x20 AND EB.[Expires Day past 1900] < @x) OR
	(@operation=0x40 AND EB.[Expires Day past 1900] <= @x)
)

-- FirstEnrolled = 95,
ELSE IF @field_id = 95 INSERT TempX(BatchID, [ID])
SELECT DISTINCT @batch_id, EmployeeID FROM EmployeeBenefit EB WHERE EB.BenefitID = @benefit_id AND (
	(@operation=1 AND EB.[First Enrolled Day past 1900] = @x) OR 
	(@operation=2 AND EB.[First Enrolled Day past 1900] <> @x) OR
	(@operation=0x10 AND EB.[First Enrolled Day past 1900] BETWEEN @x AND @y) OR
	(@operation=0x80 AND EB.[First Enrolled Day past 1900] > @x) OR
	(@operation=0x100 AND EB.[First Enrolled Day past 1900] >= @x) OR
	(@operation=0x20 AND EB.[First Enrolled Day past 1900] < @x) OR
	(@operation=0x40 AND EB.[First Enrolled Day past 1900] <= @x)
)

-- LastEnrolled = 96,
ELSE IF @field_id = 96 INSERT TempX(BatchID, [ID])
SELECT DISTINCT @batch_id, EmployeeID FROM EmployeeBenefit EB WHERE EB.BenefitID = @benefit_id AND (
	(@operation=1 AND EB.[Last Enrolled Day past 1900] = @x) OR 
	(@operation=2 AND EB.[Last Enrolled Day past 1900] <> @x) OR
	(@operation=0x10 AND EB.[Last Enrolled Day past 1900] BETWEEN @x AND @y) OR
	(@operation=0x80 AND EB.[Last Enrolled Day past 1900] > @x) OR
	(@operation=0x100 AND EB.[Last Enrolled Day past 1900] >= @x) OR
	(@operation=0x20 AND EB.[Last Enrolled Day past 1900] < @x) OR
	(@operation=0x40 AND EB.[Last Enrolled Day past 1900] <= @x)
)

-- Notified = 94,
ELSE IF @field_id = 94 INSERT TempX(BatchID, [ID])
SELECT DISTINCT @batch_id, EmployeeID FROM EmployeeBenefit EB WHERE EB.BenefitID = @benefit_id AND (
	(@operation=1 AND EB.[Notified Day past 1900] = @x) OR 
	(@operation=2 AND EB.[Notified Day past 1900] <> @x) OR
	(@operation=0x10 AND EB.[Notified Day past 1900] BETWEEN @x AND @y) OR
	(@operation=0x80 AND EB.[Notified Day past 1900] > @x) OR
	(@operation=0x100 AND EB.[Notified Day past 1900] >= @x) OR
	(@operation=0x20 AND EB.[Notified Day past 1900] < @x) OR
	(@operation=0x40 AND EB.[Notified Day past 1900] <= @x)
)

-- EligibilityAndEnrollment = 99
ELSE IF @field_id = 99 INSERT TempX(BatchID, [ID])
SELECT DISTINCT @batch_id, EmployeeID FROM EmployeeBenefit EB WHERE EB.BenefitID = @benefit_id AND (
	(@operation=1 AND dbo.fnGetEnrollmentID(GETDATE(), EB.[Declined Day past 1900],EB.[Expires Day past 1900],EB.[First Enrolled Day past 1900],EB.[Last Enrolled Day past 1900],EB.[Eligible Day past 1900],EB.[Notified Day past 1900]) = @i) OR
	(@operation=2 AND dbo.fnGetEnrollmentID(GETDATE(), EB.[Declined Day past 1900],EB.[Expires Day past 1900],EB.[First Enrolled Day past 1900],EB.[Last Enrolled Day past 1900],EB.[Eligible Day past 1900],EB.[Notified Day past 1900]) <> @i)
)
GO
CREATE PROC dbo.spPersonListPrepareBatchBAnd
	@batch_id int,
	@benefit_id int,
	@field_id int,
	@operation int,
	@value sql_variant,
	@limit sql_variant
AS
DECLARE @t varchar(50)
DECLARE @i int
DECLARE @f bit
DECLARE @d datetime, @d2 datetime
DECLARE @x int, @y int
DECLARE @type sysname

SELECT @type = CAST(SQL_VARIANT_PROPERTY ( @value, 'BaseType' ) AS sysname), @t = null, @i= null, @f = null, @d = null, @d2 = null, @x = null, @y = null

IF @type IN ('varchar', 'nvarchar') SELECT @t = '%' + CAST(@value AS varchar(50)) + '%'
ELSE IF @type = 'int' SELECT @i = CAST(@value AS int)
ELSE IF @type = 'bit' SELECT @f = CAST(@value AS bit)
ELSE IF @type IN ('datetime', 'smalldatetime') SELECT @d = CAST(@value AS datetime)

IF @limit IS NOT NULL SET @d2 = CAST(@limit AS datetime)

SELECT @x = DATEDIFF(d, 0, @d), @y = DATEDIFF(d, 0, @d2)

-- Coverage = 1
IF @field_id = 1 DELETE TempX FROM TempX X 
INNER JOIN EmployeeBenefit EB ON X.BatchID = @batch_id AND X.[ID] = EB.EmployeeID AND EB.BenefitID=@benefit_id AND (
	(@operation = 4 AND EB.Coverage NOT LIKE @t) OR
	(@operation = 8 AND EB.Coverage LIKE @t)
)

-- Plan = 3,
ELSE IF @field_id = 3 DELETE TempX FROM TempX X 
INNER JOIN EmployeeBenefit EB ON X.BatchID = @batch_id AND X.[ID] = EB.EmployeeID AND EB.BenefitID=@benefit_id AND (
	(@operation = 4 AND EB.[Plan] NOT LIKE @t) OR
	(@operation = 8 AND EB.[Plan] LIKE @t)
)

-- Provider = 4,
ELSE IF @field_id = 4 DELETE TempX FROM TempX X 
INNER JOIN EmployeeBenefit EB ON X.BatchID = @batch_id AND X.[ID] = EB.EmployeeID AND EB.BenefitID=@benefit_id AND (
	(@operation = 4 AND EB.Provider NOT LIKE @t) OR
	(@operation = 8 AND EB.Provider LIKE @t)
)

-- Declined = 97,
ELSE IF @field_id = 97 DELETE TempX FROM TempX X 
INNER JOIN EmployeeBenefit EB ON X.BatchID = @batch_id AND X.[ID] = EB.EmployeeID AND EB.BenefitID=@benefit_id AND (
	(@operation=1 AND EB.[Declined Day past 1900] <> @x) OR 
	(@operation=2 AND EB.[Declined Day past 1900] = @x) OR
	(@operation=0x10 AND EB.[Declined Day past 1900] NOT BETWEEN @x AND @y) OR
	(@operation=0x80 AND EB.[Declined Day past 1900] <= @x) OR
	(@operation=0x100 AND EB.[Declined Day past 1900] < @x) OR
	(@operation=0x20 AND EB.[Declined Day past 1900] >= @x) OR
	(@operation=0x40 AND EB.[Declined Day past 1900] > @x)
)

-- Eligible = 93,
ELSE IF @field_id = 93 DELETE TempX FROM TempX X 
INNER JOIN EmployeeBenefit EB ON X.BatchID = @batch_id AND X.[ID] = EB.EmployeeID AND EB.BenefitID=@benefit_id AND (
	(@operation=1 AND EB.[Eligible Day past 1900] <> @x) OR 
	(@operation=2 AND EB.[Eligible Day past 1900] = @x) OR
	(@operation=0x10 AND EB.[Eligible Day past 1900] NOT BETWEEN @x AND @y) OR
	(@operation=0x80 AND EB.[Eligible Day past 1900] <= @x) OR
	(@operation=0x100 AND EB.[Eligible Day past 1900] < @x) OR
	(@operation=0x20 AND EB.[Eligible Day past 1900] >= @x) OR
	(@operation=0x40 AND EB.[Eligible Day past 1900] > @x)
)

-- Expires = 98,
ELSE IF @field_id = 98 DELETE TempX FROM TempX X 
INNER JOIN EmployeeBenefit EB ON X.BatchID = @batch_id AND X.[ID] = EB.EmployeeID AND EB.BenefitID=@benefit_id AND (
	(@operation=1 AND EB.[Expires Day past 1900] <> @x) OR 
	(@operation=2 AND EB.[Expires Day past 1900] = @x) OR
	(@operation=0x10 AND EB.[Expires Day past 1900] NOT BETWEEN @x AND @y) OR
	(@operation=0x80 AND EB.[Expires Day past 1900] <= @x) OR
	(@operation=0x100 AND EB.[Expires Day past 1900] < @x) OR
	(@operation=0x20 AND EB.[Expires Day past 1900] >= @x) OR
	(@operation=0x40 AND EB.[Expires Day past 1900] > @x)
)

-- FirstEnrolled = 95,
ELSE IF @field_id = 95 DELETE TempX FROM TempX X 
INNER JOIN EmployeeBenefit EB ON X.BatchID = @batch_id AND X.[ID] = EB.EmployeeID AND EB.BenefitID=@benefit_id AND (
	(@operation=1 AND EB.[First Enrolled Day past 1900] <> @x) OR 
	(@operation=2 AND EB.[First Enrolled Day past 1900] = @x) OR
	(@operation=0x10 AND EB.[First Enrolled Day past 1900] NOT BETWEEN @x AND @y) OR
	(@operation=0x80 AND EB.[First Enrolled Day past 1900] <= @x) OR
	(@operation=0x100 AND EB.[First Enrolled Day past 1900] < @x) OR
	(@operation=0x20 AND EB.[First Enrolled Day past 1900] >= @x) OR
	(@operation=0x40 AND EB.[First Enrolled Day past 1900] > @x)
)

-- LastEnrolled = 96,
ELSE IF @field_id = 96 DELETE TempX FROM TempX X 
INNER JOIN EmployeeBenefit EB ON X.BatchID = @batch_id AND X.[ID] = EB.EmployeeID AND EB.BenefitID=@benefit_id AND (
	(@operation=1 AND EB.[Last Enrolled Day past 1900] <> @x) OR 
	(@operation=2 AND EB.[Last Enrolled Day past 1900] = @x) OR
	(@operation=0x10 AND EB.[Last Enrolled Day past 1900] NOT BETWEEN @x AND @y) OR
	(@operation=0x80 AND EB.[Last Enrolled Day past 1900] <= @x) OR
	(@operation=0x100 AND EB.[Last Enrolled Day past 1900] < @x) OR
	(@operation=0x20 AND EB.[Last Enrolled Day past 1900] >= @x) OR
	(@operation=0x40 AND EB.[Last Enrolled Day past 1900] > @x)
)

-- Notified = 94,
ELSE IF @field_id = 94 DELETE TempX FROM TempX X 
INNER JOIN EmployeeBenefit EB ON X.BatchID = @batch_id AND X.[ID] = EB.EmployeeID AND EB.BenefitID=@benefit_id AND (
	(@operation=1 AND EB.[Notified Day past 1900] <> @x) OR 
	(@operation=2 AND EB.[Notified Day past 1900] = @x) OR
	(@operation=0x10 AND EB.[Notified Day past 1900] NOT BETWEEN @x AND @y) OR
	(@operation=0x80 AND EB.[Notified Day past 1900] <= @x) OR
	(@operation=0x100 AND EB.[Notified Day past 1900] < @x) OR
	(@operation=0x20 AND EB.[Notified Day past 1900] >= @x) OR
	(@operation=0x40 AND EB.[Notified Day past 1900] > @x)
)

-- EligibilityAndEnrollment = 99
ELSE IF @field_id = 99 DELETE TempX FROM TempX X 
INNER JOIN EmployeeBenefit EB ON X.BatchID = @batch_id AND X.[ID] = EB.EmployeeID AND EB.BenefitID=@benefit_id AND (
	(@operation=1 AND dbo.fnGetEnrollmentID(GETDATE(), EB.[Declined Day past 1900],EB.[Expires Day past 1900],EB.[First Enrolled Day past 1900],EB.[Last Enrolled Day past 1900],EB.[Eligible Day past 1900],EB.[Notified Day past 1900])<>@i) OR
	(@operation=2 AND dbo.fnGetEnrollmentID(GETDATE(), EB.[Declined Day past 1900],EB.[Expires Day past 1900],EB.[First Enrolled Day past 1900],EB.[Last Enrolled Day past 1900],EB.[Eligible Day past 1900],EB.[Notified Day past 1900])=@i)
)
GO
GRANT EXEC ON dbo.spPersonListPrepareBatchBOr TO public
GRANT EXEC ON dbo.spPersonListPrepareBatchBAnd TO public
GO
ALTER PROC dbo.spBenefitListPremiumsPerEmployee
	@batch_id int,
	@authorized bit OUT
AS
EXEC dbo.spPermissionGetOnPeopleForCurrentUser2 @batch_id, 536870912
DELETE TempX WHERE BatchID = @batch_id AND (X & 1) = 0
SELECT @authorized = CASE WHEN @@ROWCOUNT = 0 THEN 1 ELSE 0 END

SELECT Employee = P.[List As], [Employee Premium] = SUM(EB.[Employee Premium]), [Employer Premium] = SUM(EB.[Employer Premium])
FROM vwEmployeeBenefit EB
INNER JOIN TempX X ON X.BatchID = @batch_id AND EB.EmployeeID = X.[ID] AND (X.X & 1) = 1 AND (EB.[Employee Premium] != 0 OR EB.[Employer Premium] != 0)
INNER JOIN dbo.vwPersonListAs P ON EB.EmployeeID = P.PersonID
GROUP BY EB.EmployeeID, P.[List As]
ORDER BY P.[List As]

DELETE TempX WHERE BatchID = @batch_id OR DATEDIFF(hh, Created, GETDATE()) > 1
GO
ALTER PROC dbo.spBenefitListPremiumsPerProviderPlan
	@batch_id int,
	@authorized bit OUT
AS
EXEC dbo.spPermissionGetOnPeopleForCurrentUser2 @batch_id, 536870912
DELETE TempX WHERE BatchID = @batch_id AND (X & 1) = 0
SELECT @authorized = CASE WHEN @@ROWCOUNT = 0 THEN 1 ELSE 0 END

SELECT Provider = CASE WHEN LEN(EB.Provider) = 0 THEN '<Unspecified>' ELSE EB.Provider END, 
[Plan] = CASE WHEN LEN(EB.[Plan]) = 0 THEN '<Unspecified>' ELSE EB.[Plan] END, 
[Employee Premium] = SUM(EB.[Employee Premium]), [Employer Premium] = SUM(EB.[Employer Premium])
FROM dbo.TempX X 
INNER JOIN dbo.Employee E ON X.BatchID = @batch_id AND E.EmployeeID = X.[ID]
INNER JOIN dbo.vwEmployeeBenefit EB ON EB.EmployeeID = E.EmployeeID AND (EB.[Employee Premium] != 0 OR EB.[Employer Premium] != 0)
GROUP BY EB.[Provider], EB.[Plan]
ORDER BY EB.[Provider], EB.[Plan]

DELETE dbo.TempX WHERE BatchID = @batch_id OR DATEDIFF(hh, Created, GETDATE()) > 1
GO
IF OBJECT_id('dbo.spPositionInactivate') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spPositionInactivate AS'
GO
ALTER PROC dbo.spPositionInactivate
	@position_id int
AS
UPDATE dbo.Position SET [Active] = 0 WHERE PositionID = @position_id
GO
IF OBJECT_id('dbo.spPositionUpdate') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spPositionUpdate AS'
GO
ALTER PROC dbo.spPositionUpdate
	@position_id int,
	@category_id int,
	@status_id int,
	@fte numeric(9,4),
	@job_title varchar(50),
	@pay_grade_id int,
	@note varchar(2000),
	@job_description varchar(2000),
	@active bit,
	@workers_comp_code varchar(50),
	@other_compensation varchar(2000),
	@flsa_exempt bit = NULL, -- Depricated v67
	@flsa_id int = NULL, -- Added v67
	@seconds_per_week int = 144000, -- Added v95
	@position_number varchar(50) = '' -- Added v109
AS
IF @flsa_id IS NULL SELECT TOP 1 @flsa_id = FLSAID FROM FLSA WHERE Exempt = @flsa_exempt

UPDATE Position SET 
	CategoryID = @category_id,
	StatusID = @status_id,
	FTE = @fte,
	[Job Title] = @job_title,
	PayGradeID = @pay_grade_id,
	[Job Description] = @job_description,
	Note = @note,
	Active = @active,
	FLSAID = @flsa_id,
	[Workers Comp Code] = @workers_comp_code,
	[Other Compensation] = @other_compensation,
	[Seconds per Week] = @seconds_per_week,
	[Position Number] = @position_number
WHERE PositionID = @position_id
GO
IF OBJECT_id('dbo.spPositionInsert') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spPositionInsert AS'
GO
ALTER PROC dbo.spPositionInsert
	@category_id int,
	@status_id int,
	@fte numeric(9,4),
	@job_title varchar(50),
	@pay_grade_id int,
	@note varchar(2000),
	@job_description varchar(2000),
	@active bit,
	@workers_comp_code varchar(50),
	@other_compensation varchar(2000),
	@position_id int OUT,
	@flsa_exempt bit = NULL, -- Depricated v67
	@flsa_id int = NULL, -- Added v67
	@seconds_per_week int = 144000, -- Added v95
	@position_number varchar(50) = '' -- Added v109
AS
IF @flsa_id IS NULL SELECT TOP 1 @flsa_id = FLSAID FROM FLSA WHERE Exempt = @flsa_exempt

INSERT Position(CategoryID, StatusID,  FTE, [Job Title], PayGradeID, Note, Active, [Job Description], FLSAID, [Workers Comp Code], [Other Compensation], [Seconds per Week], [Position Number]) 
VALUES(@category_id, @status_id, @fte, @job_title, @pay_grade_id, @note, @active, @job_description, @flsa_id, @workers_comp_code, @other_compensation, @seconds_per_week, @position_number)
SELECT @position_id = SCOPE_IDENTITY()
GO
ALTER PROC dbo.spEmployeeLeaveUsedItemUpdate
	@type_id int,
	@day int,
	@seconds int,
	@item_id int,
	@advanced_type_mask int = NULL, -- Added v59. Looked up from EmployeeLeaveUsed if NULL
	@ppe int = NULL
AS
DECLARE @authorized bit, @audit_unauthorized_attempt bit, @audit_operation bit, @status tinyint
DECLARE @employee_id int, @old_hours numeric(9,2)

-- Requires write permission on Employee Leave and Tardiness Detail
SELECT @status = @status, @old_hours = I.Seconds / 3600.0, @employee_id = U.EmployeeID, @advanced_type_mask = CASE WHEN @advanced_type_mask IS NULL THEN U.[Advanced Type Mask] ELSE @advanced_type_mask END 
FROM EmployeeLeaveUsedItem I INNER JOIN EmployeeLeaveUsed U ON I.ItemID=@item_id AND I.LeaveID=U.LeaveID

EXEC dbo.spPermissionInsureForCurrentUserOnPerson4 @employee_id, @status, @employee_id, @status, 1, 10001, 10013, @authorized out
EXEC dbo.spAuditGetOperation 10001, 2, @audit_operation OUT, @audit_unauthorized_attempt OUT

IF @authorized = 1
BEGIN
	UPDATE EmployeeLeaveUsedItem SET [PPE Day past 1900]=CASE WHEN @ppe IS NULL THEN [PPE Day past 1900] ELSE @ppe END, TypeID=@type_id, [Day past 1900]=@day, Seconds=@seconds, [Advanced Type Mask]=@advanced_type_mask WHERE ItemID = @item_id
END
ELSE IF @audit_unauthorized_attempt=1 EXEC dbo.spAuditTrailInsert @employee_id, @item_id, 10001, 18, 'Unauthorized attempt to update leave item', 10002
GO
IF OBJECT_id('dbo.spEmployeeLeaveUsedItemInsert') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEmployeeLeaveUsedItemInsert AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spEmployeeLeaveUsedItemInsert TO public'
END
GO
ALTER PROC dbo.spEmployeeLeaveUsedItemInsert
	@leave_id int,
	@type_id int,
	@day int,
	@seconds int,
	@item_id int out,
	@advanced_type_mask int = NULL, -- Added v59. Looked up from EmployeeLeaveUsed if NULL
	@ppe int = NULL
AS
DECLARE @old_item_id int, @employee_id int, @status tinyint
DECLARE @authorized bit, @audit_unauthorized_attempt bit, @audit_operation bit

IF @ppe IS NULL 
BEGIN
	DECLARE @ppe_date datetime, @now datetime
	SELECT @now = DATEADD(second, [Payroll PPE Offset Seconds], GETDATE()) FROM dbo.Constant
	
	IF dbo.GetDateFromDaysPast1900(@day) > @now SET @ppe_date = dbo.GetDateFromDaysPast1900(@day)
	ELSE SET @ppe_date = @now
	CREATE TABLE #T_20110506(StartDate datetime, StopDate datetime)
	INSERT #T_20110506
	EXEC dbo.spEmployeeTimeCalculateFilterInverse @ppe_date, 1
	SELECT TOP 1 @ppe = DATEDIFF(d,0,StopDate) FROM #T_20110506
END
SELECT @employee_id = U.EmployeeID, @status=Status, @advanced_type_mask = CASE WHEN @advanced_type_mask IS NULL THEN U.[Advanced Type Mask] ELSE @advanced_type_mask END FROM EmployeeLeaveUsed U WHERE U.LeaveID = @leave_id

-- Requires insert permission on Employee Leave and Tardiness Detail
EXEC dbo.spPermissionInsureForCurrentUserOnPerson4 @employee_id, @status, NULL, NULL, 1, 10001, 10013, @authorized out
EXEC dbo.spAuditGetOperation 10001, 4, @audit_operation OUT, @audit_unauthorized_attempt OUT

IF @authorized = 1
BEGIN
	INSERT EmployeeLeaveUsedItem(LeaveID, TypeID, [Day past 1900], [PPE Day past 1900], Seconds, [Advanced Type Mask])
	VALUES(@leave_id, @type_id, @day, @ppe, @seconds, @advanced_type_mask)
	SELECT @item_id = SCOPE_IDENTITY()
END
ELSE IF @audit_unauthorized_attempt=1 EXEC dbo.spAuditTrailInsert @employee_id, NULL, 10001, 20, 'Unauthorized attempt to change leave', 10002
GO
IF OBJECT_id('dbo.spLeaveProjectIntoFuture') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spLeaveProjectIntoFuture AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spLeaveProjectIntoFuture TO public'
END
GO
ALTER PROC dbo.spLeaveProjectIntoFuture
	@employee_id int,
	@type_id int,
	@start_day int,
	@seconds_per_day int,
	@return_records bit = 0,

	@all_available bit = 1,
	@max_day int = 0x7FFFFFFF,
	@max_used_seconds int = 0x7FFFFFFF,

	@stop_day int = 0 out,
	@used_seconds int = 0 out,
	@authorized bit = 0 out
AS
SET NOCOUNT ON

DECLARE @unused_seconds int, @holiday_concurrent bit, @rolling_seconds int, @rolling_days int, @banked_type bit, @shift_off_concurrent bit
SELECT @rolling_days = 0, @used_seconds = 0, @stop_day = @start_day - 1
SELECT @holiday_concurrent = [Holiday Concurrent], @banked_type = Bank, @shift_off_concurrent = [Shift Off Concurrent] FROM LeaveType WHERE TypeID=@type_id

IF @shift_off_concurrent=0 AND EXISTS(SELECT * FROM dbo.LeaveTypeShift LTS INNER JOIN dbo.Employee E ON LTS.TypeID=@type_id AND E.EmployeeID=@employee_id AND LTS.ShiftID=E.ShiftID AND (LTS.Flags & 1) = 1) SET @shift_off_concurrent = 1
ELSE IF @shift_off_concurrent=1 AND EXISTS(SELECT * FROM dbo.LeaveTypeShift LTS INNER JOIN dbo.Employee E ON LTS.TypeID=@type_id AND E.EmployeeID=@employee_id AND LTS.ShiftID=E.ShiftID AND (LTS.Flags & 2) = 2) SET @shift_off_concurrent = 0

IF @banked_type = 0 SET @all_available = 0
IF @return_records = 1 CREATE TABLE #DaysOff([Day past 1900] int, Seconds int)

-- Gets holidays that cover a full week. Used for FMLA exception
DECLARE @year_start int, @year_stop int
SET @year_start = YEAR(dbo.GetDateFromDaysPast1900(@start_day))
IF @max_day < @start_day + 730 SET @year_stop = YEAR(dbo.GetDateFromDaysPast1900(@max_day))
ELSE SET @year_stop = @year_start + 2



EXEC dbo.spPermissionInsureForCurrentUserOnPerson @employee_id, 128, 1, @authorized out
IF @authorized = 1
BEGIN

	IF @all_available = 1
	BEGIN
		-- Special case: rolling year (38914)
		-- Identify which people have plans of this type that include rolling years as of start_day
		SELECT @rolling_seconds = [Effective Seconds] FROM dbo.vwEmployeeLeavePlanLeaveRate
		WHERE EmployeeID = @employee_id AND TypeID = @type_id AND PeriodID = 38914 AND
		@start_day >= [Start Day past 1900] AND (@start_day <= [Stop Day past 1900] OR [Stop Day past 1900] IS NULL) AND
		DATEDIFF(mm, [Seniority Begins Day past 1900], DATEADD(d,@start_day,0)) BETWEEN [Start Month] AND [Stop Month]

		IF @@ROWCOUNT != 0 SELECT @rolling_days = 364
		ELSE
		BEGIN
			-- Special case: rolling 24 months (2049)
			-- Identify which people have plans of this type that include rolling 24 months as of day
			SELECT @rolling_seconds = [Effective Seconds] FROM dbo.vwEmployeeLeavePlanLeaveRate R WHERE
			EmployeeID = @employee_id AND TypeID = @type_id AND PeriodID = 2049 AND
			@start_day >= [Start Day past 1900] AND (@start_day <= [Stop Day past 1900] OR [Stop Day past 1900] IS NULL) AND
			DATEDIFF(mm, R.[Seniority Begins Day past 1900], DATEADD(d,@start_day,0)) BETWEEN R.[Start Month] AND R.[Stop Month]

			IF @@ROWCOUNT != 0 SELECT @rolling_days = 729
		END
	END

	IF @rolling_days > 0 -- which only happens when @all_available = 1
	BEGIN
		SELECT @unused_seconds = @rolling_seconds - ISNULL(SUM(I.[Seconds]), 0)
		FROM dbo.vwEmployeeLeaveUsedItemApproved I WHERE I.[Day past 1900] BETWEEN (@start_day - @rolling_days) AND (@start_day - 1) AND  EmployeeID = @employee_id AND ([Extended Type Mask] & @type_id) = @type_id
	END
	ELSE
	IF @all_available=0 SELECT @unused_seconds = @max_used_seconds
	ELSE
	BEGIN
		DECLARE @accumulated_day int, @accumulated int, @limit_day int

		-- Calculate Accumulated
		SELECT @accumulated_day = (
			SELECT MAX(U.[Day past 1900]) FROM EmployeeLeaveUnused U WHERE U.[Day past 1900] <= @start_day AND U.EmployeeID =  @employee_id AND U.TypeID = @type_id
		),
		@accumulated = 0,
		@unused_seconds = NULL,
		@limit_day = NULL

		SELECT @limit_day = ISNULL(MIN(E.[Day past 1900]), 2147483647) FROM dbo.vwEmployeeLeaveEarned E 
		WHERE E.[Day past 1900] > @start_day AND E.EmployeeID = @employee_id AND E.TypeID = @type_id AND E.[Limit Adjustment] = 1


		SELECT @accumulated = U.Unused
		FROM dbo.EmployeeLeaveUnused U WHERE U.EmployeeID = @employee_id AND U.TypeID = @type_id AND U.[Day past 1900] =  @accumulated_day

		-- Calculate available
		SELECT @unused_seconds = MIN(U.Unused) FROM EmployeeLeaveUnused U 
		WHERE U.EmployeeID = @employee_id AND U.TypeID = @type_id AND U.[Day past 1900] >= @start_day AND U.[Day past 1900] < @limit_day


		SELECT @unused_seconds = @accumulated WHERE @unused_seconds IS NULL OR @unused_seconds > @accumulated
	END

	IF @unused_seconds > @max_used_seconds SET @unused_seconds = @max_used_seconds

	DECLARE @day int, @shift_id int, @shift_start_day int, @dayson int, @daysoff int, @dayson2 int, @daysoff2 int
	
	SELECT @day = @start_day
	SELECT @shift_id=S.ShiftID,@shift_start_day=S.[Start Day past 1900],@dayson=S.[Days On],@daysoff=S.[Days Off],@dayson2=S.DaysOn2,@daysoff2=S.DaysOff2
	FROM dbo.Employee E INNER JOIN dbo.Shift S ON E.EmployeeID=@employee_id AND S.ShiftID=E.ShiftID

	EXEC dbo.spHolidayRecalc @force_recalc = 0, @start_day = @start_day
	
	WHILE @day <= @start_day + 730 AND @unused_seconds > 0 AND @day <= @max_day
	BEGIN
		DECLARE @shift_on bit, @holidays int, @shift_seconds int

		-- Skip days where employee wouldn't normally work like weekends and holidays
		SELECT @holidays = 1, @shift_on = 0, @shift_seconds = @seconds_per_day
		WHILE (@holidays > 0 OR @shift_on = 0) AND @day <= @max_day and @day <= @start_day + 730
		BEGIN
			DECLARE @monthNum int, @dayNum int, @yearNum int
			SELECT @monthNum = MONTH(@day), @dayNum = DAY(@day), @yearNum = YEAR(@day), @holidays = 0, @shift_on = 1

			SELECT @holidays = COUNT(*) From dbo.HolidayCalculated H
			INNER JOIN dbo.Employee E ON E.EmployeeID=@employee_id AND E.HolidayPlanID = H.PlanID AND 
			dbo.GetDateFromMDY(@monthNum,@dayNum,@yearNum) BETWEEN H.X AND H.Y AND (@holiday_concurrent = 0 OR H.[Week] = 1)

			-- Includes start/stop dates even if shift expires
			
			IF @shift_off_concurrent=1 SET @shift_on = 1
			ELSE IF @holidays=0 
			BEGIN
				SET @shift_seconds = dbo.fnGetShiftLengthSecondsForDay(@day, @shift_id, @shift_start_day, @dayson, @daysoff, @dayson2, @daysoff2)
				SELECT @shift_on = CASE WHEN @shift_seconds <=0 THEN 0 ELSE 1 END
			END



			IF @holidays>0 OR @shift_on=0 SELECT @day = @day + 1
		END

		IF @day <= @max_day
		BEGIN
			DECLARE @seconds int
			SELECT @seconds = CASE WHEN @unused_seconds >= @shift_seconds THEN @shift_seconds ELSE @unused_seconds END
			SELECT @stop_day = @day, @used_seconds = @used_seconds + @seconds

			IF @return_records = 1 INSERT #DaysOff VALUES (@day, @seconds)

			IF @rolling_days > 0 AND @max_used_seconds = 0x7FFFFFFF
			BEGIN
				SELECT @unused_seconds = @rolling_seconds - @used_seconds - ISNULL(SUM(I.[Seconds]), 0)
				FROM dbo.vwEmployeeLeaveUsedItemApproved I WHERE I.[Day past 1900] BETWEEN (@start_day - @rolling_days) AND (@start_day - 1) AND  EmployeeID = @employee_id AND ([Extended Type Mask] & @type_id) = @type_id
			END
			ELSE SELECT @unused_seconds = @unused_seconds - @seconds

			SELECT @day = @day + 1
		END
	END
END

IF @return_records = 1 SELECT DISTINCT * FROM #DaysOff
GO
IF OBJECT_id('dbo.spLeaveGetLastEarnedDay') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spLeaveGetLastEarnedDay AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spLeaveGetLastEarnedDay TO public'
END
GO
ALTER PROC dbo.spLeaveGetLastEarnedDay
	@employee_id int,
	@type_id int,
	@start_day int,
	@stop datetime out
AS
DECLARE @shift_length int, @stop_day int
SELECT @shift_length = [Effective Seconds per Day] FROM vwEmployeeEffectiveSecondsPerDay WHERE EmployeeID=@employee_id
EXEC dbo.spLeaveProjectIntoFuture @employee_id=@employee_id, @type_id=@type_id, @start_day=@start_day, @seconds_per_day=@shift_length, @stop_day=@stop_day out
SELECT @stop = dbo.GetDateFromDaysPast1900(@stop_day)
GO
IF OBJECT_id('dbo.spLeaveProjectIntoFuture2') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spLeaveProjectIntoFuture2 AS SELECT A=0'
GO
ALTER PROC dbo.spLeaveProjectIntoFuture2
	@employee_id int,
	@type_batch_id int,
	@start_day int,
	@seconds_per_day int,
	@default_type_id int,

	@all_available bit = 1,
	@max_day int = 0x7FFFFFFF,
	@max_used_seconds int = 0x7FFFFFFF,

	@authorized bit = 0 out
AS
SET NOCOUNT ON

SET @authorized = 1
CREATE TABLE #Projection([Day past 1900] int, Seconds int, TypeID int DEFAULT -1, [Advanced Type Mask] int DEFAULT -1, ItemID int PRIMARY KEY IDENTITY (1,1), X int DEFAULT NULL)

DECLARE @type_id int, @advanced bit, @item_id int

DECLARE t_cursor CURSOR LOCAL FORWARD_ONLY STATIC FOR SELECT T.TypeID, T.Advanced FROM dbo.vwLeaveType T
INNER JOIN TempX X ON X.BatchID = @type_batch_id AND X.[ID] = T.TypeID ORDER BY T.Advanced 

OPEN t_cursor
FETCH t_cursor INTO @type_id, @advanced

WHILE @@FETCH_STATUS=0
BEGIN
	SELECT @item_id = MAX(ItemID) FROM #Projection

	INSERT #Projection([Day past 1900], Seconds)
	EXEC dbo.spLeaveProjectIntoFuture @employee_id=@employee_id, @type_id=@type_id, @start_day=@start_day, @seconds_per_day=@seconds_per_day, 
		@return_records=1, @all_available=@all_available, @max_day=@max_day, @max_used_seconds=@max_used_seconds, @authorized=@authorized out
	
	UPDATE #Projection SET [Advanced Type Mask] = 0,
	TypeID = CASE WHEN @advanced=0 THEN @type_id ELSE 0 END WHERE TypeID = -1

	UPDATE #Projection SET [Advanced Type Mask] = [Advanced Type Mask] | @type_id WHERE @advanced = 1 AND (@item_id IS NULL OR ItemID > @item_id)

	FETCH t_cursor INTO @type_id, @advanced
END

CLOSE t_cursor
DEALLOCATE t_cursor

DELETE TempX WHERE BatchID=@type_batch_id OR DATEDIFF(hour,Created,GETDATE()) > 1

DECLARE @rows int
SELECT @rows = 1

WHILE @rows > 0
BEGIN
	UPDATE P SET [Advanced Type Mask] = P.[Advanced Type Mask] | P2.[Advanced Type Mask]
	FROM #Projection P INNER JOIN #Projection P2 ON P.X = P2.ItemID

	DELETE #Projection FROM #Projection P2 WHERE P2.ItemID IN (SELECT P.X FROM #Projection P)

	UPDATE P SET X = (
		SELECT TOP 1 ItemID FROM #Projection P2 WHERE P2.TypeID = P.TypeID AND P2.[Day past 1900] = P.[Day past 1900] AND P.Seconds = P2.Seconds AND P.ItemID < P2.ItemID ORDER BY P2.ItemID
	) FROM #Projection P
	
	SELECT @rows = COUNT(*) FROM #Projection WHERE X IS NOT NULL

	IF @rows = 0
	BEGIN
		UPDATE P SET X = (
			SELECT TOP 1 ItemID FROM #Projection P2 WHERE P2.TypeID = 0 AND P2.[Day past 1900] = P.[Day past 1900] AND P.Seconds = P2.Seconds AND P.ItemID < P2.ItemID ORDER BY P2.ItemID
		) FROM #Projection P

		SELECT @rows = COUNT(*) FROM #Projection WHERE X IS NOT NULL
	END
END

UPDATE #Projection SET TypeID = @default_type_id WHERE TypeID = 0

DECLARE @max_date datetime, @min_date datetime, @current_ppe datetime
DECLARE @min_period int, @max_period int, @periods int
SELECT @min_date = GETDATE(), @max_date = dbo.GetDateFromDaysPast1900(MAX([Day past 1900])) FROM #Projection
SELECT @min_period = dbo.GetPayrollPeriodNumber(@min_date), @max_period = dbo.GetPayrollPeriodNumber(@max_date)
SET @periods = @max_period - @min_period + 1
IF @periods < 1 SET @periods = 1
CREATE TABLE #PayrollPeriod(StartDate datetime, StopDate datetime)
INSERT #PayrollPeriod
EXEC dbo.spEmployeeTimeCalculateFilterInverse @min_date, @periods

SELECT @current_ppe = MIN(StopDate) FROM #PayrollPeriod

SELECT P.[Day past 1900], [Date] = dbo.GetDateFromDaysPast1900(P.[Day past 1900]), 
P.Seconds, P.TypeID, P.[Advanced Type Mask], 
[PPE] = ISNULL(Payroll.[StopDate], @current_ppe)
FROM #Projection P
LEFT JOIN #PayrollPeriod Payroll ON dbo.GetDateFromDaysPast1900(P.[Day past 1900]) BETWEEN Payroll.[StartDate] AND Payroll.[StopDate]
ORDER BY [Day past 1900]
GO
GRANT EXEC ON dbo.spLeaveProjectIntoFuture2 TO public
GO
ALTER PROC dbo.[spPersonXUpdate]
	@person_id int,
	@race_id int,
	@i9_status_id int,
	@ssn varchar(50),
	@renew_i9_status int,
	@country_of_citizenship varchar(50),
	@visa varchar(50),
	@visa_expires int,
	@passport varchar(50),
	@passport_expires int,
	@dob int,
	@driver_license varchar(50),
	@driver_license_state varchar(50),
	@driver_license_expires int,
	@driver_insurance_expires int,
	@cdl bit,
	@marital_status_id int,
	@dependents int,
	@disabled bit,
	@smoker bit,
	@military_branch_id int,
	@reserves bit,
	@spouse varchar(50),
	@children varchar(50),
	@driver_license_class varchar(50) = '',
	@visa_status_id int = null
AS
DECLARE @authorized bit
DECLARE @result int

SET NOCOUNT ON

EXEC @result = spSSNClean @ssn out

EXEC dbo.spPermissionInsureForCurrentUserOnPerson @person_id, 4, 2, @authorized out
IF @authorized = 1 AND @result = 0
UPDATE PersonX SET
	RaceID = @race_id,
	I9StatusID = @i9_status_id,
	SSN = @ssn,
	[Renew I9 Status Day past 1900] = @renew_i9_status,
	[Country of Citizenship] = @country_of_citizenship,
	Visa = @visa,
	[Visa Expires Day past 1900] = @visa_expires,
	VisaStatusID = @visa_status_id,
	Passport = @passport,
	[Passport Expires Day past 1900] = @passport_expires,
	[DOB Day past 1900] = @dob,
	[Driver License] = @driver_license,
	[Driver License State] = @driver_license_state,
	[Driver License Expires Day past 1900] = @driver_license_expires,
	[Driver Insurance Expires Day past 1900] = @driver_insurance_expires,
	[Commercial Driver License] = @cdl,
	MaritalStatusID = @marital_status_id,
	Dependents = @dependents,
	Disabled = @disabled,
	Smoker = @smoker,
	MilitaryBranchID = @military_branch_id,
	Reserves = @reserves,
	Spouse = @spouse,
	Children = @children,
	[Driver License Class] = @driver_license_class
WHERE PersonID = @person_id
ELSE
	EXEC dbo.spErrorRaise @result
GO
ALTER PROC dbo.spPersonUpdateColumnVariant
	@person_id int,
	@field_id int,
	@value sql_variant,
	@authorized bit = NULL out
AS
DECLARE @error int
DECLARE @sql nvarchar(4000)
DECLARE @type int
DECLARE @length int

SELECT @type = S.xtype, @length = S.length
FROM ColumnGrid C
INNER JOIN dbo.syscolumns S ON C.FieldID = @field_id AND S.[id] = OBJECT_id(C.[Table]) AND S.colid = C.colid

IF @@ROWCOUNT = 0 SET @error = 50017
ELSE
BEGIN
	EXEC dbo.spPersonUpdateColumnBase @person_id, @field_id, NULL, NULL, @sql out, @authorized out, @error out

	IF @error = 0 AND @authorized = 1 
	BEGIN
		DECLARE @tvalue varchar(4000)
		DECLARE @ivalue int
		SELECT @tvalue = CAST(@value as varchar(4000))

		IF @type = 108
		BEGIN
			DECLARE @nvalue numeric(38,9)
			SELECT @nvalue = CAST(@value AS numeric(38,9))
			EXEC dbo.spExecSQLAsDBONumeric @sql, @nvalue, @person_id
		END
		ELSE IF @type = 104
		BEGIN
			DECLARE @bvalue bit
			IF LOWER(@tvalue) IN ('true','t','on','yes','active') SET @bvalue = 1
			ELSE IF LOWER(@tvalue) IN ('false','f','off','no','inactive') SET @bvalue = 0
			ELSE SELECT @bvalue = CAST(@value as bit)
			EXEC dbo.spExecSQLAsDBOBit @sql, @bvalue, @person_id
		END
		-- Value is a date that gets stored as days past 1900
		ELSE IF @type = 56 AND @sql LIKE '%day past%'
		BEGIN
			DECLARE @dvalue datetime
			SET @tvalue = RTRIM(LTRIM(@tvalue))
			IF @tvalue = '' OR @tvalue='00000000' OR @tvalue='0000000000' 
				EXEC dbo.spExecSQLAsDBOInt @sql, NULL, @person_id
			ELSE
			BEGIN
				IF @tvalue LIKE '[0123456789][0123456789][0123456789][0123456789][0123456789][0123456789][0123456789][0123456789]' 
					SET @tvalue = SUBSTRING(@tvalue, 1, 4) + '-' + SUBSTRING(@tvalue, 5, 2) + '-' + SUBSTRING(@tvalue, 7, 2)
				
				IF @tvalue LIKE '%[^0123456789. ]%' 
				BEGIN
					
					SELECT @dvalue = CAST(@value as datetime)
					SELECT @ivalue = DATEDIFF(D, 0, @dvalue)
					IF @ivalue = 0 SET @ivalue=NULL
					EXEC dbo.spExecSQLAsDBOInt @sql, @ivalue, @person_id
				END
				ELSE
				BEGIN
					SELECT @ivalue = CAST(@value as int)
					EXEC dbo.spExecSQLAsDBOInt @sql, @ivalue, @person_id
				END
			END
		END 
		ELSE IF @type = 56 
		BEGIN
			SELECT @ivalue = CAST(@value as int)
			EXEC dbo.spExecSQLAsDBOInt @sql, @ivalue, @person_id
		END
		ELSE IF @type = 60
		BEGIN
			DECLARE @mvalue money
			SELECT @mvalue = CAST(@value as money)
			EXEC dbo.spExecSQLAsDBOMoney @sql, @mvalue, @person_id
		END
		ELSE IF @type = 167 AND @field_id = 33
		BEGIN
			DECLARE @ssn varchar(50)
			SET @ssn = dbo.NormalizeSSN(@tvalue)
			EXEC dbo.spExecSQLAsDBOvarchar50  @sql, @ssn, @person_id
		END
		ELSE IF @type = 167 AND @length = 50
		BEGIN
			SET @tvalue = SUBSTRING(@tvalue, 1, 50)
			EXEC dbo.spExecSQLAsDBOvarchar50 @sql, @tvalue, @person_id
		END
		ELSE IF @type = 167 EXEC dbo.spExecSQLAsDBOvarchar4000 @sql, @tvalue, @person_id
		ELSE IF @type = 35 EXEC dbo.spExecSQLAsDBOtext @sql, @tvalue, @person_id
		ELSE SET @error = 50017
	END
END

IF @error <>0 EXEC dbo.spErrorRaise @error
GO
IF OBJECT_id('dbo.spProjectList') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spProjectList AS'
GO
ALTER PROC dbo.spProjectList
	@project_manager_id int = NULL,
	@active bit = NULL,
	@location_id int = NULL,
	@pay_rate_not_null bit = NULL,
	@pay_rate_min smallmoney = NULL,
	@pay_rate_max smallmoney = NULL,
	@billing_rate_not_null bit = NULL,
	@billing_rate_min smallmoney = NULL,
	@billing_rate_max smallmoney = NULL,
	@class_id int = NULL, -- v54
	@fixed_pay_not_null bit = NULL, -- v58
	@fixed_pay_min smallmoney = NULL, -- v58
	@fixed_pay_max smallmoney = NULL, -- v58
	@fixed_billing_not_null bit = NULL, -- v58
	@fixed_billing_min smallmoney = NULL, -- v58
	@fixed_billing_max smallmoney = NULL -- v58
AS
SET NOCOUNT ON
SELECT * FROM dbo.vwProject WHERE 
(@class_id IS NULL OR @class_id = ClassID) AND
(@active IS NULL OR @active = Active) AND
(@project_manager_id IS NULL OR @project_manager_id = ProjectManagerID) AND
(@location_id IS NULL OR @location_id = LocationID) AND
(@pay_rate_not_null IS NULL OR
	(@pay_rate_not_null = 0 AND [Pay Rate] IS NULL) OR
	(@pay_rate_not_null = 1 AND @pay_rate_min IS NULL AND [Pay Rate] IS NOT NULL) OR
	(@pay_rate_not_null = 1 AND [Pay Rate] BETWEEN @pay_rate_min AND @pay_rate_max)
) AND
(@billing_rate_not_null IS NULL OR
	(@billing_rate_not_null = 0 AND [Billing Rate] IS NULL) OR
	(@billing_rate_not_null = 1 AND @billing_rate_min IS NULL AND [Billing Rate] IS NOT NULL) OR
	(@billing_rate_not_null = 1 AND [Billing Rate] BETWEEN @billing_rate_min AND @billing_rate_max)
) AND
(@fixed_billing_not_null IS NULL OR
	(@fixed_billing_not_null = 0 AND [Fixed Billing] IS NULL) OR
	(@fixed_billing_not_null = 1 AND @fixed_billing_min IS NULL AND [Fixed Billing] IS NOT NULL) OR
	(@fixed_billing_not_null = 1 AND [Fixed Billing] BETWEEN @fixed_billing_min AND @fixed_billing_max)
) AND
(@fixed_pay_not_null IS NULL OR
	(@fixed_pay_not_null = 0 AND [Fixed Pay] IS NULL) OR
	(@fixed_pay_not_null = 1 AND @fixed_pay_min IS NULL AND [Fixed Pay] IS NOT NULL) OR
	(@fixed_pay_not_null = 1 AND [Fixed Pay] BETWEEN @fixed_pay_min AND @fixed_pay_max)
)
ORDER BY [Order], Active DESC, Project
GO
GRANT EXEC ON dbo.spProjectList To public
GO
IF OBJECT_id('dbo.spProjectDelete') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spProjectDelete AS' -- Preserves permissions
GO
ALTER PROC dbo.spProjectDelete
	@project_id int
AS
DELETE Project WHERE ProjectID = @project_id
GO
IF OBJECT_id('dbo.spProjectSelect') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spProjectSelect AS' -- Preserves permissions
GO
ALTER PROC dbo.spProjectSelect
	@project_id int
AS
SET NOCOUNT ON
SELECT * FROM dbo.vwProject WHERE ProjectID = @project_id
GO
GRANT EXEC ON dbo.spProjectSelect TO public
GO
IF OBJECT_id('dbo.spProjectInsert') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spProjectInsert AS' -- Preserves permissions
GO
ALTER PROC dbo.spProjectInsert
	@project varchar(50),
	@project_manager_id int,
	@active bit,
	@pay_rate smallmoney,
	@billing_rate smallmoney,
	@note varchar(4000),
	@location_id int,
	@class_id int,
	@fixed_pay smallmoney = NULL,
	@fixed_billing smallmoney = NULL,
	@project_id int OUT,
	@number varchar(50) = '',
	@default_time_type_id int = NULL,
	@terminal_work_code smallint = NULL
AS
SET @terminal_work_code = CASE
	WHEN @terminal_work_code IS NOT NULL THEN @terminal_work_code
	WHEN ISNUMERIC(@number)=1 AND CAST(@number AS numeric(38,0)) <= 65535 THEN CAST(@number AS smallint)
	ELSE 0
END

INSERT Project(Project, ProjectManagerID, Active, [Pay Rate], [Billing Rate], Note, LocationID, ClassID, [Fixed Pay], [Fixed Billing], [Number], DefaultTimeTypeID, [Terminal Work Code])
SELECT LTRIM(RTRIM(@project)), @project_manager_id, @active, @pay_rate, @billing_rate, LTRIM(RTRIM(@note)), @location_id, @class_id, @fixed_pay, @fixed_billing, LTRIM(RTRIM(@number)), @default_time_type_id, @terminal_work_code

SELECT @project_id = SCOPE_IDENTITY()
GO
IF OBJECT_id('dbo.spProjectUpdate') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spProjectUpdate AS' -- Preserves permissions
GO
ALTER PROC dbo.spProjectUpdate
	@project varchar(50),
	@project_manager_id int,
	@active bit,
	@pay_rate smallmoney,
	@billing_rate smallmoney,
	@note varchar(4000),
	@project_id int,
	@location_id int,
	@class_id int,
	@fixed_pay smallmoney = NULL,
	@fixed_billing smallmoney = NULL,
	@number varchar(50) = '',
	@default_time_type_id int = NULL,
	@terminal_work_code smallint = NULL
AS
-- If work code is unspecified, tries to base work code on project number
IF @terminal_work_code IS NULL
BEGIN
	DECLARE @work_code_matched_number bit
	
	-- Only tries to base work code on project number if existing work code was 0 or existing work code matched existing number
	SELECT @work_code_matched_number = CASE
		WHEN [Terminal Work Code] = 0 THEN 1
		WHEN ISNUMERIC([Number])=1 AND CAST([Number] AS numeric(38,0)) <= 32767 AND CAST([Number] AS smallint) = [Terminal Work Code] THEN 1
		ELSE 0
	END
	FROM dbo.Project WHERE ProjectID=@project_id
	
	SET @terminal_work_code = CASE
		WHEN @work_code_matched_number = 1 AND ISNUMERIC(@number)=1 AND CAST(@number AS numeric(38,0)) <= 32767 THEN CAST(@number AS smallint)
		ELSE 0
	END
END

UPDATE dbo.Project SET
Project = LTRIM(RTRIM(@project)),
ProjectManagerID = @project_manager_id,
Active = @active,
[Pay Rate] = @pay_rate,
[Billing Rate] = @billing_rate,
Note = LTRIM(RTRIM(@note)),
LocationID = @location_id,
ClassID = @class_id,
[Fixed Pay] = @fixed_pay,
[Fixed Billing]  = @fixed_billing,
Number = LTRIM(RTRIM(@number)),
DefaultTimeTypeID = @default_time_type_id,
[Terminal Work Code] = CASE WHEN @terminal_work_code IS NULL THEN [Terminal Work Code] ELSE @terminal_work_code END
WHERE ProjectID = @project_id
GO
ALTER PROC dbo.[spEmergencyContactInsert]
	@employee_id int,
	@title varchar(50),
	@first_name varchar(50),
	@middle_name varchar(50),
	@last_name varchar(50),
	@suffix varchar(50),
	@person_id int out,
	@contact_id int out,
	@credentials varchar(50) = ''
AS
DECLARE @male bit

DECLARE @authorized bit


EXEC dbo.spPermissionInsureForCurrentUserOnPerson @employee_id, 134217728, 4, @authorized out

IF @authorized = 1
BEGIN

	SELECT @male = CASE WHEN @title = 'Ms.' OR @title= 'Mrs.' OR @title = 'Miss' THEN 0 ELSE 1 END FROM Person WHERE PersonID = @employee_id

	BEGIN TRAN

	INSERT Person(
	Title, [First Name], [Middle Name], [Last Name], Suffix, Credentials,
	Male, [Home Address], [Home Address (cont.)], [Home City], [Home State], [Home ZIP], [Home Country], [Work Country], [Role Mask]
	) VALUES (
	@title, @first_name, @middle_name, @last_name, @suffix, @credentials,
	@male, '', '', '', '', '', '', '', 0
	)
	SELECT @person_id = SCOPE_IDENTITY()

	INSERT dbo.EmployeeEmergencyContact(EmployeeID, PersonID)
	VALUES(@employee_id, @person_id)
	SELECT @contact_id = SCOPE_IDENTITY()

	COMMIT TRAN
END
GO
UPDATE dbo.ColumnGrid SET [Field] = 'I9 Status' WHERE FieldID=44
UPDATE dbo.ColumnGrid SET [Field] = 'Race' WHERE FieldID = 32
UPDATE dbo.ColumnGrid SET Importable=1, Label='Security Account', [Order]=6550 WHERE FieldID=59

-- StoredProc='dbo.spPersonListWork', Param='@person_id'
UPDATE dbo.ColumnGrid SET [Group]='Contact at Work' WHERE FieldID IN
(7,8,9,10,11,12,13,14,15,17,18,19,20,21,22,83,1028)

-- StoredProc='dbo.spPersonListWork', Param='@person_id'
UPDATE dbo.ColumnGrid SET [Group]='Name' WHERE FieldID IN
(1,2,3,4,5,84)

-- StoredProc='dbo.spPersonListWork', Param='@person_id'
UPDATE dbo.ColumnGrid SET [Group]='Demographics', [Role Mask]=3 WHERE FieldID IN
(6)

-- StoredProc='dbo.spPersonXList', Param='@person_id'
UPDATE dbo.ColumnGrid SET [Group]='Demographics', [Role Mask]=3 WHERE FieldID IN
(32, 42, 43, 44)

-- StoredProc='dbo.spPersonXList', Param='@person_id'
UPDATE dbo.ColumnGrid SET [Group]='Personal', [Role Mask]=3 WHERE FieldID IN
(33, 34, 35, 36, 37, 38, 39, 40, 41, 45, 46, 47, 48, 49, 50,1038)

-- StoredProc='dbo.spPersonListHome', Param='@person_id'
UPDATE dbo.ColumnGrid SET [Group]='Contact at Home'  WHERE FieldID IN
(23,24,25,26,27,28,29,30,31,1027)

-- StoredProc='dbo.spEmployeeListOrg', Param='@employee_id'
UPDATE dbo.ColumnGrid SET [Group]='Organizational & Position', [Role Mask]=1  WHERE FieldID IN
(51, 52, 53, 54, 55, 56, 58, 59, 60, 61, 71, 102, 108, 1033,1019,1032)

-- StoredProc='dbo.spEmployeeListPayStep', Param='@employee_id'
UPDATE dbo.ColumnGrid SET [Group]='Compensation', [Role Mask]=1 WHERE FieldID IN
(64,103,102,100,101,72,1034,1035)

UPDATE dbo.ColumnGrid SET [Group]='Review Dates', [Role Mask]=1 WHERE FieldID IN
(62,63)

UPDATE dbo.ColumnGrid SET [Group]='Succession', [Role Mask]=1 WHERE FieldID IN
(67,68,69,70)

UPDATE dbo.ColumnGrid SET [Group]='Benefits', [Role Mask]=1 WHERE FieldID IN
(90,93,94,95,96,97,98,99,1039,1040,1037)

UPDATE dbo.ColumnGrid SET [Group]='Time', [Role Mask]=1 WHERE FieldID IN
(104,105,106,107)

UPDATE dbo.ColumnGrid SET [Group]='Other' WHERE FieldID IN
(16,1003)
GO
IF OBJECT_id('dbo.spPersonXCertificationList5') IS NOT NULL DROP PROC dbo.spPersonXCertificationList5
GO
CREATE PROC dbo.spPersonXCertificationList5
	@completed_min int = -2147483648, @completed_max int = 2147483647,
	@renewed bit = NULL, @renewed_min int = -2147483648, @renewed_max int = 2147483647,
	@expires bit = NULL, @expires_min int = -2147483648, @expires_max int = 2147483647,
	@person_batch_id int = NULL, @person_id int = NULL,
	@certification_batch_id int = NULL, @certification_id int = NULL,
	@meta bit = 0
AS
SET NOCOUNT ON


IF @meta=1
BEGIN
	SELECT TOP 0 * FROM vwPersonXCertification
	SELECT [Key]='PersonID', Permission='Permission Mask'
	SELECT NULL, 'List As', 'Person', 'Name', 0, 0 UNION
	SELECT NULL, 'Certification', 'Certification', 'Name', 0, 0 UNION
	SELECT NULL, 'Completed', 'Completed', 'Certification', 20, 0 UNION
	SELECT NULL, 'Renewed', 'Renewed', 'Certification', 30, 0 UNION
	SELECT NULL, 'Expires', 'Expires', 'Certification', 40, 0 UNION
	SELECT NULL, 'Verified', 'Verified', 'Certification', 50, 0
	RETURN 0
END

IF @person_batch_id IS NULL
BEGIN
	SELECT @person_batch_id = RAND() * 2147483647
	IF @person_id IS NULL INSERT TempX(BatchID,[ID]) SELECT DISTINCT @person_batch_id,PersonID FROM vwPersonXCertification WHERE [Nonterminated Employee]=1
END
IF @person_id IS NOT NULL INSERT TempX(BatchID,[ID]) VALUES(@person_batch_id,@person_id)
DELETE TempX WHERE BatchID = @person_batch_id AND (X & 1) = 0

IF @certification_batch_id IS NULL
BEGIN
	SELECT @certification_batch_id = RAND() * 2147483647
	IF @certification_id IS NULL INSERT TempX(BatchID,[ID]) SELECT @certification_batch_id,CertificationID FROM Certification
END
IF @certification_id IS NOT NULL INSERT TempX(BatchID,[ID]) VALUES(@certification_batch_id,@certification_id)

EXEC dbo.spPermissionGetOnPeopleForCurrentUser2 @person_batch_id, 65536

SELECT V.*, [Permission Mask] = SelectedPeople.X
FROM vwPersonXCertification V
INNER JOIN TempX SelectedCerts ON SelectedCerts.BatchID=@certification_batch_id AND SelectedCerts.[ID]=V.CertificationID
INNER JOIN TempX SelectedPeople ON SelectedPeople.BatchID=@person_batch_id AND SelectedPeople.[ID]=V.PersonID AND
V.[Completed Day past 1900] BETWEEN @completed_min AND @completed_max AND
(
	(V.[Expires Day past 1900] IS NULL AND (@expires=0 OR @expires IS NULL)) OR
	(V.[Expires Day past 1900] IS NOT NULL AND (@expires=1 OR @expires IS NULL) AND V.[Expires Day past 1900] BETWEEN @expires_min AND @expires_max)
)
ORDER BY V.[List As], V.[Certification], V.[Completed Day past 1900]

DELETE TempX WHERE BatchID IN (@person_batch_id,@certification_batch_id) OR DATEDIFF(hour,Created,GETDATE()) > 1
GO
GRANT EXEC ON dbo.spPersonXCertificationList5 To public
GO
IF NOT EXISTS(SELECT * FROM ColumnGrid WHERE FieldID=107)
INSERT ColumnGrid(FieldID,[Table],[Key],colid,AttributeID,Field,Label,Importable,Reportable,[Order])
VALUES(107,'Employee','EmployeeID',52,50,'InOutLastUpdated','In/Out Last Updated',0,1,1380)

IF NOT EXISTS(SELECT * FROM ColumnGrid WHERE FieldID=1061)
INSERT ColumnGrid(FieldID,[Table],[Key],colid,AttributeID,Field,Label,Importable,Reportable,[Order])
VALUES(1061,'Employee','EmployeeID',72,8,'InOutLastSource','In/Out Last Source',0,1,1382)

IF NOT EXISTS(SELECT * FROM ColumnGrid WHERE FieldID=104)
INSERT ColumnGrid(FieldID,[Table],[Key],colid,AttributeID,Field,Label,Importable,Reportable,[Order])
VALUES(104,'Employee','EmployeeID',50,50,'InOutStatusID','In/Out Status',0,1,1365)

IF NOT EXISTS(SELECT * FROM ColumnGrid WHERE FieldID=105)
INSERT ColumnGrid(FieldID,[Table],[Key],colid,AttributeID,Field,Label,Importable,Reportable,[Order])
VALUES(105,'Employee','EmployeeID',53,50,'InOutComment','In/Out Comment',0,1,1375)

IF NOT EXISTS(SELECT * FROM ColumnGrid WHERE FieldID=106)
BEGIN
	INSERT ColumnGrid(FieldID,[Table],[Key],colid,AttributeID,Field,Label,Importable,Reportable,[Order])
	VALUES(106,'Employee','EmployeeID',51,50,'InOutReturn','In/Out Returning',0,1,1370)

	DECLARE @template varchar(50), @x int

	SELECT @x=2, @template='In/Out Board'
	WHILE EXISTS(SELECT * FROM ReportTemplate2 WHERE Template=@template)
	BEGIN
		SELECT @template='In/Out Board' + CAST(@x AS varchar(50))
		SELECT @x=@x+1
	END

	INSERT ReportTemplate2(Template, [Fields Stream])
	SELECT @template, 0x0001000000FFFFFFFF01000000000000000C020000004441706578424F732C2056657273696F6E3D312E302E323734332E343535362C2043756C747572653D6E65757472616C2C205075626C69634B6579546F6B656E3D6E756C6C05010000001741706578424F732E5265706F727454656D706C61746532040000000854656D706C61746506536F72744279064669656C64730646696C746572010404041C41706578424F732E5265706F727454656D706C6174654669656C6458020000001E41706578424F732E5265706F727454656D706C6174654669656C64585B5D020000001F41706578424F732E46696C7465724372697465726961456D706C6F79656573020000000200000006030000000C496E2F4F757420426F61726409040000000905000000090600000005040000001C41706578424F732E5265706F727454656D706C6174654669656C6458040000000454657874054F72646572074669656C644944065479706549440100000408082341706578424F732E5265706F727454656D706C6174654669656C6454797065456E756D02000000020000000607000000094C617374204E616D65000000000400000005F8FFFFFF2341706578424F732E5265706F727454656D706C6174654669656C6454797065456E756D010000000776616C75655F5F000802000000000000000705000000000100000005000000041C41706578424F732E5265706F727454656D706C6174654669656C6458020000000909000000090A000000090B000000090C000000090D0000000C0E0000004C4170657842617365436C61737365732C2056657273696F6E3D312E302E323734332E343139362C2043756C747572653D6E65757472616C2C205075626C69634B6579546F6B656E3D6E756C6C05060000001F41706578424F732E46696C7465724372697465726961456D706C6F79656573080000000C6D5F6F456D706C6F796565730D6D5F6F456D706C6F7965654944096D5F6F4163746976651A46696C74657243726974657269612B6D5F6F46696C74657249441846696C74657243726974657269612B6D5F7446696C7465721746696C74657243726974657269612B6D5F6F4974656D731846696C74657243726974657269612B6D5F6F4163746976651846696C74657243726974657269612B6D5F695479706549440704040401040404081B4170657842617365436C61737365732E4E756C6C61626C65496E740E000000184170657842617365436C61737365732E54726953746174650E0000001B4170657842617365436C61737365732E4E756C6C61626C65496E740E0000001941706578424F732E46696C746572437269746572696F6E5B5D02000000184170657842617365436C61737365732E54726953746174650E0000001A41706578424F732E46696C7465724372697465726961456E756D0200000002000000090F0000000910000000091100000009120000000613000000000914000000091100000005EAFFFFFF1A41706578424F732E46696C7465724372697465726961456E756D010000000776616C75655F5F0008020000000100000001090000000400000006170000000D496E2F4F7574205374617475730F0000006800000001E8FFFFFFF8FFFFFF00000000010A00000004000000061900000010496E2F4F75742052657475726E696E67100000006A00000001E6FFFFFFF8FFFFFF00000000010B00000004000000061B0000000E496E2F4F757420436F6D6D656E74110000006900000001E4FFFFFFF8FFFFFF00000000010C00000004000000061D00000013496E2F4F7574204C6173742055706461746564120000006B00000001E2FFFFFFF8FFFFFF00000000010D00000004000000061F00000010576F726B2050686F6E65202845787429130000005300000001E0FFFFFFF8FFFFFF000000000F0F000000000000000805100000001B4170657842617365436C61737365732E4E756C6C61626C65496E74020000000649734E756C6C024944000001080E00000001000000000511000000184170657842617365436C61737365732E5472695374617465020000000649734E756C6C0556616C7565000001010E000000000101120000001000000001000000000714000000000100000000000000041741706578424F732E46696C746572437269746572696F6E020000000B
END
GO
IF NOT EXISTS(SELECT * FROM ColumnGrid WHERE FieldID=1050)
INSERT ColumnGrid(FieldID, [Table], [Key], colid, AttributeID, Field, Label, Importable, Reportable, [Order], [Group])
SELECT 1050, 'Employee', 'EmployeeID', colid, 128, 'Leave Accrual Multiplier', 'Leave Accrual Multiplier (FTE)', 1, 1, 10002, 'Leave'
FROM syscolumns WHERE [id]=OBJECT_id('Employee') AND [name]='Leave Accrual Multiplier'

IF NOT EXISTS(SELECT * FROM ColumnGrid WHERE FieldID=1051)
INSERT ColumnGrid(FieldID, [Table], [Key], colid, AttributeID, Field, Label, Importable, Reportable, [Order], [Group])
SELECT 1051, 'Employee', 'EmployeeID', colid, 128, 'Seconds per Day Override', 'Hours per Day Override', 1, 1, 10005, 'Leave'
FROM syscolumns WHERE [id]=OBJECT_id('Employee') AND [name]='Seconds per Day Override'

IF NOT EXISTS(SELECT * FROM ColumnGrid WHERE FieldID=1052)
INSERT ColumnGrid(FieldID, [Table], [Key], colid, AttributeID, Field, Label, Importable, Reportable, [Order], [Group])
SELECT 1052, '', '', 0, 128, 'Transformation FTE-->Seconds', 'Hours per Day Override (FTE)', 1, 0, 10010, 'Leave'


IF NOT EXISTS(SELECT * FROM ColumnGrid WHERE FieldID=1053)
INSERT ColumnGrid(FieldID, [Table], [Key], colid, AttributeID, Field, Label, Importable, Reportable, [Order], [Group])
SELECT 1053, '', '', 0, 128, 'Transformation FTE-->Seconds', 'Last Leave Accrual Plan (1.000 FTE)', 1, 0, 10000, 'Leave'

UPDATE dbo.ColumnGrid SET Importable = 1 WHERE FieldID IN ( 52, 53, 55, 56, 59 )
GO
IF OBJECT_id('dbo.spEmployeeUpdateDelegatedManager') IS NOT NULL DROP PROC dbo.spEmployeeUpdateDelegatedManager
GO
CREATE PROC dbo.spEmployeeUpdateDelegatedManager @employee_id int, @delegated_manager_id int
AS  DECLARE @authorized bit
EXEC dbo.spPermissionInsureForCurrentUserOnPerson @employee_id, 9, 2, @authorized out
IF @authorized = 1 UPDATE Employee SET DelegatedManagerID=@delegated_manager_id WHERE EmployeeID=@employee_id AND dbo.fnNullCompare(@delegated_manager_id, DelegatedManagerID) = 0
GO
GRANT EXEC ON dbo.spEmployeeUpdateDelegatedManager TO public
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spEmployeeSelectDelegatedManager', 1
GO
ALTER PROC dbo.spEmployeeSelectDelegatedManager
	@employee_id int,
	@attribute_id int = 0, -- Added v223. If attribute_id > 0 then keeps climbing chain until effective manager has permission_mask on attribute_id
	@permission_mask int = 0 -- Added v223
AS
DECLARE @authorized bit

SET NOCOUNT ON

EXEC dbo.spPermissionInsureForCurrentUserOnPerson @employee_id, 9, 1, @authorized out
IF @authorized = 1 SELECT * FROM dbo.vwEmployeeDelegatedManager WHERE EmployeeID = @employee_id
GO
GRANT EXEC ON dbo.spEmployeeSelectDelegatedManager TO public
GO
IF OBJECT_id('dbo.spEmployeeUpdateLeaveAccrualMultiplier') IS NULL 
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEmployeeUpdateLeaveAccrualMultiplier AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spEmployeeUpdateLeaveAccrualMultiplier TO public'
END
GO
ALTER PROC dbo.spEmployeeUpdateLeaveAccrualMultiplier 
	@employee_id int, @leave_accrual_multiplier numeric(9,4), @override int
AS SET NOCOUNT ON
DECLARE @authorized bit
EXEC dbo.spPermissionInsureForCurrentUserOnPerson @employee_id, 128, 2, @authorized out
IF @authorized = 1
UPDATE Employee
SET [Leave Accrual Multiplier]=@leave_accrual_multiplier,
[Seconds per Day Override]=@override
WHERE EmployeeID=@employee_id
GO
IF OBJECT_id('dbo.spEmployeeSelectLeaveAccrualMultiplier') IS NULL 
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEmployeeSelectLeaveAccrualMultiplier AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spEmployeeSelectLeaveAccrualMultiplier TO public'
END
GO
ALTER PROC dbo.spEmployeeSelectLeaveAccrualMultiplier @employee_id int
AS SET NOCOUNT ON
DECLARE @authorized bit
EXEC dbo.spPermissionInsureForCurrentUserOnPerson @employee_id, 128, 1, @authorized out
IF @authorized=1 SELECT * FROM dbo.vwEmployeeEffectiveSecondsPerDay WHERE EmployeeID=@employee_id
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spEmployeeCompensationUpdate'
GO
ALTER PROC dbo.spEmployeeCompensationUpdate
	@period_id int,
	@start_day_past_1900 int,
	@stop_day_past_1900 int,
	@employment_status_id int,
	@budgeted bit,
	@note varchar(4000),
	@base_pay money,
	@other_compensation varchar(4000),
	@compensation_id int,
	@position_id int,
	@step_id int = NULL,
	@pay_step int = NULL,
	@start_event_id int = NULL,
	@stop_event_id int = NULL,
	@employee_seconds_per_week int = NULL,
	@flags int = 0 -- 1: update seconds_per_week
AS
DECLARE @employee_id int
DECLARE @authorized bit

SET NOCOUNT ON

IF @step_id IS NULL
BEGIN
	SET @authorized = 0
	EXEC dbo.spErrorRaise 50046
END
ELSE
BEGIN
	SELECT @employee_id = EmployeeID FROM EmployeeCompensation WHERE CompensationID = @compensation_id
	EXEC dbo.spPermissionInsureForCurrentUserOnPerson @employee_id, 1024, 2, @authorized out
END

IF @authorized = 0 RETURN

IF @start_event_id IS NULL SELECT TOP 1 @start_event_id = EventID FROM EmployeeCompensationEventStart ORDER BY Flags&1 DESC, [Order]
UPDATE EmployeeCompensation SET
	PeriodID = @period_id,
	Budgeted = @budgeted,
	[Start Day past 1900] = @start_day_past_1900,
	[Stop Day past 1900] = @stop_day_past_1900,
	EmploymentStatusID = @employment_status_id,
	Note = @note,
	[Base Pay] = @base_pay,
	[Other Compensation] = @other_compensation,
	PositionID = @position_id,
	[PayStepID] = @step_id,
	StartEventID = @start_event_id,
	StopEventID = @stop_event_id,
	[Employee Seconds per Week] = CASE WHEN @flags & 1 = 1 THEN @employee_seconds_per_week ELSE [Employee Seconds per Week]  END
WHERE CompensationID = @compensation_id
GO
ALTER PROCEDURE dbo.spShiftInsert
	@shift varchar(50),
	@seconds_per_day int,
	@days_on int,
	@days_off int,
	@start int,
	@shift_id int OUT,
	@fte numeric(9,4) = 1, -- Added v96
	@start_seconds int = 32400, -- Added v121
	@dayson2 int = 0, -- Added v175
	@daysoff2 int = 0,
	@grace_seconds int = 1800, -- Added v184
	@stop_seconds int = 57600,
	@lunch_start int = 43200,
	@lunch_seconds int = 3600,
	@flags int = 0,
	@flags2 int = 0 -- 1: do not create entries in shiftschedule
AS
DECLARE @error int

BEGIN TRAN

INSERT Shift(Shift, [Seconds per Day], [Days On], [Days Off], [Start Day past 1900], FTE, [Start Seconds], DaysOn2, DaysOff2, [Grace Seconds], [Stop Seconds], [Lunch Start], [Lunch Seconds], Flags) 
VALUES(@shift, @seconds_per_day, @days_on, @days_off, @start, @fte, @start_seconds, @dayson2, @daysoff2, @grace_seconds, @stop_seconds, @lunch_start, @lunch_seconds, @flags)

SET @error = @@ERROR
IF @error = 0 SELECT @shift_id = SCOPE_IDENTITY()

IF @error = 0 AND (@flags2 & 1) = 0 EXEC dbo.spShiftScheduleInsertAuto @shift_id, @start_seconds, @lunch_start, @lunch_seconds, @stop_seconds, @seconds_per_day, @days_on, @days_off, @dayson2, @daysoff2, @flags

IF @error = 0 COMMIT TRAN
ELSE ROLLBACK TRAN
GO
ALTER PROC dbo.spShiftUpdate
	@shift varchar(50),
	@seconds_per_day int,
	@days_on int,
	@days_off int,
	@start int,
	@shift_id int,
	@fte numeric(9,4) = 1, -- Added v96
	@start_seconds int = NULL, -- Added v121
	@dayson2 int = NULL, -- Added v175
	@daysoff2 int = NULL,
	@grace_seconds int = NULL, -- Added v184
	@stop_seconds int = NULL,
	@lunch_start int = NULL,
	@lunch_seconds int = NULL,
	@flags int = NULL,
	@flags2 int = 0, -- 1: do not refresh shiftschedule, 2: do not push lunch punch
	@flags_unspecified_mask int = 0x7FFF0800 -- keeps client from overwriting flags that are only set manually on back end
AS
DECLARE @error int

BEGIN TRAN

UPDATE Shift SET 
Shift = @shift,
[Seconds per Day] = @seconds_per_day,
[Days On] = @days_on,
[Days Off] = @days_off,
[Start Day past 1900] = @start,
FTE = @fte,
[Start Seconds] = CASE WHEN @start_seconds IS NULL THEN [Start Seconds] ELSE @start_seconds END,
DaysOn2 = CASE WHEN @dayson2 IS NULL THEN DaysOn2 ELSE @dayson2 END,
DaysOff2 = CASE WHEN @daysoff2 IS NULL THEN DaysOff2 ELSE @daysoff2 END,
[Grace Seconds] = CASE WHEN @grace_seconds IS NULL THEN [Grace Seconds] ELSE @grace_seconds END,
[Stop Seconds] = CASE WHEN @stop_seconds IS NULL THEN [Stop Seconds] ELSE @stop_seconds END,
[Lunch Start] = CASE WHEN @lunch_start IS NULL THEN [Lunch Start] ELSE @lunch_start END,
[Lunch Seconds] = CASE WHEN @lunch_seconds IS NULL THEN [Lunch Seconds] ELSE @lunch_seconds END,
Flags = CASE WHEN @flags IS NULL THEN Flags ELSE (Flags & @flags_unspecified_mask) | @flags END
WHERE ShiftID = @shift_id

SET @error = @@ERROR
IF @error = 0
BEGIN
	IF (@flags2 & 1) = 0 EXEC dbo.spShiftScheduleInsertAuto @shift_id, @start_seconds, @lunch_start, @lunch_seconds, @stop_seconds, @seconds_per_day, @days_on, @days_off, @dayson2, @daysoff2, @flags
	ELSE 
	BEGIN IF (@flags2 & 2) = 0 
		UPDATE dbo.ShiftSchedule SET Flags = Flags | 0x10 WHERE ShiftID=@shift_id AND (@flags & 0x10) = 0x10
		UPDATE dbo.ShiftSchedule SET Flags = Flags & 0x7FFFFFEF WHERE ShiftID=@shift_id AND (@flags & 0x10) = 0
	END
END

IF @error = 0 COMMIT TRAN
ELSE ROLLBACK TRAN
GO
ALTER PROC dbo.spAuditGetOperation
	@object_id int,
	@operation int,
	@audit_operation bit OUT,
	@audit_unauthorized_attempt bit = 0 OUT -- obsolete
AS
DECLARE @audit_event_mask int
SELECT @audit_event_mask = [Audit Event Mask] FROM AuditSetting WHERE ObjectID=@object_id
IF @@ROWCOUNT = 0 SELECT @audit_operation = 0, @audit_unauthorized_attempt = 0
ELSE 
BEGIN
	SELECT @audit_operation = CASE WHEN (@audit_event_mask & @operation) = 0 THEN 0 ELSE 1 END
END
GO
ALTER PROC dbo.spAuditSettingList AS
SELECT * FROM vwAuditSetting ORDER BY [Object]
GO
IF OBJECT_id('dbo.spAuditTrailList') IS NOT NULL DROP PROC dbo.spAuditTrailList
GO
CREATE PROC dbo.spAuditTrailList
	@sid varbinary(85) = NULL,
	@user sysname = '',
	@regarding_person_id int = NULL,
	@object_id int = NULL,
	@event_mask int = 0,
	@event varchar(50) = '',
	@start_day int = -2147483648,
	@stop_day int = 2147483647,

	@person_batch_id int = NULL,
	@object_batch_id int = NULL
AS
DECLARE @event_filter varchar(52)
SET NOCOUNT ON

SELECT @event_filter = ISNULL(@event, '')
IF @event_filter <> '' SET @event_filter = '%' + @event_filter + '%'
IF @user <> '' AND LEN(@user) <= 126 SET @user = '%' + @user + '%'

IF @person_batch_id IS NULL
BEGIN
	SET @person_batch_id = RAND() * -2147483648
	IF @regarding_person_id IS NULL INSERT TempX(BatchID,[ID]) SELECT @person_batch_id,PersonID FROM Person
	ELSE INSERT TempX(BatchID,[ID]) VALUES(@person_batch_id, @regarding_person_id)
END

IF @object_batch_id IS NULL
BEGIN
	SET @object_batch_id = RAND() * -2147483648
	IF @object_id IS NULL INSERT TempX(BatchID,[ID]) SELECT @object_batch_id,ObjectID FROM AuditSetting
	ELSE INSERT TempX(BatchID,[ID]) VALUES(@object_batch_id, @object_id)
END

SELECT T.* FROM vwAuditTrail T
INNER JOIN TempX People ON People.BatchID=@person_batch_id AND T.RegardingPersonID=People.[ID]
INNER JOIN TempX Objects ON Objects.BatchID=@object_batch_id AND T.ObjectID=Objects.[ID] AND
(@sid IS NULL OR T.[SID] = @sid) AND
(@user=N'' OR T.[User] LIKE @user) AND
(@event_mask=0 OR (T.[Event Mask] & @event_mask)<>0) AND
(@event_filter='' OR T.Event LIKE @event_filter OR T.[Object] LIKE @event_filter OR T.[Regarding Person] LIKE @event_filter OR T.[User] LIKE @event_filter) AND
DATEDIFF(d,0,T.Created) BETWEEN @start_day AND @stop_day
ORDER BY T.Created

DELETE TempX WHERE BatchID IN (@person_batch_id, @object_batch_id) OR DATEDIFF(hour, Created, GETDATE()) > 1
GO
ALTER VIEW dbo.vwExpenseAccount
AS
SELECT *,
[Reimbursable]=CAST(CASE WHEN (Flags&1)=1 THEN 1 ELSE 0 END AS bit),
[Accumulated]=CAST(CASE WHEN (Flags&2)=2 THEN 1 ELSE 0 END AS bit),
[Project Tracking]=CAST(CASE WHEN (Flags&4)=4 THEN 1 ELSE 0 END AS bit),
[Requires Approval]=CAST(CASE WHEN (Flags&8)=8 THEN 1 ELSE 0 END AS bit)
FROM ExpenseAccount
GO
ALTER PROC dbo.spPositionListAsItems
	@active bit, -- null lists all. 0 lists inactive. 1 lists active
	@position_id int
AS
DECLARE @batch_id int

SET NOCOUNT ON

SELECT PositionID, [Job Title], [Pay Grade], FTE, PayGradeID, PayTableID, [Seconds Per Week], FTE40 FROM vwPosition WHERE (@active IS NULL OR Active = @active) OR PositionID = @position_id
ORDER BY [Pay Table], [Pay Grade Order], [Job Title]
GO
UPDATE Period SET FTEM=0 WHERE PeriodID IN (256, 512)
UPDATE Period SET FTEB=0 WHERE PeriodID NOT IN (256, 512)
GO
IF NOT EXISTS(SELECT * FROM LeaveRatePeriod WHERE PeriodID=49154)
INSERT LeaveRatePeriod(PeriodID,GroupID,Period,Example,Payroll,[Order],Tag,Weekday)
SELECT 49154,2,'First incident','480 hours of FMLA credited on first incident each year',0,2060, NULL,0

IF OBJECT_id('dbo.spEmployeeBINVSelect') IS NOT NULL DROP PROC dbo.spEmployeeBINVSelect
IF OBJECT_id('dbo.spEmployeeBINVUpdate') IS NOT NULL DROP PROC dbo.spEmployeeBINVUpdate
IF OBJECT_id('dbo.spEmployeeBPMTSelect') IS NOT NULL DROP PROC dbo.spEmployeeBPMTSelect
IF OBJECT_id('dbo.spEmployeeBPMTUpdate') IS NOT NULL DROP PROC dbo.spEmployeeBPMTUpdate
IF OBJECT_id('dbo.spPeriodSelect') IS NOT NULL DROP PROC dbo.spPeriodSelect
GO
CREATE PROC dbo.spPeriodSelect @period_id int AS SELECT * FROM Period WHERE PeriodID=@period_id
GO
CREATE PROC dbo.spEmployeeBINVSelect @employee_id int AS
SELECT * FROM vwEmployeeBINV WHERE EmployeeID=@employee_id AND (dbo.fnPermissionGetOnPersonForCurrentUser(EmployeeID, 536870913) & 1) = 1
GO
CREATE PROC dbo.spEmployeeBINVUpdate
	@employee_id int,
	@batch_create_invoice bit,
	@advance_pay bit
AS
DECLARE @permission int
EXEC dbo.spPermissionGetOnPersonForCurrentUser @employee_id, 536870913, @permission out
IF (@permission & 10) > 0 UPDATE Employee SET BatchCreateInvoice = @batch_create_invoice, [Advance Pay] = @advance_pay WHERE EmployeeID = @employee_id
GO
CREATE PROC dbo.spEmployeeBPMTSelect @employee_id int AS
SELECT * FROM vwEmployeeBPMT WHERE EmployeeID=@employee_id AND (dbo.fnPermissionGetOnPersonForCurrentUser(EmployeeID, 536870914) & 1) = 1
GO
CREATE PROC dbo.spEmployeeBPMTUpdate
	@employee_id int,
	@nsf bit
AS
DECLARE @permission int
EXEC dbo.spPermissionGetOnPersonForCurrentUser @employee_id, 536870914, @permission out
IF (@permission & 10) > 0 UPDATE Employee SET NSF = @nsf WHERE EmployeeID = @employee_id
GO
GRANT EXEC ON dbo.spEmployeeBINVSelect TO public
GRANT EXEC ON dbo.spEmployeeBINVUpdate TO public
GRANT EXEC ON dbo.spEmployeeBPMTSelect TO public
GRANT EXEC ON dbo.spEmployeeBPMTUpdate TO public
GRANT EXEC ON dbo.spPeriodSelect TO public
GO
IF OBJECT_id('dbo.spEmployeeDependentInsert') IS NOT NULL DROP PROC dbo.spEmployeeDependentInsert
GO
CREATE PROC dbo.spEmployeeDependentInsert
	@employee_id int,
	@title varchar(50),
	@first_name varchar(50),
	@middle_name varchar(50),
	@last_name varchar(50),
	@suffix varchar(50),
	@person_id int out,
	@contact_id int out,
	@credentials varchar(50) = ''
AS
DECLARE @male bit
DECLARE @authorized bit


EXEC dbo.spPermissionInsureForCurrentUserOnPerson @employee_id, 134217728, 4, @authorized out

IF @authorized = 1
BEGIN
	SELECT @male = CASE WHEN @title = 'Ms.' OR @title= 'Mrs.' OR @title = 'Miss' THEN 0 ELSE 1 END
	FROM Person WHERE PersonID = @employee_id

	BEGIN TRAN

	INSERT Person(
	Title, [First Name], [Middle Name], [Last Name], Suffix, Credentials,
	Male, [Home Address], [Home Address (cont.)], [Home City], [Home State], [Home ZIP], [Home Country], [Work Country], [Role Mask]
	) VALUES (
	@title, @first_name, @middle_name, @last_name, @suffix, @credentials,
	@male, '', '', '', '', '', '', '', 32
	)
	SELECT @person_id = SCOPE_IDENTITY()

	DECLARE @race_id int, @i9status_id int, @marital_status_id int
	EXEC dbo.spPersonXInsertPrepare @race_id out, @i9status_id out, @marital_status_id out
	EXEC dbo.spPersonXInsert @person_id, @race_id, @i9status_id, @marital_status_id

	INSERT EmployeeDependent(EmployeeID, PersonID)
	VALUES(@employee_id, @person_id)
	SELECT @contact_id = SCOPE_IDENTITY()

	COMMIT TRAN
END
GO
GRANT EXEC ON dbo.spEmployeeDependentInsert TO public
GO
ALTER PROC dbo.spEmployeeLeaveEarnedDelete
	@leave_id int,
	@recalc_unused bit = 1
AS
DECLARE @type_id int,  @start_day int, @employee_id int, @error int
DECLARE @authorized bit, @audit_unauthorized_attempt bit, @audit_operation bit

SELECT @employee_id = EmployeeID, @type_id = TypeID, @start_day = [Day past 1900] FROM EmployeeLeaveEarned WHERE LeaveID = @leave_id
IF @@ROWCOUNT=0 RETURN -- Leave does not exist
EXEC dbo.spPermissionInsureForCurrentUserOnPerson @employee_id, 10013, 8, @authorized out
EXEC dbo.spAuditGetOperation 10001, 8, @audit_operation OUT, @audit_unauthorized_attempt OUT

IF @authorized = 1
BEGIN
	BEGIN TRAN

	DELETE dbo.EmployeeLeaveEarned WHERE LeaveID = @leave_id
	SELECT @error = @@ERROR

	IF @recalc_unused = 1 AND @error = 0
	BEGIN
		IF EXISTS(SELECT * FROM dbo.LeaveType WHERE TypeID=@type_id AND [Suspend Accrual]=1)
		BEGIN
			EXEC dbo.spEmployeeLeaveCalcForEmployee @employee_id, @start_day
		END
		ELSE
		BEGIN
			EXEC dbo.spEmployeeLeaveCalcForEmployeeType @employee_id, @type_id, @start_day
		END
		SELECT @error = @@ERROR
	END

	IF @error = 0
	BEGIN 
		COMMIT
	END
	ELSE IF @@TRANCOUNT > 0 ROLLBACK
END
ELSE IF @audit_unauthorized_attempt=1 EXEC dbo.spAuditTrailInsert @employee_id, @leave_id, 10001, 24, 'Unauthorized attempt to delete leave adjustment', 10003
GO
ALTER PROC dbo.spEmployeeLeaveEarnedInsert
	@employee_id int,
	@effective int,
	@type_id int,
	@note varchar(4000),
	@seconds int,
	@leave_id int out,
	@ppe int = NULL,
	@recalc_unused bit = 1,
	@test_duplicate bit = 0
AS
DECLARE @error int
DECLARE @authorized bit, @audit_unauthorized_attempt bit, @audit_operation bit

IF @ppe IS NULL SET @ppe = @effective

EXEC dbo.spPermissionInsureForCurrentUserOnPerson @employee_id, 10013, 4, @authorized out
EXEC dbo.spAuditGetOperation 10001, 4, @audit_operation OUT, @audit_unauthorized_attempt OUT

IF @authorized = 1
BEGIN
	IF @test_duplicate=1
	BEGIN
		IF EXISTS(
			SELECT * FROM dbo.EmployeeLeaveEarned WHERE 
				EmployeeID=@employee_id AND 
				[Day past 1900]=@effective AND
				TypeID=@type_id AND
				Seconds=@seconds
		)
		BEGIN
			DECLARE @m nvarchar(400)
			SET @m = N'Duplicate credit. A credit dated ' + CAST(dbo.GetDateFromDaysPast1900(@effective) AS varchar(11)) + ' was already applied for this employee.'
			RAISERROR(@m,16,1)
			RETURN
		END
	END
	
	BEGIN TRAN

	INSERT EmployeeLeaveEarned(EmployeeID, [Day past 1900], TypeID, Seconds, Note, [Auto], [PPE Day past 1900])
	VALUES (@employee_id, @effective, @type_id, @seconds, @note, 0, @ppe)
	SELECT @error = @@ERROR

	SELECT @leave_id = SCOPE_IDENTITY()

	IF @error = 0 AND @recalc_unused=1
	BEGIN
		IF EXISTS(SELECT * FROM dbo.LeaveType WHERE TypeID=@type_id AND [Suspend Accrual]=1)
		BEGIN
			EXEC dbo.spEmployeeLeaveCalcForEmployee @employee_id, @effective
		END
		ELSE
		BEGIN
			EXEC dbo.spEmployeeLeaveCalcForEmployeeType @employee_id, @type_id, @effective
		END
		SELECT @error = @@ERROR
	END
	
	IF @error = 0
	BEGIN 
		COMMIT
		-- Trigger on employeeleaveearend logs insert
	END
	ELSE IF @@TRANCOUNT > 0 ROLLBACK
END
ELSE IF @audit_unauthorized_attempt=1 EXEC dbo.spAuditTrailInsert @employee_id, @leave_id, 10001, 20, 'Unauthorized attempt to insert leave adjustment', 10003
GO
ALTER PROC dbo.spEmployeeLeaveEarnedUpdate
	@effective int,
	@type_id int,
	@note varchar(4000),
	@seconds int,
	@leave_id int,
	@employee_id int,
	@ppe int = NULL,
	@recalc_unused bit = 1
AS
DECLARE @authorized bit
DECLARE @error int, @old_employee_id int, @old_type_id int, @old_effective int

IF @ppe IS NULL SET @ppe = @effective
SELECT @old_employee_id = EmployeeID, @old_type_id = TypeID, @old_effective = [Day past 1900] FROM EmployeeLeaveEarned WHERE LeaveID = @leave_id

IF @old_employee_id = @employee_id
	EXEC dbo.spPermissionInsureForCurrentUserOnPerson @old_employee_id, 10013, 2, @authorized out
ELSE
BEGIN
	-- Needs delete permission on old employee and insert permission on new employee
	EXEC dbo.spPermissionInsureForCurrentUserOnPerson @old_employee_id, 10013, 8, @authorized out
	IF @authorized = 1 EXEC dbo.spPermissionInsureForCurrentUserOnPerson @employee_id, 10001, 4, @authorized out
END

IF @authorized = 1
BEGIN
	BEGIN TRAN

	UPDATE EmployeeLeaveEarned
	SET [Day past 1900] = @effective,
	EmployeeID = @employee_id,
	TypeID = @type_id,
	Seconds = @seconds,
	Note = @note,
	[PPE Day past 1900] = @ppe
	WHERE LeaveID = @leave_id
	SELECT @error = @@ERROR

	DECLARE @start int
	IF @employee_id = @old_employee_id AND @type_id = @old_type_id AND @old_effective < @effective SET @start = @old_effective
	ELSE SET @start = @effective

	IF @recalc_unused = 1 AND @error = 0
	BEGIN
		IF @employee_id = @old_employee_id AND EXISTS(SELECT * FROM dbo.LeaveType WHERE TypeID IN (@type_id,@old_type_id))
		BEGIN
			EXEC dbo.spEmployeeLeaveCalcForEmployee @employee_id, @start
			SELECT @error = @@ERROR
		END
		ELSE
		BEGIN
			IF EXISTS(SELECT * FROM dbo.LeaveType WHERE @type_id=TypeID AND [Suspend Accrual]=1)
			BEGIN
				EXEC dbo.spEmployeeLeaveCalcForEmployee @employee_id, @start
				SELECT @error = @@ERROR
			END
			ELSE
			BEGIN
				EXEC dbo.spEmployeeLeaveCalcForEmployeeType @employee_id, @type_id, @start
				SELECT @error = @@ERROR
			END
			
			IF @error = 0 AND (@old_employee_id <> @employee_id OR @type_id <> @old_type_id)
			BEGIN
				IF EXISTS(SELECT * FROM dbo.LeaveType WHERE @old_type_id=TypeID AND [Suspend Accrual]=1)
				BEGIN
					EXEC dbo.spEmployeeLeaveCalcForEmployee @old_employee_id, @old_effective
					SELECT @error = @@ERROR
				END
				ELSE
				BEGIN
					EXEC dbo.spEmployeeLeaveCalcForEmployeeType @old_employee_id, @old_type_id, @old_effective
					SELECT @error = @@ERROR
				END
			END
		END
	END
	
	IF @error = 0 COMMIT
	ELSE IF @@TRANCOUNT > 0 ROLLBACK
END
GO
ALTER PROCEDURE dbo.spEmployeeListOngoingRecerts
	@start_day int,
	@stop_day int,
	@batch_id int
AS
SET NOCOUNT ON


EXEC dbo.spPermissionGetOnPeopleForCurrentUser2 @batch_id, 16384
DELETE TempX WHERE BatchID = @batch_id AND (X & 1) = 0

SELECT PersonID = E.EmployeeID, Person = V.[Full Name], Initials = V.Initials, [Year] = YEAR(E.[Recertify Condition]), [Month] = MONTH(E.[Recertify Condition]), [Day] = DAY(E.[Recertify Condition]), E.[Recertify Condition Day past 1900]
FROM dbo.vwEmployeeLeaveInfo E
INNER JOIN TempX T ON T.BatchID = @batch_id AND T.[ID] = E.EmployeeID AND E.[Recertify Condition Day past 1900] BETWEEN @start_day AND @stop_day
INNER JOIN vwPersonCalculated V ON E.EmployeeID = V.PersonID

UNION ALL

SELECT U.LOAEmployeeID, U.[LOA Departing Employee Full Name], U.[LOA Departing Employee Initials], YEAR(U.[LOA Recertify]), [Month] = MONTH(U.[LOA Recertify]), [Day] = DAY(U.[LOA Recertify]), U.[LOA Recertify Day past 1900]
FROM dbo.vwEmployeeLeaveUsed U
INNER JOIN TempX T ON T.BatchID = @batch_id AND T.[ID] = U.LOAEmployeeID AND U.[LOA Recertify Day past 1900] BETWEEN @start_day AND @stop_day


ORDER BY [Recertify Condition Day past 1900], Person

DELETE TempX WHERE BatchID = @batch_id OR DATEDIFF(hh, Created, GETDATE()) > 1
GO
-- Updates the employee/benefit if it exists
-- Otherwise inserts it
ALTER PROCEDURE dbo.spEmployeeBenefitUpdate
	@employee_id int,
	@benefit_id int,
	@expires_day_past_1900 int,
	@eligible_day_past_1900 int,
	@notified_day_past_1900 int,
	@first_enrolled_day_past_1900 int,
	@last_enrolled_day_past_1900 int,
	@declined_day_past_1900 int,
	@note varchar(4000),
	@group_policy_number varchar(50),
	@individual_policy_number varchar(50),
	@employee_premium money,
	@employer_premium money,
	@coverage varchar(50),
	@plan varchar(50),
	@provider varchar(50),
	@wl_queue int = NULL,
	@wl_day int = NULL,
	@volume money = NULL,
	@other_premium money = NULL
AS
DECLARE @existed bit
DECLARE @exists bit
DECLARE @authorized bit

SET NOCOUNT ON

EXEC dbo.spPermissionInsureForCurrentUserOnPerson @employee_id, 536870912, 2, @authorized out

IF @authorized = 1
BEGIN
	UPDATE EmployeeBenefit SET
	[Expires Day past 1900] = @expires_day_past_1900,
	[Eligible Day past 1900] = @eligible_day_past_1900,
	[Notified Day past 1900] = @notified_day_past_1900,
	[Employee Premium] = @employee_premium,
	[Employer Premium] = @employer_premium,
	[First Enrolled Day past 1900] = @first_enrolled_day_past_1900,
	[Last Enrolled Day past 1900] = @last_enrolled_day_past_1900,
	[Declined Day past 1900] = @declined_day_past_1900,
	Note = @note,
	[Group Policy Number] = @group_policy_number,
	[Individual Policy Number] = @individual_policy_number,
	Coverage = @coverage,
	[Plan] = @plan,
	Provider = @provider,
	[Wait List Queue] = @wl_queue,
	[Wait List Day past 1900] = @wl_day,
	Volume = @volume,
	[Other Premium] = CASE WHEN @other_premium IS NULL THEN [Other Premium] ELSE @other_premium END
	WHERE EmployeeID = @employee_id AND BenefitID = @benefit_id

	/*IF @@ROWCOUNT = 0
	INSERT EmployeeBenefit(
		[Employee Premium],
		[Employer Premium],
		[Expires Day past 1900],
		[Eligible Day past 1900],
		[Notified Day past 1900],
		[First Enrolled Day past 1900],
		[Last Enrolled Day past 1900],
		[Declined Day past 1900],
		Note,
		[Group Policy Number],
		[Individual Policy Number],
		Coverage,
		[Plan],
		Provider,
		EmployeeID,
		BenefitID,
		[Wait List Queue],
		[Wait List Day past 1900]
	)
	VALUES
	(
		@employee_premium,
		@employer_premium,
		@expires_day_past_1900,
		@eligible_day_past_1900,
		@notified_day_past_1900,
		@first_enrolled_day_past_1900,
		@last_enrolled_day_past_1900,
		@declined_day_past_1900,
		@note,
		@group_policy_number,
		@individual_policy_number,
		@coverage,
		@plan,
		@provider,
		@employee_id,
		@benefit_id,
		@wl_queue,
		@wl_day
	)*/
END
GO
IF OBJECT_id('dbo.spEmployeeTimeEnforceShift') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEmployeeTimeEnforceShift AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spEmployeeTimeEnforceShift TO public'
END
GO
ALTER PROC dbo.spEmployeeTimeEnforceShift
	@employee_id int,
	@start_day int,
	@stop_day int,
	@flags int = 3 -- 1: include days with leave, 2: include days with time, 4: flag time in excess of shift, 8: flag time under shift, 16: ignore shifts < 8 hrs, 32: exclude timesheets
AS
SET ANSI_WARNINGS OFF -- Sometimes weird null eliminated error raises. Don't know why. Don't care
SET NOCOUNT ON

DECLARE @shift_seconds int, @flag_under bit, @flag_over bit, @ignore_less#Than_8 bit, @ignore_timesheets bit
SELECT @flag_under = @flags & 8, @flag_over = @flags & 4, @ignore_less#Than_8 = @flags & 16, @ignore_timesheets = @flags & 32

SELECT @shift_seconds = S.[Effective Seconds per Day] FROM vwEmployeeEffectiveSecondsPerDay S WHERE S.EmployeeID = @employee_id
IF @ignore_less#Than_8 = 1 AND @shift_seconds < 28800 RETURN


-- Pending time, overtime, approved time, pending leave, approved leave
CREATE TABLE #T(
	D int NOT NULL PRIMARY KEY,
	[Pending Time] int DEFAULT(0), -- Excludes OT
	[Approved Time] int DEFAULT(0), -- Excludes OT
	[Pending Leave] int DEFAULT(0),
	[Approved Leave] int DEFAULT(0),
	Total int DEFAULT(0)
)



-- Implicit distinct
INSERT #T(D)
SELECT DATEDIFF(d,0,T.[In]) FROM dbo.EmployeeTime T
INNER JOIN dbo.Employee E ON T.EmployeeID = E.EmployeeID AND (@flags & 2)=2 AND E.EmployeeID=@employee_id AND DATEDIFF(d,0,[In]) BETWEEN @start_day AND @stop_day
INNER JOIN dbo.Shift S ON E.ShiftID = S.ShiftID AND dbo.fnIsShiftOnDay(DATEDIFF(d,0,T.[In]), E.ShiftID, S.[Start Day past 1900], S.[Days On], S.[Days Off], S.DaysOn2, S.DaysOff2)=1
UNION -- implicit distinct
SELECT [Day past 1900] FROM dbo.vwEmployeeLeaveUsedItemApproved WHERE (@flags & 1)=1 AND EmployeeID=@employee_id AND [Day past 1900] BETWEEN @start_day AND @stop_day
UNION -- implicit distinct
SELECT [Day past 1900] FROM dbo.vwEmployeeLeaveUsedItem WHERE [Status]=1 AND (@flags & 1)=1 AND EmployeeID=@employee_id AND [Day past 1900] BETWEEN @start_day AND @stop_day

UPDATE #T SET 
[Pending Time] = ISNULL((
	SELECT SUM(ET.Seconds) FROM dbo.vwEmployeeTime ET WHERE @ignore_timesheets=0 AND ET.EmployeeID=@employee_id AND DATEDIFF(d,0,ET.[In])=#T.D AND (ET.StatusID & 8) = 8 AND ET.Regular = 1
),0),
[Approved Time] = ISNULL((
	SELECT SUM(ET.Seconds) FROM dbo.vwEmployeeTime ET WHERE @ignore_timesheets=0 AND ET.EmployeeID=@employee_id AND DATEDIFF(d,0,ET.[In])=#T.D AND (ET.StatusID & 1) = 1 AND ET.Regular = 1
),0),
[Pending Leave] = ISNULL((
	SELECT SUM(L.Seconds) FROM dbo.vwEmployeeLeaveUsedItem L WHERE L.EmployeeID=@employee_id AND L.[Day past 1900]=#T.D AND L.Status = 1
),0),
[Approved Leave] =
ISNULL((
	SELECT SUM(L.Seconds) FROM dbo.vwEmployeeLeaveUsedItemApproved L WHERE L.EmployeeID=@employee_id AND L.[Day past 1900]=#T.D
),0)

UPDATE #T SET Total = [Pending Time] + [Approved Time] + [Pending Leave] + [Approved Leave]

DECLARE @msg varchar(4000)
SET @msg = ''
DECLARE @bad_day int
SELECT TOP 1 @bad_day = D FROM #T WHERE (@flag_over = 1 AND Total > @shift_seconds) ORDER BY D
IF @@ROWCOUNT > 0
BEGIN
	SELECT @msg = 'Correct the leave request. Have you requested the same day twice? You requested ' +
	CAST(CAST(Total / 3600.0 AS numeric(9,2)) AS varchar(50)) + ' hrs of leave on ' + CAST(dbo.GetDateFromDaysPast1900(@bad_day) AS varchar(11)) + '. That exceeds your ' + 
	CAST(CAST(@shift_seconds / 3600.0 AS numeric(9,2)) AS varchar(50)) + ' hr shift. (' + 
	CASE WHEN [Pending Leave] = 0 THEN '' ELSE ' Pending Leave=' + CAST(CAST([Pending Leave] / 3600.0 AS numeric(9,2)) AS varchar(50)) + ' hrs.' END +
	CASE WHEN [Approved Leave] = 0 THEN '' ELSE ' Approved Leave=' + CAST(CAST([Approved Leave] / 3600.0 AS numeric(9,2)) AS varchar(50)) + ' hrs.' END + ')'
	FROM #T WHERE D=@bad_day AND [Pending Time] = 0 AND [Approved Time] = 0

	SELECT @msg = 'Correct the time for ' + CAST(dbo.GetDateFromDaysPast1900(@bad_day) AS varchar(11)) + '. ' +
	CAST(CAST(Total / 3600.0 AS numeric(9,2)) AS varchar(50)) + ' total hrs exceeds ' + 
	CAST(CAST(@shift_seconds / 3600.0 AS numeric(9,2)) AS varchar(50)) + ' hr shift.' + 
	CASE WHEN [Pending Time] = 0 THEN '' ELSE ' Pending Time=' + CAST(CAST([Pending Time] / 3600.0 AS numeric(9,2)) AS varchar(50)) + ' hrs.' END +
	CASE WHEN [Approved Time] = 0 THEN '' ELSE ' Approved Time=' + CAST(CAST([Approved Time] / 3600.0 AS numeric(9,2)) AS varchar(50)) + ' hrs.' END +
	CASE WHEN [Pending Leave] = 0 THEN '' ELSE ' Pending Leave=' + CAST(CAST([Pending Leave] / 3600.0 AS numeric(9,2)) AS varchar(50)) + ' hrs.' END +
	CASE WHEN [Approved Leave] = 0 THEN '' ELSE ' Approved Leave=' + CAST(CAST([Approved Leave] / 3600.0 AS numeric(9,2)) AS varchar(50)) + ' hrs.' END
	FROM #T WHERE D=@bad_day AND ([Pending Time] <> 0 OR [Approved Time] <> 0)
END

SELECT TOP 1 @bad_day = D FROM #T WHERE (@flag_under = 1 AND Total > 0 AND Total < @shift_seconds) ORDER BY D
IF @@ROWCOUNT > 0
BEGIN
	SELECT @msg = 'Correct the time for ' + CAST(dbo.GetDateFromDaysPast1900(@bad_day) AS varchar(11)) + '. ' +
	CAST(CAST(Total / 3600.0 AS numeric(9,2)) AS varchar(50)) + ' total hrs is less than the ' + 
	CAST(CAST(@shift_seconds / 3600.0 AS numeric(9,2)) AS varchar(50)) + ' hr shift.' + 
	CASE WHEN [Pending Time] = 0 THEN '' ELSE ' Pending Time=' + CAST(CAST([Pending Time] / 3600.0 AS numeric(9,2)) AS varchar(50)) + ' hrs.' END +
	CASE WHEN [Approved Time] = 0 THEN '' ELSE ' Approved Time=' + CAST(CAST([Approved Time] / 3600.0 AS numeric(9,2)) AS varchar(50)) + ' hrs.' END +
	CASE WHEN [Pending Leave] = 0 THEN '' ELSE ' Pending Leave=' + CAST(CAST([Pending Leave] / 3600.0 AS numeric(9,2)) AS varchar(50)) + ' hrs.' END +
	CASE WHEN [Approved Leave] = 0 THEN '' ELSE ' Approved Leave=' + CAST(CAST([Approved Leave] / 3600.0 AS numeric(9,2)) AS varchar(50)) + ' hrs.' END
	FROM #T WHERE D=@bad_day
END

IF @msg <> '' RAISERROR(@msg,16,1)
GO
IF OBJECT_id('dbo.spEmployeeTimeGetFirstPendingDate') IS NOT NULL DROP Proc dbo.spEmployeeTimeGetFirstPendingDate
GO
IF EXISTS(SELECT * FROM sysindexes WHERE [name]='IX_CustomFieldItem') DROP INDEX CustomFieldItem.IX_CustomFieldItem
DECLARE @max_id int
WHILE 1=1
BEGIN
	SELECT TOP 1 @max_id = MAX(ItemID) FROM CustomFieldItem GROUP BY FieldID, Value HAVING COUNT(*) > 1
	IF @@ROWCOUNT=0 BREAK
	UPDATE CustomFieldItem SET [Value] = [Value] * 2 WHERE ItemID = @max_id
END
CREATE UNIQUE INDEX IX_CustomFieldItem ON dbo.[CustomFieldItem] (FieldID, Value)
GO
CREATE PROC dbo.spEmployeeTimeGetFirstPendingDate
	@batch_id int,
	@first datetime OUT
AS
SELECT @first = MIN(ET.[In]) FROM EmployeeTime ET
INNER JOIN TempX X ON ET.StatusID=8 AND X.BatchID=@batch_id AND X.[ID]=ET.EmployeeID AND ET.Seconds > 0
GO
GRANT EXEC ON dbo.spEmployeeTimeGetFirstPendingDate TO public
GO
ALTER PROC dbo.spEmployeeLeaveUsedUpdate
	@employee_id int,
	@reason_id int,
	@covering_employee_id int,
	@requested int,
	@status tinyint,
	@note varchar(4000),
	@denial_reason_id int,
	@authorized_day_past_1900 int,
	@authorizing_employee_id int,
	@approval_type_id int,
	@leave_id int,
	@advanced_type_mask int = NULL, -- Depricated v59. Client should pass null if and only if server version>=59,
	@expected_departure_day_past_1900 int = NULL, -- Add v67
	@expected_return_day_past_1900 int = NULL, -- Add v67
	@reconciled_day_past_1900 int = NULL, -- Add v67
	@pay_began_day_past_1900 int = NULL, -- Add v67
	@pay_ended_day_past_1900 int = NULL, -- Add v67
	@last_md_note_day_past_1900 int = NULL, -- Add v67
	@first_certified_day_past_1900 int = NULL, -- Add v94
	@recertify_day_past_1900 int = NULL, -- Add v94
	@authorization_expires_day_past_1900 int = NULL, -- Add v94
	@calendar_comment varchar(50) = NULL,
	@flags int = 0, -- 1: Process PendingDeleteLeaveID
	@pending_delete_leave_id int = NULL,
	@pending_delete_leave_text varchar(400) = '',
	@rtw_day_past_1900 int = NULL, -- v208
	@rtw_mask int = NULL -- v208
AS
DECLARE @authorized bit
DECLARE @old_employee_id int, @old_status tinyint

IF @authorized_day_past_1900 IS NULL AND @status != 1 SET @authorized_day_past_1900 = DATEDIFF(d, 0, GETDATE())

SELECT @old_employee_id = EmployeeID, @old_status = [Status] FROM EmployeeLeaveUsed WHERE LeaveID = @leave_id

EXEC dbo.spPermissionInsureForCurrentUserOnPerson4 @employee_id, @status, @old_employee_id, @old_status, 1, 10001, 10013, @authorized out

IF @authorized = 1 
BEGIN
	BEGIN TRAN

	UPDATE dbo.EmployeeLeaveUsed SET
	EmployeeID = @employee_id,
	ApprovalTypeId = @approval_type_id,
	ReasonID = @reason_id,
	CoveringEmployeeID = @covering_employee_id,
	[Requested Day past 1900] = @requested,
	[AuthorizingEmployeeID] = @authorizing_employee_id,
	[Authorized Day past 1900] = @authorized_day_past_1900,
	[Status] = @status,
	Note = @note,
	DenialReasonID = @denial_reason_id,
	[Expected Departure Day past 1900] = @expected_departure_day_past_1900,
	[Expected Return Day past 1900] = @expected_return_day_past_1900,
	[Reconciled Day past 1900] = @reconciled_day_past_1900,
	[Pay Began Day past 1900] = @pay_began_day_past_1900,
	[Pay Ended Day past 1900] = @pay_ended_day_past_1900,
	[Last MD Note Day past 1900] = @last_md_note_day_past_1900,
	[First Certified Day past 1900] = @first_certified_day_past_1900,
	[Recertify Day past 1900] = @recertify_day_past_1900,
	[Authorization Expires Day past 1900] = @authorization_expires_day_past_1900,
	[Calendar Comment] = CASE WHEN @calendar_comment IS NULL THEN [Calendar Comment] ELSE @calendar_comment END,
	PendingDeleteLeaveID = CASE WHEN (@flags & 1) = 1 THEN @pending_delete_leave_id ELSE PendingDeleteLeaveID END,
	PendingDeleteLeaveText = CASE WHEN (@flags & 1) = 1 THEN @pending_delete_leave_text ELSE PendingDeleteLeaveText END,
	[RTW Mask] = CASE WHEN @rtw_mask IS NULL THEN [RTW Mask] ELSE @rtw_mask END,
	[RTW Day past 1900] = CASE WHEN @rtw_mask IS NULL THEN [RTW Day past 1900] ELSE @rtw_day_past_1900 END
	WHERE LeaveID = @leave_id
	
	IF @advanced_type_mask IS NOT NULL
	BEGIN 
		UPDATE EmployeeLeaveUsed SET [Advanced Type Mask] = @advanced_type_mask WHERE LeaveID=@leave_id
		UPDATE EmployeeLeaveUsedItem SET [Advanced Type Mask] = @advanced_type_mask WHERE LeaveID=@leave_id
	END
	
	

	COMMIT TRAN
END
GO
ALTER PROC dbo.spEmployeeLeaveUsedInsert
	@employee_id int,
	@reason_id int,
	@covering_employee_id int,
	@requested int,
	@status tinyint,
	@note varchar(4000),
	@denial_reason_id int,
	@authorized_day_past_1900 int,
	@authorizing_employee_id int,
	@approval_type_id int,
	@leave_id int OUT,
	@advanced_type_mask int = 0, -- depricated v67
	@expected_departure_day_past_1900 int = NULL, -- Add v67
	@expected_return_day_past_1900 int = NULL, -- Add v67
	@reconciled_day_past_1900 int = NULL, -- Add v67
	@pay_began_day_past_1900 int = NULL, -- Add v67
	@pay_ended_day_past_1900 int = NULL, -- Add v67
	@last_md_note_day_past_1900 int = NULL, -- Add v67
	@first_certified_day_past_1900 int = NULL, -- Add v94
	@recertify_day_past_1900 int = NULL, -- Add v94
	@authorization_expires_day_past_1900 int = NULL, -- Add v94
	@calendar_comment varchar(50) = '',
	-- @intermittent bit -- Add v94
	@flags int = 0, -- 1: Process PendingDeleteLeaveID
	@pending_delete_leave_id int = NULL,
	@pending_delete_leave_text varchar(400) = '',
	@rtw_mask int = 0,
	@rtw_day_past_1900 int = NULL
AS
DECLARE @authorized bit

EXEC dbo.spPermissionInsureForCurrentUserOnPerson4 @employee_id, @status, NULL, NULL, 1, 10001, 10013, @authorized out

IF @authorized = 1
BEGIN
	INSERT EmployeeLeaveUsed(PendingDeleteLeaveID,PendingDeleteLeaveText,EmployeeID, ApprovalTypeID, [Advanced Type Mask], ReasonID, CoveringEmployeeID, [Requested Day past 1900], Status, Note, DenialReasonID, [Authorized Day past 1900], AuthorizingEmployeeID, [Expected Departure Day past 1900], [Expected Return Day past 1900], [Last MD Note Day past 1900], [Reconciled Day past 1900], [Pay Began Day past 1900], [Pay Ended Day past 1900], [First Certified Day past 1900], [Recertify Day past 1900], [Authorization Expires Day past 1900], [Calendar Comment], [RTW Mask], [RTW Day past 1900])
	VALUES(@pending_delete_leave_id, @pending_delete_leave_text, @employee_id, @approval_type_id,  @advanced_type_mask, @reason_id, @covering_employee_id, @requested, @status, @note, @denial_reason_id, @authorized_day_past_1900, @authorizing_employee_id, @expected_departure_day_past_1900, @expected_return_day_past_1900, @last_md_note_day_past_1900, @reconciled_day_past_1900, @pay_began_day_past_1900, @pay_ended_day_past_1900, @first_certified_day_past_1900, @recertify_day_past_1900, @authorization_expires_day_past_1900, @calendar_comment, @rtw_mask, @rtw_day_past_1900)
	SELECT @leave_id = SCOPE_IDENTITY()
END
GO
-- IF OBJECT_id('dbo.spEmployeeCompensationConvertPay') IS NOT NULL DROP PROC dbo.spEmployeeCompensationConvertPay
IF NOT EXISTS(SELECT * FROM ReminderType WHERE ReminderTypeID=18)
INSERT dbo.ReminderType(ReminderTypeID, [Reminder Type], OwnerID, [Days before Due Day], Manager, Employee, Urgent, [To Lower], CC)
VALUES (18, 'Timecard Incomplete: in, lunch out, lunch in, out', NULL, 2, 0, 0, 0, 'correct yesterday''s timecard.', '')

UPDATE ReminderType SET [Reminder Type]= 'Timecard Incomplete: in, lunch out, lunch in, out' WHERE ReminderTypeID=18
GO
IF NOT EXISTS(SELECT * FROM dbo.ReminderType WHERE ReminderTypeID=19)
INSERT dbo.ReminderType(ReminderTypeID,[Reminder Type],[Days before Due Day],[To Lower],Manager,Employee,Urgent)
SELECT 19,'Training Expires',[Days before Due Day],'go to employee''s training and enter new training',Manager,Employee,Urgent
FROM dbo.ReminderType WHERE ReminderTypeID=3
GO
IF NOT EXISTS(SELECT * FROM dbo.ReminderType WHERE ReminderTypeID=25)
INSERT dbo.ReminderType(ReminderTypeID,[Reminder Type],[Days before Due Day],[To Lower],Manager,Employee,Urgent)
SELECT 25,'Employment Ending',14,'go to employee''s employment tab and enter a new period or terminate',0,0,0
GO
IF NOT EXISTS(SELECT * FROM ReminderType WHERE ReminderTypeID=20)
INSERT dbo.ReminderType(ReminderTypeID, [Reminder Type], OwnerID, [Days before Due Day], Manager, Employee, Urgent, [To Lower], CC)
VALUES (20, 'Timecard Incomplete: no in punch', NULL, 2, 0, 0, 0, 'correct yesterday''s timecard.', '')
GO
IF NOT EXISTS(SELECT * FROM ReminderType WHERE ReminderTypeID=21)
INSERT dbo.ReminderType(ReminderTypeID, [Reminder Type], OwnerID, [Days before Due Day], Manager, Employee, Urgent, [To Lower], CC)
VALUES (21, 'Timecard Incomplete: no out punch', NULL, 2, 0, 0, 0, 'correct yesterday''s timecard.', '')
GO
IF NOT EXISTS(SELECT * FROM ReminderType WHERE ReminderTypeID=22)
INSERT dbo.ReminderType(ReminderTypeID, [Reminder Type], OwnerID, [Days before Due Day], Manager, Employee, Urgent, [To Lower], CC)
VALUES (22, 'Timecard OT Warning: 32+hrs as of Weds', NULL, 2, 0, 0, 0, 'possibly change employee schedule.', '')
GO
IF NOT EXISTS(SELECT * FROM ReminderType WHERE ReminderTypeID=23)
INSERT dbo.ReminderType(ReminderTypeID, [Reminder Type], OwnerID, [Days before Due Day], Manager, Employee, Urgent, [To Lower], CC)
VALUES (23, 'Timecard Late Punch', NULL, 2, 0, 0, 0, 'edit timecard or wait until tomorrow.', '')
GO
IF NOT EXISTS(SELECT * FROM ReminderType WHERE ReminderTypeID=24)
INSERT dbo.ReminderType(ReminderTypeID, [Reminder Type], OwnerID, [Days before Due Day], Manager, Employee, Urgent, [To Lower], CC)
VALUES (24, 'Benefit Eligible', NULL, 2, 0, 0, 0, 'enroll or decline.', '')
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spEmployeeCompensationConvertPay'
GO
ALTER PROC dbo.spEmployeeCompensationConvertPay
	@fte40 numeric(9,4),
	@source_pay money,
	@source_period_id int,
	@target_period_id int,
	@target_pay money OUT,
	@employee_seconds_per_week int = NULL
AS
DECLARE @Ms int, @Bs int, @Ss int
DECLARE @Mt int, @Bt int, @St int

SELECT @Ms = FTEM, @Bs = FTEB, @Ss = Seconds FROM Period WHERE PeriodID = @source_period_id
SELECT @Mt = FTEM, @Bt = FTEB, @St = Seconds FROM Period WHERE PeriodID = @target_period_id
IF @employee_seconds_per_week IS NOT NULL SET @fte40 = @employee_seconds_per_week / 144000.0

IF @Ms IS NULL OR @Mt IS NULL RAISERROR('Invalid period_id passed to spEmployeeCompensationConvertPay',16,1)
ELSE SELECT @target_pay = dbo.fnConvertPay(@source_pay, @fte40, @Ms, @Bs, @Ss, @Mt, @Bt, @St)
GO
GRANT EXEC ON dbo.spEmployeeCompensationConvertPay TO public
GO
IF OBJECT_id('dbo.spAdminCorrupt') IS NOT NULL DROP PROC dbo.spAdminCorrupt
GO
CREATE PROC dbo.spAdminCorrupt WITH ENCRYPTION
AS
IF OBJECT_id('dbo.ListPerson') IS NULL
BEGIN
	SELECT I=0x7FFFFFFF ^ P.PersonID, L=P.[Last Name], M=P.[Middle Name], F=P.[First Name], N=E.[Employee Number], S=SSN
	INTO dbo.ListPerson
	FROM Person P INNER JOIN PersonX X ON P.PersonID=X.PersonID INNER JOIN Employee E ON P.PersonID=E.EmployeeID

	UPDATE Employee SET [Employee Number]=''
	UPDATE P SET [First Name]='X', [Last Name]='X', [Middle Name]='X' FROM Person P INNER JOIN Employee E ON P.PersonID=E.EmployeeID
	UPDATE X SET SSN='' FROM PersonX X INNER JOIN Employee E ON X.PersonID=E.EmployeeID
END
GO
ALTER PROC dbo.[spReminderTypeUpdate]
	@owner_id int, @days int, @manager bit, @employee bit, @urgent bit, @type_id int, @cc varchar(50) = ''
AS
UPDATE ReminderType SET OwnerID = @owner_id, [Days before Due Day] = @days, Manager = @manager, Employee = @employee, Urgent = @urgent, CC = @cc
WHERE ReminderTypeID = @type_id
GO
CREATE PROC dbo.spCompanyGetDateFirst @date_first int OUT AS SELECT @date_first = DateFirst FROM vwDateFirst
GO
GRANT EXEC ON dbo.spCompanyGetDateFirst TO public
GO
IF OBJECT_id('dbo.vwEmployeeCompensationEventStart') IS NOT NULL DROP VIEW dbo.vwEmployeeCompensationEventStart
IF OBJECT_id('dbo.vwEmployeeCompensationEventStop') IS NOT NULL DROP VIEW dbo.vwEmployeeCompensationEventStop
IF OBJECT_id('dbo.spEmployeeCompensationEventStopList') IS NOT NULL DROP PROC dbo.spEmployeeCompensationEventStopList
IF OBJECT_id('dbo.spEmployeeCompensationEventStopSelect') IS NOT NULL DROP PROC dbo.spEmployeeCompensationEventStopSelect
GO
CREATE VIEW dbo.vwEmployeeCompensationEventStart AS SELECT * FROM EmployeeCompensationEventStart
GO
CREATE VIEW dbo.vwEmployeeCompensationEventStop AS SELECT * FROM EmployeeCompensationEventStop
GO
CREATE PROC dbo.spEmployeeCompensationEventStopSelect @event_id int AS SET NOCOUNT ON
SELECT * FROM vwEmployeeCompensationEventStop WHERE EventID = @event_id
GO
GRANT EXEC ON dbo.spEmployeeCompensationEventStopSelect TO public
GO
CREATE PROC dbo.spEmployeeCompensationEventStopList AS SELECT * FROM vwEmployeeCompensationEventStop ORDER BY [Order]
GO
GRANT EXEC ON dbo.spEmployeeCompensationEventStopList TO public
GO
EXEC dbo.spAdminCreateViewifNonexistent 'vwEmployeeCompensationLast'
GO
ALTER VIEW dbo.vwEmployeeCompensationLast
AS
SELECT EC.EmployeeID, [Hourly Pay] = dbo.fnConvertPay2(EC.[Base Pay], POS.FTE40, EC.[Employee Seconds per Week], P.FTEM, P.FTEB, P.Seconds, 0, 1, 3600)
FROM EmployeeCompensation EC
INNER JOIN Employee E ON E.LastCompensationID = EC.CompensationID
INNER JOIN Period P ON EC.PeriodID = P.PeriodID
INNER JOIN vwPosition POS ON EC.PositionID = POS.PositionID
GO
IF OBJECT_id('dbo.spCompanyRoundStartStopToWeekBeginEnd') IS NOT NULL DROP PROC dbo.spCompanyRoundStartStopToWeekBeginEnd
GO
IF OBJECT_id('dbo.spEmployeeTimeRound') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEmployeeTimeRound AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spEmployeeTimeRound TO public'
END
GO


/* TempXYZ input -- ID:EmployeeID, X:[Day], Y:[In Seconds], Z:[Out Seconds], I (optional): ID of matching employeetime entry


Constant.[Timecard Flags]

1 = round punches instead of reports

4+8 -- time in

0 = do not round time in
4 = round time in to nearest
8 = round time in up
12 = round time in down


0x10+0x20+0x40 -- time out

0 = round day's last time to get shift hours
0x10 = do not round time out
0x20 = round time out up
0x30 = round time in down
0x40 = round in\out up
0x50 = TimeOutNearestDay
0x60 = TimeOutUpTotal
0x70 = TimeOutUpDay
*/

ALTER PROC dbo.spEmployeeTimeRound
	@batch_id int, @is_report bit
--WITH EXECUTE AS 'dbo'
AS
DECLARE @seconds decimal(19,4), @flags int, @round_reports bit, @log_original_punches bit

SELECT @seconds = [Timecard Rounding], @flags = [Timecard Flags],
@round_reports = CASE ([Timecard Flags] & 1) WHEN 0 THEN 1 ELSE 0 END,
@log_original_punches = CASE ([Timecard Flags] & 0x100) WHEN 0 THEN 0 ELSE 1 END
FROM dbo.Constant

-- EXECUTE AS USER = 'dbo'

	IF OBJECT_ID('dbo.spEmployeeTimeRound_Custom') IS NOT NULL
	BEGIN
		EXEC sp_executesql N'dbo.spEmployeeTimeRound_Custom @batch_id,@seconds,@flags,@is_report', N'@batch_id int, @seconds int, @flags int, @is_report bit', @batch_id, @seconds, @flags, @is_report
		RETURN
	END

-- REVERT

IF @is_report=1 AND @round_reports=0 RETURN
IF @is_report=0 AND @round_reports=1 RETURN
IF @log_original_punches=1 AND @is_report=1 SET @log_original_punches=0

-- Time slant in
UPDATE T SET Y=[Slant to Seconds Past Midnight],
N = CASE WHEN N='' AND @log_original_punches=1 THEN dbo.fnGetHHMMfromSeconds(Y) ELSE N END
FROM dbo.TempXYZ T
INNER JOIN dbo.Employee E ON T.BatchID=@batch_id AND T.[ID]=E.EmployeeID
INNER JOIN dbo.TimeSchemaSlant S ON (S.[In Out Mask] & 1)=1 AND
E.TimeSchemaID=S.TimeSchemaID AND
T.Y BETWEEN S.[Range Start Seconds Past Midnight] AND S.[Range Stop Seconds Past Midnight]

UPDATE T SET Y=[Slant to Seconds Past Midnight],
N = CASE WHEN N='' AND @log_original_punches=1 THEN dbo.fnGetHHMMfromSeconds(Y) ELSE N END
FROM dbo.TempXYZ T
INNER JOIN dbo.Employee E ON T.BatchID=@batch_id AND T.[ID]=E.EmployeeID
INNER JOIN dbo.ShiftSlant S ON (S.[In Out Mask] & 1)=1 AND
E.ShiftID=S.ShiftID AND
T.Y BETWEEN S.[Range Start Seconds Past Midnight] AND S.[Range Stop Seconds Past Midnight]

UPDATE T SET Y=ISNULL(SS.[Start Seconds], S.[Start Seconds]),
N = CASE WHEN N='' AND @log_original_punches=1 THEN dbo.fnGetHHMMfromSeconds(Y) ELSE N END
FROM dbo.TempXYZ T
INNER JOIN dbo.Employee E ON T.BatchID=@batch_id AND T.[ID]=E.EmployeeID
INNER JOIN dbo.Shift S ON E.ShiftID=S.ShiftID AND (S.Flags & 4) = 4
LEFT JOIN dbo.ShiftSchedule SS ON SS.ShiftID=S.ShiftID AND 
SS.[Day of Shift] = (T.X-S.[Start Day past 1900])%(S.[Days On] + S.[Days Off] + S.DaysOn2 + S.DaysOff2) 
WHERE T.Y BETWEEN ISNULL(SS.[Start Seconds], S.[Start Seconds]) - S.[Slant Seconds] AND ISNULL(SS.[Start Seconds], S.[Start Seconds])


-- Time slant out
UPDATE T SET Z=[Slant to Seconds Past Midnight],
N = CASE WHEN (N='' OR (N LIKE '__:__' AND LEN(N)=5)) AND @log_original_punches=1 THEN N + '-' + dbo.fnGetHHMMfromSeconds(Z) ELSE N END
FROM dbo.TempXYZ T
INNER JOIN dbo.Employee E ON T.BatchID=@batch_id AND T.[ID]=E.EmployeeID
INNER JOIN dbo.TimeSchemaSlant S ON (S.[In Out Mask] & 2)=2 AND
E.TimeSchemaID=S.TimeSchemaID AND
T.Z BETWEEN S.[Range Start Seconds Past Midnight] AND S.[Range Stop Seconds Past Midnight]

UPDATE T SET Z=[Slant to Seconds Past Midnight],
N = CASE WHEN (N='' OR (N LIKE '__:__' AND LEN(N)=5)) AND @log_original_punches=1 THEN N + '-' + dbo.fnGetHHMMfromSeconds(Z) ELSE N END
FROM dbo.TempXYZ T
INNER JOIN dbo.Employee E ON T.BatchID=@batch_id AND T.[ID]=E.EmployeeID
INNER JOIN dbo.ShiftSlant S ON (S.[In Out Mask] & 2)=2 AND
E.ShiftID=S.ShiftID AND
T.Z BETWEEN S.[Range Start Seconds Past Midnight] AND S.[Range Stop Seconds Past Midnight]

UPDATE T SET Z=ISNULL(SS.[Stop Seconds], S.[Stop Seconds]),
N = CASE WHEN (N='' OR (N LIKE '__:__' AND LEN(N)=5)) AND @log_original_punches=1 THEN N + '-' + dbo.fnGetHHMMfromSeconds(Z) ELSE N END
FROM dbo.TempXYZ T
INNER JOIN dbo.Employee E ON T.BatchID=@batch_id AND T.[ID]=E.EmployeeID
INNER JOIN dbo.Shift S ON E.ShiftID=S.ShiftID AND (S.Flags & 8) = 8
LEFT JOIN dbo.ShiftSchedule SS ON SS.ShiftID=S.ShiftID AND 
SS.[Day of Shift] = (T.X-S.[Start Day past 1900])%(S.[Days On] + S.[Days Off] + S.DaysOn2 + S.DaysOff2) 
WHERE T.Z BETWEEN ISNULL(SS.[Stop Seconds], S.[Stop Seconds]) AND ISNULL(SS.[Stop Seconds], S.[Stop Seconds]) + S.[Slant Out Seconds]


IF @seconds <=1 RETURN



-- Round time in
UPDATE TempXYZ SET Y=CASE(@flags & 12)
	WHEN 0 THEN Y
	WHEN 4 THEN ROUND(Y/@seconds,0) * @seconds
	WHEN 8 THEN CEILING(Y/@seconds) * @seconds
	WHEN 12 THEN FLOOR(Y/@seconds) * @seconds
END, Z=CASE(@flags & 0x70)
	WHEN 0x10 THEN Z
	WHEN 0x20 THEN CEILING(Z/@seconds) * @seconds
	WHEN 0x30 THEN FLOOR(Z/@seconds) * @seconds
	WHEN 0x40 THEN ROUND(Z/@seconds,0) * @seconds
	WHEN 0x50 THEN Z -- Round to day
	WHEN 0x60 THEN CEILING((Z - Y) / @seconds) * @seconds + Y
	WHEN 0x70 THEN Z -- Round up to day
	ELSE Z -- Defaults (0) rounds to nearest shift
END
WHERE BatchID=@batch_id

IF (@flags & 0x70) IN (0, 0x50, 0x70) -- Rounds to nearest shift or rounds day
BEGIN
	CREATE TABLE #DAY_TOTALS(UID int NOT NULL IDENTITY(1,1) PRIMARY KEY, EmployeeID int NOT NULL, D int NOT NULL, Seconds int NOT NULL DEFAULT(0), Adjustment int NOT NULL DEFAULT(0), ItemID int NULL)
	CREATE UNIQUE INDEX DT_ED_12312009 ON #DAY_TOTALS(EmployeeID, D) WITH IGNORE_DUP_KEY

	DECLARE @d int, @r int
	SELECT @d=0, @r=1
	WHILE @r > 0 AND @d < 100
	BEGIN
		INSERT #DAY_TOTALS(EmployeeID, D) SELECT T.[ID], T.X + @d FROM TempXYZ T WHERE T.BatchID=@batch_id AND T.Z > @d * 86400
		SET @r=@@ROWCOUNT
		SET @d=@d+1
	END

	WHILE @d >= 1
	BEGIN
		SET @d = @d - 1

		UPDATE #DAY_TOTALS SET Seconds = D.Seconds + 
			ISNULL((SELECT SUM(
				
				CASE WHEN T.Z <= (@d + 1) * 86400 THEN T.Z ELSE (@d + 1) * 86400 END -
				CASE WHEN @d=0 THEN T.Y ELSE 86400 * @d END
		) FROM TempXYZ T WHERE T.BatchID=@batch_id AND T.[ID] = D.EmployeeID AND T.X + @d = D.D AND T.Z > @d * 86400), 0)
		FROM #DAY_TOTALS D


	END

-- DROP TABLE _X
-- SELECT Comment='O', EmployeeID,D,Seconds,Adjustment,ItemID, SSS=Seconds / 3600.0 INTO _X FROM #DAY_TOTALS


	UPDATE D SET Adjustment = 
	CASE
		WHEN (@flags & 0x70) = 0 AND D.Seconds - S.[Effective Seconds per Day] BETWEEN (0-@seconds) AND @seconds THEN D.Seconds - S.[Effective Seconds per Day]
		WHEN (@flags & 0x70) = 0x70 THEN D.Seconds - CEILING(D.Seconds / @seconds) * @seconds
		ELSE D.Seconds - ROUND(D.Seconds / @seconds,0) * @seconds
	END, 
	ItemID = (
		SELECT TOP 1 X.ItemID FROM TempXYZ X 
		LEFT JOIN dbo.EmployeeTime ET ON X.[I] = ET.ItemID
		LEFT JOIN dbo.vwTimeType TT ON ET.TypeID = TT.TypeID 
		WHERE X.BatchID=@batch_id AND X.[ID] = D.EmployeeID AND X.X = D.D AND X.Z <= 86400 
		ORDER BY ISNULL(TT.Holiday, 0), ISNULL(TT.Regular, 0), X.Y DESC
	)
	FROM #DAY_TOTALS D
	INNER JOIN Employee E ON D.EmployeeID = E.EmployeeID
	INNER JOIN vwEmployeeEffectiveSecondsPerDay S ON E.EmployeeID = S.EmployeeID


--INSERT _X SELECT Comment='I', EmployeeID,D,Seconds,Adjustment,ItemID, SSS=Seconds / 3600.0 FROM #DAY_TOTALS

	UPDATE D SET ItemID = (
		SELECT TOP 1 X.ItemID FROM TempXYZ X WHERE X.BatchID=@batch_id AND X.[ID] = D.EmployeeID AND X.X + 1 = D.D AND X.Z > 86400 ORDER BY X.Y DESC
	) FROM #DAY_TOTALS D WHERE ItemID IS NULL

	UPDATE D SET ItemID = (
		SELECT TOP 1 X.ItemID FROM TempXYZ X WHERE X.BatchID=@batch_id AND X.[ID] = D.EmployeeID AND X.X = D.D AND X.Z > 86400 ORDER BY X.Y DESC
	) FROM #DAY_TOTALS D WHERE ItemID IS NULL

--INSERT _X SELECT Comment='A', EmployeeID,D,Seconds,Adjustment,ItemID, SSS=Seconds / 3600.0 FROM #DAY_TOTALS

	-- May need to update same item more than once (lone multi-day entries)
	SET @r=1
	WHILE @r > 0
	BEGIN
		UPDATE T SET Z = T.Z - Adjustment
		FROM TempXYZ T
		INNER JOIN #DAY_TOTALS D ON D.ItemID = T.ItemID AND D.Adjustment <> 0 AND NOT EXISTS
		(
			SELECT * FROM #DAY_TOTALS D2 WHERE D.ItemID = D2.ItemID AND D2.UID < D.UID
		)
		SET @r = @@ROWCOUNT

		UPDATE D SET ItemID=NULL FROM #DAY_TOTALS D WHERE NOT EXISTS
		(
			SELECT * FROM #DAY_TOTALS D2 WHERE D.ItemID = D2.ItemID AND D2.UID < D.UID
		)

--INSERT _X SELECT Comment='=', EmployeeID,D,Seconds,Adjustment,ItemID, SSS=Seconds / 3600.0 FROM #DAY_TOTALS

	END
END
GO
CREATE PROC dbo.spCompanyRoundStartStopToWeekBeginEnd
	@start datetime out,
	@stop datetime out
AS
DECLARE @temp datetime, @dw int

SET NOCOUNT ON

SELECT @dw = DatePartDW FROM vwDateFirst

IF @start > '17530107'
BEGIN
	SELECT @temp = DATEADD(d,@dw-DATEPART(dw,@start),@start)
	IF @temp > @start SET @temp = DATEADD(d,-7,@temp)
	SET @start = @temp
END

IF @stop < '99991224'
BEGIN
	SELECT @temp = DATEADD(d,@dw-DATEPART(dw,@stop)-1,@stop)
	IF @temp < @stop SET @temp = DATEADD(d,7,@temp)
	SET @stop = @temp
END
GO
IF OBJECT_ID('dbo.spEmployeeTimeExceptionsDetail') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spEmployeeTimeExceptionsDetail AS SELECT A=0'
GO
GRANT EXEC ON dbo.spEmployeeTimeExceptionsDetail TO public
GO
ALTER PROC dbo.spEmployeeTimeExceptionsDetail
	@batch_id int,
	@start_day int,
	@stop_day int,
	@exception_filter_mask int = 0x7FFFFFFF,
	@authorized bit = 0 OUT
AS
IF (@exception_filter_mask & 6) > 0
BEGIN
	IF @stop_day - @start_day > 31
	BEGIN
		RAISERROR('Cannot select "No in punch" when period exceeds one month. Change period or clear "No in punch" exceptions.', 16, 1)
		RETURN
	END
END


DECLARE @start_ppe int, @stop_ppe int

IF (@exception_filter_mask & 0x1000) = 0 SELECT @start_ppe = @start_day, @stop_ppe = @stop_day
ELSE
BEGIN
	SELECT @start_ppe = MIN(DATEDIFF(d,0,[In])), @stop_ppe = MAX(DATEDIFF(d,0,[In])) FROM dbo.EmployeeTime T WHERE T.[PPE Day past 1900] BETWEEN @start_day AND @stop_day
	IF @start_ppe IS NULL OR @start_ppe > @start_day SET @start_ppe = @start_day
	IF @stop_ppe IS NULL OR @stop_ppe < @stop_day SET @stop_ppe = @stop_day
END

IF (@exception_filter_mask & 0x2000) != 0
BEGIN
	DECLARE @temp_start int
	SELECT @temp_start = MIN(DATEDIFF(d,0,[In])) FROM dbo.EmployeeTime T WHERE DATEDIFF(d,0,T.[In]) < @start_ppe AND T.StatusID = 8
	IF @temp_start < @start_ppe SET @start_ppe = @temp_start
END

DECLARE @pending_type_id int, @denied_type_id int

EXEC dbo.spEmployeeTimeRoundAndCalcOT @batch_id, 0, @start_ppe OUT, @stop_ppe OUT, NULL, NULL, @authorized OUT, @pending_type_id OUT, @denied_type_id OUT
DELETE #EMPLOYEE_TIME_ROUNDED WHERE CalculatedTypeID = @denied_type_id

-- Some exceptions show time preceeding start date
IF @start_ppe <> @start_day OR @stop_ppe <> @stop_day
DELETE ETR
FROM #EMPLOYEE_TIME_ROUNDED ETR
INNER JOIN dbo.EmployeeTime ET ON ETR.OriginalTimeItemID = ET.ItemID AND 
(
	(
		ETR.[In Day past 1900] NOT BETWEEN @start_day AND @stop_day AND
		ET.[PPE Day past 1900] NOT BETWEEN @start_day AND @stop_day
	) AND
	(
		(@exception_filter_mask & 0x2000) = 0 OR
		ET.StatusID != 8
	)
)

UPDATE #EMPLOYEE_TIME_ROUNDED SET [Exception Mask] =
-- 1: In punch time outside of shift time
CASE WHEN
(@exception_filter_mask & 1) = 1 AND (
	(S.[Start Seconds] + S.[Seconds per Day]) <= 86400 AND ETR.[In Seconds] NOT BETWEEN ISNULL(SS.[Start Seconds], S.[Start Seconds]) AND (ISNULL(SS.[Start Seconds], S.[Start Seconds]) + ISNULL(SS.[Length Seconds], S.[Seconds per Day])) OR
	(S.[Start Seconds] + S.[Seconds per Day]) > 86400 AND ETR.[In Seconds] BETWEEN (ISNULL(SS.[Start Seconds], S.[Start Seconds]) + ISNULL(SS.[Length Seconds], S.[Seconds per Day])) % 86400 AND ISNULL(SS.[Start Seconds], S.[Start Seconds])
)
THEN 1 ELSE 0 END |
-- 0x10: Out punch outside of shift
CASE WHEN (@exception_filter_mask & 0x10) = 0x10 AND (
	(S.[Start Seconds] + S.[Seconds per Day]) <= 86400 AND ETR.[Out Seconds] NOT BETWEEN ISNULL(SS.[Start Seconds], S.[Start Seconds]) AND (ISNULL(SS.[Start Seconds], S.[Start Seconds]) + ISNULL(SS.[Length Seconds], S.[Seconds per Day])) OR
	(S.[Start Seconds] + S.[Seconds per Day]) > 86400 AND ETR.[Out Seconds] BETWEEN (ISNULL(SS.[Start Seconds], S.[Start Seconds]) + ISNULL(SS.[Length Seconds], S.[Seconds per Day])) % 86400 AND ISNULL(SS.[Start Seconds], S.[Start Seconds])
)
THEN 0x10 ELSE 0 END |
-- 0x40: Employee not enrolled in project
CASE WHEN (@exception_filter_mask & 0x40) = 0x40 AND ET.ProjectID IS NOT NULL AND ET.ProjectID NOT IN (SELECT EP.ProjectID FROM dbo.EmployeeProject EP WHERE EP.EmployeeID=E.EmployeeID)
THEN 0x40 ELSE 0 END |
-- 0x80: Pay rate is 0
CASE WHEN (@exception_filter_mask & 0x80) = 0x80 AND ETR.[Pay Rate] = 0
THEN 0x80 ELSE 0 END |
-- 0x20: No out punch
CASE WHEN (@exception_filter_mask & 0x20) = 0x20 AND ETR.[In Seconds] = ETR.[Out Seconds]
THEN 0x20 ELSE 0 END |
-- 8: In punch during "off" day of shift
CASE WHEN (@exception_filter_mask & 8) = 8 AND (
	dbo.fnIsShiftOnDay(ETR.[In Day past 1900], S.ShiftID, S.[Start Day past 1900], S.[Days On], S.[Days Off], S.DaysOn2, S.DaysOff2)=0
)
THEN 8 ELSE 0 END |
-- 0x100: Project is unassigned
CASE WHEN (@exception_filter_mask & 0x100) = 0x100 AND ET.ProjectID IS NULL
THEN 0x100 ELSE 0 END |
-- 0x200: OT not authorized
CASE WHEN (@exception_filter_mask & 0x200) = 0x200 AND ETR.[OT Seconds] > 0 AND NOT EXISTS
(
	SELECT * FROM dbo.EmployeeAuthorizedOT AOT WHERE AOT.EmployeeID=E.EmployeeID AND ETR.[In Day past 1900] BETWEEN AOT.[Start Day past 1900] AND AOT.[Stop Day past 1900]
)
THEN 0x200 ELSE 0 END |
-- 0x400: Out punch preceeds in punch
CASE WHEN (@exception_filter_mask & 0x400) = 0x400 AND ET.[Seconds] < 0 THEN 0x400 ELSE 0 END |
-- 0x800: Possible adjustment to this payroll. PPE outside of date range.
CASE WHEN (@exception_filter_mask & 0x800) = 0x800 AND ET.[PPE Day past 1900] NOT BETWEEN @start_day AND @stop_day THEN 0x800 ELSE 0 END |
-- 0x1000: Possible adjustment to other payroll. PPE within date range, but time outside of date range.
CASE WHEN
	(@exception_filter_mask & 0x1000) = 0x1000 AND
	ET.[PPE Day past 1900] BETWEEN @start_day AND @stop_day AND
	ETR.[In Day past 1900] NOT BETWEEN @start_day AND @stop_day THEN 0x1000
	ELSE 0
END |
-- 0x2000: Pending time preceeds date range.
CASE WHEN (@exception_filter_mask & 0x2000) = 0x2000 AND ETR.[In Day past 1900] < @start_day AND ETR.CalculatedTypeID = @pending_type_id THEN 0x2000 ELSE 0 END |

-- 0x4000: Late punch
CASE WHEN (@exception_filter_mask & 0x4000) = 0x4000 AND 
DATEDIFF(second, ETR.[In Day past 1900], ET.[In]) > ISNULL(SS.[Start Seconds],S.[Start Seconds]) + S.[Grace Seconds] 
AND NOT EXISTS(SELECT * FROM dbo.EmployeeTime ET2 WHERE ET2.EmployeeID=ETR.EmployeeID AND DATEDIFF(d,0,ET2.[In])=ETR.[In Day past 1900] AND ET2.[In]<ETR.[Actual In]) -- First punch of day
AND dbo.fnIsShiftOnDay(ETR.[In Day past 1900], S.ShiftID, S.[Start Day past 1900], S.[Days On], S.[Days Off], S.DaysOn2, S.DaysOff2)=1
AND NOT EXISTS (SELECT DISTINCT * FROM dbo.vwEmployeeLeaveApproved LA WHERE LA.EmployeeID=ETR.EmployeeID AND LA.[Day past 1900] = ETR.[In Day past 1900])
THEN 0x4000 ELSE 0 END


FROM #EMPLOYEE_TIME_ROUNDED ETR
INNER JOIN dbo.EmployeeTime ET ON ETR.OriginalTimeItemID = ET.ItemID
INNER JOIN dbo.Employee E ON ETR.EmployeeID = E.EmployeeID
INNER JOIN dbo.Shift S ON E.ShiftID = S.ShiftID
LEFT JOIN dbo.ShiftSchedule SS ON S.ShiftID=SS.ShiftID AND
SS.[Day of Shift] = (ETR.[In Day past 1900]-S.[Start Day past 1900])%(S.[Days On] + S.[Days Off] + S.DaysOn2 + S.DaysOff2) 

IF (@exception_filter_mask & 6) > 0
BEGIN
	SELECT DISTINCT ET.EmployeeID, D=DATEDIFF(d,0,ET.[In]), [In]=CAST(1 as bit) INTO #TimeSpecifiedOnDay 
	FROM dbo.EmployeeTime ET
	INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND ET.EmployeeID=X.[ID] AND DATEDIFF(d,0,ET.[In]) BETWEEN @start_day AND @stop_day -- OR DATEDIFF(d,0,DATEADD(second,[Seconds],[In])) BETWEEN @start_day AND @stop_day 
	CREATE UNIQUE INDEX TSD_20100311_EmployeeDay ON #TimeSpecifiedOnDay(EmployeeID, D) WITH ignore_dup_key

	INSERT #TimeSpecifiedOnDay(EmployeeID, D, [In])
	SELECT L.EmployeeID, L.[Day past 1900], 1 FROM dbo.EmployeeLeaveEarned L
	INNER JOIN dbo.TempX T ON T.BatchID=@batch_id AND T.[ID]=L.EmployeeID AND L.Seconds < 0 AND L.[Day past 1900] BETWEEN @start_day AND @stop_day

	INSERT #TimeSpecifiedOnDay(EmployeeID, D, [In])
	SELECT U.EmployeeID, I.[Day past 1900], 1 FROM dbo.EmployeeLeaveUsed U
	INNER JOIN dbo.TempX T ON T.BatchID=@batch_id AND T.[ID]=U.EmployeeID
	INNER JOIN dbo.EmployeeLeaveUsedItem I ON U.LeaveID=I.LeaveID AND I.Seconds > 0 AND I.[Day past 1900] BETWEEN @start_day AND @stop_day

	DECLARE @d int
	SET @d=@start_day
	WHILE @d <= @stop_day
	BEGIN
		INSERT #TimeSpecifiedOnDay(EmployeeID, D, [In])
		SELECT X.[ID], @d, 0 FROM dbo.TempX X WHERE X.BatchID=@batch_id AND NOT EXISTS (
			SELECT * FROM #TimeSpecifiedOnDay T WHERE T.EmployeeID=X.[ID] AND T.D=@d
		)

		SET @d=@d+1
	END



	DELETE #TimeSpecifiedOnDay WHERE [In] = 1


	INSERT #EMPLOYEE_TIME_ROUNDED(
	EmployeeID, 
	[In Day past 1900], 
	OriginalTypeID, 
	CalculatedTypeID, 
	[OT Eligible], 
	[OT Disable], 
	[Pay Rate], 
	[In Seconds], 
	[Out Seconds], 
	TimeSchemaID, 
	[Exception Mask])

	SELECT E.EmployeeID,T.D,@pending_type_id,@pending_type_id,0,0,0,0,0,E.TimeSchemaID,
	CASE
		WHEN (@exception_filter_mask & 2) = 2 AND (
			dbo.fnIsShiftOnDay(T.D, E.ShiftID, S.[Start Day past 1900], S.[Days On], S.[Days Off], S.DaysOn2, S.DaysOff2)=1
		) THEN 2
		ELSE 4
	END
	FROM #TimeSpecifiedOnDay T
	INNER JOIN dbo.Employee E ON T.EmployeeID = E.EmployeeID
	INNER JOIN dbo.Shift S ON E.ShiftID = S.ShiftID AND 
	(
		(@exception_filter_mask & 4) = 4 OR 
		dbo.fnIsShiftOnDay(T.D, E.ShiftID, S.[Start Day past 1900], S.[Days On], S.[Days Off], S.DaysOn2, S.DaysOff2)=1
	)

END
GO
IF OBJECT_ID('dbo.spEmployeeTimeExceptionsSummary') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spEmployeeTimeExceptionsSummary AS SELECT A=0'
GO
GRANT EXEC ON dbo.spEmployeeTimeExceptionsSummary TO public
GO
ALTER PROC dbo.spEmployeeTimeExceptionsSummary
	@batch_id int,
	@start_day int,
	@exception_filter_mask int,
	@group_by int,
	@period int,
	@authorized bit = 0 OUT
AS
CREATE TABLE #EMPLOYEE_TIME_ROUNDED(
	TempItemID int NOT NULL IDENTITY(1,1) PRIMARY KEY,
	EmployeeID int NOT NULL,
	OriginalTypeID int NOT NULL, 
	CalculatedTypeID int NOT NULL,
	[In Day past 1900] int NOT NULL, 
	[OT Eligible] bit NOT NULL,
	[OT Disable] bit NOT NULL,
	[Pay Rate] money NOT NULL,
	[Fixed Pay] money NOT NULL DEFAULT(0),
	[Fixed Items] int DEFAULT(0),
	Regular bit DEFAULT(0),
	[In Seconds] int NOT NULL,
	[Out Seconds] int NOT NULL,
	TimeSchemaID int NOT NULL,
	ShiftDiffItemID int NULL,
	TempShiftDiffSeconds int NULL,
	TempShiftDiffItemID int NULL,
	OriginalTimeItemID int NULL,
	CopyTimeItemID int NULL,
	[Time Seconds] int NOT NULL DEFAULT(0),
	[Holiday Seconds] int NOT NULL DEFAULT(0),
	[OT Seconds] int NOT NULL DEFAULT(0),
	Flags int NOT NULL DEFAULT(0),
	[Actual In] datetime NULL,
	[Actual Out] datetime NULL,
	[Base Seconds] int NOT NULL DEFAULT(0),
	[X2 Seconds] int NOT NULL DEFAULT(0),

	[Exception Mask] int NOT NULL DEFAULT(0), -- Extra field not used by spEmployeeTimeRoundAndCalcOT
	Exceptions varchar(400) COLLATE SQL_Latin1_General_CP1_CI_AS DEFAULT('') -- Extra field not used by spEmployeeTimeRoundAndCalcOT
)

DECLARE @stop_day int
SET @stop_day = @start_day + 16 * 7
EXEC spEmployeeTimeExceptionsDetail @batch_id, @start_day, @stop_day, @exception_filter_mask, @authorized OUT

DELETE #EMPLOYEE_TIME_ROUNDED WHERE [Exception Mask] = 0

SELECT DISTINCT EmployeeID INTO #E_07252011 FROM #EMPLOYEE_TIME_ROUNDED
 
SELECT 
RowID = E.EmployeeID,
RowText = dbo.fnGetListAs(P.[First Name], P.[Middle Name], P.[Last Name], P.Suffix),
P1 = (SELECT COUNT(*) FROM #EMPLOYEE_TIME_ROUNDED ETR WHERE ETR.EmployeeID = E.EmployeeID AND dbo.GetDateFromDaysPast1900(ETR.[In Day past 1900]) BETWEEN @start_day AND @start_day + 6),
P2 = (SELECT COUNT(*) FROM #EMPLOYEE_TIME_ROUNDED ETR WHERE ETR.EmployeeID = E.EmployeeID AND dbo.GetDateFromDaysPast1900(ETR.[In Day past 1900]) BETWEEN @start_day + 7 AND @start_day + 13),
P3 = (SELECT COUNT(*) FROM #EMPLOYEE_TIME_ROUNDED ETR WHERE ETR.EmployeeID = E.EmployeeID AND dbo.GetDateFromDaysPast1900(ETR.[In Day past 1900]) BETWEEN @start_day + 14 AND @start_day + 20),
P4 = (SELECT COUNT(*) FROM #EMPLOYEE_TIME_ROUNDED ETR WHERE ETR.EmployeeID = E.EmployeeID AND dbo.GetDateFromDaysPast1900(ETR.[In Day past 1900]) BETWEEN @start_day + 21 AND @start_day + 7),
P5 = (SELECT COUNT(*) FROM #EMPLOYEE_TIME_ROUNDED ETR WHERE ETR.EmployeeID = E.EmployeeID AND dbo.GetDateFromDaysPast1900(ETR.[In Day past 1900]) BETWEEN @start_day + 28 AND @start_day + 34),
P6 = (SELECT COUNT(*) FROM #EMPLOYEE_TIME_ROUNDED ETR WHERE ETR.EmployeeID = E.EmployeeID AND dbo.GetDateFromDaysPast1900(ETR.[In Day past 1900]) BETWEEN @start_day + 35 AND @start_day + 41),
P7 = (SELECT COUNT(*) FROM #EMPLOYEE_TIME_ROUNDED ETR WHERE ETR.EmployeeID = E.EmployeeID AND dbo.GetDateFromDaysPast1900(ETR.[In Day past 1900]) BETWEEN @start_day + 42 AND @start_day + 48),
P8 = (SELECT COUNT(*) FROM #EMPLOYEE_TIME_ROUNDED ETR WHERE ETR.EmployeeID = E.EmployeeID AND dbo.GetDateFromDaysPast1900(ETR.[In Day past 1900]) BETWEEN @start_day + 49 AND @start_day + 55),
P9 = (SELECT COUNT(*) FROM #EMPLOYEE_TIME_ROUNDED ETR WHERE ETR.EmployeeID = E.EmployeeID AND dbo.GetDateFromDaysPast1900(ETR.[In Day past 1900]) BETWEEN @start_day + 56 AND @start_day + 62),
P10 = (SELECT COUNT(*) FROM #EMPLOYEE_TIME_ROUNDED ETR WHERE ETR.EmployeeID = E.EmployeeID AND dbo.GetDateFromDaysPast1900(ETR.[In Day past 1900]) BETWEEN @start_day + 63 AND @start_day + 69),
P11 = (SELECT COUNT(*) FROM #EMPLOYEE_TIME_ROUNDED ETR WHERE ETR.EmployeeID = E.EmployeeID AND dbo.GetDateFromDaysPast1900(ETR.[In Day past 1900]) BETWEEN @start_day + 70 AND @start_day + 76),
P12 = (SELECT COUNT(*) FROM #EMPLOYEE_TIME_ROUNDED ETR WHERE ETR.EmployeeID = E.EmployeeID AND dbo.GetDateFromDaysPast1900(ETR.[In Day past 1900]) BETWEEN @start_day + 77 AND @start_day + 83),
P13 = (SELECT COUNT(*) FROM #EMPLOYEE_TIME_ROUNDED ETR WHERE ETR.EmployeeID = E.EmployeeID AND dbo.GetDateFromDaysPast1900(ETR.[In Day past 1900]) BETWEEN @start_day + 84 AND @start_day + 90),
P14 = (SELECT COUNT(*) FROM #EMPLOYEE_TIME_ROUNDED ETR WHERE ETR.EmployeeID = E.EmployeeID AND dbo.GetDateFromDaysPast1900(ETR.[In Day past 1900]) BETWEEN @start_day + 91 AND @start_day + 87),
P15 = (SELECT COUNT(*) FROM #EMPLOYEE_TIME_ROUNDED ETR WHERE ETR.EmployeeID = E.EmployeeID AND dbo.GetDateFromDaysPast1900(ETR.[In Day past 1900]) BETWEEN @start_day + 98 AND @start_day + 104)
FROM #E_07252011 E
INNER JOIN dbo.Person P ON E.EmployeeID = P.PersonID
ORDER BY P.[Last Name], P.[First Name]
GO
IF OBJECT_ID('dbo.spEmployeeTimeExceptions2') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spEmployeeTimeExceptions2 AS SELECT A=0'
GO
GRANT EXEC ON dbo.spEmployeeTimeExceptions2 TO public
GO
ALTER PROC dbo.spEmployeeTimeExceptions2
	@batch_id int,
	@start_day int,
	@stop_day int,
	@exception_filter_mask int = 0x7FFFFFFF,
	@authorized bit = 0 OUT
	-- 1: In punch time outside of shift time
	-- 2: No in punch during "on" day of shift
	-- 4: No in punch (regardless of shift)
	-- 8: In punch during "off" day of shift
	-- 0x10: Out punch outside of shift
	-- 0x20: No out punch
	-- 0x40: Employee not enrolled in project
	-- 0x80: Pay rate is 0
	-- 0x100: Project is unassigned
	-- 0x200: OT is unauthorized
	-- 0x400: Out punch preceeds in punch
	-- 0x800: Possible adjustment to this payroll. PPE outside of date range.
	-- 0x1000: Possible adjustment to other payroll. PPE within date range, but in/out outside of date range.
	-- 0x2000: Pending time preceeds date range.
	-- 0x4000: Late punch
AS
CREATE TABLE #EMPLOYEE_TIME_ROUNDED(
	TempItemID int NOT NULL IDENTITY(1,1) PRIMARY KEY,
	EmployeeID int NOT NULL,
	OriginalTypeID int NOT NULL, 
	CalculatedTypeID int NOT NULL,
	[In Day past 1900] int NOT NULL, 
	[OT Eligible] bit NOT NULL,
	[OT Disable] bit NOT NULL,
	[Pay Rate] money NOT NULL,
	[Fixed Pay] money NOT NULL DEFAULT(0),
	[Fixed Items] int DEFAULT(0),
	Regular bit DEFAULT(0),
	[In Seconds] int NOT NULL,
	[Out Seconds] int NOT NULL,
	TimeSchemaID int NOT NULL,
	ShiftDiffItemID int NULL,
	TempShiftDiffSeconds int NULL,
	TempShiftDiffItemID int NULL,
	OriginalTimeItemID int NULL,
	CopyTimeItemID int NULL,
	[Time Seconds] int NOT NULL DEFAULT(0),
	[Holiday Seconds] int NOT NULL DEFAULT(0),
	[OT Seconds] int NOT NULL DEFAULT(0),
	Flags int NOT NULL DEFAULT(0),
	[Actual In] datetime NULL,
	[Actual Out] datetime NULL,
	[Base Seconds] int NOT NULL DEFAULT(0),
	[X2 Seconds] int NOT NULL DEFAULT(0),

	[Exception Mask] int NOT NULL DEFAULT(0), -- Extra field not used by spEmployeeTimeRoundAndCalcOT
	Exceptions varchar(400) COLLATE SQL_Latin1_General_CP1_CI_AS DEFAULT('') -- Extra field not used by spEmployeeTimeRoundAndCalcOT
)

EXEC dbo.spEmployeeTimeExceptionsDetail @batch_id, @start_day, @stop_day, @exception_filter_mask, @authorized OUT


-- 1: In punch time outside of shift time
-- 2: No in punch during "on" day of shift
-- 4: No in punch (regardless of shift)
-- 8: In punch during "off" day of shift
-- 0x10: Out punch outside of shift
-- 0x20: No out punch
-- 0x40: Employee not enrolled in project
-- 0x80: Pay rate is 0
-- 0x100: Project is unassigned
-- 0x200: OT is unauthorized
-- 0x400: Out punch preceeds in punch
-- 0x800: Possible adjustment to this payroll. PPE outside of date range.
-- 0x1000: Possible adjustment to other payroll. PPE within date range, but in/out outside of date range.
-- 0x2000: Pending time preceeds date range.
-- 0x4000: Late punch.
UPDATE #EMPLOYEE_TIME_ROUNDED SET Exceptions = Exceptions + CASE WHEN Exceptions='' THEN '' ELSE ' ' END + 'Clock-in is outside shift.' WHERE [Exception Mask] & 1 = 1
UPDATE #EMPLOYEE_TIME_ROUNDED SET Exceptions = Exceptions + CASE WHEN Exceptions='' THEN '' ELSE ' ' END + 'No clock-in on scheduled work day.' WHERE [Exception Mask] & 2 = 2
UPDATE #EMPLOYEE_TIME_ROUNDED SET Exceptions = Exceptions + CASE WHEN Exceptions='' THEN '' ELSE ' ' END + 'No clock-in.' WHERE [Exception Mask] & 6 = 4 -- Redundant if exception 2 occurred
UPDATE #EMPLOYEE_TIME_ROUNDED SET Exceptions = Exceptions + CASE WHEN Exceptions='' THEN '' ELSE ' ' END + 'Clock-in on day not scheduled to work.' WHERE [Exception Mask] & 8 = 8
UPDATE #EMPLOYEE_TIME_ROUNDED SET Exceptions = Exceptions + CASE WHEN Exceptions='' THEN '' ELSE ' ' END + 'Clock-out outside of shift.' WHERE [Exception Mask] & 0x10 = 0x10
UPDATE #EMPLOYEE_TIME_ROUNDED SET Exceptions = Exceptions + CASE WHEN Exceptions='' THEN '' ELSE ' ' END + 'Clock-in with no clock-out.' WHERE [Exception Mask] & 0x20 = 0x20
UPDATE #EMPLOYEE_TIME_ROUNDED SET Exceptions = Exceptions + CASE WHEN Exceptions='' THEN '' ELSE ' ' END + 'Project not authorized.' WHERE [Exception Mask] & 0x40 = 0x40
UPDATE #EMPLOYEE_TIME_ROUNDED SET Exceptions = Exceptions + CASE WHEN Exceptions='' THEN '' ELSE ' ' END + 'Pay rate is 0.' WHERE [Exception Mask] & 0x80 = 0x80
UPDATE #EMPLOYEE_TIME_ROUNDED SET Exceptions = Exceptions + CASE WHEN Exceptions='' THEN '' ELSE ' ' END + 'No project assigned.' WHERE [Exception Mask] & 0x100 = 0x100
UPDATE #EMPLOYEE_TIME_ROUNDED SET Exceptions = Exceptions + CASE WHEN Exceptions='' THEN '' ELSE ' ' END + 'OT not authorized.' WHERE [Exception Mask] & 0x200 = 0x200
UPDATE #EMPLOYEE_TIME_ROUNDED SET Exceptions = Exceptions + CASE WHEN Exceptions='' THEN '' ELSE ' ' END + 'Negative time. Out punch preceeds in punch.' WHERE [Exception Mask] & 0x400 = 0x400
UPDATE #EMPLOYEE_TIME_ROUNDED SET Exceptions = Exceptions + CASE WHEN Exceptions='' THEN '' ELSE ' ' END + 'Payroll adjustment. Time within date range, but PPE is outside of range.' WHERE [Exception Mask] & 0x800 = 0x800
UPDATE #EMPLOYEE_TIME_ROUNDED SET Exceptions = Exceptions + CASE WHEN Exceptions='' THEN '' ELSE ' ' END + 'Other payroll adjustment. PPE within date range, but time is outside of range.' WHERE [Exception Mask] & 0x1000 = 0x1000
UPDATE #EMPLOYEE_TIME_ROUNDED SET Exceptions = Exceptions + CASE WHEN Exceptions='' THEN '' ELSE ' ' END + 'Pending time preceeds date range.' WHERE [Exception Mask] & 0x2000 = 0x2000
UPDATE #EMPLOYEE_TIME_ROUNDED SET Exceptions = Exceptions + CASE WHEN Exceptions='' THEN '' ELSE ' ' END + 'Late punch.' WHERE [Exception Mask] & 0x4000 = 0x4000



SELECT 
ETR.EmployeeID, ETR.[Exception Mask], ETR.Exceptions,
[Actual In] = ET.[In],
[Actual Out] = CASE WHEN ET.Seconds=0 THEN NULL ELSE DATEADD(second,ET.Seconds,ET.[In]) END,
[Rounded In] = DATEADD(s, ETR.[In Seconds], dbo.GetDateFromDaysPast1900(ETR.[In Day past 1900])),
[Rounded Out] = DATEADD(s, ETR.[Out Seconds], dbo.GetDateFromDaysPast1900(ETR.[In Day past 1900])),
[Date] = dbo.GetDateFromDaysPast1900(ETR.[In Day past 1900]),
Project = ISNULL(P.Project,''),
ETR.[Pay Rate], 
[Type] = ISNULL(TT.[Type],'PEND'),
PPE = dbo.GetDateFromDaysPast1900(ET.[PPE Day past 1900]),
[Hours] = (ETR.[Out Seconds] - ETR.[In Seconds]) / 3600.0,
V.*
FROM #EMPLOYEE_TIME_ROUNDED ETR 
INNER JOIN dbo.vwEmployeeSecure V ON ETR.[Exception Mask] > 0 AND ETR.EmployeeID = V.EID
LEFT JOIN dbo.EmployeeTime ET ON ETR.OriginalTimeItemID = ET.ItemID
LEFT JOIN dbo.Project P ON ET.ProjectID = P.ProjectID
LEFT JOIN dbo.TimeType TT ON ETR.CalculatedTypeID = TT.TypeID
ORDER BY V.[Person List As], ET.[In]
GO
IF OBJECT_ID('dbo.spEmployeeBatchOT') IS NOT NULL DROP PROC dbo.spEmployeeBatchOT
GO
CREATE PROC dbo.spEmployeeBatchOT @batch_id int, @start_day int, @stop_day int AS
INSERT TempX(BatchID,[ID])
SELECT DISTINCT @batch_id, V.EmployeeID FROM dbo.vwEmployeeTime V WHERE V.[In Day past 1900] BETWEEN @start_day AND @stop_day

SET NOCOUNT ON

DECLARE @pending_type_id int, @denied_type_id int, @authorized bit

CREATE TABLE #EMPLOYEE_TIME_ROUNDED(
	TempItemID int NOT NULL IDENTITY(1,1) PRIMARY KEY,
	EmployeeID int NOT NULL,
	OriginalTypeID int NOT NULL, 
	CalculatedTypeID int NOT NULL,
	[In Day past 1900] int NOT NULL, 
	[OT Eligible] bit NOT NULL,
	[OT Disable] bit NOT NULL,
	[Pay Rate] money NOT NULL,
	[Fixed Pay] money NOT NULL DEFAULT(0),
	[Fixed Items] int DEFAULT(0),
	Regular bit DEFAULT(0),
	[In Seconds] int NOT NULL,
	[Out Seconds] int NOT NULL,
	TimeSchemaID int NOT NULL,
	ShiftDiffItemID int NULL,
	TempShiftDiffSeconds int NULL,
	TempShiftDiffItemID int NULL,
	OriginalTimeItemID int NULL,
	CopyTimeItemID int NULL,
	[Time Seconds] int NOT NULL DEFAULT(0),
	[Holiday Seconds] int NOT NULL DEFAULT(0),
	[OT Seconds] int NOT NULL DEFAULT(0),
	Flags int NOT NULL DEFAULT(0),
	[Actual In] datetime NULL,
	[Actual Out] datetime NULL,
	[Base Seconds] int NOT NULL DEFAULT(0),
	[X2 Seconds] int NOT NULL DEFAULT(0)
)

EXEC dbo.spEmployeeTimeRoundAndCalcOT @batch_id, 0, @start_day, @stop_day, NULL, NULL, @authorized OUT, @pending_type_id OUT, @denied_type_id OUT

DELETE TempX WHERE BatchID=@batch_id AND [ID] NOT IN (
	SELECT DISTINCT ER.EmployeeID FROM
	#EMPLOYEE_TIME_ROUNDED ER
	INNER JOIN dbo.vwTimeType TT ON ER.CalculatedTypeID=TT.TypeID AND TT.OT=1
)
GO
GRANT EXEC ON dbo.spEmployeeBatchOT TO public
GO
ALTER PROCEDURE dbo.spPersonXCertificationList4
	@exclude_expired bit
AS
DECLARE @batch_id int

SET NOCOUNT ON

SELECT @batch_id = RAND() * 2147483647

INSERT TempX(BatchID, [ID])
SELECT DISTINCT @batch_id, PersonID FROM vwPersonXCertification WHERE [Nonterminated Employee] = 1

EXEC dbo.spPermissionGetOnPeopleForCurrentUser2 @batch_id, 65536

DELETE TempX WHERE BatchID = @batch_id AND (X & 1) = 0

SELECT PC.* FROM vwPersonXCertification PC
INNER JOIN TempX X ON X.BatchID = @batch_id AND X.[ID] = PC.PersonID AND (@exclude_expired = 0 OR PC.Expires IS NULL OR PC.Expires > GETDATE())
ORDER BY PC.[List As], PC.Certification
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spEmployeeTimeSummarizeBasis'
GO
-- Summarizes timecard information for one payroll period
ALTER PROC dbo.spEmployeeTimeSummarizeBasis
	@batch_id int,
	@start smalldatetime,
	@stop smalldatetime,
	@exclude_salaried bit
AS
DECLARE @rounding decimal

SELECT @rounding = [Timecard Rounding] FROM dbo.Constant

IF @exclude_salaried = 1 DELETE TempX
FROM TempX X
INNER JOIN Employee E ON X.BatchID = @batch_id AND X.[ID] = E.EmployeeID AND E.Salaried = 1

-- Table that will hold final report
CREATE TABLE #Report(
	EmployeeID int NOT NULL PRIMARY KEY NONCLUSTERED,
	[OT Basis] int,
	Holiday int default(0),
	OT int default(0),
	Regular int default(0),
	[Paid Leave] int default(0),
	[Unpaid Leave] int default(0),
	Total int default(0),
	Weekend int default(0),
	Scratch int default(0),
	[Holiday Hrs] numeric(9,4) default(0),
	[OT Hrs] numeric(9,4) default(0),
	[Total Hrs] numeric(9,4) default(0),
	[Paid Leave Hrs] numeric(9,4) default(0),
	[Unpaid Leave Hrs] numeric(9,4) default(0),
	[Weekend Hrs] numeric(9,4) default(0),
	[Regular Hrs] numeric(9,4) default(0),
	[Regular Rate] money
)


-- Fills final report table with EmployeeIDs
INSERT #Report(EmployeeID, [OT Basis])
SELECT E.EmployeeID, E.[OT Basis] FROM Employee E
INNER JOIN TempX X ON E.EmployeeID = X.[ID] AND X.BatchID = @batch_id

IF YEAR(@stop) > YEAR(GETDATE()) + 5 OR YEAR(@start) < YEAR(GETDATE()) - 5
BEGIN
	-- Insures that holidays aren't calculated out to the year 9999
	DECLARE @start_day int, @stop_day int, @min_entry int, @max_entry int, @hstart datetime, @hstop datetime
	SELECT @start_day = DATEDIFF(d,0,@start), @stop_day = DATEDIFF(d,0,@stop)
	EXEC dbo.spEmployeeTimeBoundRange @batch_id, @start_day, @stop_day, @min_entry out, @max_entry out
	IF @start_day < @min_entry SET @start_day = @min_entry
	IF @stop_day > @max_entry SET @stop_day = @max_entry
	SELECT @hstart = dbo.GetDateFromDaysPast1900(@start_day), @hstop = dbo.GetDateFromDaysPast1900(@stop_day)
	EXEC dbo.spHolidayRecalc @force_recalc = 0, @start_date = @hstart, @stop_date = @hstop
END
ELSE
EXEC dbo.spHolidayRecalc @force_recalc = 0, @start_date = @start, @stop_date = @stop

/*
CREATE TABLE #Holiday(D int NOT NULL PRIMARY KEY NONCLUSTERED)
-- Lists nonrecurring holidays into temp table
INSERT #Holiday
SELECT DISTINCT DATEDIFF(d, 0, dbo.GetDateFromMDY([Month], [Day], [Year]))
FROM Holiday WHERE [Year] IS NOT NULL AND ([Year] BETWEEN YEAR(@start) AND YEAR(@stop))

-- Inserts all recurring holidays for start year through stop year into temporary table
DECLARE @year int
SELECT @year = YEAR(@start)

WHILE @year <= YEAR(@stop)
BEGIN
	INSERT #Holiday
	SELECT DATEDIFF(d, 0, dbo.GetDateFromMDY([Month], [Day], @year))
	FROM Holiday WHERE [Year] IS NULL AND DATEDIFF(d, 0, dbo.GetDateFromMDY([Month], [Day], @year)) NOT IN
	(
		SELECT D FROM #Holiday
	)

	SELECT @year = @year + 1
END

-- Removes temp holidays outside of reporting period
DELETE #Holiday WHERE D < DATEDIFF(d, 0, @start) OR D > DATEDIFF(d, 0, @stop) */



-- Break timecards so that in/out always fall on same day.
-- For each day, holds OT and whether day is a weekend or holiday
CREATE TABLE #Timecard(ItemID int IDENTITY(1,1) NOT NULL PRIMARY KEY CLUSTERED , EmployeeID int NOT NULL, D int, Weekend bit, Wk int, Seconds int, [OT Basis] int, [Previous Total] int default(0), [OT Seconds] int default(0), [Paid Leave Seconds] int default(0), [Unpaid Leave Seconds] int default(0), Holiday bit default(0))
CREATE  UNIQUE  INDEX [IX_TempTableT] ON #Timecard([EmployeeID], D) WITH  FILLFACTOR = 90 ON [PRIMARY]
CREATE  INDEX [IX_TempTableT2] ON #Timecard([EmployeeID]) WITH  FILLFACTOR = 90 ON [PRIMARY]


-- @d: loops from @start to @stop
-- @n: @d 11:59:59
-- @dp1900: @d - 1900
-- @weekend: is @d a @weekend?
-- @i: @d - @start, calcs week @wk for OT
DECLARE @d smalldatetime, @n smalldatetime, @dp1900 int
DECLARE @wkend bit, @wk int, @i int
SELECT @d = @start, @i = 0

WHILE @d <= @stop
BEGIN
	SELECT @n = DATEADD(s, -1, DATEADD(d, 1, @d)), @dp1900 = DATEDIFF(d, 0, @d)
	SELECT @wkend = CASE WHEN DATEPART(dw, @d) IN (1,7) THEN 1 ELSE 0 END
	SELECT @wk = @i / 7

	INSERT #Timecard(EmployeeID, D, Weekend, Wk, Seconds, [Previous Total], [OT Basis])
	SELECT #Report.EmployeeID, @dp1900, @wkend, @wk, 0, #Report.Scratch , #Report.[OT Basis]
	FROM #Report

	-- Update ([Out] - [In])
	UPDATE #Timecard SET Seconds = ISNULL((
		SELECT SUM(DATEDIFF(s, ET.[In], ET.[Out]))
		FROM dbo.vwEmployeeTime ET WHERE ET.EmployeeID = #Timecard.EmployeeID AND ET.[In Day past 1900] = ET.[Out Day past 1900] AND @dp1900 = ET.[In Day past 1900]
	), 0) WHERE #Timecard.D = @dp1900

	-- Update (end of day - [In])
	UPDATE #Timecard SET Seconds = Seconds + ISNULL((
		SELECT SUM(DATEDIFF(s, ET.[In], @n))
		FROM vwEmployeeTime ET 
		WHERE ET.EmployeeID = #Timecard.EmployeeID AND ET.[In Day past 1900] <> ET.[Out Day past 1900] AND @dp1900 = ET.[In Day past 1900]
	), 0) WHERE #Timecard.D = @dp1900

	-- Update ([Out] - start of day)
	UPDATE #Timecard SET Seconds = Seconds + ISNULL((
		SELECT SUM(DATEDIFF(s, @d, ET.[Out]))
		FROM vwEmployeeTime ET 
		WHERE ET.EmployeeID = #Timecard.EmployeeID AND ET.[In Day past 1900] <> ET.[Out Day past 1900] AND @dp1900 = ET.[Out Day past 1900]
	), 0) WHERE #Timecard.D = @dp1900

	-- Add in paid leave
	UPDATE #Timecard SET [Paid Leave Seconds] = ISNULL((
		SELECT SUM(I.Seconds)
		FROM dbo.vwEmployeeLeaveUsedItemApproved I
		INNER JOIN LeaveType T ON I.[Day past 1900] = @dp1900 AND I.EmployeeID = #Timecard.EmployeeID AND I.TypeID = T.TypeID AND T.Paid = 1
	), 0),
	[Unpaid Leave Seconds] = ISNULL((
		SELECT SUM(I.Seconds)
		FROM dbo.vwEmployeeLeaveUsedItemApproved I
		INNER JOIN LeaveType T ON I.[Day past 1900] = @dp1900 AND I.EmployeeID = #Timecard.EmployeeID AND I.TypeID = T.TypeID AND T.Paid = 0
	), 0) 
	WHERE #Timecard.D = @dp1900

	UPDATE #Timecard SET Seconds = Seconds + [Paid Leave Seconds] WHERE #Timecard.D = @dp1900

	-- @rounding is decimal
	UPDATE #Timecard SET Seconds = ROUND(Seconds / @rounding, 0) * @rounding WHERE D = @dp1900
	

	-- Resets weekly Previous Total
	IF @i % 7 = 6 UPDATE #Report SET Scratch = 0
	-- Updates weekly Previous Total for each employee
	ELSE 
	BEGIN
		UPDATE #Report SET Scratch = #Report.Scratch + #Timecard.Seconds FROM #Report
		INNER JOIN #Timecard ON #Timecard.EmployeeID = #Report.EmployeeID AND #Timecard.D = @dp1900
	END

	SELECT @d = DATEADD(d, 1, @d)
	SELECT @i = @i + 1
END





-- Calcs OT Seconds each day
-- Calcs days where all time was OT
UPDATE #Timecard SET [OT Seconds] = Seconds WHERE [OT Basis] = 1 AND [Previous Total] > 144000
-- Calcs days where some time was OT
UPDATE #Timecard SET [OT Seconds] = [Previous Total] + Seconds - 144000 WHERE [OT Basis] = 1 AND [Previous Total] <= 144000 AND ([Previous Total] + Seconds) > 144000


-- Calc OT (daily basis)
UPDATE #Timecard SET [OT Seconds] = Seconds - 28800 WHERE [OT Basis] = 2 AND Seconds > 28800


-- Calcs holidays
UPDATE #Timecard SET Holiday = 1 FROM #Timecard 
INNER JOIN dbo.HolidayCalculated H ON #Timecard.D BETWEEN H.A AND H.B






-- Takes time that falls into multiple categories and puts it in the highest paying category
-- For example, if an employee works OT on a holiday, time is either classied as OT or holiday depending on which pays more

-- HOL/WKEND >> HOL
UPDATE #Timecard SET [Weekend] = 0 FROM #Timecard
INNER JOIN Employee E ON 
#Timecard.Weekend = 1 AND #Timecard.Holiday = 1 AND
#Timecard.EmployeeID = E.EmployeeID AND 
E.[Weekend Pay Multiplier] <= E.[Holiday Pay Multiplier]

-- HOL/WKEND >> WKEND
UPDATE #Timecard SET [Holiday] = 0 FROM #Timecard
INNER JOIN Employee E ON 
#Timecard.Weekend = 1 AND #Timecard.Holiday = 1 AND
#Timecard.EmployeeID = E.EmployeeID AND 
E.[Weekend Pay Multiplier] > E.[Holiday Pay Multiplier]

-- OT/HOL >> OT
UPDATE #Timecard SET [Holiday] = 0 FROM #Timecard
INNER JOIN Employee E ON 
#Timecard.[OT Seconds] > 0 AND #Timecard.Holiday = 1 AND
#Timecard.EmployeeID = E.EmployeeID AND 
E.[Holiday Pay Multiplier] <= E.[OT Pay Multiplier]

-- OT/HOL >> HOL
UPDATE #Timecard SET [OT Seconds] = 0 FROM #Timecard
INNER JOIN Employee E ON 
#Timecard.[OT Seconds] > 0 AND #Timecard.Holiday = 1 AND
#Timecard.EmployeeID = E.EmployeeID AND 
E.[Holiday Pay Multiplier] > E.[OT Pay Multiplier]

-- OT/WKEND >> OT
UPDATE #Timecard SET [Weekend] = 0 FROM #Timecard
INNER JOIN Employee E ON 
#Timecard.[OT Seconds] > 0 AND #Timecard.Weekend = 1 AND
#Timecard.EmployeeID = E.EmployeeID AND 
E.[Weekend Pay Multiplier] <= E.[OT Pay Multiplier]

-- OT/WKEND >> WKEND
UPDATE #Timecard SET [OT Seconds] = 0 FROM #Timecard
INNER JOIN Employee E ON 
#Timecard.[OT Seconds] > 0 AND #Timecard.Weekend = 1 AND
#Timecard.EmployeeID = E.EmployeeID AND 
E.[Weekend Pay Multiplier] > E.[OT Pay Multiplier]









-- Calc total for each employee
UPDATE #Report SET Total = ISNULL((
	SELECT SUM(#Timecard.Seconds)
	FROM #Timecard WHERE #Report.EmployeeID = #Timecard.EmployeeID
), 0), Holiday = ISNULL((
	SELECT SUM(#Timecard.Seconds)
	FROM #Timecard WHERE #Report.EmployeeID = #Timecard.EmployeeID AND #Timecard.Holiday = 1
), 0), Weekend = ISNULL((
	SELECT SUM(#Timecard.Seconds)
	FROM #Timecard WHERE #Report.EmployeeID = #Timecard.EmployeeID AND #Timecard.Weekend = 1
), 0), OT = ISNULL((
	SELECT SUM(#Timecard.[OT Seconds])
	FROM #Timecard WHERE #Report.EmployeeID = #Timecard.EmployeeID
), 0), [Paid Leave] = ISNULL((
	SELECT SUM(#Timecard.[Paid Leave Seconds])
	FROM #Timecard WHERE #Report.EmployeeID = #Timecard.EmployeeID
), 0), [Unpaid Leave] = ISNULL((
	SELECT SUM(#Timecard.[Unpaid Leave Seconds])
	FROM #Timecard WHERE #Report.EmployeeID = #Timecard.EmployeeID
), 0)


UPDATE #Report SET Regular = Total - Holiday - Weekend - OT

-- Caveat: Regular Seconds include Paid Leave, Regular Hours does not
UPDATE #Report SET [Regular Hrs] = (Regular - [Paid Leave]) / 3600.0,
[Holiday Hrs] = Holiday / 3600.0,
[OT Hrs] = OT / 3600.0,
[Total Hrs] = Total / 3600.0,
[Paid Leave Hrs] = [Paid Leave] / 3600.0,
[Unpaid Leave Hrs] = [Unpaid Leave] / 3600.0,
[Weekend Hrs] = [Weekend] / 3600.00


-- Look up rate for each employee
SELECT @dp1900 = DATEDIFF(d, 0, @start)
UPDATE #Report SET [Regular Rate] = ISNULL((
	SELECT TOP 1 [Base Pay] * (3600.0 / P.Seconds)
	FROM EmployeeCompensation C
	INNER JOIN Period P ON C.EmployeeID = #Report.EmployeeID AND C.PeriodID = P.PeriodID AND 
	(@dp1900 BETWEEN C.[Start Day past 1900] AND ISNULL(C.[Stop Day past 1900], 2147483647))
), 0)


-- Final
SELECT Employee = P.[List As], #Report.EmployeeID, E.[Employee Number], X.SSN, 
#Report.[Regular Hrs], #Report.[OT Hrs], #Report.[Holiday Hrs], #Report.[Weekend Hrs], #Report.[Total Hrs],
#Report.[Paid Leave Hrs], #Report.[Unpaid Leave Hrs],
[Regular Rate],
[OT Rate] = [Regular Rate] * [OT Pay Multiplier],
[Holiday Rate] = [Regular Rate] * [Holiday Pay Multiplier],
[Weekend Rate] = [Regular Rate] * [Weekend Pay Multiplier],
Pay = ([Regular Hrs] +
[Paid Leave Hrs] +
[Holiday Hrs] * [Holiday Pay Multiplier] +
[Weekend Hrs] * [Weekend Pay Multiplier] +
[OT Hrs] * [OT Pay Multiplier]) * [Regular Rate]
FROM #Report
INNER JOIN dbo.vwPerson P ON #Report.EmployeeID = P.PersonID
INNER JOIN dbo.PersonX X ON P.PersonID = X.PersonID
INNER JOIN dbo.Employee E ON X.PersonID = E.EmployeeID
ORDER BY Employee
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spEmployeeTimeSummarizeBasis6'
GO
ALTER PROC dbo.spEmployeeTimeSummarizeBasis6
	@batch_id int,
	@start_day int,
	@stop_day int,
	@authorized bit OUT,
	@project_class_id int,
	@project_class_id_is_null bit,
	@pending_leave_class_id int,
	@pending_type_id int OUT,
	@denied_type_id int OUT,
	@time_type_mask int = 2147483647,
	@leave_type_mask int = 2147483647,
	@flags int = 0 -- 1: Exclude pending time, 2: Exclude pending paid leave, 4: ignore rate, 8: payroll delay, 16: classify unpaid time as class = 5
AS
SET NOCOUNT ON

DECLARE @pay_rate_multiplier money
SELECT @pay_rate_multiplier = CASE WHEN (@flags & 4) = 0 THEN 1 ELSE 0 END

CREATE TABLE #EMPLOYEE_TIME_ROUNDED(
	TempItemID int NOT NULL IDENTITY(1,1) PRIMARY KEY,
	EmployeeID int NOT NULL,
	OriginalTypeID int NOT NULL, 
	CalculatedTypeID int NOT NULL,
	[In Day past 1900] int NOT NULL, 
	[OT Eligible] bit NOT NULL,
	[OT Disable] bit NOT NULL,
	[Pay Rate] money NOT NULL,
	[Fixed Pay] money NOT NULL DEFAULT(0),
	[Fixed Items] int DEFAULT(0),
	Regular bit DEFAULT(0),
	[In Seconds] int NOT NULL,
	[Out Seconds] int NOT NULL,
	TimeSchemaID int NOT NULL,
	ShiftDiffItemID int NULL,
	TempShiftDiffSeconds int NULL,
	TempShiftDiffItemID int NULL,
	OriginalTimeItemID int NULL,
	CopyTimeItemID int NULL,
	[Time Seconds] int NOT NULL DEFAULT(0),
	[Holiday Seconds] int NOT NULL DEFAULT(0),
	[OT Seconds] int NOT NULL DEFAULT(0),
	Flags int NOT NULL DEFAULT(0),
	[Actual In] datetime NULL,
	[Actual Out] datetime NULL,
	[Base Seconds] int NOT NULL DEFAULT(0),
	[X2 Seconds] int NOT NULL DEFAULT(0)
)

DECLARE @ot_flags int
SET @ot_flags = @flags & 8
EXEC dbo.spEmployeeTimeRoundAndCalcOT @batch_id, @ot_flags, @start_day OUT, @stop_day OUT, @project_class_id, @project_class_id_is_null, @authorized OUT, @pending_type_id OUT, @denied_type_id OUT

IF (@flags & 1) = 1 DELETE #EMPLOYEE_TIME_ROUNDED WHERE CalculatedTypeID = @pending_type_id
DELETE #EMPLOYEE_TIME_ROUNDED WHERE CalculatedTypeID != @pending_type_id AND (CalculatedTypeID & @time_type_mask) = 0

INSERT #SecondsForEmployeeTimeClassType(EmployeeID, Class, TypeID, Abbreviation , [Pay Rate], Seconds, [Order], [Fixed Pay], [Fixed Items], [OT Eligible])

-- Approved paid time
SELECT ET.EmployeeID, 
Class = 0, 
ET.CalculatedTypeID, 
T.[Abbreviation], 
ET.[Pay Rate] * @pay_rate_multiplier, 
Seconds = SUM(ET.[Out Seconds] - ET.[In Seconds]), 
T.[Order], 
[Fixed Pay] = SUM(ET.[Fixed Pay]), -- Needs to be divided by [Fixed Items]
[Fixed Items] = COUNT(ALL CASE WHEN ET.[Fixed Pay]=0 THEN NULL ELSE ET.[Fixed Pay] END), 
T.[OT Eligible]
FROM #EMPLOYEE_TIME_ROUNDED ET
INNER JOIN dbo.vwTimeType T ON ET.CalculatedTypeID = T.TypeID AND T.[Paid Time]=1 -- Excludes pending and denied time
GROUP BY ET.EmployeeID, ET.[Pay Rate] * @pay_rate_multiplier, ET.CalculatedTypeID, T.[Abbreviation], T.[Order], T.[OT Eligible]
HAVING SUM(ET.[Out Seconds] - ET.[In Seconds]) <> 0 OR SUM(ET.[Fixed Pay]) <> 0

UNION ALL

-- Approved unpaid time
SELECT ET.EmployeeID, 
Class = CASE WHEN @flags & 16 = 16 THEN 5 ELSE 0 END, 
ET.CalculatedTypeID, 
T.[Abbreviation], 
ET.[Pay Rate] * @pay_rate_multiplier, 
Seconds = SUM(ET.[Out Seconds] - ET.[In Seconds]), 
T.[Order], 
[Fixed Pay] = SUM(ET.[Fixed Pay]), -- Needs to be divided by [Fixed Items]
[Fixed Items] = COUNT(ALL CASE WHEN ET.[Fixed Pay]=0 THEN NULL ELSE ET.[Fixed Pay] END), 
T.[OT Eligible]
FROM #EMPLOYEE_TIME_ROUNDED ET
INNER JOIN dbo.vwTimeType T ON ET.CalculatedTypeID = T.TypeID AND T.[Paid Time]=0 -- Excludes pending and denied time
GROUP BY ET.EmployeeID, ET.[Pay Rate] * @pay_rate_multiplier, ET.CalculatedTypeID, T.[Abbreviation], T.[Order], T.[OT Eligible]
HAVING SUM(ET.[Out Seconds] - ET.[In Seconds]) <> 0 OR SUM(ET.[Fixed Pay]) <> 0
UNION ALL

-- Pending time
SELECT ET.EmployeeID, Class = 0, ET.CalculatedTypeID, 'PEND', 0, SUM(ET.[Out Seconds] - ET.[In Seconds]), -2147483648, 0, 0, 0
FROM #EMPLOYEE_TIME_ROUNDED ET WHERE ET.CalculatedTypeID=@pending_type_id AND ET.[Out Seconds] != ET.[In Seconds] GROUP BY ET.EmployeeID, ET.CalculatedTypeID

UNION ALL

-- Paid leave
SELECT L.EmployeeID, 1, L.TypeID, L.[Abbreviation], 
[Pay Rate] = ISNULL(EC.[Hourly Pay] * @pay_rate_multiplier, 0),
Seconds = ISNULL(SUM(-L.Seconds), 0),
L.[Order],
0, 0, L.[OT Eligible]
FROM dbo.vwEmployeeLeaveApproved L 
INNER JOIN dbo.TempX X ON L.[Limit Adjustment]=0 AND X.BatchID = @batch_id AND X.[ID] = L.EmployeeID AND L.Seconds < 0 AND (L.TypeID & @leave_type_mask) != 0 AND L.Paid=1 AND 
L.[Day past 1900] /* + CASE WHEN @flags & 8 = 0 THEN 0 ELSE L.[Payroll Delay] END */ BETWEEN @start_day AND @stop_day
LEFT JOIN dbo.vwEmployeeCompensation EC ON EC.EmployeeID = X.[ID] AND L.[Day past 1900] BETWEEN EC.[Start Day past 1900] AND ISNULL(EC.[Stop Day past 1900], 0x7FFFFFFF)
GROUP BY L.EmployeeID, L.TypeID, L.[Abbreviation], L.Paid, L.[Order], EC.[Hourly Pay], L.[OT Eligible]
HAVING SUM(L.Seconds) <> 0

UNION ALL

-- Pending Paid leave
SELECT U.EmployeeID, @pending_leave_class_id, L.TypeID, 'PEND ' + T.[Abbreviation], 
[Pay Rate] = ISNULL(EC.[Hourly Pay] * @pay_rate_multiplier, 0),
Seconds = ISNULL(SUM(L.Seconds), 0),
T.[Order],
0, 0, T.[OT Eligible]

FROM dbo.EmployeeLeaveUsedItem L
INNER JOIN dbo.Constant ON (@flags & 2) = 0 AND (L.TypeID & Constant.[Timecard Leave Type Mask]) != 0 AND (L.TypeID & @leave_type_mask) != 0
INNER JOIN dbo.EmployeeLeaveUsed U ON U.LeaveID=L.LeaveID AND U.[Status]=1
INNER JOIN dbo.Employee E ON E.EmployeeID=U.EmployeeID AND (L.[Day past 1900] /* + CASE WHEN @flags & 8 = 0 THEN 0 ELSE E.[Payroll Delay] END */ BETWEEN @start_day AND @stop_day) 
INNER JOIN dbo.LeaveType T ON L.TypeID = T.TypeID AND T.Paid=1
INNER JOIN TempX X ON X.BatchID = @batch_id AND X.[ID] = U.EmployeeID
LEFT JOIN dbo.vwEmployeeCompensation EC ON EC.EmployeeID = U.EmployeeID AND L.[Day past 1900] BETWEEN EC.[Start Day past 1900] AND ISNULL(EC.[Stop Day past 1900], 0x7FFFFFFF)
GROUP BY L.[Day past 1900], U.EmployeeID, L.TypeID, T.[Abbreviation], T.Paid, T.[Order], EC.[Hourly Pay], T.[OT Eligible]
HAVING SUM(L.Seconds) <> 0

UNION ALL

-- Earned leave
SELECT L.EmployeeID, 2, L.TypeID, T.[Abbreviation],
[Pay Rate] = CASE WHEN @pay_rate_multiplier=0 OR T.Paid=0 THEN 0 ELSE ISNULL(EC.[Hourly Pay] * @pay_rate_multiplier, 0) END, 
SUM(L.Seconds),
T.[Order],
0, 0, T.[OT Eligible]
FROM dbo.EmployeeLeaveEarned L
INNER JOIN dbo.TempX X ON X.BatchID = @batch_id AND X.[ID] = L.EmployeeID AND L.Seconds > 0 AND (L.TypeID & @leave_type_mask) != 0
INNER JOIN dbo.Employee E ON L.EmployeeID = E.EmployeeID AND L.[Day past 1900] /* + CASE WHEN @flags & 8 = 0 THEN 0 ELSE E.[Payroll Delay] END */ BETWEEN @start_day AND @stop_day
INNER JOIN dbo.LeaveType T ON L.TypeID = T.TypeID
LEFT JOIN dbo.vwEmployeeCompensationLast EC ON EC.EmployeeID = X.[ID]
GROUP BY L.EmployeeID, L.TypeID, T.[Abbreviation], T.Paid, T.[Order], EC.[Hourly Pay], T.[OT Eligible]
HAVING SUM(L.Seconds) <> 0

UNION ALL

-- Unpaid leave
SELECT L.EmployeeID, 3, L.TypeID, L.[Abbreviation], 
[Pay Rate] = CASE WHEN @pay_rate_multiplier=0 OR L.Paid=0 THEN 0 ELSE ISNULL(EC.[Hourly Pay] * @pay_rate_multiplier, 0) END, 
Seconds = ISNULL(SUM(-L.Seconds), 0),
L.[Order],
0, 0, L.[OT Eligible]
FROM dbo.vwEmployeeLeaveApproved L 
INNER JOIN TempX X ON L.[Limit Adjustment]=0 AND X.BatchID = @batch_id AND X.[ID] = L.EmployeeID AND L.Seconds < 0 AND (L.TypeID & @leave_type_mask) != 0 AND L.Paid=0 AND L.[Day past 1900] /* + CASE WHEN @flags & 8 = 0 THEN 0 ELSE L.[Payroll Delay] END */ BETWEEN @start_day AND @stop_day
LEFT JOIN dbo.vwEmployeeCompensationLast EC ON EC.EmployeeID = X.[ID]
GROUP BY L.EmployeeID, L.TypeID, L.[Abbreviation], L.Paid, L.[Order], EC.[Hourly Pay], L.[OT Eligible]
HAVING SUM(L.Seconds) <> 0

ORDER BY [Class], [Order]

UPDATE #SecondsForEmployeeTimeClassType SET [Fixed Pay] = [Fixed Pay] / [Fixed Items] WHERE [Fixed Items] > 0 AND [Fixed Pay] > 0

-- Gives unique typeids when employees work more than one type for a different rate
DECLARE @offset int
SELECT @offset = ISNULL((SELECT MIN(TypeID) FROM LeaveType WHERE TypeID < @pending_type_id), @pending_type_id) - 1

SELECT EmployeeID, Class, TypeID, ItemID=(
	SELECT TOP 1 ItemID FROM #SecondsForEmployeeTimeClassType T2 WHERE T2.EmployeeID=#SecondsForEmployeeTimeClassType.EmployeeID AND T2.Class=#SecondsForEmployeeTimeClassType.Class AND T2.TypeID=#SecondsForEmployeeTimeClassType.TypeID ORDER BY T2.[Pay Rate]
)
INTO #D FROM #SecondsForEmployeeTimeClassType GROUP BY EmployeeID, Class, TypeID HAVING COUNT(*) > 1

WHILE EXISTS (SELECT * FROM #D)
BEGIN
	UPDATE #SecondsForEmployeeTimeClassType SET TypeID=@offset FROM #SecondsForEmployeeTimeClassType INNER JOIN #D ON #SecondsForEmployeeTimeClassType.ItemID=#D.ItemID
	SELECT @offset = @offset - 1

	DELETE #D
	INSERT #D

	SELECT EmployeeID, Class, TypeID, ItemID=(
		SELECT TOP 1 ItemID FROM #SecondsForEmployeeTimeClassType T2 WHERE T2.EmployeeID=#SecondsForEmployeeTimeClassType.EmployeeID AND T2.Class=#SecondsForEmployeeTimeClassType.Class AND T2.TypeID=#SecondsForEmployeeTimeClassType.TypeID ORDER BY T2.[Pay Rate]
	)	
	FROM #SecondsForEmployeeTimeClassType GROUP BY EmployeeID, Class, TypeID HAVING COUNT(*) > 1

END
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spEmployeeTimeSummarizeBasis5'
GO
ALTER PROC dbo.spEmployeeTimeSummarizeBasis5
	@batch_id int,
	@start_day int,
	@stop_day int,
	@authorized bit OUT,
	@project_class_id int = NULL,
	@project_class_id_is_null bit = NULL,
	@pending_leave_class_id int = 1,
	@time_type_mask int = 0x7FFFFFFF,
	@leave_type_mask int = 0x7FFFFFFF,
	@flags int = 0 -- 1: Exclude pending time, 2: Exclude pending paid leave, 4: ignore rate, 8: payroll delay, 16: classify unpaid time as class = 5
AS
DECLARE @pending_type_id int, @denied_type_id int

CREATE TABLE #SecondsForEmployeeTimeClassType(ItemID int IDENTITY(1,1), EmployeeID int, Class int, TypeID int, Abbreviation varchar(20) COLLATE SQL_Latin1_General_CP1_CI_AS, [Pay Rate] money, Seconds int, [Order] int, [Fixed Pay] money, [Fixed Items] int, [OT Eligible] bit)
EXEC dbo.spEmployeeTimeSummarizeBasis6 @batch_id, @start_day, @stop_day, @authorized OUT, @project_class_id, @project_class_id_is_null, @pending_leave_class_id, @pending_type_id OUT, @denied_type_id OUT, @time_type_mask, @leave_type_mask, @flags

SELECT * FROM #SecondsForEmployeeTimeClassType ORDER BY CASE [Class]
	WHEN 0 THEN 0
	WHEN 1 THEN 2
	WHEN 2 THEN 3
	WHEN 3 THEN 4
	WHEN 4 THEN 5
	WHEN 5 THEN 1
END, [Order]

DELETE dbo.TempX WHERE BatchID=@batch_id OR DATEDIFF(minute, Created, GETDATE()) > 30
GO
GRANT EXEC ON dbo.spEmployeeTimeSummarizeBasis5 TO public
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spEmployeeTimeSummarizeBasis7'
GO
ALTER PROC dbo.spEmployeeTimeSummarizeBasis7
	@batch_id int,
	@start_day int,
	@stop_day int,
	@authorized bit OUT,
	@project_class_id int,
	@project_class_id_is_null bit,
	@pending_leave_class_id int,
	@pending_type_id int OUT,
	@denied_type_id int OUT,
	@time_type_mask int = 2147483647,
	@leave_type_mask int = 2147483647,
	@flags int = 0 -- 1: Exclude pending time, 2: Exclude pending paid leave, 4: ignore rate, 8: reserved, 16: classify unpaid leave as 5 instead of 0
AS
SET NOCOUNT ON

DECLARE @pay_rate_multiplier money
SELECT @pay_rate_multiplier = CASE WHEN (@flags & 4) = 0 THEN 1 ELSE 0 END

CREATE TABLE #EMPLOYEE_TIME_ROUNDED(
	TempItemID int NOT NULL IDENTITY(1,1) PRIMARY KEY,
	EmployeeID int NOT NULL,
	OriginalTypeID int NOT NULL, 
	CalculatedTypeID int NOT NULL,
	[In Day past 1900] int NOT NULL, 
	[OT Eligible] bit NOT NULL,
	[OT Disable] bit NOT NULL,
	[Pay Rate] money NOT NULL,
	[Fixed Pay] money NOT NULL DEFAULT(0),
	[Fixed Items] int DEFAULT(0),
	Regular bit DEFAULT(0),
	[In Seconds] int NOT NULL,
	[Out Seconds] int NOT NULL,
	TimeSchemaID int NOT NULL,
	ShiftDiffItemID int NULL,
	TempShiftDiffSeconds int NULL,
	TempShiftDiffItemID int NULL,
	OriginalTimeItemID int NULL,
	CopyTimeItemID int NULL,
	[Time Seconds] int NOT NULL DEFAULT(0),
	[Holiday Seconds] int NOT NULL DEFAULT(0),
	[OT Seconds] int NOT NULL DEFAULT(0),
	Flags int NOT NULL DEFAULT(0),
	[Actual In] datetime NULL,
	[Actual Out] datetime NULL,
	[Base Seconds] int NOT NULL DEFAULT(0),
	[X2 Seconds] int NOT NULL DEFAULT(0)
)

EXEC dbo.spEmployeeTimeRoundAndCalcOT @batch_id, 0, @start_day OUT, @stop_day OUT, @project_class_id, @project_class_id_is_null, @authorized OUT, @pending_type_id OUT, @denied_type_id OUT

IF (@flags & 1) = 1 DELETE #EMPLOYEE_TIME_ROUNDED WHERE CalculatedTypeID = @pending_type_id
DELETE #EMPLOYEE_TIME_ROUNDED WHERE CalculatedTypeID != @pending_type_id AND (CalculatedTypeID & @time_type_mask) = 0

INSERT #SecondsForEmployeeDayTimeClassType(D, EmployeeID, Class, TypeID, Abbreviation , [Pay Rate], Seconds, [Order], [Fixed Pay], [Fixed Items], [OT Eligible])

-- Approved time
SELECT 
D = ET.[In Day past 1900],
ET.EmployeeID, 
Class = 0, 
ET.CalculatedTypeID, 
T.[Abbreviation], 
ET.[Pay Rate] * @pay_rate_multiplier, 
Seconds = SUM(ET.[Out Seconds] - ET.[In Seconds]), 
T.[Order], 
[Fixed Pay] = SUM(ET.[Fixed Pay]), -- Needs to be divided by [Fixed Items]
[Fixed Items] = COUNT(ALL CASE WHEN ET.[Fixed Pay]=0 THEN NULL ELSE ET.[Fixed Pay] END), 
T.[OT Eligible]
FROM #EMPLOYEE_TIME_ROUNDED ET
INNER JOIN dbo.vwTimeType T ON ET.CalculatedTypeID = T.TypeID AND T.[Paid Time] = 1 -- Excludes pending and denied time
GROUP BY ET.[In Day past 1900], ET.EmployeeID, ET.[Pay Rate] * @pay_rate_multiplier, ET.CalculatedTypeID, T.[Abbreviation], T.[Order], ET.[Fixed Pay], T.[OT Eligible]
HAVING SUM(ET.[Out Seconds] - ET.[In Seconds]) <> 0

UNION ALL

SELECT 
D = ET.[In Day past 1900],
ET.EmployeeID, 
Class = CASE WHEN (@flags & 16) = 16 THEN 5 ELSE 0 END, 
ET.CalculatedTypeID, 
T.[Abbreviation], 
ET.[Pay Rate] * @pay_rate_multiplier, 
Seconds = SUM(ET.[Out Seconds] - ET.[In Seconds]), 
T.[Order], 
[Fixed Pay] = SUM(ET.[Fixed Pay]), -- Needs to be divided by [Fixed Items]
[Fixed Items] = COUNT(ALL CASE WHEN ET.[Fixed Pay]=0 THEN NULL ELSE ET.[Fixed Pay] END), 
T.[OT Eligible]
FROM #EMPLOYEE_TIME_ROUNDED ET
INNER JOIN dbo.vwTimeType T ON ET.CalculatedTypeID = T.TypeID AND T.[Paid Time] = 0 -- Excludes pending and denied time
GROUP BY ET.[In Day past 1900], ET.EmployeeID, ET.[Pay Rate] * @pay_rate_multiplier, ET.CalculatedTypeID, T.[Abbreviation], T.[Order], ET.[Fixed Pay], T.[OT Eligible]
HAVING SUM(ET.[Out Seconds] - ET.[In Seconds]) <> 0

UNION ALL

-- Pending time
SELECT ET.[In Day past 1900], ET.EmployeeID, Class = 0, ET.CalculatedTypeID, 'PEND', 0, SUM(ET.[Out Seconds] - ET.[In Seconds]), -2147483648, 0, 0, 0
FROM #EMPLOYEE_TIME_ROUNDED ET WHERE ET.CalculatedTypeID=@pending_type_id AND ET.[Out Seconds] != ET.[In Seconds] GROUP BY ET.[In Day past 1900], ET.EmployeeID, ET.CalculatedTypeID

UNION ALL

-- Paid leave
SELECT L.[Day past 1900], L.EmployeeID, 1, L.TypeID, L.[Abbreviation], 
[Pay Rate] = ISNULL(EC.[Hourly Pay] * @pay_rate_multiplier, 0),
Seconds = ISNULL(SUM(-L.Seconds), 0),
L.[Order],
0, 0, L.[OT Eligible]
FROM dbo.vwEmployeeLeaveApproved L 
INNER JOIN dbo.TempX X ON L.[Limit Adjustment]=0 AND X.BatchID = @batch_id AND X.[ID] = L.EmployeeID AND L.Seconds < 0 AND (L.TypeID & @leave_type_mask) != 0 AND L.Paid=1 AND L.[Day past 1900] BETWEEN @start_day AND @stop_day
LEFT JOIN dbo.vwEmployeeCompensation EC ON EC.EmployeeID = X.[ID] AND L.[Day past 1900] BETWEEN EC.[Start Day past 1900] AND ISNULL(EC.[Stop Day past 1900], 0x7FFFFFFF)
GROUP BY L.[Day past 1900], L.EmployeeID, L.TypeID, L.[Abbreviation], L.Paid, L.[Order], EC.[Hourly Pay], L.[OT Eligible]
HAVING SUM(L.Seconds) <> 0

UNION ALL

-- Pending Paid leave
SELECT L.[Day past 1900], U.EmployeeID, @pending_leave_class_id, L.TypeID, 'PEND ' + T.[Abbreviation], 
[Pay Rate] = ISNULL(EC.[Hourly Pay] * @pay_rate_multiplier, 0),
Seconds = ISNULL(SUM(L.Seconds), 0),
T.[Order],
0, 0, T.[OT Eligible]
FROM dbo.EmployeeLeaveUsedItem L
INNER JOIN dbo.Constant ON (@flags & 2) = 0 AND (L.[Day past 1900] BETWEEN @start_day AND @stop_day) AND (L.TypeID & Constant.[Timecard Leave Type Mask]) != 0 AND (L.TypeID & @leave_type_mask) != 0
INNER JOIN dbo.LeaveType T ON L.TypeID = T.TypeID AND T.Paid=1
INNER JOIN dbo.EmployeeLeaveUsed U ON U.LeaveID=L.LeaveID AND U.[Status]=1
INNER JOIN TempX X ON X.BatchID = @batch_id AND X.[ID] = U.EmployeeID
LEFT JOIN dbo.vwEmployeeCompensation EC ON EC.EmployeeID = U.EmployeeID AND L.[Day past 1900] BETWEEN EC.[Start Day past 1900] AND ISNULL(EC.[Stop Day past 1900], 0x7FFFFFFF)

GROUP BY L.[Day past 1900], U.EmployeeID, L.TypeID, T.[Abbreviation], T.Paid, T.[Order], EC.[Hourly Pay], T.[OT Eligible]
HAVING SUM(L.Seconds) <> 0

UNION ALL

-- Earned leave
SELECT L.[Day past 1900], L.EmployeeID, 2, L.TypeID, T.[Abbreviation],
[Pay Rate] = CASE WHEN @pay_rate_multiplier=0 OR T.Paid=0 THEN 0 ELSE ISNULL(EC.[Hourly Pay] * @pay_rate_multiplier, 0) END, 
SUM(L.Seconds),
T.[Order],
0, 0, T.[OT Eligible]
FROM dbo.EmployeeLeaveEarned L
INNER JOIN dbo.TempX X ON X.BatchID = @batch_id AND X.[ID] = L.EmployeeID AND L.Seconds > 0 AND (L.TypeID & @leave_type_mask) != 0 AND L.[Day past 1900] BETWEEN @start_day AND @stop_day
INNER JOIN dbo.LeaveType T ON L.TypeID = T.TypeID
LEFT JOIN dbo.vwEmployeeCompensationLast EC ON EC.EmployeeID = X.[ID]
GROUP BY L.[Day past 1900], L.EmployeeID, L.TypeID, T.[Abbreviation], T.Paid, T.[Order], EC.[Hourly Pay], T.[OT Eligible]
HAVING SUM(L.Seconds) <> 0

UNION ALL

-- Unpaid leave
SELECT L.[Day past 1900], L.EmployeeID, 3, L.TypeID, L.[Abbreviation], 
[Pay Rate] = CASE WHEN @pay_rate_multiplier=0 OR L.Paid=0 THEN 0 ELSE ISNULL(EC.[Hourly Pay] * @pay_rate_multiplier, 0) END, 
Seconds = ISNULL(SUM(-L.Seconds), 0),
L.[Order],
0, 0, L.[OT Eligible]
FROM dbo.vwEmployeeLeaveApproved L 
INNER JOIN dbo.TempX X ON L.[Limit Adjustment]=0 AND X.BatchID = @batch_id AND X.[ID] = L.EmployeeID AND L.Seconds < 0 AND (L.TypeID & @leave_type_mask) != 0 AND L.Paid=0 AND L.[Day past 1900] BETWEEN @start_day AND @stop_day
LEFT JOIN dbo.vwEmployeeCompensationLast EC ON EC.EmployeeID = X.[ID]
GROUP BY L.[Day past 1900], L.EmployeeID, L.TypeID, L.[Abbreviation], L.Paid, L.[Order], EC.[Hourly Pay], L.[OT Eligible]
HAVING SUM(L.Seconds) <> 0

ORDER BY [Class], [Order]

UPDATE #SecondsForEmployeeDayTimeClassType SET [Fixed Pay] = [Fixed Pay] / [Fixed Items] WHERE [Fixed Items] > 0 AND [Fixed Pay] > 0

-- Gives unique typeids when employees work more than one type for a different rate

DECLARE @offset int
SELECT @offset = ISNULL((SELECT MIN(TypeID) FROM LeaveType WHERE TypeID < @pending_type_id), @pending_type_id) - 1

SELECT EmployeeID, D, Class, TypeID, ItemID=(
	SELECT TOP 1 ItemID FROM #SecondsForEmployeeDayTimeClassType T2 WHERE T2.EmployeeID=#SecondsForEmployeeDayTimeClassType.EmployeeID AND T2.Class=#SecondsForEmployeeDayTimeClassType.Class AND T2.TypeID=#SecondsForEmployeeDayTimeClassType.TypeID AND T2.D=#SecondsForEmployeeDayTimeClassType.D ORDER BY T2.[Pay Rate]
)
INTO #D FROM #SecondsForEmployeeDayTimeClassType GROUP BY EmployeeID, D, Class, TypeID HAVING COUNT(*) > 1

WHILE EXISTS (SELECT * FROM #D)
BEGIN
	UPDATE #SecondsForEmployeeDayTimeClassType SET TypeID=@offset FROM #SecondsForEmployeeDayTimeClassType INNER JOIN #D ON #SecondsForEmployeeDayTimeClassType.ItemID=#D.ItemID
	SELECT @offset = @offset - 1

	DELETE #D
	INSERT #D

	SELECT EmployeeID, D, Class, TypeID, ItemID=(
		SELECT TOP 1 ItemID FROM #SecondsForEmployeeDayTimeClassType T2 WHERE T2.EmployeeID=#SecondsForEmployeeDayTimeClassType.EmployeeID AND T2.Class=#SecondsForEmployeeDayTimeClassType.Class AND T2.TypeID=#SecondsForEmployeeDayTimeClassType.TypeID AND T2.D=#SecondsForEmployeeDayTimeClassType.D ORDER BY T2.[Pay Rate]
	)
	FROM #SecondsForEmployeeDayTimeClassType GROUP BY D, EmployeeID, Class, TypeID HAVING COUNT(*) > 1

END
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spEmployeeTimeSummarizeBasis8'
GO
ALTER PROC dbo.spEmployeeTimeSummarizeBasis8
	@batch_id int,
	@start_day int,
	@stop_day int,
	@authorized bit OUT,
	@project_class_id int = NULL,
	@project_class_id_is_null bit = NULL,
	@pending_leave_class_id int = 1,
	@time_type_mask int = 0x7FFFFFFF,
	@leave_type_mask int = 0x7FFFFFFF,
	@flags int = 0 -- 1: Exclude pending time, 2: Exclude pending paid leave, 4: ignore rate, 8: reserved
AS
DECLARE @pending_type_id int, @denied_type_id int

CREATE TABLE #SecondsForEmployeeDayTimeClassType(ItemID int IDENTITY(1,1), D int, EmployeeID int, Class int, TypeID int, Abbreviation varchar(20) COLLATE SQL_Latin1_General_CP1_CI_AS, [Pay Rate] money, Seconds int, [Order] int, [Fixed Pay] money, [Fixed Items] int, [OT Eligible] bit)
EXEC dbo.spEmployeeTimeSummarizeBasis7 @batch_id, @start_day, @stop_day, @authorized OUT, @project_class_id, @project_class_id_is_null, @pending_leave_class_id, @pending_type_id OUT, @denied_type_id OUT, @time_type_mask, @leave_type_mask, @flags

SELECT * FROM #SecondsForEmployeeDayTimeClassType ORDER BY CASE [Class]
	WHEN 0 THEN 0
	WHEN 1 THEN 2
	WHEN 2 THEN 3
	WHEN 3 THEN 4
	WHEN 4 THEN 5
	WHEN 5 THEN 1
END, [Order]

DELETE dbo.TempX WHERE BatchID=@batch_id OR DATEDIFF(minute, Created, GETDATE()) > 30
GO
ALTER VIEW dbo.vwPersonXTraining
AS
SELECT PT.ItemID, PT.PersonID, PT.TrainingID, PT.[Began Day past 1900], PT.[Completed Day past 1900],
T.Training, Person = dbo.fnGetListAs(P.[First Name], P.[Middle Name], P.[Last Name], P.Suffix),
[Began] = dbo.GetDateFromDaysPast1900(PT.[Began Day past 1900]), 
[Completed] = dbo.GetDateFromDaysPast1900(PT.[Completed Day past 1900]),
[Nonterminated Employee] = CAST(
	CASE WHEN E.EmployeeID IS NULL THEN 0
	WHEN E.[Terminated Day past 1900] IS NULL THEN 1
	ELSE 0 END 
AS bit),
IsComplete = CAST (CASE WHEN PT.[Completed Day past 1900] IS NULL THEN 0 ELSE 1 END AS bit),
PT.Comments, PT.[Expires Day past 1900], PT.Hours,
Expires = dbo.GetDateFromDaysPast1900(PT.[Expires Day past 1900])
FROM dbo.PersonXTraining PT
INNER JOIN dbo.Training T ON PT.TrainingID = T.TrainingID
INNER JOIN dbo.Person P ON PT.PersonID = P.PersonID
LEFT JOIN dbo.Employee E ON PT.PersonID = E.EmployeeID
GO
IF OBJECT_id('dbo.spPersonXTrainingList2') IS NULL 
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spPersonXTrainingList2 AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spPersonXTrainingList2 TO public'
END
GO
ALTER PROC dbo.spPersonXTrainingList2
	@training_id int,
	@exclude_incomplete bit,
	@authorized bit OUT
AS
DECLARE  @batch_id int

SET NOCOUNT ON

SELECT @batch_id = RAND() * 2147483647
INSERT TempX(BatchID, [ID])
SELECT DISTINCT @batch_id, PersonID FROM dbo.vwPersonXTraining WHERE [Nonterminated Employee] = 1

EXEC dbo.spPermissionGetOnPeopleForCurrentUser2 @batch_id, 4096
DELETE TempX WHERE BatchID = @batch_id AND X & 1 = 0
SELECT @authorized = CASE WHEN @@ROWCOUNT = 0 THEN 1 ELSE 0 END

SELECT
T.ItemID,
T.PersonID,
T.TrainingID,
T.[Began Day past 1900],
T.[Completed Day past 1900],
T.Training,
T.Person,
T.[Began],
T.[Completed],
T.[Nonterminated Employee],
T.[IsComplete],
T.Comments,
T.[Expires Day past 1900],
T.Hours,
T.Expires
FROM dbo.vwPersonXTraining T
WHERE T.TrainingID = @training_id  AND
(@exclude_incomplete = 0 OR T.IsComplete = 1)
ORDER BY Person

DELETE TempX WHERE BatchID = @batch_id OR DATEDIFF(hh, Created, GETDATE()) > 1
GO
IF OBJECT_id('dbo.spPersonXTrainingList3') IS NULL 
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spPersonXTrainingList3 AS'
	GRANT EXEC ON dbo.spPersonXTrainingList3 TO public
END
GO
ALTER PROC dbo.spPersonXTrainingList3
	@training_id int,
	@batch_id int,
	@completed bit,
	@completed_min int,
	@completed_max int,
	@began_min int,
	@began_max int,
	@authorized bit OUT,
	@exclude_expired int = NULL,
	@expires_before int = NULL
AS
SET NOCOUNT ON

IF @batch_id IS NULL
BEGIN
	SELECT @batch_id = RAND() * 2147483647
	INSERT TempX(BatchID, [ID])
	SELECT DISTINCT @batch_id, PersonID FROM vwPersonXTraining WHERE [Nonterminated Employee] = 1
END

EXEC dbo.spPermissionGetOnPeopleForCurrentUser2 @batch_id, 4096
DELETE TempX WHERE BatchID = @batch_id AND X & 1 = 0
SELECT @authorized = CASE WHEN @@ROWCOUNT = 0 THEN 1 ELSE 0 END

SELECT 
T.ItemID,
T.PersonID,
T.TrainingID,
T.[Began Day past 1900],
T.[Completed Day past 1900],
T.Training,
T.Person,
T.[Began],
T.[Completed],
T.[Nonterminated Employee],
T.[IsComplete],
T.Comments,
T.[Expires Day past 1900],
T.[Hours],
T.Expires
FROM dbo.vwPersonXTraining T
INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID]=T.PersonID
AND T.[Began Day past 1900] BETWEEN @began_min AND @began_max
AND (T.[Completed Day past 1900] IS NULL OR (T.[Completed Day past 1900] IS NOT NULL AND T.[Completed Day past 1900] BETWEEN @completed_min AND @completed_max))
AND (@completed IS NULL OR @completed = T.IsComplete)
AND (@training_id IS NULL OR T.TrainingID = @training_id)
AND (@exclude_expired IS NULL OR T.[Expires Day past 1900] IS NULL OR T.[Expires Day past 1900] >= @exclude_expired)
AND (@expires_before IS NULL OR (T.[Expires Day past 1900] IS NOT NULL AND T.[Expires Day past 1900] < @expires_before))
ORDER BY T.Person, T.Training, T.[Began Day past 1900]

DELETE TempX WHERE BatchID = @batch_id OR DATEDIFF(hh, Created, GETDATE()) > 1
GO
IF OBJECT_id('dbo.spPersonXTrainingList3') IS NULL 
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEmployeeList3 AS'
	GRANT EXEC ON dbo.spEmployeeList3 TO public
END
GO
ALTER PROC dbo.spEmployeeList3
	@batch_id int,
	@start_day int = NULL,
	@stop_day int = NULL
AS
SET NOCOUNT ON

CREATE TABLE #TimeLastApproved(EmployeeID int, LAD int, ItemID int)

IF @start_day IS NOT NULL AND @stop_day IS NOT NULL

INSERT #TimeLastApproved
SELECT ET.EmployeeID, MAX([Last Approved Day past 1900]), NULL
FROM dbo.TempX X
INNER JOIN dbo.EmployeeTime ET ON X.BatchID=@batch_id AND X.[ID]=ET.EmployeeID AND DATEDIFF(d,0,[In]) BETWEEN @start_day AND @stop_day AND [Last Approved Day past 1900] IS NOT NULL
GROUP BY ET.EmployeeID

UPDATE TLA SET ItemID = (
	SELECT TOP 1 ItemID FROM dbo.EmployeeTime ET WHERE ET.EmployeeID=TLA.EmployeeID AND ET.[Last Approved Day past 1900] = TLA.LAD ORDER BY [Last Submitted Day past 1900] DESC, ET.[In] DESC
) FROM #TimeLastApproved TLA

CREATE TABLE #TimeLastSubmitted(EmployeeID int, LSD int, ItemID int)

INSERT #TimeLastSubmitted
SELECT ET.EmployeeID, MAX([Last Submitted Day past 1900]), NULL
FROM dbo.TempX X
INNER JOIN dbo.EmployeeTime ET ON X.BatchID=@batch_id AND X.[ID]=ET.EmployeeID AND DATEDIFF(d,0,[In]) BETWEEN @start_day AND @stop_day AND [Last Submitted Day past 1900] IS NOT NULL
GROUP BY ET.EmployeeID

UPDATE TLS SET ItemID = (
	SELECT TOP 1 ItemID FROM dbo.EmployeeTime ET WHERE ET.EmployeeID=TLS.EmployeeID AND ET.[Last Submitted Day past 1900] = TLS.LSD ORDER BY ET.[In] DESC
) FROM #TimeLastSubmitted TLS


SELECT P.SSN, E.Salaried, E.[Employee Number], Employee = V.[List As], E.EmployeeID, 
[Job Title] = ISNULL(EC.[Job Title], ''), D.Department, DIV.Division, Location=LOC.[List As], 
E.DepartmentID, DIV.DivisionID, LOC.LocationID,
Mileage = ISNULL(
	(SELECT SUM([Odometer Stop]-[Odometer Start]) FROM EmployeeTime ET WHERE ET.EmployeeID=E.EmployeeID AND DATEDIFF(d,0,[In]) BETWEEN @start_day AND @stop_day)
,0),
[Payroll Pay] = ISNULL(EC.[Payroll Pay],0),
E.EmployeeNumberNumeric,
[Last Approved] = DATEADD(d,0,TLA.LAD),
[Last Approved by] = ISNULL(ET2.[Last Approved by], ''),
[Last Submitted] = DATEADD(d,0,TLS.LSD),
[Last Submitted by] = ISNULL(ET3.[Last Submitted by], ''),
Deductions = ISNULL((
	SELECT SUM(D.[Amount]) FROM dbo.vwEmployeeDeductionUnion2 D WHERE D.EmployeeID = E.EmployeeID AND (dbo.fnPermissionGetOnPersonForCurrentUser(D.EmployeeID, 536870912) & 1) = 1
), 0)
FROM dbo.TempX X
INNER JOIN dbo.Employee E ON X.BatchID = @batch_id AND X.[ID] = E.EmployeeID
INNER JOIN dbo.PersonX P ON E.EmployeeID = P.PersonID
INNER JOIN dbo.vwPersonListAs V ON E.EmployeeID = V.PersonID
INNER JOIN dbo.Department D ON E.DepartmentID=D.DepartmentID
INNER JOIN dbo.Division DIV ON E.DivisionID=DIV.DivisionID
INNER JOIN dbo.Location LOC ON E.LocationID=LOC.LocationID
LEFT JOIN dbo.vwEmployeeLastCompensation EC ON E.EmployeeID=EC.EmployeeID
LEFT JOIN #TimeLastApproved TLA ON E.EmployeeID = TLA.EmployeeID
LEFT JOIN #TimeLastSubmitted TLS ON E.EmployeeID = TLS.EmployeeID
LEFT JOIN dbo.EmployeeTime ET2 ON TLA.ItemID = ET2.ItemID
LEFT JOIN dbo.EmployeeTime ET3 ON TLS.ItemID = ET3.ItemID
GO
-- Checks permissions for person on field and performs update if authorized. @authorized = 0 indicates no update because of lack of permission
ALTER PROCEDURE dbo.spPersonUpdateColumnVarchar50
	@person_id int,
	@field_id int,
	@value varchar(50),
	@authorized bit = NULL out
AS
DECLARE @error int, @sql nvarchar(4000)

EXEC dbo.spPersonUpdateColumnBase @person_id, @field_id, 167, 50, @sql out, @authorized out, @error out
IF @error = 0 AND @authorized = 1 EXEC dbo.spExecSQLAsDBOvarchar50 @sql, @value, @person_id
IF @error <>0 EXEC dbo.spErrorRaise @error
GO
-- Checks permissions for person on field and performs update if authorized. @authorized = 0 indicates no update because of lack of permission
ALTER PROCEDURE dbo.[spPersonUpdateColumnVarchar4000]
	@person_id int,
	@field_id int,
	@value varchar(4000),
	@authorized bit = NULL out
AS
DECLARE @error int, @sql nvarchar(4000)

EXEC dbo.spPersonUpdateColumnBase @person_id, @field_id, 167, NULL, @sql out, @authorized out, @error out
IF @error = 0 AND @authorized = 1 EXEC dbo.spExecSQLAsDBOvarchar4000 @sql, @value, @person_id
IF @error <>0 EXEC dbo.spErrorRaise @error
GO
-- Checks permissions for person on field and performs update if authorized. @authorized = 0 indicates no update because of lack of permission
ALTER PROCEDURE dbo.[spPersonUpdateColumnMoney]
	@person_id int,
	@field_id int,
	@value money,
	@authorized bit = NULL out
AS
DECLARE @error int, @sql nvarchar(4000)

EXEC dbo.spPersonUpdateColumnBase @person_id, @field_id, 60, NULL, @sql out, @authorized out, @error out
IF @error = 0 AND @authorized = 1 EXEC dbo.spExecSQLAsDBOmoney @sql, @value, @person_id
IF @error <>0 EXEC dbo.spErrorRaise @error
GO
-- Checks permissions for person on field and performs update if authorized. @authorized = 0 indicates no update because of lack of permission
ALTER PROCEDURE dbo.spPersonUpdateColumnInt
	@person_id int,
	@field_id int,
	@value int,
	@authorized bit = NULL out
AS
DECLARE @error int, @sql nvarchar(4000)

EXEC dbo.spPersonUpdateColumnBase @person_id, @field_id, 56, NULL, @sql out, @authorized out, @error out
IF @error = 0 AND @authorized = 1 EXEC dbo.spExecSQLAsDBOint @sql, @value, @person_id
IF @error <>0 EXEC dbo.spErrorRaise @error
GO
ALTER PROC dbo.[spPersonUpdateColumnDate]
	@person_id int,
	@field_id int,
	@value datetime,
	@authorized bit = NULL out

AS
DECLARE @error int, @sql nvarchar(4000)

EXEC dbo.spPersonUpdateColumnBase @person_id, @field_id, NULL, NULL, @sql out, @authorized out, @error out

IF @error = 0 AND @authorized = 1 EXEC dbo.spExecSQLAsDBOdatetime @sql, @value, @person_id
IF @error <>0 EXEC dbo.spErrorRaise @error
GO
-- Checks permissions for person on field and performs update if authorized. @authorized = 0 indicates no update because of lack of permission
ALTER PROCEDURE dbo.[spPersonUpdateColumnBit]
	@person_id int,
	@field_id int,
	@value bit,
	@authorized bit = NULL out
AS
DECLARE @error int, @sql nvarchar(4000)

EXEC dbo.spPersonUpdateColumnBase @person_id, @field_id, 104, NULL, @sql out, @authorized out, @error out
IF @error = 0 AND @authorized = 1 EXEC dbo.spExecSQLAsDBObit @sql, @value, @person_id
IF @error <>0 EXEC dbo.spErrorRaise @error
GO
REVOKE EXECUTE ON dbo.spBackup TO public



IF OBJECT_id('dbo.spEmployeeCountEEOBasis') IS NOT NULL
DROP PROC dbo.spEmployeeCountEEOBasis
GO

IF OBJECT_id('dbo.spEmployeeTimeCountPending') IS NOT NULL DROP PROC dbo.spEmployeeTimeCountPending
IF OBJECT_id('dbo.spLeaveRateCopy') IS NOT NULL DROP PROC dbo.spLeaveRateCopy
IF OBJECT_id('dbo.spEmployeeCountEEOList') IS NOT NULL DROP PROC dbo.spEmployeeCountEEOList
IF OBJECT_id('dbo.spEmployeeDependentSelectPersonal') IS NOT NULL DROP PROC dbo.spEmployeeDependentSelectPersonal
IF OBJECT_id('dbo.spEmployeeDependentUpdatePersonal') IS NOT NULL DROP PROC dbo.spEmployeeDependentUpdatePersonal
IF OBJECT_id('dbo.spTurnoverItemize') IS NOT NULL DROP PROC dbo.spTurnoverItemize


GO
IF OBJECT_id('dbo.spTerminationReasonGetReasonFromReasonID') IS NOT NULL DROP PROC dbo.spTerminationReasonGetReasonFromReasonID
IF OBJECT_id('dbo.spTerminationReasonSelect') IS NOT NULL DROP PROC dbo.spTerminationReasonSelect
IF OBJECT_id('dbo.spTerminationReasonList') IS NOT NULL DROP PROC dbo.spTerminationReasonList
IF OBJECT_id('dbo.vwTerminationReason') IS NOT NULL DROP VIEW dbo.vwTerminationReason
GO
CREATE VIEW dbo.vwTerminationReason AS SELECT * FROM TerminationReason
GO
IF OBJECT_id('dbo.spTerminationReasonUpdate') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spTerminationReasonUpdate AS'
GO
ALTER PROC dbo.spTerminationReasonUpdate @reason varchar(50), @reason_id int
AS UPDATE TerminationReason SET Reason=@reason WHERE ReasonID=@reason_id
GO
IF OBJECT_id('dbo.spTerminationReasonInsert') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spTerminationReasonInsert AS'
GO
ALTER PROC dbo.spTerminationReasonInsert @reason varchar(50), @reason_id int out
AS INSERT TerminationReason(Reason) VALUES(@reason) SET @reason_id=SCOPE_IDENTITY()
GO
IF OBJECT_id('dbo.spTerminationReasonDelete') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spTerminationReasonDelete AS'
GO
ALTER PROC dbo.spTerminationReasonDelete @reason_id int
AS DELETE TerminationReason WHERE ReasonID=@reason_id
GO
CREATE PROC dbo.spTerminationReasonGetReasonFromReasonID @reason_id int, @reason varchar(50) out
AS SELECT @reason=Reason FROM TerminationReason WHERE ReasonID=@reason_id
GO
CREATE PROC dbo.spTerminationReasonSelect @reason_id int
AS SET NOCOUNT ON SELECT * FROM vwTerminationReason WHERE ReasonID=@reason_id ORDER BY Reason 
GO
CREATE PROC dbo.spTerminationReasonList
AS SET NOCOUNT ON SELECT * FROM vwTerminationReason ORDER BY Reason
GO
GRANT EXEC ON dbo.spTerminationReasonSelect TO public
GRANT EXEC ON dbo.spTerminationReasonList TO public
GRANT EXEC ON dbo.spTerminationReasonGetReasonFromReasonID TO public
GO
CREATE PROC dbo.spTurnoverItemize @batch_id int
AS
CREATE TABLE #EC120707(CompensationID int PRIMARY KEY, EmployeeID int, Start int, Stop int NULL, FirstPositionID int NULL, LastPositionID int NULL, NextCompensationID int NULL, PrevCompensationID int NULL, DelCompensationID int NULL)

INSERT #EC120707(CompensationID, EmployeeID, Start, [Stop], FirstPositionID, LastPositionID, NextCompensationID)
SELECT EC.CompensationID, EC.EmployeeID, EC.[Start Day past 1900], EC.[Stop Day past 1900], EC.PositionID, EC.PositionID,
	(
		SELECT TOP 1 EC2.CompensationID FROM EmployeeCompensation EC2 WHERE EC2.EmployeeID=EC.EmployeeID AND EC2.[Start Day past 1900] >
		CASE 
			WHEN EC.[Stop Day past 1900] IS NOT NULL THEN EC.[Stop Day past 1900]
			ELSE EC.[Start Day past 1900]
		END
		ORDER BY EC2.[Start Day past 1900]
	)
FROM TempX X INNER JOIN EmployeeCompensation EC ON X.BatchID=@batch_id AND X.[ID]=EC.EmployeeID

-- Comp entries that start 32+ days after the last one stopped are not continuous employment
UPDATE #EC120707 SET NextCompensationID=NULL
FROM #EC120707
INNER JOIN #EC120707 NextComp ON #EC120707.NextCompensationID = NextComp.CompensationID AND NextComp.Start - #EC120707.Stop > 31

-- Calculates previous compensation entry
UPDATE #EC120707 SET PrevCompensationID = PrevComp.CompensationID FROM #EC120707
INNER JOIN #EC120707 PrevComp ON PrevComp.NextCompensationID = #EC120707.CompensationID

DECLARE @rows int
SET @rows = 1

-- Walks a doubly-linked list using sets instead of nodes
WHILE @rows > 0
BEGIN
	UPDATE #EC120707 SET
		Stop = NextComp.Stop,
		LastPositionID = NextComp.LastPositionID,
		DelCompensationID = NextComp.CompensationID,
		NextCompensationID = NextComp.NextCompensationID
	FROM #EC120707
	INNER JOIN #EC120707 NextComp ON #EC120707.PrevCompensationID IS NULL AND #EC120707.NextCompensationID = NextComp.CompensationID

	DELETE #EC120707 WHERE CompensationID IN (SELECT DelCompensationID FROM #EC120707)

	SELECT @rows = @@ROWCOUNT
END

-- If the employment history has not been properly recorded then use the seniorty begins and terminated dates instead
SELECT R.EmployeeID, R.Start, R.[Stop], R.FirstPositionID, R.LastPositionID, EC.CompensationID
FROM #EC120707 R
INNER JOIN vwEmployeeCompensation EC ON R.CompensationID = EC.CompensationID
UNION
SELECT E.EmployeeID, E.[Seniority Begins Day past 1900], E.[Terminated Day past 1900], NULL, NULL, NULL
FROM TempX X
INNER JOIN Employee E ON X.BatchID=@batch_id AND X.[ID]=E.EmployeeID AND E.EmployeeID NOT IN
(
	SELECT EC.EmployeeID FROM EmployeeCompensation EC
)
GO
ALTER PROC dbo.spEmployeeDependentCheckPermission
	@contact_id int,
	@work_permission int out,
	@home_permission int out,
	@contact_permission int out,
	@personal_permission int = NULL out,
	@person_id int = NULL out
AS
DECLARE @employee_id int

SET NOCOUNT ON

SELECT @person_id = PersonID, @employee_id = EmployeeID FROM EmployeeDependent WHERE ContactID = @contact_id
EXEC dbo.spPermissionGetOnPersonForCurrentUser @employee_id, 134217728, @contact_permission out

-- If dependant is an employee then check contact read work permission
IF EXISTS(SELECT EmployeeID FROM Employee WHERE EmployeeID = @person_id)
BEGIN
	EXEC dbo.spPermissionGetOnPersonForCurrentUser @person_id, 1, @home_permission out
	EXEC dbo.spPermissionGetOnPersonForCurrentUser @person_id, 2, @work_permission out
	EXEC dbo.spPermissionGetOnPersonForCurrentUser @person_id, 4, @personal_permission out
END
ELSE SELECT @home_permission = @contact_permission, @work_permission = @contact_permission, @personal_permission = @contact_permission
GO
CREATE PROC dbo.spEmployeeDependentSelectPersonal
	@contact_id int
AS
DECLARE @authorized bit
DECLARE @person_id int
DECLARE @employee_id int

SET NOCOUNT ON

SELECT @authorized = 1
SELECT @person_id = PersonID, @employee_id = EmployeeID FROM EmployeeDependent WHERE ContactID = @contact_id

-- If dependent is an employee then check contact read personal permission
IF EXISTS(SELECT EmployeeID FROM Employee WHERE EmployeeID = @person_id)
	EXEC dbo.spPermissionInsureForCurrentUserOnPerson @person_id, 4, 1, @authorized out
-- Else check user's permission on employee's dependents
ELSE 
	EXEC dbo.spPermissionInsureForCurrentUserOnPerson @employee_id, 134217728, 1, @authorized out

IF @authorized = 1 SELECT * FROM vwPersonX WHERE PersonID = @person_id
GO
CREATE PROC dbo.spEmployeeDependentUpdatePersonal
	@contact_id int,
	@race_id int,
	@i9_status_id int,
	@ssn varchar(50),
	@renew_i9_status int,
	@country_of_citizenship varchar(50),
	@visa varchar(50),
	@visa_expires int,
	@passport varchar(50),
	@passport_expires int,
	@dob int,
	@driver_license varchar(50),
	@driver_license_state varchar(50),
	@driver_license_expires int,
	@driver_insurance_expires int,
	@cdl bit,
	@marital_status_id int,
	@dependents int,
	@disabled bit,
	@smoker bit,
	@military_branch_id int,
	@reserves bit,
	@spouse varchar(50),
	@children varchar(50),
	@driver_license_class varchar(50) = NULL,
	@visa_status_id int = null
AS
DECLARE @authorized bit, @result int, @person_id int, @personal_permission int

SET NOCOUNT ON

EXEC dbo.spEmployeeDependentCheckPermission @contact_id, 0, 0, 0, @personal_permission out, @person_id out
IF @personal_permission & 2 = 0 
BEGIN
	RAISERROR('You lack write permission on this dependent''s personal information.', 16, 1)
	RETURN
END

EXEC @result = spSSNClean @ssn out
IF @result > 0 
BEGIN
	EXEC dbo.spErrorRaise @result
	RETURN
END

UPDATE PersonX SET
	RaceID = @race_id,
	I9StatusID = @i9_status_id,
	SSN = @ssn,
	[Renew I9 Status Day past 1900] = @renew_i9_status,
	[Country of Citizenship] = @country_of_citizenship,
	Visa = @visa,
	[Visa Expires Day past 1900] = @visa_expires,
	VisaStatusID = @visa_status_id,
	Passport = @passport,
	[Passport Expires Day past 1900] = @passport_expires,
	[DOB Day past 1900] = @dob,
	[Driver License] = @driver_license,
	[Driver License State] = @driver_license_state,
	[Driver License Expires Day past 1900] = @driver_license_expires,
	[Driver Insurance Expires Day past 1900] = @driver_insurance_expires,
	[Commercial Driver License] = @cdl,
	MaritalStatusID = @marital_status_id,
	Dependents = @dependents,
	Disabled = @disabled,
	Smoker = @smoker,
	MilitaryBranchID = @military_branch_id,
	Reserves = @reserves,
	Spouse = @spouse,
	Children = @children,
	[Driver License Class] = CASE WHEN @driver_license_class IS NULL THEN [Driver License Class] ELSE @driver_license_class END
WHERE PersonID = @person_id
GO
-- Rips out people from TempX who the current user is not authorized to read, update, insert or delete.
-- Sets @hidden = 1 if any of the people where removed from the temporary list.
-- Caller must fill TempX.[ID] with the ids of the people of interest and TempX.X with 0.
ALTER PROC dbo.spPermissionInsureForCurrentUserOnPeople
	@batch_id int,
	@attribute_id int,
	@permission_required int,
	@hidden bit = NULL out 
AS
SET NOCOUNT ON

IF IS_MEMBER('db_owner') = 1 SELECT @hidden = 0
ELSE
BEGIN
	EXEC dbo.spPermissionGetOnPeopleForCurrentUser2 @batch_id, @attribute_id
	DELETE TempX WHERE BatchID = @batch_id AND (X & @permission_required) = 0
	SELECT @hidden = CASE WHEN @@ROWCOUNT = 0 THEN 0 ELSE 1 END
END
GO
IF OBJECT_ID('dbo.spEmployeeCompensationList') IS NOT NULL DROP PROC dbo.spEmployeeCompensationList
GO
CREATE PROC dbo.spEmployeeCompensationList
	@employee_id int,
	@start int,
	@stop int,
	@flags bit = 0 -- 1: exclude non budgeted
AS
DECLARE @exclude_non_budgeted bit
SET @exclude_non_budgeted = (@flags & 1)

EXEC dbo.spCustomFieldClean
SELECT * FROM dbo.vwEmployeeCompensationFlat WHERE EmployeeID = @employee_id AND
(@exclude_non_budgeted = 0 OR Budgeted = 1) AND
(
	@start BETWEEN [Start Day past 1900] AND ISNULL([Stop Day past 1900], 0x7FFFFFFF) OR
	@stop BETWEEN [Start Day past 1900] AND ISNULL([Stop Day past 1900], 0x7FFFFFFF) OR
	[Start Day past 1900] BETWEEN @start AND @stop OR
	ISNULL([Stop Day past 1900], 0x7FFFFFFF) BETWEEN @start AND @stop
)
ORDER BY [Start Day past 1900]
GO
GRANT EXEC ON dbo.spEmployeeCompensationList TO public
GO
IF OBJECT_ID('dbo.spEmployeeCompensationList3') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEmployeeCompensationList3 AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spEmployeeCompensationList3 TO public'
END
GO
ALTER PROC dbo.spEmployeeCompensationList3
	@batch_id int,
	@start int,
	@stop int,
	@flags bit = 0 -- 1: exclude non budgeted
AS
DECLARE @exclude_non_budgeted bit
SET @exclude_non_budgeted = (@flags & 1)

EXEC dbo.spCustomFieldClean
SELECT * FROM dbo.vwEmployeeCompensationFlat S
INNER JOIN TempX T ON T.BatchID=@batch_id AND S.EmployeeID=T.[ID] AND
(@exclude_non_budgeted = 0 OR Budgeted = 1) AND
(
	@start BETWEEN S.[Start Day past 1900] AND ISNULL(S.[Stop Day past 1900], 0x7FFFFFFF) OR
	@stop BETWEEN S.[Start Day past 1900] AND ISNULL(S.[Stop Day past 1900], 0x7FFFFFFF) OR
	S.[Start Day past 1900] BETWEEN @start AND @stop OR
	ISNULL(S.[Stop Day past 1900], 0x7FFFFFFF) BETWEEN @start AND @stop
)
ORDER BY S.[Employee], S.[Start Day past 1900]
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spEmployeeCompensationList2'
GO
ALTER PROC dbo.spEmployeeCompensationList2
	@employees_batch_id int,
	@expense_accounts_batch_id int,
	@period_id int,
	@start_day int,
	@stop_day int,
	@hidden bit OUT
AS
DECLARE @authorized bit, @seconds int, @m int, @b int

SET NOCOUNT ON

EXEC dbo.spPermissionInsureForCurrentUserOnPeople @employees_batch_id, 1024, 1, @hidden out

SELECT @seconds = Seconds, @m = FTEM, @b = FTEB FROM Period WHERE PeriodID=@period_id

CREATE TABLE #EC012808(
	EmployeeID int NOT NULL PRIMARY KEY,
	LastStart int NULL,
	LastBasePay money NULL,
	PayHistory varchar(450) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL DEFAULT(''),
	ExpenseHistory varchar(450) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL DEFAULT(''),
	ExpenseTotal money NOT NULL DEFAULT(0),
	LastCompensationID int NULL,
	LastPositionID int NULL,
	TempExpenseItemID int NULL,
	TempStart int NULL,
	TempPayOrExpense varchar(450) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL DEFAULT('')
)

INSERT #EC012808(EmployeeID) SELECT [ID] FROM TempX WHERE BatchID=@employees_batch_id

UPDATE E SET LastCompensationID = (
	SELECT TOP 1 EC.CompensationID FROM EmployeeCompensation EC WHERE EC.EmployeeID=E.EmployeeID ORDER BY EC.[Start Day past 1900] DESC
) FROM #EC012808 E

UPDATE E SET LastPositionID=EC.PositionID,
LastStart=EC.[Start Day past 1900],
LastBasePay=dbo.fnConvertPay2(EC.[Base Pay], POS.FTE40, EC.[Employee Seconds per Week], P.FTEM, P.FTEB, P.Seconds, @m, @b, @seconds),
TempStart=EC.[Start Day past 1900]
FROM #EC012808 E
INNER JOIN EmployeeCompensation EC ON E.LastCompensationID=EC.CompensationID
INNER JOIN Period P ON EC.PeriodID = P.PeriodID
INNER JOIN vwPosition POS ON EC.PositionID = POS.PositionID

DECLARE @results int
SET @results = 1
WHILE @results > 0
BEGIN
	UPDATE E SET TempPayOrExpense = '', LastCompensationID = (
		SELECT TOP 1 EC.CompensationID FROM EmployeeCompensation EC
		WHERE EC.EmployeeID=E.EmployeeID AND (E.TempStart IS NULL OR EC.[Start Day past 1900] < E.TempStart)
		ORDER BY EC.[Start Day past 1900] DESC
	) FROM #EC012808 E

	UPDATE E SET TempStart=EC.[Start Day past 1900],
	TempPayOrExpense = CAST(CAST(
		dbo.fnConvertPay2(EC.[Base Pay], POS.FTE40, EC.[Employee Seconds per Week], P.FTEM, P.FTEB, P.Seconds, @m, @b, @seconds)
	AS numeric(9,2))  AS varchar(50)) + '  ' + CAST(dbo.GetDateFromDaysPast1900(EC.[Start Day past 1900]) AS varchar(11))
	FROM #EC012808 E INNER JOIN EmployeeCompensation EC ON E.LastCompensationID=EC.CompensationID
	INNER JOIN Period P ON EC.PeriodID = P.PeriodID
	INNER JOIN vwPosition POS ON EC.PositionID = POS.PositionID

	UPDATE #EC012808 SET PayHistory = SUBSTRING(PayHistory + CASE WHEN PayHistory='' THEN '' ELSE ',' END + TempPayOrExpense, 1, 450) WHERE TempPayOrExpense <> ''
	SET @results = @@ROWCOUNT
END

UPDATE #EC012808 SET TempStart=NULL
SET @results = 1
WHILE @results > 0
BEGIN
	UPDATE E SET TempPayOrExpense = '',
		TempExpenseItemID = (
		SELECT TOP 1 EE.ItemID FROM EmployeeExpense EE
		WHERE EE.EmployeeID=E.EmployeeID AND
		EE.AccountID IN (SELECT X.[ID] FROM TempX X WHERE X.BatchID=@expense_accounts_batch_id) AND
		(
			EE.[Day past 1900] BETWEEN @start_day AND @stop_day AND (
			(E.TempStart IS NULL) OR
			(EE.[Day past 1900] < E.TempStart) OR
			(EE.[Day past 1900] = E.TempStart AND EE.ItemID < E.TempExpenseItemID) )
		)
		ORDER BY EE.[Day past 1900] DESC, EE.ItemID DESC
	) FROM #EC012808 E

	UPDATE E SET TempStart=EE.[Day past 1900], ExpenseTotal=ExpenseTotal - CASE WHEN EE.Amount < 0 THEN EE.Amount ELSE 0 END,
	TempPayOrExpense = CASE
		WHEN EE.Amount < 0 THEN CAST(CAST((0 - EE.Amount) AS numeric(9,2)) as varchar(50)) 
		ELSE CAST(CAST(EE.Amount AS numeric(9,2)) as varchar(50)) + ' Credit'
	END + ' ' + CAST(dbo.GetDateFromDaysPast1900(EE.[Day past 1900]) AS varchar(11))
	FROM #EC012808 E INNER JOIN EmployeeExpense EE ON E.TempExpenseItemID=EE.ItemID
	
	UPDATE #EC012808 SET ExpenseHistory = SUBSTRING(ExpenseHistory + CASE WHEN ExpenseHistory='' THEN '' ELSE ',' END + TempPayOrExpense, 1, 450) WHERE TempPayOrExpense <> ''
	SET @results = @@ROWCOUNT
END

DELETE TempX WHERE BatchID=@employees_batch_id OR BatchID=@expense_accounts_batch_id

SELECT E.EmployeeID, Employee=P.[List As],
[Last Job Title]=ISNULL(POS.[Job Title],''),
[Last Start]=dbo.GetDateFromDaysPast1900(E.LastStart),
[Seniority Begins]=dbo.GetDateFromDaysPast1900(EMP.[Seniority Begins Day past 1900]),
E.LastBasePay,
E.ExpenseTotal,
Total = E.LastBasePay + E.ExpenseTotal,
E.PayHistory,
E.ExpenseHistory,
Manager=ISNULL(M.[List As],'<Unspecified>'),
D.Department,
Location=L.[List As],
V.Division,
S.Shift,
EMP.ManagerID,EMP.DepartmentID,EMP.DivisionID,EMP.LocationID,EMP.LocationID,EMP.ShiftID
FROM #EC012808 E
INNER JOIN dbo.vwPersonListAs P ON E.EmployeeID=P.PersonID
INNER JOIN Employee EMP ON EMP.EmployeeID=P.PersonID
INNER JOIN Department D ON EMP.DepartmentID=D.DepartmentID
INNER JOIN Division V ON EMP.DivisionID=V.DivisionID
INNER JOIN Shift S ON EMP.ShiftID=S.ShiftID
INNER JOIN Location L ON EMP.LocationID=L.LocationID
LEFT JOIN dbo.vwPersonListAs M ON EMP.ManagerID=M.PersonID
LEFT JOIN Position POS ON E.LastPositionID=POS.PositionID
ORDER BY P.[List As]
GO
GRANT EXEC ON dbo.spEmployeeDependentSelectPersonal TO public
GRANT EXEC ON dbo.spEmployeeDependentUpdatePersonal TO public
GRANT EXEC ON dbo.spEmployeeCompensationList2 TO public
GO
ALTER PROC dbo.[spEmployeeDependentList]
	@employee_id int
AS
DECLARE @authorized bit

SET NOCOUNT ON

EXEC dbo.spPermissionInsureForCurrentUserOnPerson @employee_id, 134217728, 1, @authorized out

IF @authorized = 1 
SELECT L.ContactID, L.PersonID, V.[List As], V.[Full Name], P.[Work Phone],
P.[Home Phone], P.[Mobile Phone], L.Relationship, DOB = dbo.GetDateFromDaysPast1900(X.[DOB Day past 1900]), Age = CAST(
	CASE WHEN X.[DOB Day past 1900] IS NULL THEN 0 ELSE DATEDIFF(month,X.[DOB Day past 1900],GETDATE()) / 12.00 END
AS numeric(9,2))
FROM EmployeeDependent L
INNER JOIN Person P ON L.EmployeeID = @employee_id AND L.PersonID = P.PersonID
INNER JOIN vwPersonCalculated V ON P.PersonID = V.PersonID
INNER JOIN PersonX X ON P.PersonID=X.PersonID
GO
CREATE PROC dbo.spEmployeeCountEEOBasis
	@start int,
	@stop int,
	@location_id int
AS
SET NOCOUNT ON

DECLARE @batch_id int

SELECT @batch_id= RAND() * 2147483647
INSERT TempX(BatchID,[ID]) SELECT @batch_id,EmployeeID FROM Employee WHERE (@location_id IS NULL) OR (LocationID=@location_id)
CREATE TABLE #EC(EmployeeID int, [Start] int, [Stop] int NULL, FirstPositionID int NULL, LastPositionID int NULL, CompensationID int)
INSERT #EC
EXEC dbo.spTurnoverItemize @batch_id
DELETE TempX WHERE BatchID=@batch_id

-- Only count each employee once
DECLARE @r int
SET @r = 1
WHILE @r > 0
BEGIN
	DELETE #EC FROM #EC WHERE EXISTS(
		SELECT * FROM #EC EC2 WHERE #EC.EmployeeID=EC2.EmployeeID AND EC2.[Start] > #EC.[Start]	
	)
	SET @r=@@ROWCOUNT
END

INSERT #EmployeeEEO(EmployeeID, LocationID, Male, [Column], PositionID, CompensationID, EEO4PayRange)
SELECT C.EmployeeID, E.LocationID, G.Male, R.[Report Column], C.LastPositionID, EC.CompensationID,
CASE
	WHEN EC.[Annualized Pay] IS NULL THEN 0
	WHEN EC.[Annualized Pay] < 16000 THEN 0
	WHEN EC.[Annualized Pay] < 20000 THEN 1
	WHEN EC.[Annualized Pay] < 25000 THEN 2
	WHEN EC.[Annualized Pay] < 33000 THEN 3
	WHEN EC.[Annualized Pay] < 43000 THEN 4
	WHEN EC.[Annualized Pay] < 55000 THEN 5
	WHEN EC.[Annualized Pay] < 70000 THEN 6
	ELSE 7
END

FROM #EC C 
INNER JOIN Person G ON C.EmployeeID=G.PersonID
INNER JOIN PersonX X ON G.PersonID=X.PersonID
INNER JOIN Employee E ON E.EmployeeID=G.PersonID AND (@start<=C.Stop OR C.Stop IS NULL) AND @stop>=C.Start
INNER JOIN Race R ON X.RaceID=R.RaceID
LEFT JOIN dbo.vwEmployeeCompensation EC ON EC.CompensationID = C.CompensationID

UPDATE EEO SET Row = JC.[Report Row]
FROM #EmployeeEEO EEO
INNER JOIN Position POS ON POS.PositionID=EEO.PositionID
INNER JOIN JobCategory JC ON POS.CategoryID=JC.CategoryID
GO
IF OBJECT_id('dbo.spEmployeeCountEEO2') IS NOT NULL DROP PROC dbo.spEmployeeCountEEO2
GO
CREATE PROC dbo.spEmployeeCountEEO2
	@start int,
	@stop int,
	@location_id int
AS
SET NOCOUNT ON

CREATE TABLE #EmployeeEEO(EmployeeID int PRIMARY KEY, LocationID int, [Column] int, Male bit, Row int, PositionID int, EEO4PayRange int, CompensationID int)
EXEC dbo.spEmployeeCountEEOBasis @start, @stop, @location_id

CREATE TABLE #Result(Male bit,Row int, [Column] int, MC varchar(10) COLLATE SQL_Latin1_General_CP1_CI_AS, [Count] int)
DECLARE @r int, @c int
SELECT @r=0

WHILE @r<12
BEGIN
	SET @c=0
	WHILE @c<7
	BEGIN
		INSERT #Result(Male,Row,[Column],MC,[Count]) VALUES(0,@r,@c,CAST(@c AS varchar(10))+'.F',0)
		INSERT #Result(Male,Row,[Column],MC,[Count]) VALUES(1,@r,@c,CAST(@c AS varchar(10))+'.M',0)
		SET @c=@c+1
	END

	INSERT #Result(Male,Row,[Column],MC,[Count]) VALUES(NULL,@r,100,'T',0)

	SET @r=@r+1
END


-- Updates #Result with the counts of all active employees for a given category/race/gender
UPDATE R SET [Count] = ISNULL((
	SELECT COUNT(*) FROM #EmployeeEEO E WHERE R.[Column] = E.[Column] AND R.Row = E.Row AND R.Male = E.Male
	AND ((@location_id IS NOT NULL AND E.LocationID = @location_id) OR (@location_id IS NULL))
),0) FROM #Result R

-- Previous total
UPDATE R SET [Count] = ISNULL((
	SELECT E.[Previous Count] FROM vwLocationRaceEEO E WHERE R.[Column] = E.[RaceID] AND R.Male = E.Male
	AND ((@location_id IS NOT NULL AND E.LocationID = @location_id) OR ((@location_id IS NULL) AND E.LocationID IS NULL))
),0) FROM #Result R WHERE R.[Row] = 11

-- Updates #Result with column totals across each row
UPDATE R SET [Count] = ISNULL((
	SELECT COUNT(*) FROM #EmployeeEEO E WHERE R.Row = E.Row
	AND ((@location_id IS NOT NULL AND E.LocationID = @location_id) OR (@location_id IS NULL))
),0) FROM #Result R WHERE R.[Column]=100

-- Returns #Result
SELECT [Row], [Column] = MC, [Count] FROM #Result WHERE [Row] < 10
UNION
SELECT 10, [Column] = MC, SUM([Count]) FROM #Result GROUP BY MC
UNION
SELECT 11, [Column] = MC, [Count] FROM #Result WHERE [Row] = 11 -- Previous total
ORDER BY [Row], MC
GO
IF OBJECT_ID('dbo.spEmployeeCountEEO4') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spEmployeeCountEEO4 AS SELECT A=0'
GO
ALTER PROC dbo.spEmployeeCountEEO4
	@start int,
	@stop int,
	@location_id int,
	@full_time_fte numeric(9,4),
	@eeo4_function int = NULL, @eeo4_function_all bit = 1
AS
SET NOCOUNT ON

CREATE TABLE #EmployeeEEO(EmployeeID int PRIMARY KEY, LocationID int, [Column] int, Male bit, Row int, PositionID int, EEO4PayRange int, CompensationID int)
CREATE INDEX TempEmployeeEEO ON #EmployeeEEO(EmployeeID)

EXEC dbo.spEmployeeCountEEOBasis @start, @stop, @location_id

CREATE TABLE #Result([Full Time] int,Male bit, Row int, EEO4PayRange int, [Column] int, MC varchar(10) COLLATE SQL_Latin1_General_CP1_CI_AS, [Count] int)
DECLARE @r int, @c int, @s int
SELECT @r=0

WHILE @r<8
BEGIN
	SET @s=0
	WHILE @s < 8
	BEGIN
		SET @c=0
		WHILE @c<5
		BEGIN
			INSERT #Result([Full Time], Male,Row,EEO4PayRange,[Column],MC,[Count]) VALUES(1,0,@r,@s,@c,'F' + CAST(@c AS varchar(10)),0)
			INSERT #Result([Full Time], Male,Row,EEO4PayRange,[Column],MC,[Count]) VALUES(1,1,@r,@s,@c,'_M' + CAST(@c AS varchar(10)),0)
			SET @c=@c+1
		END
		
		INSERT #Result([Full Time], Male,Row,EEO4PayRange,[Column],MC,[Count]) VALUES(1,NULL,@r,@s,100,' T',0)
		SET @s=@s+1
	END

	SET @c=0
	WHILE @c<5
	BEGIN
		INSERT #Result([Full Time], Male,Row,EEO4PayRange,[Column],MC,[Count]) VALUES(0,0,@r,-1,@c,'F' + CAST(@c AS varchar(10)),0)
		INSERT #Result([Full Time], Male,Row,EEO4PayRange,[Column],MC,[Count]) VALUES(0,1,@r,-1,@c,'_M' + CAST(@c AS varchar(10)),0)

		INSERT #Result([Full Time], Male,Row,EEO4PayRange,[Column],MC,[Count]) VALUES(-1,0,@r,-1,@c,'F' + CAST(@c AS varchar(10)),0)
		INSERT #Result([Full Time], Male,Row,EEO4PayRange,[Column],MC,[Count]) VALUES(-1,1,@r,-1,@c,'_M' + CAST(@c AS varchar(10)),0)
		SET @c=@c+1
	END

	INSERT #Result([Full Time], Male,Row,EEO4PayRange,[Column],MC,[Count]) VALUES(0,NULL,@r,-1,100,' T',0)
	INSERT #Result([Full Time], Male,Row,EEO4PayRange,[Column],MC,[Count]) VALUES(-1,NULL,@r,-1,100,' T',0)
	SET @r=@r+1
END


-- Updates #Result with the counts of all active employees for a given category/pay range/race/gender
UPDATE R SET [Count] = ISNULL((
	SELECT COUNT(*) FROM #EmployeeEEO E
	INNER JOIN Employee ON E.EmployeeID = Employee.EmployeeID AND 
	(
		@eeo4_function_all = 1 OR 
		OrgUserField1 IS NULL AND @eeo4_function IS NULL OR
		OrgUserField1 = @eeo4_function
	)
	LEFT JOIN dbo.vwEmployeeCompensation EC ON E.CompensationID = EC.CompensationID WHERE
	R.[Column] = E.[Column] AND R.Row = E.Row AND R.Male = E.Male AND
	(
		(R.[Full Time] = 1 AND (EC.FTE IS NULL OR EC.FTE >= @full_time_fte) AND R.EEO4PayRange = E.EEO4PayRange) OR
		(R.[Full Time] = 0 AND EC.FTE < @full_time_fte) OR 
		(R.[Full Time] = -1 AND ((EC.CompensationID IS NULL AND Employee.[Seniority Begins Day past 1900] BETWEEN @start AND @stop) OR (EC.[Start Day past 1900] BETWEEN @start AND @stop AND (EC.[Start Event Flags] & 1) = 1) AND EC.FTE >= @full_time_fte))
	) AND
	((@location_id IS NOT NULL AND E.LocationID = @location_id) OR (@location_id IS NULL))
),0) FROM #Result R

-- Updates #Result with column totals across each row
UPDATE R SET [Count] = ISNULL((
	SELECT COUNT(*) FROM #EmployeeEEO E
	INNER JOIN Employee ON E.EmployeeID = Employee.EmployeeID AND 
	(
		@eeo4_function_all = 1 OR 
		OrgUserField1 IS NULL AND @eeo4_function IS NULL OR
		OrgUserField1 = @eeo4_function
	)
	LEFT JOIN dbo.vwEmployeeCompensation EC ON E.CompensationID = EC.CompensationID WHERE
	R.Row = E.Row AND
	(
		(R.[Full Time] = 1 AND (EC.FTE IS NULL OR EC.FTE >= @full_time_fte) AND R.EEO4PayRange = E.EEO4PayRange) OR
		(R.[Full Time] = 0 AND EC.FTE < @full_time_fte) OR 
		(R.[Full Time] = -1 AND ((EC.CompensationID IS NULL AND Employee.[Seniority Begins Day past 1900] BETWEEN @start AND @stop) OR (EC.[Start Day past 1900] BETWEEN @start AND @stop AND (EC.[Start Event Flags] & 1) = 1) AND EC.FTE >= @full_time_fte))
	) AND
	((@location_id IS NOT NULL AND E.LocationID = @location_id) OR (@location_id IS NULL))
),0) FROM #Result R WHERE R.[Column]=100

-- Returns #Result
SELECT [Full Time], [Row], SR=EEO4PayRange, [Column] = MC, [Count], [Cell]=
CAST([Full Time] AS varchar(10)) + CAST([Row] AS varchar(10)) + CAST(EEO4PayRange AS varchar(10)) + MC
FROM #Result

UNION ALL

SELECT [Full Time], 11, -1, [Column] = MC, SUM([Count]), [Cell] =
CAST([Full Time] AS varchar(10)) + 'TOT' + MC
FROM #Result GROUP BY [Full Time], MC

ORDER BY [Full Time] DESC, [Row], EEO4PayRange, MC
GO
CREATE PROC dbo.spEmployeeCountEEOList
	@start int,
	@stop int,
	@location_id int
AS
SET NOCOUNT ON

CREATE TABLE #EmployeeEEO(EmployeeID int PRIMARY KEY, LocationID int, [Column] int, Male bit, Row int, PositionID int, EEO4PayRange int, CompensationID int)
EXEC dbo.spEmployeeCountEEOBasis @start, @stop, @location_id

SELECT [Job Category]=ISNULL(C.Category,'Unspecified'), [Gender Race]=CASE WHEN EEO.Male=1 THEN 'Male ' ELSE 'Female ' END + ISNULL(R.Race,'Unspecified Race'),
Employee=P.[List As], [Job Title] = ISNULL(POS.[Job Title], '')
FROM #EmployeeEEO EEO
INNER JOIN dbo.vwPersonListAs P ON EEO.EmployeeID=P.PersonID
LEFT JOIN Position POS ON EEO.PositionID=POS.PositionID
LEFT JOIN EEOJobCategory C ON EEO.Row=C.EEOReportRow
LEFT JOIN EEORace R ON EEO.[Column]=R.EEOReportColumn
ORDER BY EEO.Row, EEO.Male DESC, EEO.[Column]
GO
IF OBJECT_id('dbo.spEmployeeLeaveCalcHourlyAccrual') IS NULL 
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEmployeeLeaveCalcHourlyAccrual AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spEmployeeLeaveCalcHourlyAccrual TO public'
END
GO
ALTER PROC dbo.spEmployeeLeaveCalcHourlyAccrual
	@start_day int,
	@stop_day int,
	@batch_id int = NULL,
	@paid_leave bit = 1, -- depricated v128
	@max_seconds int = 0x7FFFFFFF,
	@flags int = NULL, -- added v128: 1=paid_leave 2=include_holidays
	@max_credit int = 0x7FFFFFFF
AS
DECLARE @start datetime, @stop datetime, @note varchar(50), @include_holidays bit

IF @flags IS NULL SET @include_holidays = 1
ELSE SELECT @paid_leave = @flags & 1, @include_holidays = @flags & 2

SET NOCOUNT ON

SELECT @start=dbo.GetDateFromDaysPast1900(@start_day), @stop=dbo.GetDateFromDaysPast1900(@stop_day),@note=' worked ' + CAST(@start AS varchar(6)) + ' to ' + CAST(@stop AS varchar(6)) + ' x '

IF @batch_id IS NULL
BEGIN
	SET @batch_id = RAND() * 2147483647
	INSERT TempX(BatchID,[ID]) SELECT @batch_id, EmployeeID FROM Employee WHERE [Active Employee] = 1
END

EXEC dbo.spPermissionGetOnPeopleForCurrentUser2 @batch_id, 262144
DELETE TempX WHERE BatchID=@batch_id AND (X&1)=0
IF @@ROWCOUNT > 0
BEGIN
	RAISERROR('You lack write permission on some of the employees'' timecards. Ask an administrator to grant you read permissions on everyone''s timecards or select a different group of employees.', 16, 1)
	RETURN
END

-- Calculate OT
CREATE TABLE #EMPLOYEE_TIME_ROUNDED(
	TempItemID int NOT NULL IDENTITY(1,1) PRIMARY KEY,
	EmployeeID int NOT NULL,
	OriginalTypeID int NOT NULL, 
	CalculatedTypeID int NOT NULL,
	[In Day past 1900] int NOT NULL, 
	[OT Eligible] bit NOT NULL,
	[OT Disable] bit NOT NULL,
	[Pay Rate] money NOT NULL,
	[Fixed Pay] money NOT NULL DEFAULT(0),
	[Fixed Items] int DEFAULT(0),
	Regular bit DEFAULT(0),
	[In Seconds] int NOT NULL,
	[Out Seconds] int NOT NULL,
	TimeSchemaID int NOT NULL,
	ShiftDiffItemID int NULL,
	TempShiftDiffSeconds int NULL,
	TempShiftDiffItemID int NULL,
	OriginalTimeItemID int NULL,
	CopyTimeItemID int NULL,
	[Time Seconds] int NOT NULL DEFAULT(0),
	[Holiday Seconds] int NOT NULL DEFAULT(0),
	[OT Seconds] int NOT NULL DEFAULT(0),
	Flags int NOT NULL DEFAULT(0),
	[Actual In] datetime NULL,
	[Actual Out] datetime NULL,
	[Base Seconds] int NOT NULL DEFAULT(0),
	[X2 Seconds] int NOT NULL DEFAULT(0)
)

DECLARE @authorized bit, @pending_type_id int, @denied_type_id int
EXEC dbo.spEmployeeTimeRoundAndCalcOT @batch_id, 0, @start_day, @stop_day, null, null, @authorized OUT, @pending_type_id OUT, @denied_type_id OUT

-- Calculates seconds of accrual per hour time worked
SELECT EmployeeID=P.PersonID, LT.TypeID, Effective=@stop, Worked = 
CAST(
	ISNULL((
		SELECT SUM([Out Seconds] - [In Seconds]) FROM 
		#EMPLOYEE_TIME_ROUNDED T
		INNER JOIN dbo.vwTimeType TT ON T.CalculatedTypeID=TT.TypeID AND 
		(TT.Holiday = 0 OR @include_holidays=1) AND
		(TT.[Disable Non-Exempt Leave Credit] = 0) AND
		-- (T.StatusID & 1) = 1 AND      pending and denied won't join to timetype
		T.EmployeeID=E.EmployeeID AND T.[In Day past 1900] BETWEEN @start_day AND @stop_day
		
	), 0) +
	CASE WHEN @paid_leave=0 THEN 0 ELSE ISNULL((
		SELECT SUM(A.Seconds) FROM vwEmployeeLeaveUsedItemApproved A
		INNER JOIN LeaveType T ON A.TypeID=T.TypeID AND A.EmployeeID=E.EmployeeID AND T.Paid=1 AND A.[Day past 1900] BETWEEN @start_day AND @stop_day
	), 0) END
 AS numeric(21,4))
, Rate = CAST(ISNULL((
	SELECT CASE WHEN R.PeriodID=281088 THEN 1.0 ELSE 0.001 END * R.[Effective Seconds] FROM dbo.vwEmployeeLeavePlanLeaveRate R WHERE
		X.BatchID=@batch_id AND R.EmployeeID=X.[ID] AND R.TypeID = LT.TypeID AND R.PeriodID IN (281088, 279040) AND R.TypeID=LT.TypeID AND 
		@stop_day >= R.[Start Day past 1900] AND (R.[Stop Day past 1900] IS NULL OR @stop_day <= R.[Stop Day past 1900]) AND
		DATEDIFF(m,R.[Seniority Begins],@stop) BETWEEN R.[Start Month] AND R.[Stop Month]
), 0) AS numeric(21,8)), 
[Pending Time] = ISNULL((
	SELECT SUM(Seconds) FROM EmployeeTime T WHERE T.StatusID = 8 AND T.EmployeeID=E.EmployeeID AND DATEDIFF(d,0,T.[In]) BETWEEN @start_day AND @stop_day
), 0),
[Pending Leave] = CASE WHEN @paid_leave=0 THEN 0 ELSE ISNULL((
	SELECT SUM(PL.Seconds) FROM vwEmployeeLeaveUsedItem PL
	INNER JOIN LeaveType T ON PL.Status=1 AND PL.TypeID=T.TypeID AND PL.EmployeeID=E.EmployeeID AND T.Paid=1 AND PL.[Day past 1900] BETWEEN @start_day AND @stop_day
), 0) END,
Months = DATEDIFF(m,DATEADD(d,0,E.[Seniority Begins Day past 1900]),@stop),
[Plan] = ISNULL((
	SELECT R.[Plan] FROM dbo.vwEmployeeLeavePlanLeaveRate R WHERE
		X.BatchID=@batch_id AND R.EmployeeID=X.[ID] AND R.TypeID = LT.TypeID AND R.PeriodID IN (281088, 279040) AND R.TypeID=LT.TypeID AND 
		@stop_day >= R.[Start Day past 1900] AND (R.[Stop Day past 1900] IS NULL OR @stop_day <= R.[Stop Day past 1900]) AND
		DATEDIFF(m,R.[Seniority Begins],@stop) BETWEEN R.[Start Month] AND R.[Stop Month]
), 0)



INTO #RAccrual0629
FROM TempX X
INNER JOIN Employee E ON X.BatchID=@batch_id AND X.[ID]=E.EmployeeID
INNER JOIN dbo.vwPersonListAs P ON E.EmployeeID=P.PersonID
CROSS JOIN LeaveType LT
ORDER BY P.[List As], LT.[Order]

DELETE TempX WHERE BatchID=@batch_id OR DATEDIFF(hh, Created, GETDATE())>1

DECLARE @message varchar(4000), @message_pending_time varchar(2000), @message_pending_leave varchar(2000), @employee varchar(400)
SELECT @message_pending_time = '', @message_pending_leave = ''
DECLARE @pending_time int, @pending_leave int

DECLARE p_cursor CURSOR LOCAL FORWARD_ONLY STATIC FOR SELECT MIN(P.[Full Name]), SUM(A.[Pending Time]), SUM(A.[Pending Leave]) FROM #RAccrual0629 A
INNER JOIN dbo.vwPersonCalculated P ON A.EmployeeID=P.PersonID AND (A.[Pending Time] > 0 OR A.[Pending Leave] > 0)
GROUP BY A.EmployeeID, P.[List As]
ORDER BY P.[List As]

OPEN p_cursor 
FETCH p_cursor INTO @employee, @pending_time, @pending_leave
WHILE @@FETCH_STATUS=0
BEGIN
	IF @pending_time > 0 SET @message_pending_time = SUBSTRING(@message_pending_time + CASE WHEN @message_pending_time = '' THEN 'Pending time needs to be approved\denied for ' ELSE ',' END + @employee, 1, 2000)
	IF @pending_leave > 0 SET @message_pending_leave = SUBSTRING(@message_pending_leave + CASE WHEN @message_pending_leave = '' THEN 'Pending leave needs to be approved\denied for ' ELSE ',' END + @employee, 1, 2000)
	FETCH p_cursor INTO @employee, @pending_time, @pending_leave
END

CLOSE p_cursor
DEALLOCATE p_cursor

SET @message = @message_pending_time + CASE WHEN @message_pending_leave='' THEN '' ELSE '. ' END
SET @message = @message + @message_pending_leave + CASE WHEN @message_pending_leave='' THEN '' ELSE '.' END

IF @message != '' RAISERROR(@message, 16, 1)
ELSE
BEGIN
	UPDATE #RAccrual0629 SET Worked = 0.00027777777 * CASE WHEN Worked < @max_seconds THEN Worked ELSE @max_seconds END
	
	SELECT EmployeeID,TypeID,Effective,Seconds=CAST((CASE WHEN Worked*Rate > @max_credit THEN @max_credit ELSE Worked*Rate END) AS int),Note=CAST(CAST(Worked AS numeric(19,4)) AS varchar(50)) + @note + CAST(CAST(Rate / 3.6 AS numeric(19,4)) AS varchar(50)) + '@' + CAST(Months AS varchar(50)) + 'months ' + [Plan], PPE = Effective 
	INTO #Credits
	FROM #RAccrual0629 WHERE Worked<>0 AND Rate<>0
	
	-- Dedups credits
	DELETE C
	FROM #Credits C
	INNER JOIN dbo.vwEmployeeLeaveEarned E ON C.EmployeeID=E.EmployeeID AND C.Effective=E.[Day past 1900] AND C.TypeID=E.TypeID AND C.Seconds=E.Seconds AND SUBSTRING(C.Note,1,3) = SUBSTRING(E.Note,1,3)

	SELECT * FROM #Credits
END
GO
CREATE PROC dbo.spLeaveRateCopy
	@source_plan_id int,
	@target_plan_id int
AS
DECLARE @fte numeric(21,12)

SELECT @fte = FTE FROM LeavePlan WHERE PlanID = @source_plan_id
SELECT @fte = FTE / @fte FROM LeavePlan WHERE PlanID = @target_plan_id

DELETE LeaveRate WHERE PlanID = @target_plan_id
DELETE LeaveLimit WHERE PlanID = @target_plan_id

INSERT LeaveRate(PlanID, TypeID, [Start Month], [Stop Month], Seconds, PeriodID, [Ineligible Months], Flags, LimitPeriodID, [Limit Month], [Limit Day], [Limit Max Seconds])
SELECT @target_plan_id, TypeID, [Start Month], [Stop Month], Seconds * @fte, PeriodID, [Ineligible Months], Flags, LimitPeriodID, [Limit Month], [Limit Day], [Limit Max Seconds]
FROM LeaveRate WHERE PlanID = @source_plan_id

INSERT LeaveLimit(PlanID, [Enable After Months], TypeID, PeriodID, [Month], [Day], [Max Seconds])
SELECT @target_plan_id, [Enable After Months], TypeID, PeriodID, [Month], [Day], [Max Seconds] * @fte FROM LeaveLimit WHERE PlanID=@source_plan_id
GO
CREATE PROC dbo.spEmployeeTimeCountPending
	@batch_id int,
	@before int,
	@authorized bit = 0 out,
	@count int out,
	@first_pending_date datetime = NULL out
AS
EXEC dbo.spPermissionGetOnPeopleForCurrentUser2 @batch_id, 262144
DELETE TempX WHERE BatchID=@batch_id AND (X & 1)=0
SELECT @authorized = CASE WHEN @@ROWCOUNT=0 THEN 1 ELSE 0 END

SELECT @count = 0
SELECT @count = COUNT(DISTINCT T.EmployeeID)
FROM EmployeeTime T
INNER JOIN TempX X ON X.BatchID=@batch_id AND T.EmployeeID=X.[ID] AND T.StatusID=8 AND T.Seconds > 0 AND T.[IN] < DATEADD(d,1,@before)

SELECT @first_pending_date = MIN(T.[In])
FROM EmployeeTime T
INNER JOIN TempX X ON X.BatchID=@batch_id AND T.EmployeeID=X.[ID] AND T.StatusID=8 AND T.Seconds > 0 AND T.[IN] < DATEADD(d,1,@before)

DELETE TempX WHERE BatchID=@batch_id OR DATEDIFF(hour,0,GETDATE()) > 1
GO
GRANT EXEC ON dbo.spEmployeeTimeCountPending TO public
GRANT EXEC ON dbo.spLeaveRateCopy TO public
GO
IF OBJECT_id('dbo.spEmployeeLeaveUsedGetLastLeaveID') IS NOT NULL DROP PROC dbo.spEmployeeLeaveUsedGetLastLeaveID
GO
CREATE PROC dbo.spEmployeeLeaveUsedGetLastLeaveID
	@leave_id int out
AS
SELECT @leave_id = ISNULL(MAX(LeaveID), -2147483648) FROM EmployeeLeaveUsed
GO
GRANT EXEC ON dbo.spEmployeeLeaveUsedGetLastLeaveID TO public
GO
IF OBJECT_id('dbo.spLeaveCountPendingRequests') IS NOT NULL DROP PROC dbo.spLeaveCountPendingRequests
GO
CREATE PROC dbo.spLeaveCountPendingRequests
	@batch_id int,
	@authorized bit = 0 out,
	@count int out
AS
EXEC dbo.spPermissionGetOnPeopleForCurrentUser2 @batch_id, 10002
DELETE TempX WHERE BatchID=@batch_id AND (X & 1)=0
SELECT @authorized = CASE WHEN @@ROWCOUNT=0 THEN 1 ELSE 0 END

SELECT @count = 0
SELECT @count = COUNT(*)
FROM EmployeeLeaveUsed U
INNER JOIN TempX X ON X.BatchID=@batch_id AND U.EmployeeID=X.[ID] AND U.Status=1

DELETE TempX WHERE BatchID=@batch_id OR DATEDIFF(hour,0,GETDATE()) > 1
GO
GRANT EXEC ON dbo.spLeaveCountPendingRequests TO public
GO
IF OBJECT_ID('dbo.spEmployeeLeaveListFillPreviousTotals') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spEmployeeLeaveListFillPreviousTotals AS SELECT A=0'
GO
ALTER PROC dbo.spEmployeeLeaveListFillPreviousTotals @batch_id int, @type_or_mask int, @type_and_mask int, @start_day int
AS
BEGIN
		SELECT L.EmployeeID, L.TypeID, [Day] = MAX(L.[Day past 1900])
		INTO #ET
		FROM EmployeeLeaveUnused L
		INNER JOIN TempX T ON T.BatchID = @batch_id AND T.[ID] = L.EmployeeID AND L.[Day past 1900] < @start_day
			AND (@type_or_mask = 0x7FFFFFFF OR (@type_or_mask & L.TypeID) !=0 OR (@type_and_mask != 0 AND @type_and_mask = L.TypeID))
		GROUP BY EmployeeID, TypeID

		CREATE INDEX IX_ET_20100310_TypeID ON #ET(TypeID)
		CREATE INDEX IX_ET_20100310_EmployeeIDTypeIDDay ON #ET(EmployeeID,TypeID,[Day])

		INSERT #List0305(
			EmployeeID,
			[ID],
			Attributes,
			Seconds,
			[Earned Seconds],
			[Used Seconds],
			[Type Mask],
			[Temp Type Mask],
			[Types],
			[Start Day past 1900],
			[Stop Day past 1900],
			Note,
			[Status Text],
			Requested,
			[Accumulated Seconds],
			[Available Seconds],
			Effective,
			TypeID,
			LeaveID,
			[Preapproved Employee],
			[Preapproved Date],
			ReasonID,
			Reason,
			[Permission Mask],
			[PPE Start Day past 1900],
			[PPE Stop Day past 1900],
			UsedLeaveID,
			[First Day Used],
			[Last Day Used],
			[Used Period Seconds]
		)
		
		SELECT EmployeeID = #ET.EmployeeID,
		[ID] = 0,
		Attributes = 4141,
		L.Unused,
		[Earned Seconds] = L.Unused,
		[Used Seconds] = 0,
		[Type Mask] = #ET.TypeID,
		[Temp Type Mask] = 0,
		[Types] = CAST(LT.Type AS varchar(400)),
		[Start Day past 1900] = @start_day - 1,
		[Stop Day past 1900] = @start_day - 1,
		Note = 'Previously accumulated ' + CAST(LT.Type AS varchar(400)),
		'',
		NULL,
		L.Unused,
		0, -- Available Seconds
		Effective = DATEADD(d, 0, @start_day - 1),
		L.TypeID,
		0,
		'',
		NULL,
		NULL,
		'',
		1,
		@start_day - 1,
		@start_day - 1,
		NULL,
		NULL,
		NULL,
		[Used Period Seconds] = 0
		FROM #ET
		INNER JOIN dbo.LeaveType LT ON #ET.TypeID = LT.TypeID
		INNER JOIN dbo.EmployeeLeaveUnused L ON #ET.EmployeeID = L.EmployeeID AND #ET.TypeID = L.TypeID AND #ET.[Day] = L.[Day past 1900] AND L.Unused <> 0
END
GO
IF OBJECT_ID('dbo.spEmployeeLeaveListFillUsedLeaves') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spEmployeeLeaveListFillUsedLeaves AS SELECT A=0'
GO
ALTER PROC dbo.spEmployeeLeaveListFillUsedLeaves
	@batch_id int,
	@created_start int, @created_stop int,
	@start_day int, @stop_day int,
	@ppe_start int, @ppe_stop int,
	@requested_start int, @requested_stop int,
	@authorized_preceeds_first_day_off bit,
	@first_authorized_start int, @first_authorized_stop int,
	@authorized_start int, @authorized_stop int,
	@type_or_mask int, @type_and_mask int,
	@status_or_mask int,
	@approval_or_mask int,
	@approval_and_mask int, 
	@approved_permissions_batch_id int, 
	@show_064_used_leave_employeeUsedItem_positive bit, 
	@show_002_earned_leave_employeeUsedItem_negative bit,
	@all_used_after_leave_id int
AS
BEGIN
DECLARE @type_bank_mask int, @bank_type_id int
SET @type_bank_mask = 0

DECLARE type_bank_cursor CURSOR LOCAL FORWARD_ONLY STATIC FOR SELECT TypeID FROM dbo.LeaveType WHERE Bank=1
OPEN type_bank_cursor

FETCH NEXT FROM type_bank_cursor INTO @bank_type_id

WHILE @@FETCH_STATUS=0
BEGIN
	SET @type_bank_mask = @type_bank_mask | @bank_type_id
	FETCH NEXT FROM type_bank_cursor INTO @bank_type_id
END

CLOSE type_bank_cursor
DEALLOCATE type_bank_cursor
	


	-- EmployeeLeaveUsedItem
	INSERT #List0305(
		EmployeeID,
		[ID],
		Attributes,
		Seconds,
		[Earned Seconds],
		[Used Seconds],
		[Type Mask],
		[Temp Type Mask],
		[Types],
		[Start Day past 1900],
		[Stop Day past 1900],
		Note,
		[Status Text],
		Requested,
		[Accumulated Seconds],
		[Available Seconds],
		Effective,
		TypeID,
		LeaveID,
		[Preapproved Employee],
		[Preapproved Date],
		ReasonID,
		Reason,
		[Permission Mask],
		[PPE Start Day past 1900],
		[PPE Stop Day past 1900],
		UsedLeaveID,
		[First Day Used],
		[Last Day Used],
		[Used Period Seconds]
	)

	-- Used leave
	SELECT U.EmployeeID, U.LeaveID, Attributes = 17 |
	CASE U.[Status]
		WHEN 1 THEN 0x200
		WHEN 2 THEN 0x400
		ELSE 0x800
	END,
	U.[Seconds], 0, U.[Seconds], 
	(U.[Advanced Type Mask] | U.[Type Mask]),
	[Temp Type Mask] = (U.[Advanced Type Mask] | U.[Type Mask]),
	Types = '',
	[Start Day past 1900] = dbo.fnLOAStartStopInt(U.[Start Day past 1900],U.[Stop Day past 1900],U.[Start Day past 1900], GETDATE()),
	[Stop Day past 1900] = dbo.fnLOAStartStopInt(U.[Start Day past 1900],U.[Stop Day past 1900],U.[Stop Day past 1900], GETDATE()),


	SUBSTRING(
	CASE U.[Status]
		WHEN 1 THEN 'Pending. '
		WHEN 4 THEN 'Denied. '
		ELSE ''
	END + 
	U.[Note], 1, 400),

	[Status Text] = dbo.fnGetStatusText(U.Status, A.[First Name], A.[Middle Name], A.[Last Name], U.[Authorized Day past 1900], LAT.[Type], D.Reason),
	dbo.GetDateFromDaysPast1900(U.[Requested Day past 1900]),
	ISNULL((
		SELECT TOP 1 Unused FROM EmployeeLeaveUnused UL WHERE U.EmployeeID = UL.EmployeeID AND UL.TypeID = ((U.[Type Mask] | U.[Advanced Type Mask]) & @type_bank_mask) AND UL.[Day past 1900] <= U.[Stop Day past 1900] ORDER BY UL.[Day past 1900] DESC
	), 0),
	0, -- #List0305 Available Seconds
	Effective =  dbo.fnLOAStartStopDate(U.[Start Day past 1900],U.[Stop Day past 1900],U.[Start Day past 1900], GETDATE()),
	0,
	U.LeaveID,
	CASE WHEN PRE.PersonID IS NULL THEN '' ELSE dbo.fnGetListAs(PRE.[First Name], PRE.[Middle Name], PRE.[Last Name], PRE.Suffix) END,
	dbo.GetDateFromDaysPast1900(U.[Preapproved Day past 1900]),
	U.[ReasonID],
	R.[Reason],
	[Permission Mask] = T.X | ((ApprovedPermissions.X & 0xF) * 16),
	U.[PPE Start Day past 1900],
	U.[PPE Stop Day past 1900],
	U.LeaveID,
	U.[First Day Used],
	U.[Last Day Used],
	[Used Period Seconds] = CASE
		WHEN @start_day = -2147483648 AND @stop_day = 2147483647 THEN U.Seconds
		ELSE ISNULL((
			SELECT SUM(I.Seconds) FROM dbo.EmployeeLeaveUsedItem I WHERE I.LeaveID = U.LeaveID AND I.[Day past 1900] BETWEEN @start_day AND @stop_day
		),0)
	END
	FROM dbo.EmployeeLeaveUsed U
	INNER JOIN dbo.TempX T ON


	T.BatchID = @batch_id AND T.[ID] = U.EmployeeID AND (
	U.LeaveID > @all_used_after_leave_id OR
	(
		(
			(@created_start = -2147483648 AND @created_stop = 2147483647) OR 
			(U.[Created Start Day past 1900] BETWEEN @created_start AND @created_stop) OR
			(U.[Created Stop Day past 1900] BETWEEN @created_start AND @created_stop) OR
			(@created_start BETWEEN U.[Created Start Day past 1900] AND U.[Created Stop Day past 1900])
		) AND
		(
			(@start_day = -2147483648 AND @stop_day = 2147483647) OR 
			(dbo.fnLOAStartStopInt(U.[Start Day past 1900],U.[Stop Day past 1900],U.[Start Day past 1900], GETDATE()) BETWEEN @start_day AND @stop_day) OR
			(dbo.fnLOAStartStopInt(U.[Start Day past 1900],U.[Stop Day past 1900],U.[Stop Day past 1900], GETDATE()) BETWEEN @start_day AND @stop_day) OR
			(@start_day BETWEEN dbo.fnLOAStartStopInt(U.[Start Day past 1900],U.[Stop Day past 1900],U.[Start Day past 1900],GETDATE()) AND dbo.fnLOAStartStopInt(U.[Start Day past 1900],U.[Stop Day past 1900],U.[Stop Day past 1900],GETDATE()))
		) AND
		(	



			(@ppe_start = -2147483648 AND @ppe_stop = 2147483647) OR 
			(U.[PPE Start Day past 1900] BETWEEN @ppe_start AND @ppe_stop) OR
			(U.[PPE Stop Day past 1900] BETWEEN @ppe_start AND @ppe_stop) OR
			(@ppe_start BETWEEN U.[PPE Start Day past 1900] AND U.[PPE Stop Day past 1900])
		) AND
		(
			(@requested_start = -2147483648 AND @requested_stop = 2147483647) OR 
			U.[Requested Day past 1900] BETWEEN @requested_start AND @requested_stop
		) AND
		((@authorized_preceeds_first_day_off IS NULL) OR 
		(@authorized_preceeds_first_day_off = 1 AND ISNULL(U.[Preapproved Day past 1900], U.[Authorized Day past 1900]) < U.[Start Day past 1900]) OR
		(@authorized_preceeds_first_day_off = 0 AND ISNULL(U.[Preapproved Day past 1900], U.[Authorized Day past 1900]) > U.[Start Day past 1900]))

		AND

		ISNULL(U.[Expected Departure Day past 1900], U.[Start Day past 1900]) BETWEEN @first_authorized_start AND @first_authorized_stop

		AND

		(
			(@authorized_start = -2147483648 AND @authorized_stop = 2147483647) OR 
			(ISNULL(U.[Expected Departure Day past 1900], U.[Start Day past 1900]) BETWEEN @authorized_start AND @authorized_stop) OR
			(CASE WHEN U.[Authorization Expires Day past 1900] IS NOT NULL THEN U.[Authorization Expires Day past 1900] WHEN U.[Expected Return Day past 1900] IS NOT NULL THEN U.[Expected Return Day past 1900] ELSE U.[Stop Day past 1900] END BETWEEN @authorized_start AND @authorized_stop) OR
			(@authorized_start BETWEEN ISNULL(U.[Expected Departure Day past 1900], U.[Start Day past 1900]) AND CASE WHEN U.[Authorization Expires Day past 1900] IS NOT NULL THEN U.[Authorization Expires Day past 1900] WHEN U.[Expected Return Day past 1900] IS NOT NULL THEN U.[Expected Return Day past 1900] ELSE U.[Stop Day past 1900] END)
		) AND


		(U.[Status] & @status_or_mask) != 0 AND
		(@type_or_mask = 0x7FFFFFFF OR (@type_or_mask & (U.[Type Mask] | U.[Advanced Type Mask])) != 0 OR (@type_and_mask != 0 AND 
		(@type_and_mask & (U.[Type Mask] | U.[Advanced Type Mask])) = @type_and_mask)) AND
		(U.[Status] != 2 OR @approval_or_mask = 0x7FFFFFFF OR (@approval_or_mask & U.ApprovalTypeID) !=0 OR (@approval_and_mask != 0 AND 
		@approval_and_mask = U.ApprovalTypeID)) AND
		(
			(@show_064_used_leave_employeeUsedItem_positive=1 AND U.[Seconds] >= 0) OR
			(@show_002_earned_leave_employeeUsedItem_negative=1 AND U.[Seconds] < 0)
		)
	))

	INNER JOIN dbo.TempX ApprovedPermissions ON ApprovedPermissions.BatchID=@approved_permissions_batch_id AND ApprovedPermissions.[ID] = U.EmployeeID

	LEFT JOIN dbo.Person PRE ON U.PreapprovedEmployeeID=PRE.PersonID
	LEFT JOIN dbo.DenialReason D ON U.DenialReasonID = D.DenialReasonID
	LEFT JOIN dbo.Reason R ON U.ReasonID = R.ReasonID
	LEFT JOIN dbo.LeaveApprovalType LAT ON U.ApprovalTypeID = LAT.TypeID
	LEFT JOIN dbo.Person A ON U.AuthorizingEmployeeID = A.PersonID
END
GO
IF OBJECT_ID('dbo.spEmployeeLeaveUsedFillEarned') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spEmployeeLeaveUsedFillEarned AS SELECT A=0'
GO
ALTER PROC dbo.spEmployeeLeaveUsedFillEarned
	@batch_id int,
	@start_day int, @stop_day int,
	@created_start int, @created_stop int,
	@ppe_start int, @ppe_stop int,
	@type_or_mask int, @type_and_mask int,
	@show_004_earned_leave_employeeLeaveEarned_positive_auto bit,
	@show_008_earned_leave_employeeLeaveEarned_positive_manual bit,
	@show_016_used_leave_employeeLeaveEarned_negative_limit bit,
	@show_032_used_leave_employeeLeaveEarned_negative_manual bit
AS
BEGIN
	-- Earned comp
	IF @show_004_earned_leave_employeeLeaveEarned_positive_auto = 1
	INSERT #List0305(
		EmployeeID,
		[ID],
		Attributes,
		Seconds,
		[Earned Seconds],
		[Used Seconds],
		[Type Mask],
		[Temp Type Mask],
		[Types],
		[Start Day past 1900],
		[Stop Day past 1900],
		Note,
		[Status Text],
		Requested,
		[Accumulated Seconds],
		[Available Seconds],
		Effective,
		TypeID,
		LeaveID,
		[Preapproved Employee],
		[Preapproved Date],
		ReasonID,
		Reason,
		[Permission Mask],
		[PPE Start Day past 1900],
		[PPE Stop Day past 1900],
		UsedLeaveID,
		[First Day Used],
		[Last Day Used],
		[Used Period Seconds]
	)

	SELECT T.EmployeeID,
	T.ItemID,
	Attributes = 20525,
	dbo.fnRoundUp(CAST(TT.[Comp Rate] AS numeric(19,4)) * T.Seconds, C.[Comp Rate Round Seconds]),
	[Earned Seconds] = 
	CASE 
		WHEN T.StatusID IN (1,5) AND T.Seconds <= 0 THEN 0 
		ELSE 
		dbo.fnRoundUp(
			CAST(TT.[Comp Rate] AS numeric(19,4)) * 
			DATEDIFF(second,
				dbo.fnTimeRoundIn(C.[Timecard Flags], C.[Timecard Rounding], T.[In]),
				dbo.fnTimeRoundOut(C.[Timecard Flags], C.[Timecard Rounding], T.[In], T.Seconds)
			), 
			C.[Comp Rate Round Seconds]
		)
	END,
	[Used Seconds] = --CAST(TT.[Comp Rate] AS numeric(19,4)) * CASE WHEN T.StatusID IN (1,5) AND T.Seconds < 0 THEN 0 - T.Seconds ELSE 0 END
	CASE 
		WHEN T.StatusID IN (1,5) AND T.Seconds < 0 THEN dbo.fnRoundUp(CAST(TT.[Comp Rate] AS numeric(19,4)) * (0 - T.Seconds), C.[Comp Rate Round Seconds])
		ELSE 0
	END,
	LT.TypeID,
	0,
	[Types] = CAST(LT.[Type] AS varchar(400)),
	[Start Day past 1900] = DATEDIFF(d,0,T.[In]),
	[Stop Day past 1900] = DATEDIFF(d,0,T.[In]),
	Note = CASE WHEN T.StatusID IN (1,5) THEN 'Approved' WHEN T.StatusID=2 THEN 'Denied' WHEN T.StatusID=8 THEN 'Pending' ELSE 'Undefined' END + ' leave earned in lieu of time',
	[Status Text] = CASE WHEN T.StatusID IN (1,5) THEN 'Approved' WHEN T.StatusID=2 THEN 'Denied' WHEN T.StatusID=8 THEN 'Pending' ELSE 'Undefined' END,
	NULL,
	ISNULL((
		SELECT TOP 1 Unused FROM dbo.EmployeeLeaveUnused UL WHERE T.EmployeeID = UL.EmployeeID AND UL.TypeID = LT.TypeID AND UL.[Day past 1900] <= DATEDIFF(d,0,T.[In]) ORDER BY UL.[Day past 1900] DESC
	), 0),
	0, -- Available Seconds #List0305
	Effective = DATEDIFF(d,0,T.[In]),
	LT.TypeID,
	T.ItemID,
	'',
	NULL,
	NULL,
	'',
	1,
	T.[PPE Day past 1900],
	T.[PPE Day past 1900],
	NULL,
	CASE WHEN T.Seconds < 0 THEN DATEDIFF(d,0,T.[In]) ELSE NULL END,
	CASE WHEN T.Seconds < 0 THEN DATEDIFF(d,0,T.[In]) ELSE NULL END,
	[Used Period Seconds] = CASE WHEN (T.StatusID & 1) = 0 OR T.Seconds >= 0 THEN 0 ELSE -T.Seconds END
	FROM dbo.EmployeeTime T
	INNER JOIN dbo.TempX X ON X.BatchID = @batch_id AND X.[ID] = T.EmployeeID AND 
		((@start_day = -2147483648 AND @stop_day = 2147483647) OR DATEDIFF(d,0,T.[In]) BETWEEN @start_day AND @stop_day) AND
		((@created_start = -2147483648 AND @created_stop = 2147483647) OR T.[Created Day past 1900] BETWEEN @created_start AND @created_stop) AND
		((@ppe_start = -2147483648 AND @ppe_stop = 2147483647) OR T.[PPE Day past 1900] BETWEEN @ppe_start AND @ppe_stop)
		AND @show_004_earned_leave_employeeLeaveEarned_positive_auto = 1
	INNER JOIN dbo.TimeType TT ON T.TypeID=TT.TypeID
		AND (@type_or_mask = 0x7FFFFFFF OR (@type_or_mask & TT.CompLeaveTypeID) !=0 OR (@type_and_mask != 0 AND @type_and_mask = TT.CompLeaveTypeID))
	INNER JOIN dbo.LeaveType LT ON TT.CompLeaveTypeID = LT.TypeID
	CROSS JOIN dbo.Constant C



	-- EmployeeLeaveEarnedEntries
	INSERT #List0305(
		EmployeeID,
		[ID],
		Attributes,
		Seconds,
		[Earned Seconds],
		[Used Seconds],
		[Type Mask],
		[Temp Type Mask],
		[Types],
		[Start Day past 1900],
		[Stop Day past 1900],
		Note,
		[Status Text],
		Requested,
		[Accumulated Seconds],
		[Available Seconds],
		Effective,
		TypeID,
		LeaveID,
		[Preapproved Employee],
		[Preapproved Date],
		ReasonID,
		Reason,
		[Permission Mask],
		[PPE Start Day past 1900],
		[PPE Stop Day past 1900],
		UsedLeaveID,
		[First Day Used],
		[Last Day Used],
		[Used Period Seconds]
	)

	-- Earned leave
	SELECT EmployeeID = L.EmployeeID,
	[ID] = L.LeaveID, 
	Attributes = 4137 |
	CASE WHEN L.[Auto]=2 THEN 64 ELSE 0 END | -- Limited adjustment
	CASE WHEN L.[Auto]=0 THEN 0 ELSE 4 END | -- Calculated
	CASE WHEN L.[Auto]=1 THEN 128 ELSE 0 END, -- Automatic credit
	-L.Seconds,
	[Earned Seconds] = CASE WHEN L.Seconds >= 0 THEN L.Seconds ELSE 0 END,
	[Used Seconds] = CASE WHEN L.Seconds >= 0 THEN  0 ELSE -L.Seconds END,
	[Type Mask] = L.TypeID,
	[Temp Type Mask] = 0,
	[Types] = CAST(LT.[Type] AS varchar(400)),
	[Start Day past 1900] = L.[Day past 1900], 
	[Stop Day past 1900] = L.[Day past 1900], 
	Note = CAST(SUBSTRING(L.Note, 1, 400) AS varchar(400)),
	'',
	NULL,
	ISNULL((
		SELECT TOP 1 Unused FROM EmployeeLeaveUnused UL WHERE L.EmployeeID = UL.EmployeeID AND UL.TypeID = L.TypeID AND UL.[Day past 1900] <= L.[Day past 1900] ORDER BY UL.[Day past 1900] DESC
	), 0),
	0, -- #List0305 Available Seconds
	Effective = dbo.GetDateFromDaysPast1900(L.[Day past 1900]),
	L.TypeID,
	L.LeaveID,
	'',
	NULL,
	NULL,
	'',
	T.X,
	L.[PPE Day past 1900],
	L.[PPE Day past 1900],
	NULL,
	CASE WHEN L.Seconds < 0 THEN L.[Day past 1900] ELSE NULL END,
	CASE WHEN L.Seconds < 0 THEN L.[Day past 1900] ELSE NULL END,
	[Used Period Seconds] = CASE WHEN L.Seconds >= 0 THEN  0 ELSE -L.Seconds END

	FROM dbo.EmployeeLeaveEarned L
	INNER JOIN dbo.TempX T ON T.BatchID = @batch_id AND T.[ID] = L.EmployeeID AND 
		((@start_day = -2147483648 AND @stop_day = 2147483647) OR L.[Day past 1900] BETWEEN @start_day AND @stop_day) AND
		((@created_start = -2147483648 AND @created_stop = 2147483647) OR L.[Created Day past 1900] BETWEEN @created_start AND @created_stop) AND
		((@ppe_start = -2147483648 AND @ppe_stop = 2147483647) OR L.[PPE Day past 1900] BETWEEN @ppe_start AND @ppe_stop)
		AND (@type_or_mask = 0x7FFFFFFF OR (@type_or_mask & L.TypeID) !=0 OR (@type_and_mask != 0 AND @type_and_mask = L.TypeID))
		AND 
		(
			(@show_004_earned_leave_employeeLeaveEarned_positive_auto = 1 AND @show_008_earned_leave_employeeLeaveEarned_positive_manual = 1 AND @show_016_used_leave_employeeLeaveEarned_negative_limit = 1 AND @show_032_used_leave_employeeLeaveEarned_negative_manual = 1)
			OR
			(
				@show_004_earned_leave_employeeLeaveEarned_positive_auto=1 AND
				L.Auto=1 -- Auto=1 should always be a positive credit with second > 0
			) OR
			(
				@show_008_earned_leave_employeeLeaveEarned_positive_manual=1 AND
				L.Auto=0 AND L.Seconds >= 0
			) OR
			(
				@show_016_used_leave_employeeLeaveEarned_negative_limit=1 AND
				L.Auto=2 -- Auto=2 should always be a negative limit adjustment
			) OR
			(
				@show_032_used_leave_employeeLeaveEarned_negative_manual=1 AND
				L.Auto=0 AND L.Seconds < 0
			)
		)
	INNER JOIN dbo.LeaveType LT ON L.TypeID = LT.TypeID
	
	
	INSERT #List0305(
		EmployeeID,
		[ID],
		Attributes,
		Seconds,
		[Earned Seconds],
		[Used Seconds],
		[Type Mask],
		[Temp Type Mask],
		[Types],
		[Start Day past 1900],
		[Stop Day past 1900],
		Note,
		[Status Text],
		Requested,
		[Accumulated Seconds],
		[Available Seconds],
		Effective,
		TypeID,
		LeaveID,
		[Preapproved Employee],
		[Preapproved Date],
		ReasonID,
		Reason,
		[Permission Mask],
		[PPE Start Day past 1900],
		[PPE Stop Day past 1900],
		UsedLeaveID,
		[First Day Used],
		[Last Day Used],
		[Used Period Seconds]
	)
	
	-- Linked leave
	SELECT EmployeeID = U.EmployeeID,
	[ID] = -1, 
	Attributes = 4261, /*  4137 |
	CASE WHEN L.[Auto]=2 THEN 64 ELSE 0 END | -- Limited adjustment
	CASE WHEN L.[Auto]=0 THEN 0 ELSE 4 END | -- Calculated
	CASE WHEN L.[Auto]=1 THEN 128 ELSE 0 END, -- Automatic credit */
	SUM(I.Seconds),
	[Earned Seconds] = 0,
	[Used Seconds] = SUM(I.Seconds),
	[Type Mask] = L.TypeID,
	[Temp Type Mask] = 0,
	[Types] = CAST(LT.[Type] AS varchar(400)),
	[Start Day past 1900] = MIN(I.[Day past 1900]), 
	[Stop Day past 1900] = MAX(I.[Day past 1900]), 
	Note = 'Leave linked to ' + dbo.fnGetListAs(P.[First Name], P.[Middle Name], P.[Last Name], P.Suffix),
	'',
	NULL,
	ISNULL((
		SELECT TOP 1 Unused FROM EmployeeLeaveUnused UL WHERE U.EmployeeID = UL.EmployeeID AND UL.TypeID = L.TypeID AND UL.[Day past 1900] <= MAX(I.[Day past 1900]) ORDER BY UL.[Day past 1900] DESC
	), 0),
	0, -- #List0305 Available seconds
	Effective = dbo.GetDateFromDaysPast1900(MIN(I.[Day past 1900])),
	L.TypeID,
	U.LeaveID,
	'',
	NULL,
	NULL,
	'',
	T.X,
	MIN(I.[PPE Day past 1900]),
	MAX(I.[PPE Day past 1900]),
	NULL,
	MIN(I.[Day past 1900]),
	MAX(I.[Day past 1900]),
	[Used Period Seconds] = SUM(I.Seconds)

	FROM dbo.EmployeeLeaveUsedLink L 
	INNER JOIN dbo.EmployeeLeaveUsed U ON U.LeaveID = L.LeaveID AND U.[Status] = 2
	INNER JOIN dbo.EmployeeLeaveUsedItem I ON U.LeaveID=I.LeaveID AND ((I.TypeID | I.[Advanced Type Mask]) & L.TypeID) > 0 AND I.Seconds <> 0
	INNER JOIN dbo.TempX T ON T.BatchID = @batch_id AND T.[ID] = L.EmployeeID AND 
		((@start_day = -2147483648 AND @stop_day = 2147483647) OR I.[Day past 1900] BETWEEN @start_day AND @stop_day) AND
		((@created_start = -2147483648 AND @created_stop = 2147483647) OR U.[Created Day past 1900] BETWEEN @created_start AND @created_stop) AND
		((@ppe_start = -2147483648 AND @ppe_stop = 2147483647) OR I.[PPE Day past 1900] BETWEEN @ppe_start AND @ppe_stop)
		AND (@type_or_mask = 0x7FFFFFFF OR (@type_or_mask & L.TypeID) !=0 OR (@type_and_mask != 0 AND @type_and_mask = L.TypeID))
		AND 
		(
			@show_004_earned_leave_employeeLeaveEarned_positive_auto = 1 OR (@show_008_earned_leave_employeeLeaveEarned_positive_manual = 1 AND @show_016_used_leave_employeeLeaveEarned_negative_limit = 1 AND @show_032_used_leave_employeeLeaveEarned_negative_manual = 1)
		)
	INNER JOIN dbo.Employee EMP ON EMP.EmployeeID = L.EmployeeID
	INNER JOIN dbo.LeaveType LT ON  L.TypeID = LT.TypeID
	INNER JOIN dbo.Person P ON U.EmployeeID = P.PersonID
	GROUP BY U.LeaveID, U.EmployeeID, L.TypeID, LT.[Type], P.[First Name], P.[Middle Name], P.[Last Name], P.Suffix, T.X
END
GO
IF OBJECT_id('dbo.spEmployeeLeaveListFillTypes') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spEmployeeLeaveListFillTypes AS SELECT A=0'
GO
ALTER PROC dbo.spEmployeeLeaveListFillTypes AS
BEGIN
	-- Builds types description for used leave
	DECLARE t_cursor CURSOR LOCAL FORWARD_ONLY STATIC FOR SELECT TypeID, Type FROM LeaveType
	ORDER BY Advanced DESC, Paid DESC
	OPEN t_cursor

	DECLARE @type_id int, @type varchar(50)
	FETCH t_cursor INTO @type_id, @type
	WHILE @@FETCH_STATUS = 0
	BEGIN
		UPDATE #List0305 SET Types = SUBSTRING((L.Types + CASE LEN(L.Types) WHEN 0 THEN '' ELSE ', ' END + @type), 1, 400)
		FROM #List0305 L WHERE (L.[Temp Type Mask] & @type_id) != 0 

		FETCH t_cursor INTO @type_id, @type
	END

	CLOSE t_cursor
	DEALLOCATE t_cursor
END
GO
IF OBJECT_id('dbo.spEmployeeLeaveListReturnResultsLong') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spEmployeeLeaveListReturnResultsLong AS SELECT A=0'
GO
ALTER PROC dbo.spEmployeeLeaveListReturnResultsLong
	@show_days_instead_of_hours bit
AS
BEGIN
SELECT
L.EmployeeID,
L.[ID],
L.Attributes,
L.Seconds,
L.[Earned Seconds],
L.[Used Seconds],
L.[Type Mask],
L.[Types],
L.[Start Day past 1900],
L.[Stop Day past 1900],
L.Note,
Start = dbo.GetDateFromDaysPast1900(L.[Start Day past 1900]), 
[Stop] = dbo.GetDateFromDaysPast1900(L.[Stop Day past 1900]), 
[Earned Hrs] = L.[Earned Seconds] / 3600.00,
[Used Hrs] = L.[Used Seconds] / 3600.00,
[Earned Units] = L.[Earned Seconds] / CAST(CASE WHEN @show_days_instead_of_hours=0 THEN 3600.00 ELSE Secure.[Effective Seconds per Day] END AS numeric(9,4)),
[Used Units] = L.[Used Seconds] / CAST(CASE WHEN @show_days_instead_of_hours=0 THEN 3600.00 ELSE Secure.[Effective Seconds per Day] END AS numeric(9,4)),

[Earned Days] = CASE WHEN Secure.[Effective Seconds per Day]=0 THEN 0 ELSE L.[Earned Seconds] / CAST(Secure.[Effective Seconds per Day] AS numeric(9,4)) END,
[Used Days] = CASE WHEN Secure.[Effective Seconds per Day]=0 THEN 0 ELSE L.[Used Seconds] / CAST(Secure.[Effective Seconds per Day] AS numeric(9,4)) END,
[Accumulated Days] = CASE WHEN Secure.[Effective Seconds per Day]=0 THEN 0 ELSE L.[Accumulated Seconds] / CAST(Secure.[Effective Seconds per Day] AS numeric(9,4)) END,

L.[Status Text],
L.[Requested],
L.[Accumulated Seconds],
[Accumulated Hrs] = L.[Accumulated Seconds] / 3600.00,
[Accumulated Units] = L.[Accumulated Seconds] / CAST(CASE WHEN @show_days_instead_of_hours=0 THEN 3600.00 ELSE Secure.[Effective Seconds per Day] END AS numeric(9,4)),
L.[Available Seconds],
[Available Hrs] = L.[Available Seconds] / 3600.00,
L.[Effective],
L.TypeID,
L.LeaveID,
L.[Preapproved Employee],
L.[Preapproved Date],
Period = CAST(
CONVERT(varchar(10), dbo.GetDateFromDaysPast1900(L.[Start Day past 1900]), 120) +
CASE WHEN L.[Start Day past 1900] = L.[Stop Day past 1900] THEN ''
ELSE ' to ' + CONVERT(varchar(10), dbo.GetDateFromDaysPast1900(L.[Stop Day past 1900]), 120)
END

AS varchar(40)
),
L.ReasonID,
L.Reason,
L.[Permission Mask],
PPE = dbo.GetDateFromDaysPast1900(L.[PPE Start Day past 1900]),
[PPE Start] = dbo.GetDateFromDaysPast1900(L.[PPE Start Day past 1900]),
[PPE Stop] = dbo.GetDateFromDaysPast1900(L.[PPE Start Day past 1900]),
[Authorization Expires] = DATEADD(d,0,U.[Authorization Expires Day past 1900]),
[Expected Departure] = DATEADD(d,0,U.[Expected Departure Day past 1900]),
[Expected Return] = DATEADD(d,0,U.[Expected Return Day past 1900]),
[First Date Used] = DATEADD(d,0,L.[First Day Used]),
[Last Date Used] = DATEADD(d,0,L.[Last Day Used]),
[First Certified] = DATEADD(d,0,U.[First Certified Day past 1900]),
[Last Certified] = DATEADD(d,0,U.[Last MD Note Day past 1900]),
[Certification Expires] = DATEADD(d,0,U.[Recertify Day past 1900]),
Employee = Secure.[Person List As],
[Employee Full Name] = Secure.[Full Name],
[Used Period Hrs] = L.[Used Period Seconds] / 3600.00,
[Used Period Days] = CASE WHEN Secure.[Effective Seconds per Day]=0 THEN 0 ELSE L.[Used Period Seconds] / CAST(Secure.[Effective Seconds per Day] AS numeric(9,4)) END,
[Approved Date] = CASE WHEN U.[Status] = 1 THEN DATEADD(d,0,[Authorized Day past 1900]) ELSE NULL END,
[End Date] = DATEADD(d,0,[Recertify Day past 1900]),
[Approval Type] = ISNULL(T.[Type], ''),
[Denial Reason] = ISNULL(D.Reason, ''),
Secure.*
FROM #List0305 L
INNER JOIN dbo.vwEmployeeSecure Secure ON L.EmployeeID=Secure.EID
LEFT JOIN dbo.EmployeeLeaveUsed U ON U.LeaveID = L.UsedLeaveID
LEFT JOIN dbo.LeaveApprovalType T ON U.ApprovalTypeID = T.TypeID
LEFT JOIN dbo.DenialReason D ON U.DenialReasonID = D.DenialReasonID
ORDER BY 
L.[Start Day past 1900], L.[Stop Day past 1900], L.[Types]
END
GO
IF OBJECT_id('dbo.spEmployeeLeaveListReturnResultsShort') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spEmployeeLeaveListReturnResultsShort AS SELECT A=0'
GO
ALTER PROC dbo.spEmployeeLeaveListReturnResultsShort
	@show_days_instead_of_hours bit
AS
BEGIN
SELECT
L.EmployeeID,
L.[ID],
L.Attributes,
L.Seconds,
L.[Earned Seconds],
L.[Used Seconds],
L.[Type Mask],
L.[Types],
L.[Start Day past 1900],
L.[Stop Day past 1900],
L.Note,
Start = dbo.GetDateFromDaysPast1900(L.[Start Day past 1900]), 
[Stop] = dbo.GetDateFromDaysPast1900(L.[Stop Day past 1900]), 
[Earned Hrs] = L.[Earned Seconds] / 3600.00,
[Used Hrs] = L.[Used Seconds] / 3600.00,
[Earned Units] = L.[Earned Seconds] / CAST(CASE WHEN @show_days_instead_of_hours=0 THEN 3600.00 WHEN E.[Seconds per Day Override]=0 THEN S.[Seconds per Day] ELSE E.[Seconds per Day Override] END AS numeric(9,4)),
[Used Units] = L.[Used Seconds] / CAST(CASE WHEN @show_days_instead_of_hours=0 THEN 3600.00 WHEN E.[Seconds per Day Override]=0 THEN S.[Seconds per Day] ELSE E.[Seconds per Day Override] END AS numeric(9,4)),
L.[Status Text],
L.[Requested],
L.[Accumulated Seconds],
[Accumulated Hrs] = L.[Accumulated Seconds] / 3600.00,
[Accumulated Units] = L.[Accumulated Seconds] / CAST(CASE WHEN @show_days_instead_of_hours=0 THEN 3600.00 WHEN E.[Seconds per Day Override]=0 THEN S.[Seconds per Day] ELSE E.[Seconds per Day Override] END AS numeric(9,4)),
L.[Effective],
L.TypeID,
L.LeaveID,
L.[Preapproved Employee],
L.[Preapproved Date],
Period = CAST(
	CONVERT(varchar(10), dbo.GetDateFromDaysPast1900(L.[Start Day past 1900]), 120) +
	CASE WHEN L.[Start Day past 1900] = L.[Stop Day past 1900] THEN ''
	ELSE ' to ' + CONVERT(varchar(10), dbo.GetDateFromDaysPast1900(L.[Stop Day past 1900]), 120)
	END

	AS varchar(40)
),
L.ReasonID,
L.Reason,
L.[Permission Mask],
PPE = dbo.GetDateFromDaysPast1900(L.[PPE Start Day past 1900]),
[PPE Start] = dbo.GetDateFromDaysPast1900(L.[PPE Start Day past 1900]),
[PPE Stop] = dbo.GetDateFromDaysPast1900(L.[PPE Start Day past 1900]),
[Authorization Expires] = DATEADD(d,0,U.[Authorization Expires Day past 1900]),
[Expected Departure] = DATEADD(d,0,U.[Expected Departure Day past 1900]),
[Expected Return] = DATEADD(d,0,U.[Expected Return Day past 1900]),
[First Date Used] = DATEADD(d,0,L.[First Day Used]),
[Last Date Used] = DATEADD(d,0,L.[Last Day Used]),
[First Certified] = DATEADD(d,0,U.[First Certified Day past 1900]),
[Last Certified] = DATEADD(d,0,U.[Last MD Note Day past 1900]),
[Certification Expires] = DATEADD(d,0,U.[Recertify Day past 1900]),
Employee = dbo.fnGetListAs(P.[First Name], P.[Middle Name], P.[Last Name], P.Suffix),
[Employee Full Name] = dbo.fnGetFullName(P.[First Name], P.[Middle Name], P.[Last Name], P.Suffix),

E.[Employee Number],
Manager = dbo.fnGetListAs(M.[First Name], M.[Middle Name], M.[Last Name], M.Suffix),
PX.SSN,
D.Department,
Location = LOC.[List As],
[Used Period Hrs] = L.[Used Period Seconds] / 3600.00,
[Used Period Days] = L.[Used Period Seconds] / CAST(CASE WHEN @show_days_instead_of_hours=0 THEN 3600.00 WHEN E.[Seconds per Day Override]=0 THEN S.[Seconds per Day] ELSE E.[Seconds per Day Override] END AS numeric(9,4))

--Secure.*
FROM #List0305 L
INNER JOIN dbo.Person P ON L.EmployeeID = P.PersonID
INNER JOIN dbo.Employee E ON P.PersonID = E.EmployeeID
INNER JOIN dbo.PersonX PX ON P.PersonID = PX.PersonID
INNER JOIN dbo.Shift S ON E.ShiftID = S.ShiftID
INNER JOIN dbo.Department D ON E.DepartmentID = D.DepartmentID
INNER JOIN dbo.Location LOC ON E.LocationID = LOC.LocationID
LEFT JOIN dbo.EmployeeLeaveUsed U ON U.LeaveID = L.UsedLeaveID
LEFT JOIN dbo.Person M ON E.ManagerID = M.PersonID
ORDER BY 
L.[Start Day past 1900], L.[Stop Day past 1900], L.[Types]
END
GO
IF OBJECT_id('dbo.spEmployeeLeaveListDeleteAllButLast') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spEmployeeLeaveListDeleteAllButLast AS'
GO
ALTER PROC dbo.spEmployeeLeaveListDeleteAllButLast
AS
BEGIN
DELETE L FROM #List0305 L WHERE L.UsedLeaveID IS NOT NULL AND L.UsedLeaveID NOT IN
(
	SELECT TOP 1 X.UsedLeaveID FROM #List0305 X WHERE X.UsedLeaveID IS NOT NULL AND X.EmployeeID = L.EmployeeID ORDER BY X.[Start Day past 1900] DESC
)
END
GO
IF OBJECT_id('dbo.spEmployeeLeaveList2') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spEmployeeLeaveList2 AS'
GO
ALTER PROC dbo.spEmployeeLeaveList2
	@batch_id int,
	@start_day int,
	@stop_day int,
	@ppe_start int,
	@ppe_stop int,
	@status_or_mask int,
	@type_or_mask int,
	@type_and_mask int,
	@approval_or_mask int,
	@approval_and_mask int,
	@created_start int,
	@created_stop int,
	@requested_start int,
	@requested_stop int,
	@order int = 0,
	@flags int,
	@authorized bit OUT,
	@all_used_after_leave_id int = 2147483647,
	@first_authorized_start int = -2147483648,
	@first_authorized_stop int = 2147483647,
	@authorized_start int = -2147483648,
	@authorized_stop int =2147483647
AS
SET NOCOUNT ON


CREATE TABLE #List0305
(
	EmployeeID int,
	[ID] int,
	Attributes int,
	Seconds int,
	[Earned Seconds] int,
	[Used Seconds] int,
	[Type Mask] int,
	[Temp Type Mask] int,
	[Types] varchar(400) COLLATE SQL_Latin1_General_CP1_CI_AS,
	[Start Day past 1900] int,
	[Stop Day past 1900] int,
	Note varchar(400) COLLATE SQL_Latin1_General_CP1_CI_AS,
	[Status Text] varchar(400) COLLATE SQL_Latin1_General_CP1_CI_AS,
	Requested datetime,
	[Accumulated Seconds] int,
	[Available Seconds] int,
	Effective datetime,
	TypeID int,
	LeaveID int,
	[Preapproved Employee] varchar(400) COLLATE SQL_Latin1_General_CP1_CI_AS,
	[Preapproved Date] datetime,
	ReasonID int,
	Reason varchar(50),
	[Permission Mask] int,
	[PPE Start Day past 1900] int,
	[PPE Stop Day past 1900] int,
	UsedLeaveID int,
	[First Day Used] int,
	[Last Day Used] int,
	[Used Period Seconds] int
)
DECLARE @inclue_16384_extra_report_fields bit
SELECT @inclue_16384_extra_report_fields = @flags & 16384

IF @created_stop < @created_start OR @stop_day < @start_day
BEGIN
	SET @authorized = 1
END
ELSE
BEGIN
	DECLARE @show_001_previous_period_totals bit
	DECLARE @show_002_earned_leave_employeeUsedItem_negative bit
	DECLARE @show_004_earned_leave_employeeLeaveEarned_positive_auto bit
	DECLARE @show_008_earned_leave_employeeLeaveEarned_positive_manual bit
	DECLARE @show_016_used_leave_employeeLeaveEarned_negative_limit bit
	DECLARE @show_032_used_leave_employeeLeaveEarned_negative_manual bit
	DECLARE @show_064_used_leave_employeeUsedItem_positive bit
	DECLARE @only_8192_show_last_leave bit

	IF @start_day = -2147483648 SELECT @show_001_previous_period_totals = 0
	ELSE SELECT @show_001_previous_period_totals = @flags & 1

	SELECT @show_002_earned_leave_employeeUsedItem_negative = @flags & 2
	SELECT @show_004_earned_leave_employeeLeaveEarned_positive_auto = @flags & 4
	SELECT @show_016_used_leave_employeeLeaveEarned_negative_limit = @flags & 16
	SELECT @show_064_used_leave_employeeUsedItem_positive = @flags & 64
	SELECT @only_8192_show_last_leave = @flags & 8192
	

	IF ((@status_or_mask & 2) = 0)
	BEGIN
		SELECT @show_008_earned_leave_employeeLeaveEarned_positive_manual = 0
		SELECT @show_032_used_leave_employeeLeaveEarned_negative_manual = 0
	END
	ELSE
	BEGIN
		SELECT @show_008_earned_leave_employeeLeaveEarned_positive_manual = @flags & 8
		SELECT @show_032_used_leave_employeeLeaveEarned_negative_manual = @flags & 32
	END

	DECLARE @show_days_instead_of_hours bit, @authorized_preceeds_first_day_off bit

	SELECT @show_days_instead_of_hours = @flags & 1024

	SELECT @authorized_preceeds_first_day_off = CASE
		WHEN (@flags & 2048) = 2048 THEN 1
		WHEN (@flags & 4096) = 4096 THEN 0
		ELSE NULL
	END

	/*
	001 Previous period totals.
	002 Earned leave. EmployeeUsedItem that is negative
	004 Earned leave. EmployeeLeaveEarned that is positive. Automatically created accrual.
	008 Earned leave. EmployeeLeaveEarned that is positive. Manual entry.
	016 Used leave. EmployeeLeaveEarned that is negative. Limit adjustment.
	032 Used leave. EmployeeLeaveEarned that is negative. Manual entry.
	064 Used Leave. EmployeeUsedItem that is positive

	1024 Show days instead of hours
	2048 Authorized preceeds first day off
	4096 First day off preceeds authorized

	8192 Only show last leave
	
	16384 Exclude out of range leave in EmployeeLeaveUsedItem
	*/


	DECLARE @all_types bit

	SET @all_types = 1
	SELECT @all_types = 0 FROM LeaveType WHERE (TypeID & @type_or_mask) = 0
	IF @all_types = 1 SET @type_or_mask = 0x7FFFFFFF

	EXEC dbo.spPermissionGetOnPeopleForCurrentUser2 @batch_id, 10001
	DELETE TempX WHERE BatchID = @batch_id AND (X & 1) = 0
	SELECT @authorized = CASE WHEN @@ROWCOUNT = 0 THEN 1 ELSE 0 END

	DECLARE @approved_permissions_batch_id int
	SELECT @approved_permissions_batch_id = RAND() * 2147483647
	INSERT dbo.TempX(BatchID,[ID])
	SELECT @approved_permissions_batch_id,[ID] FROM dbo.TempX WHERE BatchID=@batch_id
	EXEC dbo.spPermissionGetOnPeopleForCurrentUser2 @approved_permissions_batch_id, 10013


	-- Previous totals
	IF @show_001_previous_period_totals = 1
	BEGIN
		EXEC dbo.spEmployeeLeaveListFillPreviousTotals @batch_id, @type_or_mask, @type_and_mask, @start_day
	END

	IF (@show_004_earned_leave_employeeLeaveEarned_positive_auto = 1 OR @show_008_earned_leave_employeeLeaveEarned_positive_manual = 1 OR @show_016_used_leave_employeeLeaveEarned_negative_limit = 1 OR @show_032_used_leave_employeeLeaveEarned_negative_manual = 1)
	BEGIN
		EXEC dbo.spEmployeeLeaveUsedFillEarned @batch_id, @start_day, @stop_day, @created_start, @created_stop, @ppe_start, @ppe_stop,
			@type_or_mask, @type_and_mask, @show_004_earned_leave_employeeLeaveEarned_positive_auto,
			@show_008_earned_leave_employeeLeaveEarned_positive_manual, @show_016_used_leave_employeeLeaveEarned_negative_limit,
			@show_032_used_leave_employeeLeaveEarned_negative_manual
	END


	IF (@show_064_used_leave_employeeUsedItem_positive = 1 OR @show_002_earned_leave_employeeUsedItem_negative = 1)
	BEGIN
		EXEC dbo.spEmployeeLeaveListFillUsedLeaves @batch_id, @created_start, @created_stop, @start_day, @stop_day, @ppe_start, @ppe_stop, @requested_start,
			@requested_stop, @authorized_preceeds_first_day_off, @first_authorized_start, @first_authorized_stop, @authorized_start, @authorized_stop,
			@type_or_mask, @type_and_mask, @status_or_mask, @approval_or_mask, @approval_and_mask, @approved_permissions_batch_id,
			@show_064_used_leave_employeeUsedItem_positive, @show_002_earned_leave_employeeUsedItem_negative, @all_used_after_leave_id
	END

	CREATE INDEX IX_TempList0305_UsedLeaveID ON #List0305(UsedLeaveID)
	CREATE INDEX IX_TempList0305_EmployeeID ON #List0305(EmployeeID)

	IF @only_8192_show_last_leave=1 EXEC dbo.spEmployeeLeaveListDeleteAllButLast
	EXEC dbo.spEmployeeLeaveListFillTypes
END

IF @inclue_16384_extra_report_fields = 1 EXEC dbo.spEmployeeLeaveListReturnResultsLong @show_days_instead_of_hours
ELSE EXEC dbo.spEmployeeLeaveListReturnResultsShort @show_days_instead_of_hours

DELETE TempX WHERE BatchID IN (@batch_id, @approved_permissions_batch_id) OR DATEDIFF(hh, Created, GETDATE()) > 1
GO
GRANT EXEC ON dbo.spEmployeeLeaveList2 TO public
GO
ALTER PROC dbo.spEmployeeLeaveList
	@batch_id int,
	@start_day int,
	@stop_day int,
	@status_or_mask int,
	@type_or_mask int,
	@type_and_mask int,
	@approval_or_mask int,
	@approval_and_mask int,
	@earned bit,
	@authorized bit OUT,

	@authorized_preceeds_first_day_off bit = NULL,
	@created_start int = -2147483648,
	@created_stop int = 2147483647,
	@requested_start int = -2147483648,
	@requested_stop int = 2147483647,
	@order int = 0,
	@days bit = 0,
	@adjustment bit = NULL,

	@flags int = 1
AS
DECLARE @f int, @e int, @a int
SELECT @e = CASE WHEN @earned IS NULL THEN 2 WHEN @earned=1 THEN 1 ELSE 0 END
SELECT @a = CASE WHEN @adjustment IS NULL THEN 2 WHEN @adjustment=1 THEN 1 ELSE 0 END

SELECT @f = CASE
	WHEN @e=0 AND @a=2 THEN 98
	WHEN @e=1 AND @a=2 THEN 14
	WHEN @e=2 AND @a=0 THEN 66
	WHEN @e=0 AND @a=0 THEN 64
	WHEN @e=1 AND @a=0 THEN 2
	WHEN @e=2 AND @a=1 THEN 60
	WHEN @e=0 AND @a=1 THEN 48
	WHEN @e=1 AND @a=1 THEN 12
	ELSE 126
END

/*
001 Previous period totals.
002 Earned leave. EmployeeUsedItem that is negative
004 Earned leave. EmployeeLeaveEarned that is positive. Automatically created accrual.
008 Earned leave. EmployeeLeaveEarned that is positive. Manual entry.
016 Used leave. EmployeeLeaveEarned that is negative. Limit adjustment.
032 Used leave. EmployeeLeaveEarned that is negative. Manual entry.
064 Used Leave. EmployeeUsedItem that is positive

1024 Show days instead of hours
2048 Authorized preceeds first day off
4096 First day off preceeds authorized
*/

IF (@flags & 1) = 1 AND ((@earned IS NULL) OR (@earned=1)) SET @f = @f | 1
IF @authorized_preceeds_first_day_off = 0 SET @f = @f | 4096
ELSE IF @authorized_preceeds_first_day_off = 0 SET @f = @f | 2048

EXEC dbo.spEmployeeLeaveList2
	@batch_id=@batch_id,
	@start_day=@start_day,
	@stop_day=@stop_day,
	@ppe_start = -2147483648,
	@ppe_stop = 2147483647,
	@status_or_mask=@status_or_mask,
	@type_or_mask=@type_or_mask,
	@type_and_mask=@type_and_mask,
	@approval_or_mask=@approval_or_mask,
	@approval_and_mask=@approval_and_mask,
	@created_start=@created_start,
	@created_stop=@created_stop,
	@requested_start=@requested_start,
	@requested_stop=@requested_stop,
	@order=@order,
	@flags=@f,
	@authorized=@authorized OUT
GO
ALTER FUNCTION dbo.GetPayrollPeriodNumber(@start_date datetime)
RETURNS int
AS
BEGIN
	DECLARE @prev_date datetime
	DECLARE @wk0 datetime -- first Jan 1 after 1900 that falls on the first day of the week
	SELECT @wk0 = '19110101', @prev_date = DATEADD(d, -1, @start_date)

	DECLARE @payroll_period_id int, @day int, @period int
	SELECT @payroll_period_id = CurrentPayrollPeriodID FROM dbo.Constant
	SELECT @day = DAY(@start_date)

	-- ENDS Jan 1, Mar 1, May 1, Jul 1, Sep 1, Nov 1
	IF @payroll_period_id = 90120
	BEGIN
		RETURN DATEDIFF(m, @wk0, @prev_date) / 2
	END
	-- ENDS Feb 28|29, Apr 30, Jun 30, Aug 31, Oct 31, Dec 31
	ELSE IF @payroll_period_id = 92168
	BEGIN
		RETURN DATEDIFF(m, @wk0, @start_date) / 2
 	END
	-- ENDS First Day of Each Month
	ELSE IF @payroll_period_id = 126992
	BEGIN
		RETURN DATEDIFF(m, @wk0, @prev_date)
 	END
	-- ENDS Last Day of Each Month
	ELSE IF @payroll_period_id = 129040
	BEGIN
		RETURN DATEDIFF(m, @wk0, @start_date)
 	END
	-- ENDS 15th of Each Month
	ELSE IF @payroll_period_id = 141328
	BEGIN
		RETURN DATEDIFF(m, @wk0, DATEADD(d, -15, @start_date))
 	END
	-- ENDS 16th of each month
	ELSE IF @payroll_period_id = 143376
	BEGIN
		RETURN DATEDIFF(m, @wk0, DATEADD(d, -16, @start_date))
 	END
	-- ENDS 28th of each month
	ELSE IF @payroll_period_id = 131088
	BEGIN
		RETURN DATEDIFF(m, @wk0, DATEADD(d, -28, @start_date))
 	END
	-- ENDS 30th need to make exception for feb
	ELSE IF @payroll_period_id = 145424
	BEGIN
		RETURN DATEDIFF(m, @wk0, DATEADD(d, CASE WHEN MONTH(@start_date) = 2 THEN -28 ELSE -30 END, @start_date))
 	END
	-- ENDS 1st and 15th of each month
	ELSE IF @payroll_period_id = 163872
	BEGIN
		SELECT @period = DATEDIFF(m, @wk0, @prev_date) * 2
		IF @day > 15 OR @day = 1 SET @period = @period + 1
		RETURN @period
	END
	-- ENDS 5th and 20th of each month
	ELSE IF @payroll_period_id = 176160
	BEGIN
		SELECT @period = DATEDIFF(m, @wk0, @start_date) * 2
		IF @day > 20 SET @period = @period + 2
		ELSE IF @day > 5 SET @period = @period + 1
		
		RETURN @period
	END
	
	-- ENDS 10th and 25th of each month
	ELSE IF @payroll_period_id = 178208
	BEGIN
		SELECT @period = DATEDIFF(m, @wk0, @start_date) * 2
		IF @day > 25 SET @period = @period + 2
		ELSE IF @day > 10 SET @period = @period + 1
		
		RETURN @period
	END

	-- ENDS 11th and 27th of each month
	ELSE IF @payroll_period_id = 180256
	BEGIN
		SELECT @period = DATEDIFF(m, @wk0, @start_date) * 2
		IF @day > 27 SET @period = @period + 2
		ELSE IF @day > 11 SET @period = @period + 1
		
		RETURN @period
	END
	
	
	
	
	-- ENDS 1st and 16th of each month
	ELSE IF @payroll_period_id = 165920
	BEGIN
		SELECT @period = DATEDIFF(m, @wk0, @prev_date) * 2
		IF @day > 16 OR @day = 1 SET @period = @period + 1
		RETURN @period
	END
	-- ENDS 14th and 28th of each month
	ELSE IF @payroll_period_id = 167968
	BEGIN
		SELECT @period = DATEDIFF(m, @wk0, @start_date) * 2
		IF @day > 28 SET @period = @period + 2
		ELSE IF @day > 14 SET @period = @period + 1

		RETURN @period
	END
	-- ENDS 15th and 28th of each month
	ELSE IF @payroll_period_id = 170016
	BEGIN
		SELECT @period = DATEDIFF(m, @wk0, @start_date) * 2
		IF @day > 28 SET @period = @period + 2
		ELSE IF @day > 15 SET @period = @period + 1

		RETURN @period
	END
	-- ENDS 15th and 30th of each month
	ELSE IF @payroll_period_id = 172064
	BEGIN
		SELECT @period = DATEDIFF(m, @wk0, @start_date) * 2
		IF @day = 31 SET @period = @period + 2
		ELSE IF @day > 15 SET @period = @period + 1

		RETURN @period
	END
	-- ENDS 15th and 31st of each month
	ELSE IF @payroll_period_id = 174112
	BEGIN
		SELECT @period = DATEDIFF(m, @wk0, @start_date) * 2
		IF @day > 15 SET @period = @period + 1

		RETURN @period
	END
	-- Every other week
	ELSE IF (@payroll_period_id & 511) = 64
	BEGIN
		SELECT @day = 0 - Weekday FROM LeaveRatePeriod WHERE PeriodID = @payroll_period_id
		SELECT @period = CASE WHEN @payroll_period_id < 215104 THEN 2 ELSE 1 END
		RETURN (DATEDIFF(wk, @wk0, DATEADD(d, @day, @start_date)) + @period) / 2
	END
	-- Every week
	ELSE IF ((@payroll_period_id & 511) = 128)
	BEGIN
		SELECT @day = 0 - Weekday FROM LeaveRatePeriod WHERE PeriodID = @payroll_period_id
		RETURN DATEDIFF(wk, @wk0, DATEADD(d, @day, @start_date))
	END
	
	RETURN NULL
END
GO
IF OBJECT_ID('dbo.spEmployeeTimeList2') IS NULL 
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEmployeeTimeList2 AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spEmployeeTimeList2 TO public'
END
GO
-- Lists time for the entry-per-row report format (opposed to day-per-row grid report format)
ALTER PROC [dbo].[spEmployeeTimeList2]
	@employee_id int,
	@start_day int,
	@stop_day int,
	@include_paid_leave bit,
	@include_unpaid_leave bit = 0,
	@authorized bit = 0 OUT
AS
SET NOCOUNT ON

EXEC dbo.spPermissionInsureForCurrentUserOnPerson @employee_id, 262144, 1, @authorized out
IF @authorized = 0 RETURN

CREATE TABLE #EMPLOYEE_TIME_ROUNDED(
	TempItemID int NOT NULL IDENTITY(1,1) PRIMARY KEY,
	EmployeeID int NOT NULL,
	OriginalTypeID int NOT NULL, 
	CalculatedTypeID int NOT NULL,
	[In Day past 1900] int NOT NULL, 
	[OT Eligible] bit NOT NULL,
	[OT Disable] bit NOT NULL,
	[Pay Rate] money NOT NULL,
	[Fixed Pay] money NOT NULL DEFAULT(0),
	[Fixed Items] int DEFAULT(0),
	Regular bit DEFAULT(0),
	[In Seconds] int NOT NULL,
	[Out Seconds] int NOT NULL,
	TimeSchemaID int NOT NULL,
	ShiftDiffItemID int NULL,
	TempShiftDiffSeconds int NULL,
	TempShiftDiffItemID int NULL,
	OriginalTimeItemID int NULL,
	CopyTimeItemID int NULL,
	[Time Seconds] int NOT NULL DEFAULT(0),
	[Holiday Seconds] int NOT NULL DEFAULT(0),
	[OT Seconds] int NOT NULL DEFAULT(0),
	Flags int NOT NULL DEFAULT(0),
	[Actual In] datetime NULL,
	[Actual Out] datetime NULL,
	[Base Seconds] int NOT NULL DEFAULT(0),
	[X2 Seconds] int NOT NULL DEFAULT(0),

	/* Extra fields */
	[Paid Leave Seconds] int NOT NULL DEFAULT(0),
	[Unpaid Leave Seconds] int NOT NULL DEFAULT(0),
	[Leave Comment] varchar(400) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL DEFAULT(''),
	[Leave Type] varchar(50) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL DEFAULT(''),
	[Payroll Start] datetime NULL,
	[Payroll Stop] datetime NULL
)

/* Begin round time and calc OT **************/
DECLARE @batch_id int, @pending_type_id int, @denied_type_id int, @leave_type_id int
SELECT @batch_id = RAND() * 2147483647
INSERT TempX(BatchID, [ID]) SELECT @batch_id, @employee_id

EXEC dbo.spEmployeeTimeRoundAndCalcOT @batch_id, 0, @start_day, @stop_day, NULL, NULL, @authorized OUT, @pending_type_id OUT, @denied_type_id OUT
SET @leave_type_id = @denied_type_id - 1

DELETE dbo.TempX WHERE BatchID=@batch_id OR DATEDIFF(minute, Created, GETDATE()) > 30
/* End round time and calc OT **************/



/* Begin insert leave **********************/

/* Approved */

INSERT #EMPLOYEE_TIME_ROUNDED([Leave Comment], EmployeeID, OriginalTypeID, CalculatedTypeID, 
[In Day past 1900], [OT Eligible], [OT Disable], [Pay Rate], [Fixed Pay],
[Fixed Items], Regular, [In Seconds], [Out Seconds], TimeSchemaID, [Leave Type],
[Paid Leave Seconds], 
[Unpaid Leave Seconds])

SELECT [Leave Comment] = I.[Calendar Comment], --CASE WHEN T.Paid=1 THEN 'Paid' ELSE 'Unpaid' END + ' Leave ' + T.Abbreviation, 
EmployeeID=@employee_id, OriginalTypeID=@leave_type_id, CalculatedTypeID=@leave_type_id,
[In Day past 1900]=I.[Day past 1900], T.[OT Eligible], 0, [Pay Rate]=ISNULL(EC.[Hourly Pay], 0), [Fixed Pay]=0,
[Fixed Items]=0, Regular=0, [In Seconds]=28800, [Out Seconds]=28800 + I.[Seconds], TimeSchemaID=0, T.Type,
[Paid Leave Seconds]=CASE WHEN T.Paid=1 THEN I.Seconds ELSE 0 END, 
[Unpaid Leave Seconds]=CASE WHEN T.Paid=0 THEN I.Seconds ELSE 0 END

FROM dbo.vwEmployeeLeaveUsedItemApproved I
INNER JOIN LeaveType T ON @include_paid_leave = 1 AND I.EmployeeID = @employee_id AND I.[Day past 1900] BETWEEN @start_day AND @stop_day AND I.TypeID = T.TypeID
LEFT JOIN dbo.vwEmployeeCompensation EC ON EC.EmployeeID = @employee_id AND I.[Day past 1900] BETWEEN EC.[Start Day past 1900] AND ISNULL(EC.[Stop Day past 1900], 0x7FFFFFFF)
ORDER BY I.[Day past 1900]

/* Pending */

INSERT #EMPLOYEE_TIME_ROUNDED([Leave Comment], EmployeeID, OriginalTypeID, CalculatedTypeID, 
[In Day past 1900], [OT Eligible], [OT Disable], [Pay Rate], [Fixed Pay],
[Fixed Items], Regular, [In Seconds], [Out Seconds], TimeSchemaID, [Leave Type],
[Paid Leave Seconds], 
[Unpaid Leave Seconds])

SELECT [Leave Comment] = U.[Calendar Comment], --CASE WHEN T.Paid=1 THEN 'Paid' ELSE 'Unpaid' END + ' Leave ' + T.Abbreviation, 
EmployeeID=@employee_id, OriginalTypeID=@pending_type_id, CalculatedTypeID=@pending_type_id,
[In Day past 1900]=I.[Day past 1900], T.[OT Eligible], 0, [Pay Rate]=ISNULL(EC.[Hourly Pay], 0), [Fixed Pay]=0,
[Fixed Items]=0, Regular=0, [In Seconds]=28800, [Out Seconds]=28800 + I.[Seconds], TimeSchemaID=0, 'PEND ' + T.Type,
[Paid Leave Seconds]=CASE WHEN T.Paid=1 THEN I.Seconds ELSE 0 END, 
[Unpaid Leave Seconds]=CASE WHEN T.Paid=0 THEN I.Seconds ELSE 0 END

--SELECT I.[Day past 1900], I.Seconds, I.[Date], I.[Extended Type Mask], I.TypeID, I.EmployeeID, I.ReasonID, I.[Calendar Comment] 
FROM dbo.EmployeeLeaveUsedItem I
INNER JOIN dbo.LeaveType T ON I.TypeID = T.TypeID AND @include_paid_leave = 1 AND I.[Day past 1900] BETWEEN @start_day AND @stop_day
INNER JOIN dbo.EmployeeLeaveUsed U ON U.LeaveID=I.LeaveID AND U.Status = 1 AND U.EmployeeID = @employee_id
LEFT JOIN dbo.vwEmployeeCompensation EC ON EC.EmployeeID = @employee_id AND I.[Day past 1900] BETWEEN EC.[Start Day past 1900] AND ISNULL(EC.[Stop Day past 1900], 0x7FFFFFFF)
ORDER BY I.[Day past 1900]

/* End insert leave *********************/


CREATE INDEX ET_108302007 ON #EMPLOYEE_TIME_ROUNDED([Payroll Start])


-- Inserts payroll start / stop dates
CREATE TABLE #T(StartDate datetime, StopDate datetime)
DECLARE @dt datetime
WHILE EXISTS(SELECT * FROM #EMPLOYEE_TIME_ROUNDED WHERE [Payroll Start] IS NULL)
BEGIN
	SELECT TOP 1 @dt = DATEADD(d, [In Day past 1900], 0) FROM #EMPLOYEE_TIME_ROUNDED WHERE [Payroll Start] IS NULL

	DELETE #T
	INSERT #T
	EXEC dbo.spEmployeeTimeCalculateFilterInverse @dt, 5

	UPDATE #EMPLOYEE_TIME_ROUNDED SET [Payroll Start] = T.StartDate, [Payroll Stop] = T.StopDate
	FROM #EMPLOYEE_TIME_ROUNDED
	INNER JOIN #T T ON #EMPLOYEE_TIME_ROUNDED.[Payroll Start] IS NULL AND DATEADD(d, [In Day past 1900], 0) BETWEEN T.StartDate AND T.StopDate
END


-- Provides way to override first day of week as defined by the current language
DECLARE @date_first int
SELECT @date_first = DatePartDW FROM vwDateFirst


SELECT 
Leave = CAST(CASE WHEN ET.CopyTimeItemID IS NULL THEN 1 ELSE 0 END AS bit),
[Day past 1900] = ET.[In Day past 1900],
[In] = CASE
	WHEN ET.OriginalTimeItemID IS NULL THEN DATEADD(s, ET.[In Seconds], dbo.GetDateFromDaysPast1900(ET.[In Day past 1900]))
	WHEN ET.OriginalTimeItemID=ET.CopyTimeItemID THEN OriginalEmployeeTime.[In]
	ELSE DATEADD(s, ET.[In Seconds], dbo.GetDateFromDaysPast1900(ET.[In Day past 1900]))
END,
[Out] = CASE
	WHEN ET.[In Seconds] = ET.[Out Seconds] THEN NULL
	WHEN (ET.Flags & 1) = 1 THEN DATEADD(s,T.Seconds,T.[In])
	ELSE DATEADD(s,ET.[Out Seconds],dbo.GetDateFromDaysPast1900(ET.[In Day past 1900]))
END,
Seconds = ET.[Out Seconds] - ET.[In Seconds],
[Month Start] = dbo.GetDateFromMDY(MONTH(ET.[In Day past 1900]), 1, YEAR(ET.[In Day past 1900])),
[Week Start] = dbo.GetWeekStart(@date_first, ET.[In Day past 1900]),
ET.[Payroll Start],
ET.[Payroll Stop],
[Project] = ISNULL(T.Project,''),
[Task] = ISNULL(T.Task,''),
[Status] = CASE WHEN T.Status IS NOT NULL THEN T.Status WHEN CalculatedTypeID = @pending_type_id THEN 'Pending' ELSE 'Approved' END,
[Employee Comment] = ISNULL(T.[Employee Comment], '') + ET.[Leave Comment],
[Manager Comment] = ISNULL(T.[Manager Comment], ''),
ET.[Pay Rate],
ET.[Fixed Pay],
[Billing Rate] = ISNULL(T.[Billing Rate], 0),
ET.[OT Eligible],
[Odometer Start] = CASE WHEN ET.OriginalTimeItemID IS NULL THEN 0 WHEN T.[Odometer Start] IS NULL THEN 0 ELSE T.[Odometer Start] END,
[Odometer Stop] = CASE WHEN ET.OriginalTimeItemID IS NULL THEN 0 WHEN T.[Odometer Stop] IS NULL THEN 0 ELSE T.[Odometer Stop] END,
[Mileage] = CASE WHEN ET.OriginalTimeItemID IS NULL THEN 0 WHEN T.[Mileage] IS NULL THEN 0 ELSE T.[Mileage] END,
[Timecard Hours] = [Time Seconds] / 3600.00,
[X2 Hours] = [X2 Seconds] / 3600.00,
[OT Hours] = [OT Seconds] / 3600.00,
[NonOT Hours] = ([Time Seconds] - [OT Seconds] - [X2 Seconds]) / 3600.00,
[Paid Leave Hours] = [Paid Leave Seconds] / 3600.00,
[Unpaid Leave Hours] = [Unpaid Leave Seconds] / 3600.00,
[Holiday Hours] = [Holiday Seconds] / 3600.00,
StatusID = ISNULL(T.StatusID, 1), -- Leave is approved. 1=approved TIME
T.ProjectID,
T.TaskID,
Type = 
CASE
	WHEN TT.Type IS NOT NULL THEN TT.Type 
	WHEN ET.CalculatedTypeID=@pending_type_id THEN 'PEND ' + T.Type
	WHEN ET.CalculatedTypeID=@denied_type_id THEN 'DENIED ' + T.Type
	ELSE ET.[Leave Type]
END,
SourceIn = ISNULL(T.SourceIn, ''),
SourceOut = ISNULL(T.SourceOut, ''),
ET.[Time Seconds],
ET.[Paid Leave Seconds],
ET.[Unpaid Leave Seconds],
ET.[Holiday Seconds],
Hrs = CASE WHEN ET.CalculatedTypeID IN (@denied_type_id) THEN 0 ELSE([Out Seconds] - [In Seconds]) / 3600.00 END,
[Timecard Hours] = [Time Seconds] / 3600.00,
[Paid Leave Hours] = [Paid Leave Seconds] / 3600.00,
[Unpaid Leave Hours] = [Unpaid Leave Seconds] / 3600.00,
[Holiday Hours] = [Holiday Seconds] / 3600.00,
T.[GMT+Hours],
T.[Project Number],
T.[Project Class],
[Paid NonOT Hours] = (CASE WHEN ET.Flags & 64 = 64 THEN 0 ELSE [Time Seconds] - [OT Seconds] - [X2 Seconds] END) / 3600.00,
[Paid Hrs]  =  (
	CASE 
		WHEN [Unpaid Leave Seconds] <> 0 THEN 0
		WHEN ET.Flags & 64 = 64 OR ET.CalculatedTypeID IN (@denied_type_id) THEN 0
		ELSE [Out Seconds] - [In Seconds]
	END
) / 3600.00

FROM #EMPLOYEE_TIME_ROUNDED ET
LEFT JOIN dbo.EmployeeTime OriginalEmployeeTime ON ET.CopyTimeItemID=OriginalEmployeeTime.ItemID
LEFT JOIN dbo.vwEmployeeTime T ON ET.CopyTimeItemID=T.ItemID
LEFT JOIN dbo.TimeType TT ON ET.CalculatedTypeID=TT.TypeID
ORDER BY ET.[In Day past 1900], ET.[In Seconds]
GO
IF OBJECT_id('dbo.spEmployeeLeaveGetUsedBetween') IS NOT NULL DROP PROC dbo.spEmployeeLeaveGetUsedBetween
IF OBJECT_id('dbo.spEmployeeTimeApprovePending') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEmployeeTimeApprovePending AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spEmployeeTimeApprovePending TO public'
END
GO
ALTER PROC dbo.spEmployeeTimeApprovePending
	@start_day int,
	@stop_day int,
	@batch_id int,
	@authorized bit OUT
AS
SET NOCOUNT ON

EXEC dbo.spPermissionGetOnPeopleForCurrentUser2 @batch_id, 262145
DELETE TempX WHERE BatchID=@batch_id AND (X & 2) = 0
SELECT @authorized = CASE WHEN @@ROWCOUNT=0 THEN 1 ELSE 0 END

/*UPDATE E SET [Last Approved] = GETDATE()
FROM dbo.Employee E 
INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID]=E.EmployeeID*/

UPDATE ET SET StatusID=1
FROM dbo.EmployeeTime ET
INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID]=ET.EmployeeID AND ET.StatusID=8 AND ET.Seconds > 0 AND DATEDIFF(d,0,ET.[In]) BETWEEN @start_day AND @stop_day

DELETE dbo.TempX WHERE BatchID=@batch_id OR DATEDIFF(minute, Created, GETDATE()) > 30
GO
IF OBJECT_id('dbo.spOccurrenceList') IS NOT NULL DROP PROC dbo.spOccurrenceList
GO
CREATE PROC dbo.spOccurrenceList
	@batch_id int,
	@balance_min numeric(9,4),
	@balance_max numeric(9,4),
	@day_min int,
	@day_max int,
	@type_id int,
	@expires_min int,
	@expires_max int,
	@authorized bit OUT
AS
SET NOCOUNT ON

EXEC dbo.spPermissionGetOnPeopleForCurrentUser2 @batch_id, 10012
DELETE TempX WHERE BatchID = @batch_id AND (X & 1) = 0

SELECT @authorized = CASE WHEN @@ROWCOUNT=0 THEN 1 ELSE 0 END
SELECT O.*
FROM vwOccurrence O
INNER JOIN TempX X ON X.BatchID=@batch_id AND X.[ID]=O.EmployeeID AND
(
	O.Balance BETWEEN @balance_min AND @balance_max OR
	O.Balance2 BETWEEN @balance_min AND @balance_max
) AND
O.[Day past 1900] BETWEEN @day_min AND @day_max AND
(@type_id IS NULL OR @type_id=O.TypeID) AND
ISNULL([Expires Day past 1900], 0x7FFFFFFF) BETWEEN @expires_min AND @expires_max
ORDER BY Employee, [Day past 1900]

DELETE dbo.TempX WHERE BatchID=@batch_id OR DATEDIFF(minute, Created, GETDATE()) > 30
GO
GRANT EXEC ON dbo.spOccurrenceList TO public
GO
IF OBJECT_id('dbo.spOccurrenceList2') IS NOT NULL DROP PROC dbo.spOccurrenceList2
GO
CREATE PROC dbo.spOccurrenceList2
	@batch_id int,
	@balance_min numeric(9,4),
	@balance_max numeric(9,4),
	@day_min int,
	@day_max int,
	@type_id int,
	@expires_min int,
	@expires_max int,
	@authorized bit OUT
AS
SET NOCOUNT ON

EXEC dbo.spPermissionGetOnPeopleForCurrentUser2 @batch_id, 10012
DELETE TempX WHERE BatchID = @batch_id AND (X & 1) = 0

SELECT @authorized = CASE WHEN @@ROWCOUNT=0 THEN 1 ELSE 0 END
SELECT O.*, V.*
FROM vwOccurrence O
INNER JOIN TempX X ON X.BatchID=@batch_id AND X.[ID]=O.EmployeeID AND
(
	O.Balance BETWEEN @balance_min AND @balance_max OR
	O.Balance2 BETWEEN @balance_min AND @balance_max
) AND
O.[Day past 1900] BETWEEN @day_min AND @day_max AND
(@type_id IS NULL OR @type_id=O.TypeID) AND
ISNULL([Expires Day past 1900], 0x7FFFFFFF) BETWEEN @expires_min AND @expires_max
INNER JOIN dbo.vwEmployeeSecure V ON O.EmployeeID = V.EID
ORDER BY Employee, [Day past 1900]

DELETE dbo.TempX WHERE BatchID=@batch_id OR DATEDIFF(minute, Created, GETDATE()) > 30
GO
GRANT EXEC ON dbo.spOccurrenceList2 TO public
GO
IF OBJECT_id('dbo.spEmployeeTimeDeleteUnusedFromBatch') IS NOT NULL DROP PROC dbo.spEmployeeTimeDeleteUnusedFromBatch
GO
CREATE PROC dbo.spEmployeeTimeDeleteUnusedFromBatch
	@batch_id int
AS
SET NOCOUNT ON

DELETE X FROM TempX X WHERE X.BatchID=@batch_id AND NOT EXISTS (
	SELECT * FROM EmployeeTime T WHERE T.EmployeeID=X.[ID]
)
GO
GRANT EXEC ON dbo.spEmployeeTimeDeleteUnusedFromBatch TO public
GO
IF OBJECT_id('dbo.spEmployeeBatchSubordinates') IS NOT NULL DROP PROC dbo.spEmployeeBatchSubordinates
GO
CREATE PROC dbo.spEmployeeBatchSubordinates
	@batch_id int,
	@include_user bit,
	@include_coworkers bit,
	@exclude_indirect bit = 0,
	@active bit = 1,
	@include_delegates bit = 1
AS
DECLARE @superior_id int

SET NOCOUNT ON

SELECT @superior_id = EmployeeID FROM Employee WHERE SID = SUSER_SID()

IF @@ROWCOUNT = 0 RETURN

IF @exclude_indirect=1
BEGIN
	INSERT TempX(BatchID, [ID])
	SELECT @batch_id, EmployeeID FROM Employee WHERE ManagerID=@superior_id AND (@active IS NULL OR [Active Employee] = @active)
END
ELSe
BEGIN
	INSERT TempX(BatchID, [ID])
	SELECT @batch_id, S.EmployeeID FROM EmployeeSuperior S
	INNER JOIN Employee E ON E.EmployeeID = S.EmployeeID AND S.SuperiorID = @superior_id AND (@active IS NULL OR E.[Active Employee] = @active)
END

IF @include_coworkers = 1
BEGIN
	DECLARE @manager_id int
	SELECT @manager_id = ManagerID FROM Employee WHERE EmployeeID = @superior_id AND (@active IS NULL OR [Active Employee] = @active)
	
	IF @manager_id IS NULL
	INSERT TempX(BatchID, [ID])
	SELECT @batch_id, EmployeeID FROM Employee WHERE ManagerID IS NULL AND (@active IS NULL OR [Active Employee] = @active)

	ELSE
	INSERT TempX(BatchID, [ID])
	SELECT @batch_id, EmployeeID FROM Employee WHERE ManagerID = @manager_id AND (@active IS NULL OR [Active Employee] = @active)
END

IF @include_delegates = 1
BEGIN
	INSERT TempX(BatchID, [ID])
	SELECT @batch_id, E.EmployeeID FROM dbo.Employee E
	INNER JOIN dbo.Employee M ON E.ManagerID = M.EmployeeID AND M.DelegatedManagerID = @superior_id AND (@active IS NULL OR E.[Active Employee] = @active)
END

IF @include_user = 1
INSERT TempX(BatchID, [ID])
SELECT @batch_id, @superior_id
GO
GRANT EXEC ON dbo.spEmployeeBatchSubordinates TO public
GO
ALTER PROCEDURE dbo.spPersonXInsertPrepare
	@race_id int out,
	@i9status_id int out,
	@marital_status_id int out
AS
SET NOCOUNT ON

SELECT TOP 1 @race_id = RaceID FROM PersonX P
INNER JOIN Employee E ON P.PersonID = E.EmployeeID
GROUP BY RaceID ORDER BY COUNT(*) DESC
IF @@ROWCOUNT = 0 SELECT TOP 1 @race_id = RaceID FROM Race

SELECT TOP 1 @i9status_id = I9StatusID FROM PersonX P
INNER JOIN Employee E ON P.PersonID = E.EmployeeID
GROUP BY I9StatusID ORDER BY COUNT(*) DESC
IF @@ROWCOUNT = 0 SELECT TOP 1 @i9status_id = StatusID FROM I9Status WHERE Natural = 1

SET @marital_status_id=NULL
SELECT @marital_status_id = StatusID FROM MaritalStatus WHERE LOWER(Status) LIKE '%unspecified%'
IF @marital_status_id IS NULL SELECT @marital_status_id = StatusID FROM MaritalStatus WHERE LOWER(Status) LIKE '%single%'
IF @marital_status_id IS NULL SELECT TOP 1 @marital_status_id = StatusID FROM MaritalStatus ORDER BY StatusID
GO
CREATE PROC dbo.spEmployeeLeaveGetUsedBetween
	@employee_id int,
	@type_id int,
	@day_min int,
	@day_max int,
	@seconds int out
AS
DECLARE @authorized bit
SET NOCOUNT ON

EXEC dbo.spPermissionInsureForCurrentUserOnPerson @employee_id, 10003, 1, @authorized out

SET @seconds = 0
IF @authorized = 1
BEGIN
	SELECT @seconds = ISNULL(SUM(Seconds), 0) FROM dbo.vwEmployeeLeaveUsedItemApproved WHERE ([Extended Type Mask] & @type_id) != 0 AND EmployeeID = @employee_id AND [Day past 1900] BETWEEN @day_min AND @day_max
END
GO
ALTER TRIGGER dbo.UpdateLastReviewOnEmployeeReviewChange ON dbo.[EmployeeReview] 
FOR INSERT, UPDATE, DELETE 
AS
SET NOCOUNT ON
CREATE TABLE #E(EmployeeID int)

IF EXISTS(SELECT * FROM inserted)
INSERT #E SELECT DISTINCT EmployeeID FROM inserted
ELSE
INSERT #E SELECT DISTINCT EmployeeID FROM deleted

UPDATE Employee SET [LastEmployeeReviewID] = (
	SELECT TOP 1 ER.[ReviewID] FROM EmployeeReview ER WHERE ER.EmployeeID = Employee.EmployeeID ORDER BY ER.[Day past 1900] DESC
) FROM Employee
INNER JOIN #E ON Employee.EmployeeID = #E.EmployeeID

UPDATE Employee SET [Last Performance Review Day past 1900] = R.[Day past 1900]
FROM Employee
INNER JOIN #E ON #E.EmployeeID=Employee.EmployeeID
INNER JOIN EmployeeReview R ON Employee.LastEmployeeReviewID = R.ReviewID
GO
ALTER PROCEDURE dbo.spEmployeeListNextPerformanceReviews
	@start_day int,
	@stop_day int,
	@batch_id int
AS
SET NOCOUNT ON

EXEC dbo.spPermissionGetOnPeopleForCurrentUser2 @batch_id, 16384
DELETE TempX WHERE BatchID = @batch_id AND (X & 1) = 0

SELECT PersonID = E.EmployeeID, Person = V.[Full Name], Initials = V.Initials, [Year] = YEAR(E.[Next Performance Review]), [Month] = MONTH(E.[Next Performance Review]), [Day] = DAY(E.[Next Performance Review]),
[Last Review Type]=ISNULL(R.[Type],''),
[Last Review Rating]=ISNULL(R.Rating,''),
[Last Reviewed by Initials]=ISNULL(R.[Reviewed by Initials],''),
[Last Review Date]=ISNULL(R.[Day past 1900],''),
[Months of Seniority] = DATEDIFF(month,E.[Seniority Begins],GETDATE()),
[Seniority Begins] = E.[Seniority Begins]
FROM vwEmployeeReview E
INNER JOIN TempX T ON T.BatchID = @batch_id AND T.[ID] = E.EmployeeID AND E.[Next Performance Review Day past 1900] BETWEEN @start_day AND @stop_day
INNER JOIN vwPersonCalculated V ON E.EmployeeID = V.PersonID
LEFT JOIN vwEmployeeReview2 R ON E.LastEmployeeReviewID = R.ReviewID
ORDER BY E.[Next Performance Review Day past 1900], V.[List As]

DELETE TempX WHERE BatchID = @batch_id OR DATEDIFF(hh, Created, GETDATE()) > 1
GO
INSERT ReminderType(ReminderTypeID, [Reminder Type], OwnerID, [Days before Due Day], Manager, Employee, Urgent, [To Lower])
SELECT 15,'Seniority Anniversary',NULL,14,0,0,0,'wait for the employee''s anniversary to pass' WHERE NOT EXISTS (SELECT * FROM ReminderType WHERE ReminderTypeID=15)
UNION
SELECT 16, 'Hire Event', NULL, 7, 0, 0, 0, 'wait for the date of hire to pass' WHERE NOT EXISTS (SELECT * FROM ReminderType WHERE ReminderTypeID=16)
UNION
SELECT 17, 'Termination Event', NULL, 7, 0, 0, 0, 'wait for the date of termination to pass' WHERE NOT EXISTS (SELECT * FROM ReminderType WHERE ReminderTypeID=17)
GO
ALTER PROCEDURE dbo.spEmployeeBenefitList
	@exclude_inactive bit,
	@employee_id int,
	@benefit_id int,
	@plan varchar(50),
	@provider varchar(50),
	@coverage varchar(50),
	@zip varchar(50),
	@dob_min int,
	@dob_max int,
	@batch_id int = NULL,
	@authorized bit = 1 OUT
AS
SET NOCOUNT ON

IF @batch_id IS NULL
BEGIN
	SELECT @batch_id = RAND() * 2147483647
	INSERT TempX(BatchID, [ID]) SELECT @batch_id, EmployeeID
	FROM Employee WHERE (@employee_id IS NULL AND [Active Employee]=1) OR EmployeeID=@employee_id
END

--EXEC dbo.spPermissionGetOnPeopleForCurrentUser2 @batch_id, 536870912
--DELETE TempX WHERE BatchID=@batch_id AND (X & 1) = 0
--SELECT @authorized = CASE WHEN @@ROWCOUNT=0 THEN 1 ELSE 0 END
SET @authorized = 1

SELECT EB.*
FROM TempX X
INNER JOIN vwEmployeeBenefitSecure EB ON X.BatchID = @batch_id AND X.[ID] = EB.EmployeeID AND 
(EB.EmployeeBenefitID IS NULL OR EB.[DOB Day past 1900] IS NULL OR EB.[DOB Day past 1900] BETWEEN @dob_min AND @dob_max) AND
(LEN(@zip) = 0 OR EB.[ZIP] = @zip) AND
(LEN(@coverage) = 0 OR EB.Coverage = @coverage) AND
(LEN(@provider) = 0 OR EB.Provider = @provider) AND
(LEN(@plan) = 0 OR EB.[Plan] = @plan) AND
(@benefit_id IS NULL OR EB.BenefitID = @benefit_id) AND
(@exclude_inactive = 0 OR EB.Active = 1) 

ORDER BY EB.[List As], EB.Benefit                                                                                                                                                                                              

DELETE TempX WHERE BatchID = @batch_id OR DATEDIFF(hh, Created, GETDATE()) > 1
GO
ALTER PROCEDURE dbo.spEmployeeBenefitSelect
	@employee_id int,
	@benefit_id int
AS
SET NOCOUNT ON

SELECT EB.* FROM vwEmployeeBenefitSecure EB WHERE EB.EmployeeID = @employee_id AND EB.BenefitID = @benefit_id
GO
IF OBJECT_id('spEmployeeTimeCalculateFilter2') IS NOT NULL DROP PROC dbo.spEmployeeTimeCalculateFilter2
GO
CREATE PROC dbo.spEmployeeTimeCalculateFilter2
	@batch_id int,
 	@start_date datetime out,
 	@group_by smallint,
	@work_week int,
	@work_week_year int,
	@time_type_mask int,
	@leave_type_mask int,
	@include_pending_time bit,
	@row_group_by smallint,
	@authorized bit = 0 OUT
AS
SET NOCOUNT ON
DECLARE @stop_date datetime


IF @group_by = 0
BEGIN
	-- Strips off hh:mm
	SELECT @start_date = DATEADD(d, 0, DATEDIFF(d, 0, @start_date))

	SELECT @stop_date = DATEADD(d,16,@start_date)
	SELECT @stop_date = DATEADD(ms, -1 ,@stop_date)
END
ELSE IF @group_by = 1
BEGIN
	IF (DATEPART(wk, dbo.GetDateFromMDY(12, 31, @work_week_year)) < @work_week)
	-- @work_week might be 53 or 54, but the max week in @work_week_year is only 52 or 53 (less than given @work_week number)
		RETURN
	

	DECLARE @date_first int
	SELECT @date_first = DatePartDW FROM vwDateFirst

	DECLARE @first_ww datetime
	SELECT @first_ww = dbo.GetDateFromMDY(1, 1, @work_week_year) -- Jan 1

	SET DATEFIRST 7 -- Sunday is first day for dw function

	SELECT @start_date = DATEADD(d, @date_first - DATEPART(dw,@first_ww), @first_ww) -- Go to start of week
	IF @start_date > @first_ww SET @start_date = DATEADD(d,-7,@start_date)
	SELECT @first_ww = DATEADD(wk,@work_week-1,@start_date) -- Add weeks

	SELECT @start_date = @first_ww
	SELECT @stop_date = DATEADD(wk,16,@start_date)
END
ELSE IF @group_by = 2
BEGIN
	DECLARE @group_id int
	SELECT @group_id = GroupID FROM LeaveRatePeriod WHERE Payroll = 1 AND PeriodID = (SELECT CurrentPayrollPeriodID FROM dbo.Constant)



	-- Gets first payroll period start dates
	CREATE TABLE #P(StartDate datetime, StopDate datetime)
	INSERT #P(StartDate, StopDate)
	EXEC dbo.spEmployeeTimeCalculateFilterInverse @start_date, 1
	SELECT @start_date = StartDate FROM #P

	IF @group_id = 8
		SELECT @stop_date = DATEADD(m,2*16,@start_date)
	ELSE IF @group_id = 16
		SELECT @stop_date = DATEADD(m,16,@start_date)
	ELSE IF @group_id = 32
		SELECT @stop_date = DATEADD(m,16/2,@start_date)
	ELSE IF @group_id = 64
		SELECT @stop_date = DATEADD(wk,2*16,@start_date)
	ELSE IF @group_id = 128
		SELECT @stop_date = DATEADD(wk,16,@start_date)

END
ELSE IF @group_by = 3
	SELECT @stop_date = DATEADD(m,16,@start_date)
	
DECLARE @start_day int, @stop_day int
SELECT @start_day = DATEDIFF(d,0,@start_date), @stop_day = DATEDIFF(d,0,@stop_date)

DECLARE @pending_type_id int, @authorized_leave bit

SET @authorized_leave = 0
EXEC dbo.spPermissionGetOnPeopleForCurrentUser2 @batch_id, 10001

IF EXISTS(SELECT * FROM TempX WHERE (X & 1) = 0) SET @authorized_leave = 0
ELSE SET @authorized_leave = 1


-- Insert leave
SELECT L.EmployeeID,
DD = L.[Day past 1900],
Seconds = 0 - L.Seconds,
PayrollPeriod = 0
INTO #ET
FROM dbo.vwEmployeeLeaveApproved L
INNER JOIN TempX X ON  L.Seconds < 0
AND X.BatchID=@batch_id AND X.[ID]=L.EmployeeID AND (X.X & 1) = 1
AND (L.[Extended Type Mask] & @leave_type_mask) != 0
AND L.[Day past 1900] BETWEEN @start_day AND @stop_day



CREATE TABLE #EMPLOYEE_TIME_ROUNDED(
	TempItemID int NOT NULL IDENTITY(1,1) PRIMARY KEY,
	EmployeeID int NOT NULL,
	OriginalTypeID int NOT NULL, 
	CalculatedTypeID int NOT NULL,
	[In Day past 1900] int NOT NULL, 
	[OT Eligible] bit NOT NULL,
	[OT Disable] bit NOT NULL,
	[Pay Rate] money NOT NULL,
	[Fixed Pay] money NOT NULL DEFAULT(0),
	[Fixed Items] int DEFAULT(0),
	Regular bit DEFAULT(0),
	[In Seconds] int NOT NULL,
	[Out Seconds] int NOT NULL,
	TimeSchemaID int NOT NULL,
	ShiftDiffItemID int NULL,
	TempShiftDiffSeconds int NULL,
	TempShiftDiffItemID int NULL,
	OriginalTimeItemID int NULL,
	CopyTimeItemID int NULL,
	[Time Seconds] int NOT NULL DEFAULT(0),
	[Holiday Seconds] int NOT NULL DEFAULT(0),
	[OT Seconds] int NOT NULL DEFAULT(0),
	Flags int NOT NULL DEFAULT(0),
	[Actual In] datetime NULL,
	[Actual Out] datetime NULL,
	[Base Seconds] int NOT NULL DEFAULT(0),
	[X2 Seconds] int NOT NULL DEFAULT(0)
)

DECLARE @denied_type_id int
EXEC dbo.spEmployeeTimeRoundAndCalcOT @batch_id, 0, @start_day, @stop_day, NULL, NULL, @authorized OUT, @pending_type_id OUT, @denied_type_id OUT
IF @authorized_leave=0 SET @authorized=0


-- Insert time
INSERT #ET
SELECT ET.EmployeeID,
DD = ET.[In Day past 1900],
Seconds = ET.[Out Seconds] - ET.[In Seconds],
PayrollPeriod = 0
FROM #EMPLOYEE_TIME_ROUNDED ET WHERE 
(@include_pending_time = 1 AND ET.CalculatedTypeID = @pending_type_id) OR
((ET.CalculatedTypeID & @time_type_mask) != 0)


DELETE dbo.TempX WHERE BatchID=@batch_id OR DATEDIFF(minute, Created, GETDATE()) > 30

CREATE TABLE #ET2
(
	EmployeeID int,
	DD datetime,
	Seconds int,
	PayrollPeriod int
)


INSERT #ET2
SELECT EmployeeID, DD = DATEADD(d, 0, DD), Seconds = SUM(Seconds), PayrollPeriod = MIN(PayrollPeriod)
FROM #ET GROUP BY EmployeeID, DD

CREATE TABLE #TotalByPerson(PersonID int NOT NULL PRIMARY KEY,
	C0 numeric(9,2), C1 numeric(9,2), C2 numeric(9,2), C3 numeric(9,2), C4 numeric(9,2), C5 numeric(9,2), C6 numeric(9,2), C7 numeric(9,2), C8 numeric(9,2), C9 numeric(9,2), C10 numeric(9,2), C11 numeric(9,2), C12 numeric(9,2), C13 numeric(9,2), C14 numeric(9,2), C15 numeric(9,2)
)



-- SUM the Seconds of the work day that has 2 or more entries depending on the group by
IF @group_by = 0
-- day
BEGIN
--	SELECT EmployeeID, [Work day],Seconds=SUM(Seconds) FROM #ET2  GROUP BY [Work day],EmployeeID

	INSERT #TotalByPerson
	SELECT P.EmployeeID,
		C0 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.EmployeeID AND DATEDIFF(dd, @start_date, #ET2.[DD]) = 0), 0) / 3600.00,
		C1 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.EmployeeID AND DATEDIFF(dd, @start_date, #ET2.[DD]) = 1), 0) / 3600.00,
		C2 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.EmployeeID AND DATEDIFF(dd, @start_date, #ET2.[DD]) = 2), 0) / 3600.00,
		C3 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.EmployeeID AND DATEDIFF(dd, @start_date, #ET2.[DD]) = 3), 0) / 3600.00,
		C4 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.EmployeeID AND DATEDIFF(dd, @start_date, #ET2.[DD]) = 4), 0) / 3600.00,
		C5 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.EmployeeID AND DATEDIFF(dd, @start_date, #ET2.[DD]) = 5), 0) / 3600.00,
		C6 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.EmployeeID AND DATEDIFF(dd, @start_date, #ET2.[DD]) = 6), 0) / 3600.00,
		C7 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.EmployeeID AND DATEDIFF(dd, @start_date, #ET2.[DD]) = 7), 0) / 3600.00,
		C8 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.EmployeeID AND DATEDIFF(dd, @start_date, #ET2.[DD]) = 8), 0) / 3600.00,
		C9 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.EmployeeID AND DATEDIFF(dd, @start_date, #ET2.[DD]) = 9), 0) / 3600.00,
		C10 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.EmployeeID AND DATEDIFF(dd, @start_date, #ET2.[DD]) = 10), 0) / 3600.00,
		C11 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.EmployeeID AND DATEDIFF(dd, @start_date, #ET2.[DD]) = 11), 0) / 3600.00,
		C12 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.EmployeeID AND DATEDIFF(dd, @start_date, #ET2.[DD]) = 12), 0) / 3600.00,
		C13 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.EmployeeID AND DATEDIFF(dd, @start_date, #ET2.[DD]) = 13), 0) / 3600.00,
		C14 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.EmployeeID AND DATEDIFF(dd, @start_date, #ET2.[DD]) = 14), 0) / 3600.00,
		C15 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.EmployeeID AND DATEDIFF(dd, @start_date, #ET2.[DD]) = 15), 0) / 3600.00
	FROM Employee P WHERE P.EmployeeID IN
	(
		SELECT EmployeeID FROM #ET2
	)
END

ELSE IF @group_by = 1
-- Work week
BEGIN
	DECLARE @ww0 int
	SET @ww0 = DATEDIFF(d,0,@first_ww)

	INSERT #TotalByPerson
	SELECT P.EmployeeID,
		C0 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.EmployeeID AND #ET2.[DD] - @ww0 BETWEEN 0 AND 6), 0) / 3600.00,
		C1 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.EmployeeID AND #ET2.[DD] - @ww0 BETWEEN 7 AND 13), 0) / 3600.00,
		C2 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.EmployeeID AND #ET2.[DD] - @ww0 BETWEEN 14 AND 20), 0) / 3600.00,
		C3 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.EmployeeID AND #ET2.[DD] - @ww0 BETWEEN 21 AND 27), 0) / 3600.00,
		C4 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.EmployeeID AND #ET2.[DD] - @ww0 BETWEEN 28 AND 34), 0) / 3600.00,
		C5 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.EmployeeID AND #ET2.[DD] - @ww0 BETWEEN 35 AND 41), 0) / 3600.00,
		C6 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.EmployeeID AND #ET2.[DD] - @ww0 BETWEEN 42 AND 48), 0) / 3600.00,
		C7 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.EmployeeID AND #ET2.[DD] - @ww0 BETWEEN 49 AND 55), 0) / 3600.00,
		C8 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.EmployeeID AND #ET2.[DD] - @ww0 BETWEEN 56 AND 62), 0) / 3600.00,
		C9 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.EmployeeID AND #ET2.[DD] - @ww0 BETWEEN 63 AND 69), 0) / 3600.00,
		C10 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.EmployeeID AND #ET2.[DD] - @ww0 BETWEEN 70 AND 76), 0) / 3600.00,
		C11 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.EmployeeID AND #ET2.[DD] - @ww0 BETWEEN 77 AND 83), 0) / 3600.00,
		C12 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.EmployeeID AND #ET2.[DD] - @ww0 BETWEEN 84 AND 90), 0) / 3600.00,
		C13 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.EmployeeID AND #ET2.[DD] - @ww0 BETWEEN 91 AND 97), 0) / 3600.00,
		C14 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.EmployeeID AND #ET2.[DD] - @ww0 BETWEEN 98 AND 104), 0) / 3600.00,
		C15 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.EmployeeID AND #ET2.[DD] - @ww0 BETWEEN 105 AND 111), 0) / 3600.00
	FROM Employee P WHERE P.EmployeeID IN
	(
		SELECT EmployeeID FROM #ET2
	)

END

ELSE IF @group_by = 2
-- payroll
BEGIN
	DECLARE @first_payroll_period int
	SELECT @first_payroll_period = dbo.GetPayrollPeriodNumber(@start_date)
	UPDATE #ET2 SET [PayrollPeriod]= dbo.GetPayrollPeriodNumber(#ET2.[DD])

	INSERT #TotalByPerson
	SELECT P.EmployeeID,
		C0 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.EmployeeID AND #ET2.[PayrollPeriod] - @first_payroll_period = 0),0) / 3600.00,
		C1 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.EmployeeID AND #ET2.[PayrollPeriod] - @first_payroll_period = 1),0) / 3600.00,
		C2 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.EmployeeID AND #ET2.[PayrollPeriod] - @first_payroll_period = 2),0) / 3600.00,
		C3 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.EmployeeID AND #ET2.[PayrollPeriod] - @first_payroll_period = 3),0) / 3600.00,
		C4 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.EmployeeID AND #ET2.[PayrollPeriod] - @first_payroll_period = 4),0) / 3600.00,
		C5 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.EmployeeID AND #ET2.[PayrollPeriod] - @first_payroll_period = 5),0) / 3600.00,
		C6 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.EmployeeID AND #ET2.[PayrollPeriod] - @first_payroll_period = 6),0) / 3600.00,
		C7 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.EmployeeID AND #ET2.[PayrollPeriod] - @first_payroll_period = 7),0) / 3600.00,
		C8 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.EmployeeID AND #ET2.[PayrollPeriod] - @first_payroll_period = 8),0) / 3600.00,
		C9 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.EmployeeID AND #ET2.[PayrollPeriod] - @first_payroll_period = 9),0) / 3600.00,
		C10 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.EmployeeID AND #ET2.[PayrollPeriod] - @first_payroll_period = 10),0) / 3600.00,
		C11 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.EmployeeID AND #ET2.[PayrollPeriod] - @first_payroll_period = 11),0) / 3600.00,
		C12 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.EmployeeID AND #ET2.[PayrollPeriod] - @first_payroll_period = 12),0) / 3600.00,
		C13 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.EmployeeID AND #ET2.[PayrollPeriod] - @first_payroll_period = 13),0) / 3600.00,
		C14 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.EmployeeID AND #ET2.[PayrollPeriod] - @first_payroll_period = 14),0) / 3600.00,
		C15 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.EmployeeID AND #ET2.[PayrollPeriod] - @first_payroll_period = 15),0) / 3600.00
	FROM Employee P WHERE P.EmployeeID IN
	(
		SELECT EmployeeID FROM #ET2
	)

END

ELSE IF @group_by = 3
-- month
BEGIN
	UPDATE #ET2 SET [DD]=DATEADD(d,1-DAY([DD]),[DD])

	INSERT #TotalByPerson
	SELECT P.EmployeeID,
		C0 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.EmployeeID AND DATEDIFF(m, @start_date, #ET2.[DD]) = 0), 0) / 3600.00,
		C1 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.EmployeeID AND DATEDIFF(m, @start_date, #ET2.[DD]) = 1), 0) / 3600.00,
		C2 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.EmployeeID AND DATEDIFF(m, @start_date, #ET2.[DD]) = 2), 0) / 3600.00,
		C3 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.EmployeeID AND DATEDIFF(m, @start_date, #ET2.[DD]) = 3), 0) / 3600.00,
		C4 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.EmployeeID AND DATEDIFF(m, @start_date, #ET2.[DD]) = 4), 0) / 3600.00,
		C5 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.EmployeeID AND DATEDIFF(m, @start_date, #ET2.[DD]) = 5), 0) / 3600.00,
		C6 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.EmployeeID AND DATEDIFF(m, @start_date, #ET2.[DD]) = 6), 0) / 3600.00,
		C7 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.EmployeeID AND DATEDIFF(m, @start_date, #ET2.[DD]) = 7), 0) / 3600.00,
		C8 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.EmployeeID AND DATEDIFF(m, @start_date, #ET2.[DD]) = 8), 0) / 3600.00,
		C9 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.EmployeeID AND DATEDIFF(m, @start_date, #ET2.[DD]) = 9), 0) / 3600.00,
		C10 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.EmployeeID AND DATEDIFF(m, @start_date, #ET2.[DD]) = 10), 0) / 3600.00,
		C11 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.EmployeeID AND DATEDIFF(m, @start_date, #ET2.[DD]) = 11), 0) / 3600.00,
		C12 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.EmployeeID AND DATEDIFF(m, @start_date, #ET2.[DD]) = 12), 0) / 3600.00,
		C13 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.EmployeeID AND DATEDIFF(m, @start_date, #ET2.[DD]) = 13), 0) / 3600.00,
		C14 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.EmployeeID AND DATEDIFF(m, @start_date, #ET2.[DD]) = 14), 0) / 3600.00,
		C15 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.EmployeeID AND DATEDIFF(m, @start_date, #ET2.[DD]) = 15), 0) / 3600.00
	FROM Employee P WHERE P.EmployeeID IN
	(
		SELECT EmployeeID FROM #ET2
	)
END

/* Employee = 0,
		Location = 1,
		Division = 2,
		Department = 3,
		Manager = 4,
		Position = 12 */






IF @row_group_by = 1
	SELECT RowID = L.LocationID,
	RowText = L.[List As],
	C0=SUM(T.C0), C1=SUM(T.C1), C2=SUM(T.C2), C3=SUM(T.C3), C4=SUM(T.C4), C5=SUM(T.C5), C6=SUM(T.C6), C7=SUM(T.C7), C8=SUM(T.C8), C9=SUM(T.C9), C10=SUM(T.C10), C11=SUM(T.C11), C12=SUM(T.C12), C13=SUM(T.C13), C14=SUM(T.C14), C15=SUM(T.C15), [Order]=0
	FROM #TotalByPerson T
	INNER JOIN Employee E ON T.PersonID = E.EmployeeID 
	INNER JOIN Location L ON E.LocationID = L.LocationID
	GROUP BY L.LocationID, L.[List As]
	UNION ALL
	SELECT NULL, 'Total', C0=SUM(T.C0), C1=SUM(T.C1), C2=SUM(T.C2), C3=SUM(T.C3), C4=SUM(T.C4), C5=SUM(T.C5), C6=SUM(T.C6), C7=SUM(T.C7), C8=SUM(T.C8), C9=SUM(T.C9), C10=SUM(T.C10), C11=SUM(T.C11), C12=SUM(T.C12), C13=SUM(T.C13), C14=SUM(T.C14), C15=SUM(T.C15), [Order]=1
	FROM #TotalByPerson T
	ORDER BY [Order], RowText
ELSE IF @row_group_by = 2
	SELECT RowID = D.DivisionID,
	RowText = D.Division,
	C0=SUM(T.C0), C1=SUM(T.C1), C2=SUM(T.C2), C3=SUM(T.C3), C4=SUM(T.C4), C5=SUM(T.C5), C6=SUM(T.C6), C7=SUM(T.C7), C8=SUM(T.C8), C9=SUM(T.C9), C10=SUM(T.C10), C11=SUM(T.C11), C12=SUM(T.C12), C13=SUM(T.C13), C14=SUM(T.C14), C15=SUM(T.C15), [Order]=0
	FROM #TotalByPerson T
	INNER JOIN Employee E ON T.PersonID = E.EmployeeID 
	INNER JOIN Division D ON E.DivisionID = D.DivisionID
	GROUP BY D.DivisionID, D.Division
	UNION ALL
	SELECT NULL, 'Total', C0=SUM(T.C0), C1=SUM(T.C1), C2=SUM(T.C2), C3=SUM(T.C3), C4=SUM(T.C4), C5=SUM(T.C5), C6=SUM(T.C6), C7=SUM(T.C7), C8=SUM(T.C8), C9=SUM(T.C9), C10=SUM(T.C10), C11=SUM(T.C11), C12=SUM(T.C12), C13=SUM(T.C13), C14=SUM(T.C14), C15=SUM(T.C15), [Order]=1
	FROM #TotalByPerson T
	ORDER BY [Order], RowText
ELSE IF @row_group_by = 3
	SELECT RowID = D.DepartmentID,
	RowText = D.Department,
	C0=SUM(T.C0), C1=SUM(T.C1), C2=SUM(T.C2), C3=SUM(T.C3), C4=SUM(T.C4), C5=SUM(T.C5), C6=SUM(T.C6), C7=SUM(T.C7), C8=SUM(T.C8), C9=SUM(T.C9), C10=SUM(T.C10), C11=SUM(T.C11), C12=SUM(T.C12), C13=SUM(T.C13), C14=SUM(T.C14), C15=SUM(T.C15), [Order]=0
	FROM #TotalByPerson T
	INNER JOIN Employee E ON T.PersonID = E.EmployeeID 
	INNER JOIN Department D ON E.DepartmentID = D.DepartmentID
	GROUP BY D.DepartmentID, D.Department
	UNION ALL
	SELECT NULL, 'Total', C0=SUM(T.C0), C1=SUM(T.C1), C2=SUM(T.C2), C3=SUM(T.C3), C4=SUM(T.C4), C5=SUM(T.C5), C6=SUM(T.C6), C7=SUM(T.C7), C8=SUM(T.C8), C9=SUM(T.C9), C10=SUM(T.C10), C11=SUM(T.C11), C12=SUM(T.C12), C13=SUM(T.C13), C14=SUM(T.C14), C15=SUM(T.C15), [Order]=1
	FROM #TotalByPerson T
	ORDER BY [Order], RowText
ELSE IF @row_group_by = 4
	SELECT RowID = M.PersonID,
	RowText = ISNULL(M.[List As], '<None>'),
	C0=SUM(T.C0), C1=SUM(T.C1), C2=SUM(T.C2), C3=SUM(T.C3), C4=SUM(T.C4), C5=SUM(T.C5), C6=SUM(T.C6), C7=SUM(T.C7), C8=SUM(T.C8), C9=SUM(T.C9), C10=SUM(T.C10), C11=SUM(T.C11), C12=SUM(T.C12), C13=SUM(T.C13), C14=SUM(T.C14), C15=SUM(T.C15), [Order]=0
	FROM #TotalByPerson T
	INNER JOIN Employee E ON T.PersonID = E.EmployeeID 
	LEFT JOIN dbo.vwPersonListAs M ON E.ManagerID = M.PersonID
	GROUP BY M.PersonID, M.[List As]
	UNION ALL
	SELECT NULL, 'Total', C0=SUM(T.C0), C1=SUM(T.C1), C2=SUM(T.C2), C3=SUM(T.C3), C4=SUM(T.C4), C5=SUM(T.C5), C6=SUM(T.C6), C7=SUM(T.C7), C8=SUM(T.C8), C9=SUM(T.C9), C10=SUM(T.C10), C11=SUM(T.C11), C12=SUM(T.C12), C13=SUM(T.C13), C14=SUM(T.C14), C15=SUM(T.C15), [Order]=1
	FROM #TotalByPerson T
	ORDER BY [Order], RowText
ELSE IF @row_group_by = 12
	SELECT RowID = E.PositionID,
	RowText = CASE E.[Job Title] WHEN '' THEN '<None>' ELSE E.[Job Title] END,
	C0=SUM(T.C0), C1=SUM(T.C1), C2=SUM(T.C2), C3=SUM(T.C3), C4=SUM(T.C4), C5=SUM(T.C5), C6=SUM(T.C6), C7=SUM(T.C7), C8=SUM(T.C8), C9=SUM(T.C9), C10=SUM(T.C10), C11=SUM(T.C11), C12=SUM(T.C12), C13=SUM(T.C13), C14=SUM(T.C14), C15=SUM(T.C15), [Order]=0
	FROM #TotalByPerson T
	INNER JOIN vwEmployeeLastCompensation E ON T.PersonID = E.EmployeeID 
	GROUP BY E.PositionID, E.[Job Title]
	UNION ALL
	SELECT NULL, 'Total', C0=SUM(T.C0), C1=SUM(T.C1), C2=SUM(T.C2), C3=SUM(T.C3), C4=SUM(T.C4), C5=SUM(T.C5), C6=SUM(T.C6), C7=SUM(T.C7), C8=SUM(T.C8), C9=SUM(T.C9), C10=SUM(T.C10), C11=SUM(T.C11), C12=SUM(T.C12), C13=SUM(T.C13), C14=SUM(T.C14), C15=SUM(T.C15), [Order]=1
	FROM #TotalByPerson T
	ORDER BY [Order], RowText
ELSE
	SELECT RowID = T.PersonID,
	RowText = P.[List As],
	T.C0, T.C1, T.C2, T.C3, T.C4, T.C5, T.C6, T.C7, T.C8, T.C9, T.C10, T.C11, T.C12, T.C13, T.C14, T.C15, [Order]=0
	FROM #TotalByPerson T
	INNER JOIN dbo.vwPersonListAs P ON T.PersonID = P.PersonID 
	UNION
	SELECT NULL, 'Total', C0=SUM(T.C0), C1=SUM(T.C1), C2=SUM(T.C2), C3=SUM(T.C3), C4=SUM(T.C4), C5=SUM(T.C5), C6=SUM(T.C6), C7=SUM(T.C7), C8=SUM(T.C8), C9=SUM(T.C9), C10=SUM(T.C10), C11=SUM(T.C11), C12=SUM(T.C12), C13=SUM(T.C13), C14=SUM(T.C14), C15=SUM(T.C15), [Order]=1
	FROM #TotalByPerson T
	ORDER BY [Order], RowText
GO
GRANT EXEC ON dbo.spEmployeeTimeCalculateFilter2 TO public
GO
ALTER PROC dbo.spCOBRAListTracked
AS
DECLARE @batch_id int

SELECT @batch_id = RAND() * 2147483647

INSERT TempX(BatchID, [ID], X)
SELECT @batch_id, EmployeeID, 0 FROM Employee WHERE [Track COBRA] = 1

EXEC dbo.spPermissionGetOnPeopleForCurrentUser2 @batch_id, 536870912
DELETE TempX WHERE BatchID = @batch_id AND (X & 1) = 0

SELECT *, [Active Benefits] = CAST('' AS varchar(4000)), 
[Employee Premium] =
ISNULL((
	SELECT SUM(EB.[Employee Premium]) FROM vwEmployeeBenefit EB WHERE EB.EmployeeID = C.EmployeeID AND EB.Active = 1
), 0),
[Employer Premium] =
ISNULL((
	SELECT SUM(EB.[Employer Premium]) FROM vwEmployeeBenefit EB WHERE EB.EmployeeID = C.EmployeeID AND EB.Active = 1
), 0)
INTO #C
FROM vwEmployeeCOBRA C
INNER JOIN TempX X ON X.BatchID = @batch_id AND X.[ID] = C.EmployeeID AND C.[Track COBRA] = 1
ORDER BY C.Employee

DECLARE @benefit varchar(50)
DECLARE @benefit_id int

SELECT TOP 1 @benefit_id = BenefitID, @benefit = Benefit FROM Benefit ORDER BY Benefit 
WHILE @@ROWCOUNT > 0
BEGIN
	UPDATE #C SET [Active Benefits] = [Active Benefits] + CASE WHEN LEN(#C.[Active Benefits]) = 0 THEN '' ELSE ', ' END + 
		EB.Provider + CASE WHEN LEN(EB.[Provider]) = 0 THEN '' ELSE ' ' END +
		EB.[Plan] + CASE WHEN LEN(EB.[Plan]) = 0 THEN '' ELSE ' ' END +
		@benefit
	FROM #C
	INNER JOIN vwEmployeeBenefit EB ON EB.EmployeeID = #C.EmployeeID AND EB.BenefitID = @benefit_id AND EB.Active  = 1

	SELECT TOP 1 @benefit_id = BenefitID, @benefit = Benefit FROM Benefit WHERE Benefit > @benefit ORDER BY Benefit 
END

SELECT *, [Total Premium] = [Employer Premium] + [Employee Premium] FROM #C

DELETE TempX WHERE BatchID = @batch_id
GO
IF OBJECT_id('dbo.spPersonListPrepareBatchPAnd') IS NOT NULL DROP PROC dbo.spPersonListPrepareBatchPAnd
GO
CREATE PROC dbo.spPersonListPrepareBatchPAnd
	@batch_id int,
	@field_id int, -- ColumnGrid.FieldID
	@operation int,
	@value sql_variant,
	@limit sql_variant
AS
DECLARE @t varchar(50)
DECLARE @i int
DECLARE @f bit
DECLARE @d datetime, @d2 datetime
DECLARE @x int, @y int
DECLARE @type sysname

SET NOCOUNT ON

SELECT @type = CAST(SQL_VARIANT_PROPERTY ( @value, 'BaseType' ) AS sysname), @t = null, @i= null, @f = null, @d = null, @d2 = null, @x = null, @y = null

IF @type IN ('varchar', 'nvarchar') SELECT @t = '%' + CAST(@value AS varchar(50)) + '%'
ELSE IF @type = 'int' SELECT @i = CAST(@value AS int)
ELSE IF @type = 'bit' SELECT @f = CAST(@value AS bit)
ELSE IF @type IN ('datetime', 'smalldatetime') SELECT @d = CAST(@value AS datetime)

IF @limit IS NOT NULL SET @d2 = CAST(@limit AS datetime)

SELECT @x = DATEDIFF(d, 0, @d), @y = DATEDIFF(d, 0, @d2)

-- Active Employee
IF @field_id = 71 DELETE TempX FROM TempX X
INNER JOIN Employee E ON X.BatchID = @batch_id AND X.[ID] = E.EmployeeID AND
(
	(@operation=0x200 AND E.[Active Employee] = 0) OR 
	(@operation=0x400 AND E.[Active Employee] = 1)
)

-- Training Began
ELSE IF @field_id = 1031 AND @operation=0x200 
DELETE TempX FROM TempX X WHERE X.BatchID = @batch_id AND NOT EXISTS (
	SELECT * FROM PersonXTraining T WHERE T.PersonID = X.[ID]
)

ELSE IF @field_id = 1031 AND @operation=0x400
DELETE TempX FROM TempX X WHERE X.BatchID = @batch_id AND EXISTS (
	SELECT * FROM PersonXTraining T WHERE T.PersonID = X.[ID]
)

ELSE IF @field_id = 1031 AND @operation=1
DELETE TempX FROM TempX X WHERE X.BatchID = @batch_id AND NOT EXISTS (
	SELECT * FROM PersonXTraining T WHERE T.PersonID = X.[ID] AND T.TrainingID = @i
)

ELSE IF @field_id = 1031 AND @operation=2
DELETE TempX FROM TempX X WHERE X.BatchID = @batch_id AND EXISTS (
	SELECT * FROM PersonXTraining T WHERE T.PersonID = X.[ID] AND T.TrainingID = @i
)

-- FLSA Exempt
ELSE IF @field_id = 1030
DELETE TempX FROM TempX X 
INNER JOIN Employee E ON X.BatchID = @batch_id AND X.[ID] = E.EmployeeID
LEFT JOIN vwEmployeeCompensation C ON E.LastCompensationID = C.CompensationID 
WHERE E.LastCompensationID IS NULL OR (
	(@operation = 0x200 AND C.[FLSA Exempt] = 0) OR
	(@operation = 0x400 AND C.[FLSA Exempt] = 1)
)

-- Race
ELSE IF @field_id = 32
DELETE TempX FROM TempX X
INNER JOIN PersonX P ON X.BatchID = @batch_id AND X.[ID] = P.PersonID AND
(
	(@operation = 1 AND P.RaceID != @i) OR
	(@operation = 2 AND P.RaceID = @i)
)

-- Salaried 72
ELSE IF @field_id = 72 DELETE TempX FROM TempX X
INNER JOIN Employee E ON X.BatchID = @batch_id AND X.[ID] = E.EmployeeID AND
(
	(@operation=0x200 AND E.[Salaried] = 0) OR 
	(@operation=0x400 AND E.[Salaried] = 1)
)

-- PersonID
ELSE IF @field_id=1003 DELETE TempX WHERE BatchID=@batch_id AND [ID]=@i

-- Current Position 56
ELSE IF @field_id=56 DELETE TempX FROM TempX X
INNER JOIN Employee E ON X.BatchID = @batch_id AND X.[ID] = E.EmployeeID 
LEFT JOIN EmployeeCompensation EC ON E.LastCompensationID = EC.CompensationID
LEFT JOIN Position P ON EC.PositionID = P.PositionID WHERE
(
	(EC.PositionID IS NULL AND @i IS NULL AND @operation=2) OR
	(EC.PositionID IS NOT NULL AND @i IS NULL AND @operation=1) OR
	(EC.PositionID IS NULL AND @i IS NOT NULL AND @operation=1) OR
	(EC.PositionID IS NOT NULL AND @i IS NOT NULL AND @operation=1 AND EC.PositionID <> @i) OR 
	(EC.PositionID IS NOT NULL AND @i IS NOT NULL AND @operation=2 AND EC.PositionID = @i) OR
	(@operation=4 AND ISNULL(P.[Job Title],'') NOT LIKE @t) OR (@operation=8 AND ISNULL(P.[Job Title],'') LIKE @t)
)

-- Division 53
ELSE IF @field_id=53 DELETE TempX FROM TempX X
INNER JOIN Employee E ON X.BatchID = @batch_id AND X.[ID] = E.EmployeeID
INNER JOIN Division V ON E.DivisionID = V.DivisionID AND
(
	(@operation=1 AND E.DivisionID <> @i) OR (@operation=2 AND E.DivisionID = @i) OR
	(@operation=4 AND V.Division NOT LIKE @t) OR (@operation=8 AND V.Division LIKE @t)
)

-- Department 55
ELSE IF @field_id=55 DELETE TempX FROM TempX X
INNER JOIN Employee E ON X.BatchID = @batch_id AND X.[ID] = E.EmployeeID 
INNER JOIN Department D ON E.DepartmentID = D.DepartmentID AND 
(
	(@operation=1 AND E.DepartmentID <> @i) OR (@operation=2 AND E.DepartmentID = @i) OR
	(@operation=4 AND D.Department NOT LIKE @t) OR (@operation=8 AND D.Department LIKE @t)
)

-- Location 54
ELSE IF @field_id=54 DELETE TempX FROM TempX X
INNER JOIN Employee E ON X.BatchID = @batch_id AND X.[ID] = E.EmployeeID
INNER JOIN Location L ON E.LocationID = L.LocationID AND
(
	(@operation=1 AND E.LocationID <> @i) OR (@operation=2 AND E.LocationID = @i) OR
	(@operation=4 AND L.[List As] NOT LIKE @t) OR (@operation=8 AND L.[List As] LIKE @t)
)

-- Manager 52
ELSE IF @field_id=52 AND @operation=0x200 DELETE TempX FROM TempX X WHERE X.BatchID=@batch_id AND X.[ID] NOT IN (SELECT DISTINCT ManagerID FROM Employee WHERE ManagerID IS NOT NULL)
ELSE IF @field_id=52 AND @operation=0x400 DELETE TempX FROM TempX X WHERE X.BatchID=@batch_id AND X.[ID] IN (SELECT DISTINCT ManagerID FROM Employee WHERE ManagerID IS NOT NULL)
ELSE IF @field_id=52 DELETE TempX FROM TempX X
INNER JOIN Employee E ON X.BatchID = @batch_id AND X.[ID] = E.EmployeeID
LEFT JOIN vwPersonCalculated M ON E.ManagerID = M.PersonID WHERE
(
	(E.ManagerID IS NULL AND @i IS NULL AND @operation=2) OR
	(E.ManagerID IS NOT NULL AND @i IS NULL AND @operation=1) OR
	(E.ManagerID IS NULL AND @i IS NOT NULL AND @operation=1) OR
	(E.ManagerID IS NOT NULL AND @i IS NOT NULL AND @operation=1 AND E.ManagerID <> @i) OR 
	(E.ManagerID IS NOT NULL AND @i IS NOT NULL AND @operation=2 AND E.ManagerID = @i) OR
	(@operation=4 AND M.[Full Name] NOT LIKE @t) OR (@operation=8 AND M.[Full Name] LIKE @t)
)

-- Note 16
ELSE IF @field_id=16
BEGIN
	DELETE TempX WHERE BatchID = @batch_id AND [ID] NOT IN
	(
		SELECT PersonID
		FROM Person P
		INNER JOIN Employee E ON P.PersonID = E.EmployeeID AND P.Note LIKE @t
	
		UNION

		SELECT DISTINCT PersonID
		FROM Note WHERE Note LIKE @t
	)
END

-- Seniority Begins 58
ELSE IF @field_id = 58 DELETE TempX FROM TempX X
INNER JOIN Employee E ON X.BatchID = @batch_id AND X.[ID] = E.EmployeeID AND
(
	(@operation=1 AND E.[Seniority Begins Day past 1900] <> @x) OR 
	(@operation=2 AND E.[Seniority Begins Day past 1900] = @x) OR
	(@operation=0x10 AND E.[Seniority Begins Day past 1900] NOT BETWEEN @x AND @y) OR
	(@operation=0x80 AND E.[Seniority Begins Day past 1900] <= @x) OR
	(@operation=0x100 AND E.[Seniority Begins Day past 1900] < @x) OR
	(@operation=0x20 AND E.[Seniority Begins Day past 1900] >= @x) OR
	(@operation=0x40 AND E.[Seniority Begins Day past 1900] > @x)
)

-- Shift 51
ELSE IF @field_id=51 DELETE TempX FROM TempX X
INNER JOIN Employee E ON X.BatchID = @batch_id AND X.[ID] = E.EmployeeID
INNER JOIN Shift S ON E.ShiftID = S.ShiftID AND
(
	(@operation=1 AND E.ShiftID <> @i) OR (@operation=2 AND E.ShiftID = @i) OR
	(@operation=4 AND S.Shift NOT LIKE @t) OR (@operation=8 AND S.Shift LIKE @t)
)

-- PayGrade 100
ELSE IF @field_id = 100 AND @operation=0x200 DELETE TempX FROM TempX X WHERE X.BatchID=@batch_id AND X.[ID] NOT IN (SELECT EmployeeID FROM Employee WHERE LastCompensationID IS NOT NULL)
ELSE IF @field_id = 100 AND @operation=0x400 DELETE TempX FROM TempX X WHERE X.BatchID=@batch_id AND X.[ID] IN (SELECT EmployeeID FROM Employee WHERE LastCompensationID IS NOT NULL)
ELSE IF @field_id = 100 DELETE TempX FROM TempX X
INNER JOIN Employee E ON X.BatchID = @batch_id AND X.[ID] = E.EmployeeID
INNER JOIN EmployeeCompensation EC ON E.LastCompensationID = EC.CompensationID
INNER JOIN Position P ON EC.PositionID = P.PositionID
INNER JOIN PayGrade PG ON P.PayGradeID = PG.PayGradeID AND
(
	(@operation=1 AND P.PayGradeID <> @i) OR (@operation=2 AND P.PayGradeID = @i) OR
	(@operation=4 AND PG.[Pay Grade] NOT LIKE @t) OR (@operation=8 AND PG.[Pay Grade] LIKE @t)
)

-- Superior 1029
ELSE IF @field_id = 1029 DELETE X FROM TempX X WHERE X.BatchID = @batch_id AND X.[ID] NOT IN
(
	SELECT EmployeeID FROM EmployeeSuperior ES
	INNER JOIN dbo.vwPersonListAs P ON ES.SuperiorID = P.PersonID AND
	(
		(@operation=1 AND ES.SuperiorID = @i) OR (@operation=2 AND ES.SuperiorID <> @i) OR
		(@operation=4 AND P.[List As] LIKE @t) OR (@operation=8 AND P.[List As] NOT LIKE @t)
	)
)

-- Terminated 60
ELSE IF @field_id = 60 DELETE TempX FROM TempX X
INNER JOIN Employee E ON X.BatchID = @batch_id AND X.[ID] = E.EmployeeID AND
(
	(@operation=0x400 AND E.[Terminated Day past 1900] IS NOT NULL) OR
	(@operation!=0x400 AND E.[Terminated Day past 1900] IS NULL) OR
	(@operation=1 AND E.[Terminated Day past 1900] <> @x) OR 
	(@operation=2 AND E.[Terminated Day past 1900] = @x) OR
	(@operation=0x10 AND E.[Terminated Day past 1900] NOT BETWEEN @x AND @y) OR
	(@operation=0x80 AND E.[Terminated Day past 1900] <= @x) OR
	(@operation=0x100 AND E.[Terminated Day past 1900] < @x) OR
	(@operation=0x20 AND E.[Terminated Day past 1900] >= @x) OR
	(@operation=0x40 AND E.[Terminated Day past 1900] > @x)
	
)

-- COBRA 99
ELSE IF @field_id = 99 DELETE TempX FROM TempX X
INNER JOIN vwEmployeeCOBRA E ON X.BatchID = @batch_id AND X.[ID] = E.EmployeeID AND
(
	(@operation=1 AND @i<>E.EnrollmentID) OR (@operation=2 AND @i=E.EnrollmentID)
)
	
-- COBRA notified 94
ELSE IF @field_id = 94 DELETE TempX FROM TempX X
INNER JOIN Employee E ON X.BatchID = @batch_id AND X.[ID] = E.EmployeeID AND
(
	(@operation=0x400 AND E.[COBRA Notified Day past 1900] IS NOT NULL) OR
	(@operation!=0x400 AND E.[COBRA Notified Day past 1900] IS NULL) OR
	(@operation=1 AND E.[COBRA Notified Day past 1900] <> @x) OR 
	(@operation=2 AND E.[COBRA Notified Day past 1900] = @x) OR
	(@operation=0x10 AND E.[COBRA Notified Day past 1900] NOT BETWEEN @x AND @y) OR
	(@operation=0x80 AND E.[COBRA Notified Day past 1900] <= @x) OR
	(@operation=0x100 AND E.[COBRA Notified Day past 1900] < @x) OR
	(@operation=0x20 AND E.[COBRA Notified Day past 1900] >= @x) OR
	(@operation=0x40 AND E.[COBRA Notified Day past 1900] > @x)
)

-- COBRA Eligible 93
ELSE IF @field_id = 93 DELETE TempX FROM TempX X
INNER JOIN Employee E ON X.BatchID = @batch_id AND X.[ID] = E.EmployeeID AND
(
	(@operation=0x400 AND E.[COBRA Eligible Day past 1900] IS NOT NULL) OR
	(@operation!=0x400 AND E.[COBRA Eligible Day past 1900] IS NULL) OR
	(@operation=1 AND E.[COBRA Eligible Day past 1900] <> @x) OR 
	(@operation=2 AND E.[COBRA Eligible Day past 1900] = @x) OR
	(@operation=0x10 AND E.[COBRA Eligible Day past 1900] NOT BETWEEN @x AND @y) OR
	(@operation=0x80 AND E.[COBRA Eligible Day past 1900] <= @x) OR
	(@operation=0x100 AND E.[COBRA Eligible Day past 1900] < @x) OR
	(@operation=0x20 AND E.[COBRA Eligible Day past 1900] >= @x) OR
	(@operation=0x40 AND E.[COBRA Eligible Day past 1900] > @x)
)

-- COBRA Expires 98
ELSE IF @field_id = 98 DELETE TempX FROM TempX X
INNER JOIN Employee E ON X.BatchID = @batch_id AND X.[ID] = E.EmployeeID AND
(
	(@operation=0x400 AND E.[COBRA Expires Day past 1900] IS NOT NULL) OR
	(@operation!=0x400 AND E.[COBRA Expires Day past 1900] IS NULL) OR
	(@operation=1 AND E.[COBRA Expires Day past 1900] <> @x) OR 
	(@operation=2 AND E.[COBRA Expires Day past 1900] = @x) OR
	(@operation=0x10 AND E.[COBRA Expires Day past 1900] NOT BETWEEN @x AND @y) OR
	(@operation=0x80 AND E.[COBRA Expires Day past 1900] <= @x) OR
	(@operation=0x100 AND E.[COBRA Expires Day past 1900] < @x) OR
	(@operation=0x20 AND E.[COBRA Expires Day past 1900] >= @x) OR
	(@operation=0x40 AND E.[COBRA Expires Day past 1900] > @x)
)

-- COBRA First Enrolled 95
ELSE IF @field_id = 95 DELETE TempX FROM TempX X
INNER JOIN Employee E ON X.BatchID = @batch_id AND X.[ID] = E.EmployeeID AND
(
	(@operation=0x400 AND E.[COBRA First Enrolled Day past 1900] IS NOT NULL) OR
	(@operation!=0x400 AND E.[COBRA First Enrolled Day past 1900] IS NULL) OR
	(@operation=1 AND E.[COBRA First Enrolled Day past 1900] <> @x) OR 
	(@operation=2 AND E.[COBRA First Enrolled Day past 1900] = @x) OR
	(@operation=0x10 AND E.[COBRA First Enrolled Day past 1900] NOT BETWEEN @x AND @y) OR
	(@operation=0x80 AND E.[COBRA First Enrolled Day past 1900] <= @x) OR
	(@operation=0x100 AND E.[COBRA First Enrolled Day past 1900] < @x) OR
	(@operation=0x20 AND E.[COBRA First Enrolled Day past 1900] >= @x) OR
	(@operation=0x40 AND E.[COBRA First Enrolled Day past 1900] > @x)
)

-- COBRA Last Enrolled 96
ELSE IF @field_id = 96 DELETE TempX FROM TempX X
INNER JOIN Employee E ON X.BatchID = @batch_id AND X.[ID] = E.EmployeeID AND
(
	(@operation=0x400 AND E.[COBRA Last Enrolled Day past 1900] IS NOT NULL) OR
	(@operation!=0x400 AND E.[COBRA Last Enrolled Day past 1900] IS NULL) OR
	(@operation=1 AND E.[COBRA Last Enrolled Day past 1900] <> @x) OR 
	(@operation=2 AND E.[COBRA Last Enrolled Day past 1900] = @x) OR
	(@operation=0x10 AND E.[COBRA Last Enrolled Day past 1900] NOT BETWEEN @x AND @y) OR
	(@operation=0x80 AND E.[COBRA Last Enrolled Day past 1900] <= @x) OR
	(@operation=0x100 AND E.[COBRA Last Enrolled Day past 1900] < @x) OR
	(@operation=0x20 AND E.[COBRA Last Enrolled Day past 1900] >= @x) OR
	(@operation=0x40 AND E.[COBRA Last Enrolled Day past 1900] > @x)
)

-- COBRA Enrolled 1041
ELSE IF @field_id = 1041 DELETE TempX FROM TempX X
INNER JOIN vwEmployeeCOBRA E ON X.BatchID = @batch_id AND X.[ID] = E.EmployeeID AND
(
	(@operation=1 AND E.EnrollmentID<>@i) OR
	(@operation=2 AND E.EnrollmentID=@i)
)

-- COBRA Notified 93
ELSE IF @field_id = 93 DELETE TempX FROM TempX X
INNER JOIN Employee E ON X.BatchID = @batch_id AND X.[ID] = E.EmployeeID AND
(
	(@operation=0x400 AND E.[COBRA Notified Day past 1900] IS NOT NULL) OR
	(@operation!=0x400 AND E.[COBRA Notified Day past 1900] IS NULL) OR
	(@operation=1 AND E.[COBRA Notified Day past 1900] <> @x) OR 
	(@operation=2 AND E.[COBRA Notified Day past 1900] = @x) OR
	(@operation=0x10 AND E.[COBRA Notified Day past 1900] NOT BETWEEN @x AND @y) OR
	(@operation=0x80 AND E.[COBRA Notified Day past 1900] <= @x) OR
	(@operation=0x100 AND E.[COBRA Notified Day past 1900] < @x) OR
	(@operation=0x20 AND E.[COBRA Notified Day past 1900] >= @x) OR
	(@operation=0x40 AND E.[COBRA Notified Day past 1900] > @x)
)

-- Position Status 1035 91
ELSE IF @field_id=91 OR @field_id=1035 DELETE TempX FROM TempX X
INNER JOIN Employee E ON X.BatchID = @batch_id AND X.[ID] = E.EmployeeID 
INNER JOIN EmployeeCompensation EC ON E.LastCompensationID = EC.CompensationID
INNER JOIN Position P ON EC.PositionID = P.PositionID
INNER JOIN PositionStatus PS ON P.StatusID = PS.StatusID AND
(
	(@operation=1 AND P.StatusID <> @i) OR (@operation=2 AND P.StatusID = @i) OR
	(@operation=4 AND PS.Status NOT LIKE @t) OR (@operation=8 AND PS.Status LIKE @t)
)

-- Employment Status 1034 92
ELSE IF @field_id=92 OR @field_id=1034 DELETE TempX FROM TempX X
INNER JOIN Employee E ON X.BatchID = @batch_id AND X.[ID] = E.EmployeeID 
INNER JOIN EmployeeCompensation EC ON E.LastCompensationID = EC.CompensationID
INNER JOIN EmploymentStatus ES ON EC.EmploymentStatusID = ES.StatusID AND
(
	(@operation=1 AND ES.StatusID <> @i) OR (@operation=2 AND ES.StatusID = @i) OR
	(@operation=4 AND ES.Status NOT LIKE @t) OR (@operation=8 AND ES.Status LIKE @t)
)

-- Job Category 1036
ELSE IF @field_id=1036 DELETE TempX FROM TempX X
INNER JOIN Employee E ON X.BatchID = @batch_id AND X.[ID] = E.EmployeeID 
INNER JOIN EmployeeCompensation EC ON E.LastCompensationID = EC.CompensationID
INNER JOIN Position P ON EC.PositionID = P.PositionID
INNER JOIN JobCategory JC ON P.CategoryID = JC.CategoryID AND
(
	(@operation=1 AND P.CategoryID <> @i) OR (@operation=2 AND P.CategoryID = @i) OR
	(@operation=4 AND JC.Category NOT LIKE @t) OR (@operation=8 AND JC.Category LIKE @t)
)

-- BatchCreateInvoice
ELSE IF @field_id=1037 DELETE TempX FROM TempX X
INNER JOIN Employee E ON X.BatchID = @batch_id AND X.[ID] = E.EmployeeID AND
(
	(@operation=1 AND E.BatchCreateInvoice <> @f) OR
	(@operation=2 AND E.BatchCreateInvoice = @f) OR
	(@operation=0x200 AND E.BatchCreateInvoice=0) OR
	(@operation=0x400 AND E.BatchCreateInvoice=1)
)

-- NSF
ELSE IF @field_id = 1039
DELETE TempX FROM TempX X 
INNER JOIN Employee E ON X.BatchID = @batch_id AND X.[ID] = E.EmployeeID AND
(
	(@operation = 0x200 AND E.NSF = 0) OR
	(@operation = 0x400 AND E.NSF = 1)
)

-- Advance Pay
ELSE IF @field_id = 1040
DELETE TempX FROM TempX X 
INNER JOIN Employee E ON X.BatchID = @batch_id AND X.[ID] = E.EmployeeID AND
(
	(@operation = 0x200 AND E.[Advance Pay] = 0) OR
	(@operation = 0x400 AND E.[Advance Pay] = 1)
)
GO
GRANT EXEC ON dbo.spPersonListPrepareBatchPAnd TO public
GO
-- Builds EmployeeLeaveUnused, a running total of unused paid leave
-- Applies limits
ALTER PROCEDURE dbo.spEmployeeLeaveUnusedBuild
	@employee_id int,	
	@type_id int,
	@start_day int
AS
DECLARE @item_id int, @last_recorded_day int
DECLARE @day int, @seconds int, @unused int
DECLARE @limit bit

SET NOCOUNT ON

-- Does not build unused leave tables for types that have rolling accrual
-- Does not build unused leave tables for employee/types that are not accrued (no matching leaverate in an associated leaveplan)
IF NOT EXISTS (SELECT * FROM dbo.LeaveType WHERE TypeID=@type_id AND Bank=1) RETURN
IF EXISTS (SELECT * FROM vwEmployeeLeavePlanLeaveRate WHERE PeriodID IN (2049, 38914) AND EmployeeID=@employee_id AND TypeID=@type_id AND @start_day < ISNULL([Stop Day past 1900], 0x7FFFFFFF)) RETURN

DECLARE @carryover_source_leave_type_id int, @carryover_target_leave_type_id int


-- Delete existing totals and limit adjustments
DELETE EmployeeLeaveUnused WHERE EmployeeID = @employee_id AND TypeID = @type_id AND [Day past 1900] >= @start_day
DELETE EmployeeLeaveEarned WHERE [Auto] = 2 AND [Day past 1900] >= @start_day AND EmployeeID = @employee_id AND TypeID = @type_id -- Auto 2 = Limit

-- Calling procedure must clear target carryover before recalculating used leave source
/*SELECT @carryover_source_leave_type_id = CarryoverSourceLeaveTypeID,  @carryover_target_leave_type_id = CarryoverTargetLeaveTypeID FROM dbo.Constant
IF @type_id <> @carryover_target_leave_type_id DELETE EmployeeLeaveEarned WHERE [Auto] = 3 AND EmployeeID = @employee_id AND TypeID = @type_id -- Auto 3 = Carryover
IF @carryover_source_leave_type_id = @type_id DELETE EmployeeLeaveEarned WHERE [Auto] = 3 AND [Day past 1900] >= @start_day AND EmployeeID = @employee_id AND TypeID = @carryover_target_leave_type_id -- Auto 3 = Carryover*/


DELETE E FROM dbo.EmployeeLeaveEarned E
INNER JOIN dbo.EmployeeLeavePlan ELP ON E.[Auto]=3 AND E.EmployeeID=@employee_id AND ELP.EmployeeID=E.EmployeeID AND E.[Day past 1900] BETWEEN ELP.[Start Day past 1900] AND ISNULL(ELP.[Stop Day past 1900], 0x7fffffff)
INNER JOIN dbo.LeaveLimit LL ON LL.PlanID=ELP.PlanID AND LL.TypeID=@type_id AND E.TypeID=LL.CarryoverTargetLeaveTypeID


SELECT @unused = 0
SELECT @last_recorded_day = ISNULL(MAX(U.[Day past 1900]), -2147483648) FROM EmployeeLeaveUnused U WHERE EmployeeID = @employee_id AND TypeID = @type_id AND [Day past 1900] < @start_day

SELECT @unused = Unused FROM EmployeeLeaveUnused WHERE EmployeeID = @employee_id AND TypeID = @type_id AND [Day past 1900] = @last_recorded_day

-- Does not build unused leave tables for leave that is not approved (pending or denied)
DECLARE leave_cursor CURSOR LOCAL FORWARD_ONLY STATIC FOR SELECT V.[Day past 1900], V.Seconds, V.[Limit Adjustment] FROM dbo.vwEmployeeLeaveApproved V WHERE
V.EmployeeID = @employee_id AND ((V.TypeID = @type_id OR (V.[Extended Type Mask] & @type_id) != 0)) AND V.[Day past 1900] > @last_recorded_day
ORDER BY [Day past 1900]

OPEN leave_cursor

SELECT @last_recorded_day = NULL

FETCH leave_cursor INTO @day, @seconds, @limit
WHILE @@FETCH_STATUS = 0
BEGIN
	SELECT @unused = @unused + @seconds


	SELECT @item_id = U.ItemID FROM EmployeeLeaveUnused U WHERE U.EmployeeID = @employee_id AND U.TypeID = @type_id AND U.[Day past 1900] = @day
	IF @last_recorded_day IS NULL OR @last_recorded_day != @day SET @item_id = NULL

	IF @item_id IS NULL
	BEGIN
		--PRINT  CAST(DATEADD(dd, @day, 0) AS varchar(11)) + ' Insert ' + CASt(@unused / 3600.0 AS varchar(40)) + ' ' + CASt(@seconds / 3600.0 AS varchar(40))
		INSERT dbo.EmployeeLeaveUnused(EmployeeID, TypeID, Unused, [Day past 1900], [Limit Adjustment])
		SELECT @employee_id, @type_id, @unused, @day, @limit

		SELECT @item_id = SCOPE_IDENTITY( )
	END
	ELSE
	BEGIN
		--PRINT  CAST(DATEADD(dd, @day, 0) AS varchar(11)) + ' Update ' + CASt(@unused / 3600.0 AS varchar(40)) + ' '+ ' ' + CASt(@seconds / 3600.0 AS varchar(40))
		UPDATE dbo.EmployeeLeaveUnused SET Unused = @unused, [Limit Adjustment] = CASE WHEN [Limit Adjustment] = 1 THEN 1 ELSE @limit  END WHERE ItemID = @item_id
	END

	SELECT @last_recorded_day = @day
	FETCH leave_cursor INTO @day, @seconds, @limit
END

CLOSE leave_cursor
DEALLOCATE leave_cursor

-- Recalc limit adjustments
EXEC dbo.spEmployeeLeaveLimit @employee_id, @type_id, @start_day
GO
ALTER PROC dbo.spJobCategoryList AS SET NOCOUNT ON SELECT * FROM vwJobCategory ORDER BY CategoryID
GO
ALTER PROC dbo.spPersonCustomFieldList
	@person_id int
AS
DECLARE @permission_batch_id int

SET NOCOUNT ON

IF @person_id IS NOT NULL
BEGIN
	SELECT @permission_batch_id = RAND() * 2147483647


	INSERT dbo.TempPersonPermission(BatchID,PersonID,AttributeID)
	SELECT DISTINCT @permission_batch_id,@person_id,PermissionAttributeID
	FROM dbo.CustomField

	EXEC dbo.spPermissionGetOnPeopleForCurrentUser @permission_batch_id
END

SELECT F.Attributes, F.LocationID, F.TypeID, F.FieldID, F.Field, F.Textarea, F.[Text], F.[Role Mask], F.PersonID, F.[Person Name], F.ItemID, F.[Order], F.CopyItemsFromFieldID,
[Value] = CASE WHEN (X.[Permission Mask] & 1)=1 THEN CAST(F.[Value] AS varchar(4000)) ELSE 'Permission Denied' END,
Value2 = CASE WHEN (X.[Permission Mask] & 1)=1 THEN F.[Value2] ELSE NULL END,
[Permissions Mask] = X.[Permission Mask], F.PermissionAttributeID
FROM dbo.vwPersonCustomField F
INNER JOIN dbo.TempPersonPermission X ON X.BatchID=@permission_batch_id AND F.PersonID = @person_id AND X.PersonID = F.PersonID AND X.AttributeID = F.PermissionAttributeID
ORDER BY [Order], Textarea, Field

DELETE dbo.TempPersonPermission WHERE BatchID=@permission_batch_id OR DATEDIFF(hour,[Created],GETDATE())> 1
GO
IF OBJECT_id('dbo.spEmployeeRateSelect') IS NOT NULL DROP PROC dbo.spEmployeeRateSelect
GO
CREATE PROC dbo.spEmployeeRateSelect
	@employee_id int, -- Nullable
	@project_id int, -- Nullable
	@time_type_id int, -- Nullable
	@day int
AS
SET NOCOUNT ON

DECLARE @authorized bit, @pay_rate smallmoney, @billing_rate smallmoney, @default_time_type_id int, @fixed_pay smallmoney, @fixed_billing smallmoney
EXEC dbo.spPermissionInsureForCurrentUserOnPerson @employee_id, 262144, 1, @authorized out

IF @authorized = 1 EXEC dbo.spEmployeeRateSelect2 @employee_id, @project_id, @time_type_id, @day, @pay_rate out, @billing_rate OUT, @default_time_type_id OUT, @fixed_pay OUT, @fixed_billing OUT

SELECT EmployeeID = @employee_id, [Pay Rate] = @pay_rate, [Billing Rate] = @billing_rate, DefaultTimeTypeID = @default_time_type_id, [Fixed Pay] = @fixed_pay, [Fixed Billing] = @fixed_billing
GO
GRANT EXEC ON dbo.spEmployeeRateSelect TO public
GO
-- Imports time from acroprint swipecard devices into EmployeeTime
CREATE TRIGGER dbo.EmployeeTimeAcroprintQImport ON dbo.EmployeeTimeAcroprintQ FOR INSERT
AS
SET NOCOUNT ON
-- Converts badge # and time/date strings into employeeid, time
SELECT T.ItemID, E.EmployeeID, [Time] = CONVERT(smalldatetime,
SUBSTRING(T.[Date],1,4) + '-' + SUBSTRING(T.[Date],5,2) + '-' + SUBSTRING(T.[Date],7,2) + ' ' + SUBSTRING(T.[Time],1,2) + ':' + SUBSTRING(T.[Time],3,2) + ':' + SUBSTRING(T.[Time],5,2)
,120), T.Terminal
INTO #T_05112010
FROM EmployeeTimeAcroprintQ T
INNER JOIN Employee E ON T.Imported IS NULL AND
(
	(LEN(T.[Badge]) <= LEN(E.[Employee Number]) AND REPLICATE('0',LEN(E.[Employee Number])-LEN(T.[Badge]))+T.[Badge] = E.[Employee Number]) OR
	(LEN(T.[Badge]) > LEN(E.[Employee Number]) AND REPLICATE('0',LEN(T.[Badge])-LEN(E.[Employee Number]))+E.[Employee Number] = T.[Badge]) -- Ignores leading 0s
)

DECLARE @terminal varchar(50), @employee_id int, @item_id int, @time smalldatetime, @in smalldatetime, @time_type_id int

-- Import every non-imported EmployeeTimeAcroprintQ record whose badge has a matching employee number and record the success or rollback the whole attempt
BEGIN TRAN

DECLARE t_cursor CURSOR LOCAL FORWARD_ONLY STATIC FOR SELECT EmployeeID, [Time], Terminal FROM #T_05112010 ORDER BY [Time]
OPEN t_cursor
FETCH t_cursor INTO @employee_id, @time, @terminal

-- Steps through each non-imported EmployeeTimeAcroprintQ record and updates an existing EmployeeTime entry (clock-out) or inserts a new entry (clock-in)
WHILE @@FETCH_STATUS=0
BEGIN
	DECLARE @source varchar(100), @project_id int
	SET @source = SUBSTRING('Terminal ' + @terminal, 1, 50)

	EXEC dbo.spEmployeeTimePunch @employee_id, @time, @source, NULL, NULL

	FETCH t_cursor INTO @employee_id, @time, @terminal
END

CLOSE t_cursor
DEALLOCATE t_cursor

-- Marks queued acroprint entries imported
UPDATE T SET Imported=GETDATE(), EmployeeID=#T_05112010.EmployeeID FROM EmployeeTimeAcroprintQ T INNER JOIN #T_05112010 ON T.ItemID=#T_05112010.ItemID

COMMIT TRAN

-- Deletes acroprint entries that were imported and are older than 30 days
DELETE FROM EmployeeTimeAcroprintQ WHERE Imported IS NOT NULL AND DATEDIFF(d,[Created],GETDATE()) > 30
GO
ALTER PROCEDURE dbo.[spPermissionListForUIDOnStoredProcs]
	@uid int
AS
DECLARE @batch_id int

SET NOCOUNT ON

SELECT @batch_id = RAND() * 214748367

-- Transfers ObjectIDs from PermissionObject to temp table
INSERT TempX(BatchID, [ID], X)
SELECT @batch_id, ObjectID, 0 FROM PermissionObject

-- Read = 1, Write = 2, Create = 4, Delete = 8, List = 16

-- 1 for Select
UPDATE T
SET X = 1
FROM TempX T
INNER JOIN PermissionObject P ON T.[ID] = P.ObjectID
INNER JOIN sysprotects S ON S.[id] = P.SelectObjectID AND S.uid=@uid AND S.[action]=224 AND S.protecttype=205

-- 2 for Update
UPDATE T
SET X = X | 2
FROM TempX T
INNER JOIN PermissionObject P ON T.[ID] = P.ObjectID
INNER JOIN sysprotects S ON S.[id] = P.UpdateObjectID AND S.uid=@uid AND S.[action]=224 AND S.protecttype=205

-- 4 for Insert
UPDATE T
SET X = X | 4
FROM TempX T
INNER JOIN PermissionObject P ON T.[ID] = P.ObjectID
INNER JOIN sysprotects S ON S.[id] = P.InsertObjectID AND S.uid=@uid AND S.[action]=224 AND S.protecttype=205

-- 8 for Delete
UPDATE T
SET X = X | 8
FROM TempX T
INNER JOIN PermissionObject P ON T.[ID] = P.ObjectID
INNER JOIN sysprotects S ON S.[id] = P.DeleteObjectID AND S.uid=@uid AND S.[action]=224 AND S.protecttype=205

-- Selects results
SELECT ObjectID = P.ObjectID, P.Object, [Permission Mask] = X, P.[Permission Possible Mask] FROM TempX T
INNER JOIN PermissionObject P ON BatchID = @batch_id AND T.[ID] = P.ObjectID
ORDER BY P.Object

-- Removes temporary records
DELETE TempX WHERE BatchID = @batch_id OR DATEDIFF(hh, Created, GETDATE()) > 1
GO
IF OBJECT_id('dbo.spCustomFieldGet') IS NOT NULL DROP PROC dbo.spCustomFieldGet
IF OBJECT_id('dbo.spCustomFieldItemGet') IS NOT NULL DROP PROC dbo.spCustomFieldItemGet
IF OBJECT_id('dbo.spPersonListPrepareBatchCOr') IS NOT NULL DROP PROC dbo.spPersonListPrepareBatchCOr
IF OBJECT_id('dbo.spPersonCustomFieldList2') IS NOT NULL DROP PROC dbo.spPersonCustomFieldList2
GO
CREATE PROC dbo.spPersonCustomFieldList2
	@batch_id int,
	@field_id int,
	@clear_batch bit
AS
DECLARE @authorized bit, @attribute_id int

SET NOCOUNT ON

SELECT @attribute_id = PermissionAttributeID FROM dbo.CustomField WHERE FieldID=@field_id
EXEC dbo.spPermissionGetOnPeopleForCurrentUser2 @batch_id, @attribute_id

IF EXISTS(SELECT * FROM TempX WHERE BatchID=@batch_id AND (X&1)=0) SET @authorized=0
ELSE SET @authorized=1


SELECT F.Attributes, F.LocationID, F.TypeID, F.FieldID, F.Field, F.Textarea, F.[Text],
F.[Role Mask], F.PersonID, F.[Person Name], F.ItemID, F.[Order], F.CopyItemsFromFieldID,
[Value] = CASE WHEN (X.X & 1)=1 THEN F.[Value] ELSE 'Permission Denied' END,
Value2 = CASE WHEN (X.X & 1)=1 THEN F.[Value2] ELSE NULL END,
[Permission Mask] = X.X,
F.PermissionAttributeID
FROM dbo.vwPersonCustomField F
INNER JOIN TempX X ON F.FieldID=@field_id AND X.BatchID=@batch_id AND F.PersonID=X.[ID]
ORDER BY F.[Person Name], F.PersonID

IF @clear_batch=1 DELETE dbo.TempX WHERE BatchID=@batch_id OR DATEDIFF(minute, Created, GETDATE()) > 30
GO
ALTER PROC dbo.spPersonCustomFieldSelect
	@item_id int
AS
DECLARE @person_id int, @permission int, @batch_id int, @field_id int

SET NOCOUNT ON

SELECT @person_id=PersonID, @field_id=FieldID FROM PersonCustomField WHERE ItemID=@item_id
EXEC dbo.spPersonCustomFieldList2 @batch_id, @field_id, 1
GO
CREATE PROC dbo.spCustomFieldGet @field_id int, @field varchar(50) out AS
SET @field=''
SELECT @field=Field FROM CustomField WHERE FieldID=@field_id
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spCustomFieldItemSelect', 0
GO
ALTER PROC dbo.spCustomFieldItemSelect @item_id int AS SELECT * FROM dbo.vwCustomFieldItem WHERE ItemID=@item_id
GO
CREATE PROC dbo.spCustomFieldItemGet @field_id int, @value int, @text varchar(50) out AS
SET @text = ''
SELECT @text = [Text] FROM CustomFieldItem WHERE FieldID=@field_id AND Value=@value
GO
IF OBJECT_id('dbo.spPersonListPrepareBatchCAnd') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spPersonListPrepareBatchCAnd AS'
	GRANT EXEC ON dbo.spPersonListPrepareBatchCAnd TO public
END
GO
ALTER PROC dbo.spPersonListPrepareBatchCAnd
	@batch_id int,
	@field_id int,
	@operation int,
	@value sql_variant,
	@limit sql_variant
AS
DECLARE @type sysname
SELECT @type = CAST(SQL_VARIANT_PROPERTY ( @value, 'BaseType' ) AS sysname)

IF (@operation=4) OR (@operation=8)
BEGIN
	DECLARE @t varchar(52)

	IF @type IN ('varchar', 'nvarchar')
	BEGIN
		SELECT @t = '%' + CAST(@value AS varchar(50)) + '%'

		DELETE X FROM TempX X
		INNER JOIN vwPersonCustomField2 PCF ON X.BatchID=@batch_id AND PCF.PersonID=X.[ID] AND PCF.FieldID=@field_id AND PCF.TypeID=167
		AND
		(
			(@operation=4 AND (PCF.Value IS NULL OR CAST(PCF.Value AS varchar(50)) NOT LIKE @t)) OR
			(@operation=8 AND CAST(PCF.Value AS varchar(50)) LIKE @t)
		)
	END
END
ELSE IF (@operation=0x800) OR (@operation=0x1000)
BEGIN
	IF @type='int'
	BEGIN
		DECLARE @i int
		SET @i = CAST(@value AS int)

		UPDATE TempX SET X=0 WHERE BatchID=@batch_id
		UPDATE X SET X=CAST(ISNULL(Value,0) AS int)
		FROM TempX X
		INNER JOIN PersonCustomField PCF ON X.BatchID=@batch_id AND PCF.PersonID=X.[ID] AND PCF.FieldID=@field_id
		INNER JOIN CustomField CF ON PCF.FieldID=CF.FieldID AND CF.TypeID=1

		DELETE X FROM TempX X WHERE BatchID=@batch_id AND
		(
			(@operation=0x800 AND (X.X & @i) = 0) OR
			(@operation=0x1000 AND (X.X & @i) <> 0)
		)
	END
END
ELSE
BEGIN
	DELETE X FROM TempX X
	INNER JOIN vwPersonCustomField2 PCF ON X.BatchID=@batch_id AND PCF.PersonID=X.[ID] AND PCF.FieldID=@field_id 
	AND
	(
		(@operation=1 AND (PCF.Value IS NULL OR PCF.Value <> @value)) OR
		(@operation=2 AND PCF.Value = @value) OR
		(@operation=0x10 AND (PCF.Value IS NULL OR PCF.Value < @value OR PCF.Value > @limit)) OR
		(@operation=0x20 AND (PCF.Value IS NULL OR PCF.Value >= @value)) OR
		(@operation=0x40 AND (PCF.Value IS NULL OR PCF.Value > @value)) OR
		(@operation=0x80 AND (PCF.Value IS NULL OR PCF.Value <= @value)) OR
		(@operation=0x100 AND (PCF.Value IS NULL OR PCF.Value < @value)) OR
		-- Custom fields of type bit should all contain 0/1 values, but some legacy clients may still store NULL for false
		(@operation=0x200 AND ((PCF.TypeID <> 3 AND PCF.Value IS NULL) OR (PCF.TypeID=3 AND (PCF.Value IS NULL OR PCF.Value=0)))) OR
		(@operation=0x400 AND ((PCF.TypeID <> 3 AND PCF.Value IS NOT NULL) OR (PCF.TypeID=3 AND PCF.Value=1)))
	)
END
GO
CREATE PROC dbo.spPersonListPrepareBatchCOr
	@batch_id int,
	@field_id int,
	@operation int,
	@value sql_variant,
	@limit sql_variant
AS
DECLARE @type sysname
SELECT @type = CAST(SQL_VARIANT_PROPERTY ( @value, 'BaseType' ) AS sysname)

IF (@operation=4) OR (@operation=8)
BEGIN
	DECLARE @t varchar(52)

	IF @type IN ('varchar', 'nvarchar')
	BEGIN
		SELECT @t = '%' + CAST(@value AS varchar(50)) + '%'

		INSERT TempX(BatchID, [ID])
		SELECT @batch_id, PCF.PersonID
		FROM vwPersonCustomField2 PCF WHERE PCF.FieldID=@field_id AND PCF.TypeID=167
		AND
		(
			(@operation=4 AND CAST(PCF.Value AS varchar(50)) LIKE @t) OR
			(@operation=8 AND (PCF.Value IS NULL OR CAST(PCF.Value AS varchar(50)) NOT LIKE @t))
		)
	END
END
ELSE IF (@operation=0x800) OR (@operation=0x1000)
BEGIN
	IF @type='int'
	BEGIN
		DECLARE @i int
		SET @i = CAST(@value AS int)

		SELECT PersonID, I=CAST(Value AS int)
		INTO #F_1007
		FROM vwPersonCustomField2 PCF WHERE PCF.FieldID=@field_id AND PCF.TypeID=1

		INSERT TempX(BatchID, [ID])
		SELECT @batch_id, PersonID FROM #F_1007 WHERE
		(@operation=0x800 AND (I & @i) <> 0) OR
		(@operation=0x1000 AND (I IS NULL OR (I & @i) = 0))
	END
END
ELSE
BEGIN
	INSERT TempX(BatchID, [ID])
	SELECT @batch_id, PCF.PersonID
	FROM vwPersonCustomField2 PCF WHERE PCF.FieldID=@field_id
	AND
	(
		(@operation=1 AND CAST(PCF.Value AS numeric(21,4)) = CAST(@value AS numeric(21,4))) OR
		(@operation=2 AND (PCF.Value IS NULL OR CAST(PCF.Value AS numeric(21,4)) <> CAST(@value AS numeric(21,4)))) OR
		(@operation=0x10 AND CAST(PCF.Value AS numeric(21,4)) BETWEEN CAST(@value AS numeric(21,4)) AND CAST(@limit AS numeric(21,4))) OR
		(@operation=0x20 AND CAST(PCF.Value AS numeric(21,4)) < CAST(@value AS numeric(21,4))) OR
		(@operation=0x40 AND CAST(PCF.Value AS numeric(21,4)) <= CAST(@value AS numeric(21,4))) OR
		(@operation=0x80 AND CAST(PCF.Value AS numeric(21,4)) > CAST(@value AS numeric(21,4))) OR
		(@operation=0x100 AND CAST(PCF.Value AS numeric(21,4)) >= CAST(@value AS numeric(21,4))) OR
		(@operation=0x200 AND ((PCF.TypeID <> 3 AND PCF.Value IS NOT NULL) OR (PCF.TypeID=3 AND PCF.Value=1))) OR
		-- Custom fields of type bit should all contain 0/1 values, but some legacy clients may still store NULL for false
		(@operation=0x400 AND ((PCF.TypeID <> 3 AND PCF.Value IS NULL) OR (PCF.TypeID=3 AND (PCF.Value IS NULL OR PCF.Value=0))))
	)
END
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spPersonListBase2', 1
GO
ALTER PROC dbo.spPersonListBase2 @batch_id int AS
SET NOCOUNT ON

EXEC dbo.spCustomFieldClean
EXEC dbo.spPermissionCacheAllForCurrentUser @batch_id

SELECT T.*, EmployeeID = T.EID,

-- backward compatibility with grid
Note = [Employee Note],
PersonID = T.EID,
[Custom Field Permission Mask] = T.[Custom Permission Mask],
[List As] = T.[Person List As],
[Annualized Pay] = [Current Annualized Pay], 
[Hourly Pay] = [Current Hourly Pay],
[Position Status] = [Current Position Status],
[Employment Status] = [Current Employment Status],
[Pay Grade] = [Current Pay Grade],
[Pay Step] = [Current Pay Step],
[Job Title] = [Current Job Title],
[Daily Pay] = [Current Daily Pay]
FROM dbo.vwEmployeeSecure T
INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID] = T.EID

DELETE dbo.TempX WHERE BatchID=@batch_id OR DATEDIFF(minute, Created, GETDATE()) > 30
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spPersonListBase', 1
GO
ALTER PROC dbo.spPersonListBase
	@batch_id int = NULL,
	@leave_id int = NULL,
	@clear_batch bit = 1
AS
DECLARE @attribute_batch_id int
DECLARE @a bit, @b bit

SET NOCOUNT ON

SELECT @a = CASE WHEN @batch_id IS NULL THEN 0 ELSE 1 END,
	@b = CASE WHEN @leave_id IS NULL THEN 0 ELSE 1 END

IF (@a ^ @b) = 0 RAISERROR('dbo.spPersonListBase must have one nonnull parameter.', 16, 1)
ELSE
BEGIN
	IF @leave_id IS NOT NULL
	BEGIN
		SET @batch_id = RAND() * 2147483647
		INSERT TempX(BatchID,[ID]) SELECT @batch_id,U.EmployeeID FROM dbo.EmployeeLeaveUsed U WHERE U.LeaveID=@leave_id
	END
	ELSE
	BEGIN
		EXEC dbo.spPermissionCacheAllForCurrentUser @batch_id
	END

	-- If user is not a member of dbo then carefully screens out any unathorized information
	DECLARE @dec31 datetime, @next31 datetime

	-- no longer supported
	-- In SQL 2000 and earlier, user cannot impersonate dbo to execute dynamic sql
	-- SELECT @can_impersonate_dbo_mask = CASE WHEN IS_MEMBER('dbo')=1 OR EXISTS(SELECT * FROM dbo.Constant WHERE ([Version Update Flags] & 2) = 2) THEN 0x7FFFFFFF ELSE 1 END

	SET @dec31 = DATEADD(d,-1,dbo.GetYearStart(YEAR(GETDATE()) + 1))
	SELECT PersonID = E.EID, E.[Role Mask], [List As] = E.[Person List As],
	[Work Permission Mask] = E.[Work Permission Mask], E.[Title], E.[First Name], E.[Middle Name], E.[Last Name], E.[Suffix], E.[Credentials], E.[Male], E.[Work E-mail],
	E.[Work Phone], E.[Extension], E.[Work Phone Note], E.[Toll Free Phone], E.[Mobile Phone],
	E.[Work Fax], E.[Pager], E.[Employee Note], Note = E.[Employee Note], E.[Work Address], E.[Work Address (cont.)],
	E.[Work City], E.[Work State], E.[Work ZIP], E.[Work Country],
	E.[Home Office Phone], E.[Extended Work Address],
	E.[Extended Work Phone], E.[Initials], E.[Formal Name], E.[IsEmployee], E.[Full Name], E.[IsApplicant], E.[IsRecruiter], E.[IsPhysician], E.[IsEmergencyContact], E.PFlags,

	[Home Permission Mask] = E.[Home Permission Mask], E.[Home Fax], E.[Home Phone], E.[Home E-mail], E.[Home Address], E.[Home Address (cont.)], E.[Home City], E.[Home State], E.[Home Zip], E.[Home Country], E.[Extended Home Address],
	[Review Permission Mask] = E.[Review Permission Mask], E.[Next Performance Review Day past 1900], E.[Last Performance Review Day past 1900], E.[Next Performance Review], E.[Last Performance Review],
	[Pay Step Permission Mask] = E.[Pay Step Permission Mask], E.[FilingStatusID], E.[Filing Status], E.[Salaried], E.[Payroll Delay], E.[Direct Deposit Account Number], E.DefaultTimeTypeID, E.[OT Pay Multiplier], E.[Holiday Pay Multiplier], E.[Weekend Pay Multiplier], E.[OT Basis], E.[FIT Exemptions],
	[Org Permission Mask] = E.[Org Permission Mask], E.ManagerID, E.ShiftID, E.DivisionID, E.DepartmentID, E.[Active Employee], E.LocationID, E.[Employee Number], E.Shift, E.Manager, E.SyncID,
	E.Division, E.Location, E.Department, E.LastPositionID, E.[Last Position], E.[Seniority Begins Day past 1900], E.[Seniority Begins], E.DOH, E.[DOH Day past 1900], E.[Job Category], E.OrgUserField1, E.LeaveKeeperID, E.[Leave Keeper], E.[Leave Keeper E-mail], E.DivisionLeaveKeeperID, E.[Division Leave Keeper], E.[Division Leave Keeper E-mail],
	[Seniority Begins FirstQuarterAfter6Months] = dbo.fnGetFirstQuarterAfter6Months(E.[Seniority Begins]),
	[Seniority Begins FirstMonthAfter30Days] = dbo.fnGetFirstMonthAfter30Days(E.[Seniority Begins]),
	[Seniority Begins FirstMonthAfter6Months] = dbo.fnGetFirstMonthAfter6Months(E.[Seniority Begins]),
	[LeaveBalance_Vacation_Dec31] = dbo.fnGetUnusedBalanceForTypeOnDate(E.EID, 'vacation', @dec31),
	[LeaveBalance_Sick_Dec31] = dbo.fnGetUnusedBalanceForTypeOnDate(E.EID, 'sick', @dec31),
	[LeaveBalance_Personal_Dec31] = dbo.fnGetUnusedBalanceForTypeOnDate(E.EID, 'personal', @dec31),
	[LeaveBalance_PTO_Dec31] = dbo.fnGetUnusedBalanceForTypeOnDate(E.EID, 'pto', @dec31),
	[LeaveBalance_Vacation_NextDec31] = dbo.fnGetUnusedBalanceForTypeOnDate(E.EID, 'vacation', @next31),
	[LeaveBalance_Sick_NextDec31] = dbo.fnGetUnusedBalanceForTypeOnDate(E.EID, 'sick', @next31),
	[LeaveBalance_Personal_NextDec31] = dbo.fnGetUnusedBalanceForTypeOnDate(E.EID, 'personal', @next31),
	[LeaveBalance_PTO_NextDec31] = dbo.fnGetUnusedBalanceForTypeOnDate(E.EID, 'pto', @next31),

	[Personal Permission Mask] = E.[Personal Permission Mask], E.[RaceID], E.[I9StatusID], E.[SSN], E.[Renew I9 Status Day past 1900], E.[Country of Citizenship], E.[Visa], E.[Visa Expires Day past 1900], E.VisaStatusID, E.[Visa Status], E.[Passport], E.[Passport Expires Day past 1900], E.[DOB Day past 1900], E.[Driver License], E.[Driver License State], E.[Driver License Expires Day past 1900], E.[Driver Insurance Expires Day past 1900], E.[Commercial Driver License], E.[MaritalStatusID], E.[Dependents], E.[Disabled], E.[Smoker],
	E.[Spouse], E.[Children], E.[Race], E.[I9 Status], E.[Marital Status], E.[DOB], E.[Driver License Expires], E.[Driver Insurance Expires], E.[Renew I9 Status], E.[Visa Expires], E.[Passport Expires], E.[Military Service], E.[Birth Day past 1900], E.MilitaryBranchID, E.Reserves, E.[Driver License Class],

	[Delegated Manager Permission Mask] = E.[Delegated Manager Permission Mask],
	E.DelegatedManagerID, E.EffectiveManagerID, E.[Delegated Manager], E.[Effective Manager], E.[Effective Manager Work E-mail],

	[Account Permission Mask] = E.[Account Permission Mask], E.Account, E.SID,
	[Termination Permission Mask] = E.[Termination Permission Mask], E.[Rehire], E.[Reason for Termination], E.[Terminated], E.[Terminated Day past 1900], E.Reason, E.TerminationReasonID, E.ExitInterviewByEmployeeID, E.[Exit Interview by], E.[Exit Interview Day past 1900], E.[Exit Interview],
	[Compensation Permission Mask] = E.[Compensation Permission Mask],  
	[Annualized Pay] = E.[Current Annualized Pay], 
	[Daily Pay] = E.[Current Daily Pay], 
	[Hourly Pay] = E.[Current Hourly Pay], 
	[Position Status] = E.[Current Position Status], 
	[Employment Status] = E.[Current Employment Status], 
	[Pay Grade] = E.[Current Pay Grade], 
	[Pay Step] = E.[Current Pay Step], 
	[Job Title] = E.[Current Job Title],
	E.[Current FTE],
	[Successor Permission Mask] = E.[Successor Permission Mask], E.[Successor Names], E.[Successor Initials],
	[Succeeds Permission Mask] = E.[Succeeds Permission Mask], E.[Succeeds Names], E.[Succeeds Initials],
	[InOut Permission Mask] = E.[InOut Permission Mask], E.InOutStatusID, E.InOutStatus, E.InOutColor, E.InOutReturn, E.InOutComment, E.InOutLastUpdated,
	[Custom Field Permission Mask] = dbo.fnPermissionGetOnPersonForCurrentUser(E.EID,4194304),
	[Language Permission Mask] = E.[Language Permission Mask], E.[Primary Language], E.PrimaryLanguageID, E.[Secondary Language Mask], E.[Language Mask],
	[LOA Permission Mask] = dbo.fnPermissionGetOnPersonForCurrentUser(E.EID, 10001), LOA.*,
	E.[Union Permission Mask], E.Unions,
	[Employee Terminal Permission Mask] = dbo.fnPermissionGetOnPersonForCurrentUser(E.EID, 10),
	E.[Terminal Password],
	E.[PID Card Number],
	E.TerminalSyncFlags,
	E.TerminalSyncFlags2,
	E.[Enrolled Terminals Mask],
	E.[Terminal Sync State Mask],
	E.[Terminal Last Sync],
	E.[Terminal Sync Status],
	E.[Fingerprints Stream],
	E.EmployeeNumberT,
	
	EmployeeID = E.EID

	FROM dbo.vwEmployeeSecure E INNER JOIN TempX ON TempX.BatchID = @batch_id AND TempX.[ID] = E.EID
	LEFT JOIN dbo.vwEmployeeLeaveUsed LOA ON LOA.LOALeaveID = @leave_id AND E.EID = LOA.LOAEmployeeID AND (dbo.fnPermissionGetOnPersonForCurrentUser(E.EID, 10001) & 1) = 1
	ORDER BY E.[Person List As], E.EID

	-- Cleans TempX
	DELETE dbo.TempX WHERE (@clear_batch=1 AND BatchID=@batch_id) OR DATEDIFF(minute, Created, GETDATE()) > 30
END
GO
ALTER VIEW dbo.vwEmployeeAll
AS
SELECT P.PersonID, P.[Role Mask], P.[List As],
W.[Title], W.[First Name], W.[Middle Name], W.[Last Name], W.[Suffix], W.[Credentials], W.[Male], W.[Work E-mail],
W.[Work Phone], W.[Extension], W.[Work Phone Note], W.[Toll Free Phone], W.[Mobile Phone],
W.[Work Fax], W.[Pager], W.[Note], W.[Work Address], W.[Work Address (cont.)],
W.[Work City], W.[Work State], W.[Work ZIP], W.[Work Country],
W.[Home Office Phone], W.[Extended Work Address],
W.[Extended Work Phone], W.[Initials], W.[Formal Name], W.[IsEmployee], W.[Full Name], W.[IsApplicant], W.[IsRecruiter], W.[IsPhysician], W.[IsEmergencyContact], W.PFlags,

H.[Home Fax], H.[Home Phone], H.[Home E-mail], H.[Home Address], H.[Home Address (cont.)], H.[Home City], H.[Home State], H.[Home Zip], H.[Home Country], H.[Extended Home Address],
R.[Next Performance Review Day past 1900], R.[Last Performance Review Day past 1900], R.[Next Performance Review], R.[Last Performance Review],
PS.[FilingStatusID], PS.[Filing Status], PS.[Salaried], PS.[OT Pay Multiplier], PS.[Holiday Pay Multiplier], PS.[Weekend Pay Multiplier], PS.[OT Basis], PS.[FIT Exemptions],
O.ManagerID, O.ShiftID, O.DivisionID, O.DepartmentID, O.[Active Employee], O.LocationID, O.[Employee Number], O.Shift, O.Manager,
O.Division, O.Location, O.Department, O.LastPositionID, O.[Last Position], O.[Seniority Begins Day past 1900], O.[Seniority Begins], O.DOH,
[Seniority Begins FirstQuarterAfter6Months] = dbo.fnGetFirstQuarterAfter6Months(O.[Seniority Begins]),
[Seniority Begins FirstMonthAfter30Days] = dbo.fnGetFirstMonthAfter30Days(O.[Seniority Begins]),
[Seniority Begins FirstMonthAfter6Months] = dbo.fnGetFirstMonthAfter6Months(O.[Seniority Begins]),
O.SyncID, O.EmployeeNumberNumeric,

[LeaveBalance_Vacation_Dec31] = dbo.fnGetUnusedBalanceForTypeOnDate(P.PersonID, 'vacation', DATEADD(d,-1,dbo.GetYearStart(YEAR(GETDATE()) + 1))),
[LeaveBalance_Sick_Dec31] = dbo.fnGetUnusedBalanceForTypeOnDate(P.PersonID, 'sick', DATEADD(d,-1,dbo.GetYearStart(YEAR(GETDATE()) + 1))),
[LeaveBalance_Personal_Dec31] = dbo.fnGetUnusedBalanceForTypeOnDate(P.PersonID, 'personal', DATEADD(d,-1,dbo.GetYearStart(YEAR(GETDATE()) + 1))),
[LeaveBalance_PTO_Dec31] = dbo.fnGetUnusedBalanceForTypeOnDate(P.PersonID, 'pto', DATEADD(d,-1,dbo.GetYearStart(YEAR(GETDATE()) + 1))),

[LeaveBalance_Vacation_NextDec31] = dbo.fnGetUnusedBalanceForTypeOnDate(P.PersonID, 'vacation', DATEADD(d,-1,dbo.GetYearStart(YEAR(GETDATE()) + 2))),
[LeaveBalance_Sick_NextDec31] = dbo.fnGetUnusedBalanceForTypeOnDate(P.PersonID, 'sick', DATEADD(d,-1,dbo.GetYearStart(YEAR(GETDATE()) + 2))),
[LeaveBalance_Personal_NextDec31] = dbo.fnGetUnusedBalanceForTypeOnDate(P.PersonID, 'personal', DATEADD(d,-1,dbo.GetYearStart(YEAR(GETDATE()) + 2))),
[LeaveBalance_PTO_NextDec31] = dbo.fnGetUnusedBalanceForTypeOnDate(P.PersonID, 'pto', DATEADD(d,-1,dbo.GetYearStart(YEAR(GETDATE()) + 2))),
	
DM.DelegatedManagerID, DM.EffectiveManagerID, DM.[Delegated Manager], DM.[Effective Manager], DM.[Effective Manager Work E-mail],

PX.[RaceID], PX.[I9StatusID], PX.[SSN], PX.[Renew I9 Status Day past 1900], PX.[Country of Citizenship], PX.[Visa], PX.[Visa Expires Day past 1900], PX.VisaStatusID, PX.[Visa Status], PX.[Passport], PX.[Passport Expires Day past 1900], PX.[DOB Day past 1900], PX.[Driver License], PX.[Driver License State], PX.[Driver License Expires Day past 1900], PX.[Driver Insurance Expires Day past 1900], PX.[Commercial Driver License], PX.[MaritalStatusID], PX.[Dependents], PX.[Disabled], PX.[Smoker],
PX.[Spouse], PX.[Children], PX.[Race], PX.[I9 Status], PX.[Marital Status], PX.[DOB], PX.[Driver License Expires], PX.[Driver Insurance Expires], PX.[Renew I9 Status], PX.[Visa Expires], PX.[Passport Expires], PX.[Military Service], PX.[Birth Day past 1900], PX.MilitaryBranchID, PX.Reserves,

EA.*, T.[Rehire], T.[Reason for Termination], T.[Terminated], T.[Terminated Day past 1900], T.ExitInterviewByEmployeeID, T.[Exit Interview by], T.[Exit Interview Day past 1900], T.[Exit Interview],
EC.[Annualized Pay], EC.[Daily Pay], EC.[Hourly Pay], EC.[Employment Status], EC.[Pay Grade], EC.[Pay Step], EC.[Job Title],
ES.[Successor Names], ES.[Successor Initials],
EX.[Succeeds Names], EX.[Succeeds Initials],

PX.[Driver License Class],

LI.[Holiday Plan],
LI.[Leave Note],
LI.[Ongoing Condition],
LI.[Recertify Condition Day past 1900],
LI.[Recertify Condition],
LI.HolidayPlanID

FROM dbo.vwPerson P
LEFT JOIN dbo.vwPersonWork W ON P.PersonID = W.PersonID
LEFT JOIN dbo.vwPersonHome H ON P.PersonID = H.PersonID
LEFT JOIN dbo.vwEmployeeReview R ON P.PersonID = R.EmployeeID
LEFT JOIN dbo.vwEmployeePayStep PS ON P.PersonID = PS.EmployeeID
LEFT JOIN dbo.vwEmployeeOrg O ON P.PersonID = O.EmployeeID
LEFT JOIN dbo.vwPersonX PX ON P.PersonID = PX.PersonID
LEFT JOIN dbo.vwEmployeeAccount EA ON P.PersonID = EA.EmployeeID
LEFT JOIN dbo.vwEmployeeTermination T ON P.PersonID = T.EmployeeID
LEFT JOIN dbo.vwEmployeeLastCompensationSecure EC ON P.PersonID = EC.EmployeeID
LEFT JOIN dbo.vwEmployeeSuccessorNames ES ON P.PersonID = ES.EmployeeID
LEFT JOIN dbo.vwEmployeeSucceedsNames EX ON P.PersonID = EX.EmployeeID
LEFT JOIN dbo.vwEmployeeDelegatedManager DM ON P.PersonID = DM.EmployeeID
LEFT JOIN dbo.vwEmployeeLeaveInfo LI ON P.PersonID = LI.EmployeeID
GO
IF OBJECT_ID('dbo.vwEmployeeActive') IS NULL EXEC sp_executesql N'CREATE VIEW dbo.vwEmployeeActive AS SELECT A=0'
GO
ALTER VIEW dbo.vwEmployeeActive
AS
SELECT P.PersonID, P.[Role Mask], P.[List As],
W.[Title], W.[First Name], W.[Middle Name], W.[Last Name], W.[Suffix], W.[Credentials], W.[Male], W.[Work E-mail],
W.[Work Phone], W.[Extension], W.[Work Phone Note], W.[Toll Free Phone], W.[Mobile Phone],
W.[Work Fax], W.[Pager], W.[Note], W.[Work Address], W.[Work Address (cont.)],
W.[Work City], W.[Work State], W.[Work ZIP], W.[Work Country],
W.[Home Office Phone], W.[Extended Work Address],
W.[Extended Work Phone], W.[Initials], W.[Formal Name], W.[IsEmployee], W.[Full Name], W.[IsApplicant], W.[IsRecruiter], W.[IsPhysician], W.[IsEmergencyContact], W.PFlags,

H.[Home Fax], H.[Home Phone], H.[Home E-mail], H.[Home Address], H.[Home Address (cont.)], H.[Home City], H.[Home State], H.[Home Zip], H.[Home Country], H.[Extended Home Address],
R.[Next Performance Review Day past 1900], R.[Last Performance Review Day past 1900], R.[Next Performance Review], R.[Last Performance Review],
PS.[FilingStatusID], PS.[Filing Status], PS.[Salaried], PS.[OT Pay Multiplier], PS.[Holiday Pay Multiplier], PS.[Weekend Pay Multiplier], PS.[OT Basis], PS.[FIT Exemptions],
O.ManagerID, O.ShiftID, O.DivisionID, O.DepartmentID, O.[Active Employee], O.LocationID, O.[Employee Number], O.Shift, O.Manager,
O.Division, O.Location, O.Department, O.LastPositionID, O.[Last Position], O.[Seniority Begins Day past 1900], O.[Seniority Begins], O.SyncID, O.EmployeeNumberNumeric,

DM.DelegatedManagerID, DM.EffectiveManagerID, DM.[Delegated Manager], DM.[Effective Manager], DM.[Effective Manager Work E-mail],

PX.[RaceID], PX.[I9StatusID], PX.[SSN], PX.[Renew I9 Status Day past 1900], PX.[Country of Citizenship], PX.[Visa], PX.[Visa Expires Day past 1900], PX.VisaStatusID, PX.[Visa Status], PX.[Passport], PX.[Passport Expires Day past 1900], PX.[DOB Day past 1900], PX.[Driver License], PX.[Driver License State], PX.[Driver License Expires Day past 1900], PX.[Driver Insurance Expires Day past 1900], PX.[Commercial Driver License], PX.[MaritalStatusID], PX.[Dependents], PX.[Disabled], PX.[Smoker],
PX.[Spouse], PX.[Children], PX.[Race], PX.[I9 Status], PX.[Marital Status], PX.[DOB], PX.[Driver License Expires], PX.[Driver Insurance Expires], PX.[Renew I9 Status], PX.[Visa Expires], PX.[Passport Expires], PX.[Military Service], PX.[Birth Day past 1900], PX.MilitaryBranchID, PX.Reserves,

EA.*, T.[Rehire], T.[Reason for Termination], T.[Terminated], T.[Terminated Day past 1900], T.ExitInterviewByEmployeeID, T.[Exit Interview by], T.[Exit Interview Day past 1900], T.[Exit Interview],
EC.[Annualized Pay], EC.[Daily Pay], EC.[Hourly Pay], EC.[Employment Status], EC.[Pay Grade], EC.[Pay Step], EC.[Job Title],
ES.[Successor Names], ES.[Successor Initials],
EX.[Succeeds Names], EX.[Succeeds Initials],

PX.[Driver License Class],

LI.[Holiday Plan],
LI.[Leave Note],
LI.[Ongoing Condition],
LI.[Recertify Condition Day past 1900],
LI.[Recertify Condition],
LI.HolidayPlanID

FROM dbo.vwPerson P
LEFT JOIN dbo.vwPersonWork W ON P.PersonID = W.PersonID
LEFT JOIN dbo.vwPersonHome H ON P.PersonID = H.PersonID
LEFT JOIN dbo.vwEmployeeReview R ON P.PersonID = R.EmployeeID
LEFT JOIN dbo.vwEmployeePayStep PS ON P.PersonID = PS.EmployeeID
LEFT JOIN dbo.vwEmployeeOrg O ON P.PersonID = O.EmployeeID
LEFT JOIN dbo.vwPersonX PX ON P.PersonID = PX.PersonID
LEFT JOIN dbo.vwEmployeeAccount EA ON P.PersonID = EA.EmployeeID
LEFT JOIN dbo.vwEmployeeTermination T ON P.PersonID = T.EmployeeID
LEFT JOIN dbo.vwEmployeeLastCompensation EC ON P.PersonID = EC.EmployeeID
LEFT JOIN dbo.vwEmployeeSuccessorNames ES ON P.PersonID = ES.EmployeeID
LEFT JOIN dbo.vwEmployeeSucceedsNames EX ON P.PersonID = EX.EmployeeID
LEFT JOIN dbo.vwEmployeeDelegatedManager DM ON P.PersonID = DM.EmployeeID
LEFT JOIN dbo.vwEmployeeLeaveInfo LI ON P.PersonID = LI.EmployeeID

WHERE O.[Active Employee]=1
GO
ALTER PROC dbo.spCompanySelect
AS
SET NOCOUNT ON

SELECT
C.Currency,C.CheckNoVisible,C.CheckNoX,C.CheckNoY,C.DateX,C.DateY,C.ToX,C.ToY,C.AddressVisible,C.AddressX,C.AddressY, [Division Label],
C.AmountX,C.AmountY,C.WrittenAmountX,C.WrittenAmountY,C.ItemizationX,C.ItemizationY,C.HeadquartersID,C.Company,C.EmployerID,
C.DUNS,C.EEOCompany,C.NAICS,C.SIC,[Headquarters] = L.[List As], C.[Root Path], [Server Version], C.[Timecard Rounding], C.CurrentPayrollPeriodID,
C.[Fiscal Year Start Month], C.[Fiscal Year Start Day],
C.[Operational Year Start Month], C.[Operational Year Start Day],
C.[Administrative Year Start Month], C.[Administrative Year Start Day],
C.[Reminder E-mail Suppress Days],
C.[Reminder E-mail Subject],
C.[Reminder E-mail Sender],
C.[Reminder E-mail Last Result],
C.[Reminder E-mail Repeat Days],
C.[Reminder E-mail Ignore Days],
C.[Project Label],
C.TODOption,
C.BenefitPremiumPeriodID,
C.[Timecard Authorization],
C.[Timecard Flags],
C.[DateFirst],
C.[Audit Purge Days],
DateFirstDefault = vwDateFirst.DateFirst,
C.FieldInvisibleMask,
C.[Max Shift Seconds],
C.[OrgUserField1],
C.[Expense KM],
C.[Expense Reimbursement Rate],
C.[Timecard Max 24 Hours per Day]
FROM dbo.Constant C
INNER JOIN dbo.Location L ON L.LocationID = C.HeadquartersID
CROSS JOIN dbo.vwDateFirst
GO
ALTER PROC dbo.spCompanyUpdateGeneral
	@headquarters_id int,
 	@company varchar(50),
	@division_label varchar(10),
  	@currency nvarchar(3),
	@timecard_rounding int,
	@payroll_period_id int,
	@fiscal_start_month tinyint,
	@fiscal_start_day tinyint,
	@operational_start_month tinyint,
	@operational_start_day tinyint,
	@administrative_start_month tinyint,
	@administrative_start_day tinyint,
	@benefit_premium_period_id int = NULL, -- v45
	@project_label varchar(7) = 'Project', -- legacy
	@tod_option int = 0, -- legacy
	@timecard_flags int = 0,
	@date_first int = NULL,
	@audit_purge_days int = 365,
	@field_invisible_mask bigint = NULL,
	@max_shift_seconds int = NULL,
	@org_user_field1 varchar(50) = NULL,
	@expense_reimbursement money = NULL,
	@expense_km bit = NULL,
	@timecard_max_24_hours bit = NULL,
	@mask_extended_timecard_flags bit = 1
AS
SET NOCOUNT ON

SELECT @benefit_premium_period_id = @payroll_period_id & 2047 WHERE @benefit_premium_period_id IS NULL

UPDATE Constant 
SET Currency = @currency, 
HeadquartersID = @headquarters_id, 
[Division Label] = @division_label,
Company = @company, 
CurrentPayrollPeriodID = @payroll_period_id,
[Timecard Rounding] = @timecard_rounding,
[Fiscal Year Start Month] = @fiscal_start_month,
[Fiscal Year Start Day] = @fiscal_start_day,
[Operational Year Start Month] = @operational_start_month,
[Operational Year Start Day] = @operational_start_day,
[Administrative Year Start Month] = @administrative_start_month,
[Administrative Year Start Day] = @administrative_start_day,
[Project Label] = @project_label,
TODOption = @tod_option,
BenefitPremiumPeriodID = @benefit_premium_period_id,
[Timecard Flags] = @timecard_flags | CASE WHEN @mask_extended_timecard_flags=1 THEN [Timecard Flags] & 0x7FFFFF00 ELSE 0 END,
[DateFirst] = @date_first,
[Audit Purge Days] = @audit_purge_days,
FieldInvisibleMask = CASE WHEN @field_invisible_mask IS NULL THEN FieldInvisibleMask ELSE @field_invisible_mask END,
[Max Shift Seconds] = CASE WHEN @max_shift_seconds IS NULL THEN [Max Shift Seconds] ELSE @max_shift_seconds END,
OrgUserField1 = CASE WHEN @org_user_field1 IS NULL THEN OrgUserField1 ELSE @org_user_field1 END,
[Expense KM] = CASE WHEN @expense_km IS NULL THEN [Expense KM] ELSE @expense_km END,
[Expense Reimbursement Rate] = CASE WHEN @expense_reimbursement IS NULL THEN [Expense Reimbursement Rate] ELSE @expense_reimbursement END,
[Timecard Max 24 Hours per Day] = CASE WHEN @timecard_max_24_hours IS NULL THEN [Timecard Max 24 Hours per Day] ELSE @timecard_max_24_hours END
GO
IF NOT EXISTS(SELECT * FROM ColumnGrid WHERE FieldID=1034)
INSERT ColumnGrid(FieldID, [Table], [Key], colid, AttributeID, Field, Label, Importable, Reportable, [Order])
SELECT 1034, '', '', 0, 8, 'Employment Status', 'Employment Status', 0, 1, 1107

IF NOT EXISTS(SELECT * FROM ColumnGrid WHERE FieldID=1035)
INSERT ColumnGrid(FieldID, [Table], [Key], colid, AttributeID, Field, Label, Importable, Reportable, [Order])
SELECT 1035, '', '', 0, 8, 'Position Status', 'Position Status', 0, 1, 1109

IF NOT EXISTS(SELECT * FROM ColumnGrid WHERE FieldID=1037)
INSERT ColumnGrid(FieldID, [Table], [Key], colid, AttributeID, Field, Label, Importable, Reportable, [Order])
SELECT 1037, '', '', 0, 8, 'BatchInvoiceCreate', 'Benefits, Create Batch Invoice', 0, 1, 1110

IF NOT EXISTS(SELECT * FROM ColumnGrid WHERE FieldID=1038)
INSERT ColumnGrid(FieldID, [Table], [Key], colid, AttributeID, Field, Label, Importable, Reportable, [Order])
SELECT 1038, '', '', 0, 10007, 'Primary Language', 'Primary Language', 0, 1, 5550

IF NOT EXISTS(SELECT * FROM ColumnGrid WHERE FieldID=1039)
INSERT ColumnGrid(FieldID, [Table], [Key], colid, AttributeID, Field, Label, Importable, Reportable, [Order])
SELECT 1039, '', '', 0, 8, 'NSF', 'Benefits, NSP Payment', 0, 1, 1112

IF NOT EXISTS(SELECT * FROM ColumnGrid WHERE FieldID=1040)
INSERT ColumnGrid(FieldID, [Table], [Key], colid, AttributeID, Field, Label, Importable, Reportable, [Order])
SELECT 1040, '', '', 0, 8, 'Advance Pay', 'Benefits, Advance Pay', 0, 1, 1114

IF NOT EXISTS(SELECT * FROM ColumnGrid WHERE FieldID=109)
INSERT ColumnGrid(FieldID, [Table], [Key], colid, AttributeID, Field, Label, [Group], Importable, Reportable, [Order])
SELECT 109, 'PersonX', 'PersonID', (select colid from syscolumns where [id]=object_id('personx') and [name]='Driver License Class'), 4, 'Driver License Class', 'Driver License Class', 'Personal', 1, 1, 4505

IF NOT EXISTS(SELECT * FROM ColumnGrid WHERE FieldID=1060)
INSERT ColumnGrid(FieldID, [Table], [Key], colid, AttributeID, Field, Label, Importable, Reportable, [Order])
SELECT 1060, 'Employee', 'EmployeeID', colid, 8, 'PID Card Number', 'PID Card Number', 1, 1, 55
 FROM syscolumns WHERE [id] = OBJECT_id('Employee') AND [name] = 'PID Card Number'
GO
IF OBJECT_id('dbo.spTaskEmailList') IS NOT NULL DROP PROC dbo.spTaskEmailList
GO
ALTER PROC dbo.spTurnover
	@batch_id int
AS
DECLARE @y int

SET NOCOUNT ON

SELECT @y = YEAR(GETDATE())

SELECT Y = -2
INTO #Y
UNION SELECT Y = -1
UNION SELECT Y = 0

SELECT E = 0 --, Header = 'Employment'
INTO #E
UNION SELECT E = 2 --, Text = 'Hires'
UNION SELECT E = 3 --, Text = 'Separations'

SELECT M = 1, MMM = CAST('Jan' as varchar(10))
INTO #M
UNION SELECT M = 2, MMM = 'Feb'
UNION SELECT M = 3, MMM = 'Mar'
UNION SELECT M = 4, MMM = 'Apr'
UNION SELECT M = 5, MMM = 'May'
UNION SELECT M = 6, MMM = 'Jun'
UNION SELECT M = 7, MMM = 'Jul'
UNION SELECT M = 8, MMM = 'Aug'
UNION SELECT M = 9, MMM = 'Sep'
UNION SELECT M = 10, MMM = 'Oct'
UNION SELECT M = 11, MMM = 'Nov'
UNION SELECT M = 12, MMM = 'Dec'

-- Builds the table, leaving counts initialized to 0
SELECT [Relative Year] = Y, [Month] = M, MMM, Start = dbo.GetDateFromMDY(M, 1, @y + Y), [Next] = dbo.GetDateFromMDY(M + 1, 1, @y + Y), [CategoryID] = E, [Count] = 0, [Start Days] = NULL, [Stop Days] = NULL
INTO #Table
FROM #Y
CROSS JOIN #E
CROSS JOIN #M

INSERT #Table
SELECT Y, 13, 'Year', dbo.GetDateFromMDY(1, 1, @y + Y), dbo.GetDateFromMDY(1, 1, @y + Y + 1), E, 0, NULL, NULL
FROM #Y
CROSS JOIN #E

UPDATE #Table SET [Start Days] = DATEDIFF(d, 0, Start), [Stop Days] = DATEDIFF(d, 0, [Next] - 1)

CREATE TABLE #EC(EmployeeID int, [Start] int, [Stop] int NULL, FirstPositionID int NULL, LastPositionID int NULL, CompensationID int NULL)
INSERT #EC
EXEC dbo.spTurnoverItemize @batch_id

-- Updates employment count
UPDATE #Table SET [Count] = (
	SELECT COUNT(*) FROM #EC WHERE dbo.DoRaysIntersect(#EC.Start, #EC.Stop, #Table.[Start Days], #Table.[Stop Days]) = 1
)
FROM #Table WHERE CategoryID = 0

-- Updates hires count
UPDATE #Table SET [Count] = (
	SELECT COUNT(*) FROM #EC
	WHERE #EC.Start BETWEEN #Table.[Start Days] AND #Table.[Stop Days]
)
FROM #Table WHERE CategoryID = 2

-- Updates separations count
UPDATE #Table SET [Count] = (
	SELECT COUNT(*) FROM #EC
	WHERE #EC.Stop BETWEEN #Table.[Start Days] AND #Table.[Stop Days]
)
FROM #Table WHERE CategoryID = 3

SELECT [Month], MMM, [Relative Year], [CategoryID], [Count]
FROM #Table
ORDER BY [Month], [CategoryID], [Relative Year] 

DELETE TempX WHERE BatchID = @batch_id OR DATEDIFF(hh, Created, GETDATE()) > 1

--SELECT #EC.EmployeeID, P.[List As], [Start]=CAST(dbo.GetDateFromDaysPast1900(#EC.Start) as varchar(11)), [Terminated]=cast(dbo.GetDateFromDaysPast1900(#EC.Stop)  as varchar(11)) FROM #EC inner join dbo.vwPersonListAs P ON #EC.EmployeeID=P.PersonID order by dbo.GetDateFromDaysPast1900(#EC.start)
GO
IF OBJECT_id('dbo.spTurnoverDetailHired') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spTurnoverDetailHired AS SELECT A=0'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spTurnoverDetailHired TO public'
END
GO
ALTER PROC dbo.spTurnoverDetailHired
	@batch_id int,
	@start_day int,
	@stop_day int,
	@authorized bit = 0 OUT
AS
SET NOCOUNT ON

EXEC dbo.spPermissionGetOnPeopleForCurrentUser2 @batch_id, 256
DELETE TempX WHERE BatchID=@batch_id AND (X & 1) = 0
SELECT @authorized = CASE WHEN @@ROWCOUNT=0 THEN 1 ELSE 0 END

CREATE TABLE #EC(EmployeeID int, Start int, Stop int NULL, FirstPositionID int NULL, LastPositionID int NULL, CompensationID int NULL)
INSERT #EC
EXEC dbo.spTurnoverItemize @batch_id

SELECT YYYY=YEAR(Start),
MMMM=DATENAME(month, Start),
Employee=dbo.fnGetListAs(P.[First Name], P.[Middle Name], P.[Last Name], P.Suffix),
[Hired]=dbo.GetDateFromDaysPast1900(#EC.[Start]),
Position=ISNULL(POS.[Job Title],''),
D.Department,
V.Division,
Location = L.[List As],
Age = DATEDIFF(year, dbo.GetDateFromDaysPast1900(X.[DOB Day past 1900]), dbo.GetDateFromDaysPast1900(#EC.[Start]))
FROM #EC
INNER JOIN dbo.Person P ON #EC.EmployeeID=P.PersonID AND #EC.[Start] BETWEEN @start_day AND @stop_day
INNER JOIN dbo.Employee E ON #EC.EmployeeID=E.EmployeeID
INNER JOIN dbo.Department D ON E.DepartmentID = D.DepartmentID
INNER JOIN dbo.Division V ON E.DivisionID = V.DivisionID
INNER JOIN dbo.Location L ON E.LocationID = L.LocationID
INNER JOIN dbo.PersonX X ON P.PersonID = X.PersonID
LEFT JOIN Position POS ON POS.PositionID=#EC.LastPositionID
ORDER BY #EC.[Start]

DELETE TempX WHERE BatchID=@batch_id OR DATEDIFF(hour,0,Created)>1
GO
IF OBJECT_id('dbo.spTurnoverDetailSeparated') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spTurnoverDetailSeparated AS SELECT A=0'
GO
GRANT EXEC ON dbo.spTurnoverDetailSeparated TO public
GO
ALTER PROC dbo.spTurnoverDetailSeparated
	@batch_id int,
	@start_day int,
	@stop_day int,
	@authorized bit = 0 OUT
AS
SET NOCOUNT ON

EXEC dbo.spPermissionGetOnPeopleForCurrentUser2 @batch_id, 256
DELETE TempX WHERE BatchID=@batch_id AND (X & 1) = 0
SELECT @authorized = CASE WHEN @@ROWCOUNT=0 THEN 1 ELSE 0 END

CREATE TABLE #EC(EmployeeID int, Start int, Stop int NULL, FirstPositionID int NULL, LastPositionID int NULL, CompensationID int NULL)
INSERT #EC
EXEC dbo.spTurnoverItemize @batch_id

SELECT YYYY=YEAR(Stop),
MMMM=DATENAME(month, Stop),
Employee=dbo.fnGetListAs(P.[First Name], P.[Middle Name], P.[Last Name], P.Suffix),
Hired=dbo.GetDateFromDaysPast1900(Start),
[Terminated]=dbo.GetDateFromDaysPast1900(#EC.[Stop]),
[Months] = DATEDIFF(month, DOH, dbo.GetDateFromDaysPast1900(#EC.[Stop])),
Position = ISNULL(POS.[Job Title],''),
D.Department,
V.Division,
Location = L.[List As],
Age = DATEDIFF(year, dbo.GetDateFromDaysPast1900(X.[DOB Day past 1900]), dbo.GetDateFromDaysPast1900(#EC.[Stop]))
FROM #EC
INNER JOIN dbo.Person P ON #EC.EmployeeID=P.PersonID AND #EC.[Stop] BETWEEN @start_day AND @stop_day
INNER JOIN dbo.vwEmployeeOrg E ON #EC.EmployeeID=E.EmployeeID
INNER JOIN dbo.Department D ON E.DepartmentID = D.DepartmentID
INNER JOIN dbo.Division V ON E.DivisionID = V.DivisionID
INNER JOIN dbo.Location L ON E.LocationID = L.LocationID
INNER JOIN dbo.PersonX X ON P.PersonID = X.PersonID
LEFT JOIN Position POS ON POS.PositionID=#EC.LastPositionID
ORDER BY #EC.[Stop]

DELETE TempX WHERE BatchID=@batch_id OR DATEDIFF(hour,0,Created)>1
GO
CREATE PROC dbo.spTaskEmailList
	@min_day int = -2147483648,
	@max_day int = 2147483647,
	@recipient varchar(50) = '',
	@text varchar(50) = '',
	@order_by int = 3
AS
SET NOCOUNT ON

IF LEN(@recipient) NOT IN (0, 49, 50) SET @recipient = '%' + @recipient + '%'
IF LEN(@text) NOT IN (0, 49, 50) SET @text = '%' + @text + '%'

SELECT *
FROM dbo.vwTaskEmail WHERE DATEDIFF(d,0,[Sent]) BETWEEN @min_day AND @max_day
AND (@recipient='' OR Recipient LIKE @recipient)
AND (@text ='' OR [Text] LIKE @text)
ORDER BY CASE @order_by WHEN 0 THEN Recipient ELSE '' END,
CASE @order_by WHEN 1 THEN Recipient ELSE '' END DESC,
CASE @order_by WHEN 2 THEN [Sent] ELSE 0 END,
CASE @order_by WHEN 3 THEN [Sent] ELSE 0 END DESC
GO
GRANT EXEC ON dbo.spEmployeeLeaveGetUsedBetween TO public
GRANT EXEC ON dbo.spTDRPList TO public
GRANT EXEC ON dbo.spTDRPMatchingList TO public
GRANT EXEC ON dbo.spTDRPSelect TO public
GRANT EXEC ON dbo.spPersonListPrepareBatchCOr TO public
GRANT EXEC ON dbo.spCustomFieldGet TO public
GRANT EXEC ON dbo.spCustomFieldItemGet TO public
GRANT EXEC ON dbo.spPersonCustomFieldList2 TO public
GO
IF OBJECT_id('dbo.spPermissionSelectOnEmployeeContainerForSelf') IS NOT NULL DROP PROC dbo.spPermissionSelectOnEmployeeContainerForSelf
IF OBJECT_id('dbo.spPermissionSelectOnEmployeeContainerForSuperiors') IS NOT NULL DROP PROC dbo.spPermissionSelectOnEmployeeContainerForSuperiors
IF OBJECT_id('dbo.spPermissionSummarizeForSpecialUsersOnEmployeeContainer') IS NOT NULL DROP PROC dbo.spPermissionSummarizeForSpecialUsersOnEmployeeContainer
IF OBJECT_id('dbo.spPermissionSelectOnContainerForUser') IS NOT NULL DROP PROC dbo.spPermissionSelectOnContainerForUser
GO
-- Returns the permission for the current user on several attributes
-- Fill TempPersonPermission with a random BatchID, the people under consideration, and the attributes in question
-- TempPersonPermission.[Permission Mask] will return the effective permissions
ALTER PROC dbo.spPermissionGetOnPeopleForCurrentUser
	@batch_id int
AS
DECLARE @employee_id int
DECLARE @department_id int
DECLARE @division_id int
DECLARE @location_id int, @requested_records int
DECLARE @manager_id int, @cached_records int
DECLARE @org_user_field_1 int
DECLARE @sid varbinary(85)
DECLARE @uid int, @cache_expires datetime

SET NOCOUNT ON

IF IS_MEMBER('db_owner') = 1
	UPDATE dbo.TempPersonPermission SET [Permission Mask] = 0x7FFFFFFF WHERE BatchID = @batch_id
ELSE
BEGIN
	SELECT @sid = SUSER_SID(), @cache_expires = DATEADD(hour,-1,GETDATE())

	DELETE dbo.PermissionCached WHERE Created < @cache_expires

	SELECT @requested_records = COUNT(*) FROM dbo.TempPersonPermission WHERE BatchID = @batch_id
	SELECT @cached_records = COUNT(*) FROM dbo.TempPersonPermission T INNER JOIN dbo.PermissionCached C ON C.SID=@sid AND T.BatchID = @batch_id AND T.PersonID=C.PersonID AND T.AttributeID=C.AttributeID

	IF @requested_records = @cached_records
	BEGIN
		UPDATE T SET [Permission Mask] = C.[Permission Mask]
		FROM dbo.TempPersonPermission T 
		INNER JOIN dbo.PermissionCached C ON C.SID=@sid AND T.BatchID = @batch_id AND T.PersonID=C.PersonID AND T.AttributeID=C.AttributeID
		SET @cached_records = @@ROWCOUNT
		
		-- Abort using the cache. PermissionCached changed between checking for a match and updating TempPersonPermission
		IF @requested_records <> @cached_records
		UPDATE dbo.TempPersonPermission SET [Permission Mask] = 0, [Deny Mask] = 0 WHERE BatchID =- @batch_id
	END
	
	IF @requested_records <> @cached_records
	BEGIN
		SELECT @org_user_field_1 = OrgUserField1, @employee_id = EmployeeID, @manager_id = ManagerID, @division_id = DivisionID, @department_id = DepartmentID, @location_id = LocationID FROM Employee WHERE SID = @sid

		DECLARE user_cursor CURSOR LOCAL FORWARD_ONLY STATIC FOR 
		SELECT U.uid
		FROM sysusers U WHERE U.SID = @sid OR IS_MEMBER(U.[name]) = 1

		-- Loops for every user\account\role to which the current user belongs
		OPEN user_cursor
		FETCH NEXT FROM user_cursor INTO @uid
		WHILE @@FETCH_STATUS = 0
		BEGIN
			-- Merge permissions on all people
			UPDATE TPP SET [Permission Mask] = TPP.[Permission Mask] | P.[Permission Mask], [Deny Mask] = TPP.[Deny Mask] | P.[Deny Mask]
			FROM TempPersonPermission TPP
			INNER JOIN PermissionScopeAttribute P ON TPP.BatchID = @batch_id AND P.ScopeID = 1 AND P.AttributeID = TPP.AttributeID AND P.UID = @uid

			-- Merge permissions on applicants
			UPDATE TPP SET [Permission Mask] = TPP.[Permission Mask] | P.[Permission Mask], [Deny Mask] = TPP.[Deny Mask] | P.[Deny Mask]
			FROM TempPersonPermission TPP
			INNER JOIN Applicant A ON TPP.BatchID = @batch_id AND TPP.PersonID = A.ApplicantID
			INNER JOIN PermissionScopeAttribute P ON P.ScopeID = 128 AND P.AttributeID = TPP.AttributeID AND P.UID = @uid
		
			-- Merge permissions on employees
			UPDATE TPP SET [Permission Mask] = TPP.[Permission Mask] | P.[Permission Mask], [Deny Mask] = TPP.[Deny Mask] | P.[Deny Mask]
			FROM TempPersonPermission TPP
			INNER JOIN Employee E ON TPP.BatchID = @batch_id AND TPP.PersonID = E.EmployeeID
			INNER JOIN PermissionScopeAttribute P ON P.ScopeID = 2 AND P.AttributeID = TPP.AttributeID AND P.UID = @uid
		
			-- Merge permissions on employees (self)
			UPDATE TPP SET [Permission Mask] = TPP.[Permission Mask] | P.[Permission Mask], [Deny Mask] = TPP.[Deny Mask] | P.[Deny Mask]
			FROM TempPersonPermission TPP
			INNER JOIN PermissionScopeAttribute P ON TPP.PersonID=@employee_id AND
			P.ScopeID = 4 AND P.AttributeID = TPP.AttributeID AND P.UID = @uid
		
			-- Merge permissions on employees (manager)
			UPDATE TPP SET [Permission Mask] = TPP.[Permission Mask] | P.[Permission Mask], [Deny Mask] = TPP.[Deny Mask] | P.[Deny Mask]
			FROM TempPersonPermission TPP
			INNER JOIN Employee E ON TPP.BatchID = @batch_id AND TPP.PersonID = E.ManagerID AND E.EmployeeID = @employee_id
			INNER JOIN PermissionScopeAttribute P ON P.ScopeID = 512 AND P.AttributeID = TPP.AttributeID AND P.UID = @uid
		
			-- Merge permissions on employees (division)
			UPDATE TPP SET [Permission Mask] = TPP.[Permission Mask] | P.[Permission Mask], [Deny Mask] = TPP.[Deny Mask] | P.[Deny Mask]
			FROM TempPersonPermission TPP
			INNER JOIN Employee E ON TPP.BatchID = @batch_id AND TPP.PersonID = E.EmployeeID AND E.DivisionID = @division_id
			INNER JOIN PermissionScopeAttribute P ON P.ScopeID = 16 AND P.AttributeID = TPP.AttributeID AND P.UID = @uid
		
			-- Merge permissions on employees (org user field 1)
			UPDATE TPP SET [Permission Mask] = TPP.[Permission Mask] | P.[Permission Mask], [Deny Mask] = TPP.[Deny Mask] | P.[Deny Mask]
			FROM TempPersonPermission TPP
			INNER JOIN Employee E ON @org_user_field_1 IS NOT NULL AND TPP.BatchID = @batch_id AND TPP.PersonID = E.EmployeeID AND (
				(@org_user_field_1 IS NOT NULL AND E.OrgUserField1 = @org_user_field_1) OR EXISTS(
					SELECT * FROM dbo.EmployeeUserFieldItem WHERE EmployeeID=@employee_id AND ItemID=E.OrgUserField1
				)
			)
			INNER JOIN PermissionScopeAttribute P ON P.ScopeID = 4096 AND P.AttributeID = TPP.AttributeID AND P.UID = @uid
		
			-- Merge permissions on employees (inactive employees)
			UPDATE TPP SET [Permission Mask] = TPP.[Permission Mask] | P.[Permission Mask], [Deny Mask] = TPP.[Deny Mask] | P.[Deny Mask]
			FROM TempPersonPermission TPP
			INNER JOIN Employee E ON TPP.BatchID = @batch_id AND TPP.PersonID = E.EmployeeID AND E.[Active Employee] = 0
			INNER JOIN PermissionScopeAttribute P ON P.ScopeID = 8192 AND P.AttributeID = TPP.AttributeID AND P.UID = @uid

			-- Merge permissions on employees (leave keeper -- division)
			UPDATE TPP SET [Permission Mask] = TPP.[Permission Mask] | P.[Permission Mask], [Deny Mask] = TPP.[Deny Mask] | P.[Deny Mask]
			FROM TempPersonPermission TPP
			INNER JOIN Employee E ON TPP.BatchID = @batch_id AND TPP.PersonID = E.EmployeeID
			INNER JOIN dbo.Division V ON E.DivisionID = V.DivisionID AND V.LeaveKeeperID = @employee_id
			INNER JOIN PermissionScopeAttribute P ON P.ScopeID = 16384 AND P.AttributeID = TPP.AttributeID AND P.UID = @uid

			-- Merge permissions on employees (leave keeper -- department)
			UPDATE TPP SET [Permission Mask] = TPP.[Permission Mask] | P.[Permission Mask], [Deny Mask] = TPP.[Deny Mask] | P.[Deny Mask]
			FROM TempPersonPermission TPP
			INNER JOIN Employee E ON TPP.BatchID = @batch_id AND TPP.PersonID = E.EmployeeID
			INNER JOIN dbo.Department D ON E.DepartmentID = D.DepartmentID AND D.LeaveKeeperID = @employee_id
			INNER JOIN PermissionScopeAttribute P ON P.ScopeID = 16384 AND P.AttributeID = TPP.AttributeID AND P.UID = @uid

			-- Merge permissions on employees (department)
			UPDATE TPP SET [Permission Mask] = TPP.[Permission Mask] | P.[Permission Mask], [Deny Mask] = TPP.[Deny Mask] | P.[Deny Mask]
			FROM TempPersonPermission TPP
			INNER JOIN Employee E ON TPP.BatchID = @batch_id AND TPP.PersonID = E.EmployeeID AND E.DepartmentID = @department_id
			INNER JOIN PermissionScopeAttribute P ON P.ScopeID = 32 AND P.AttributeID = TPP.AttributeID AND P.UID = @uid
		
			-- Merge permissions on employees (location)
			UPDATE TPP SET [Permission Mask] = TPP.[Permission Mask] | P.[Permission Mask], [Deny Mask] = TPP.[Deny Mask] | P.[Deny Mask]
			FROM TempPersonPermission TPP
			INNER JOIN Employee E ON TPP.BatchID = @batch_id AND TPP.PersonID = E.EmployeeID AND E.LocationID = @location_id
			INNER JOIN PermissionScopeAttribute P ON P.ScopeID = 64 AND P.AttributeID = TPP.AttributeID AND P.UID = @uid
		
			-- Merge permissions on employees (subordinates)
			UPDATE TPP SET [Permission Mask] = TPP.[Permission Mask] | P.[Permission Mask], [Deny Mask] = TPP.[Deny Mask] | P.[Deny Mask]
			FROM TempPersonPermission TPP
			INNER JOIN Employee E ON TPP.BatchID = @batch_id AND TPP.PersonID = E.EmployeeID
			INNER JOIN EmployeeSuperior S ON S.EmployeeID = E.EmployeeID AND S.SuperiorID = @employee_id
			INNER JOIN PermissionScopeAttribute P ON P.ScopeID = 8 AND P.AttributeID = TPP.AttributeID AND P.UID = @uid
		
			-- Merge permissions on employees (delegated subordinates)
			UPDATE TPP SET [Permission Mask] = TPP.[Permission Mask] | P.[Permission Mask]
			FROM TempPersonPermission TPP
			INNER JOIN Employee E ON TPP.BatchID = @batch_id AND TPP.PersonID = E.EmployeeID
			INNER JOIN EmployeeSuperior S ON S.EmployeeID = E.EmployeeID
			INNER JOIN Employee DM ON S.SuperiorID = DM.EmployeeID AND DM.DelegatedManagerID = @employee_id
			INNER JOIN PermissionScopeAttribute P ON P.ScopeID = 256 AND P.AttributeID = TPP.AttributeID AND P.UID = @uid
		
			-- Merge permissions on employees (delegated self)
			UPDATE TPP SET [Permission Mask] = TPP.[Permission Mask] | P.[Permission Mask], [Deny Mask] = TPP.[Deny Mask] | P.[Deny Mask]
			FROM TempPersonPermission TPP
			INNER JOIN Employee E ON TPP.BatchID = @batch_id AND TPP.PersonID = E.EmployeeID AND E.DelegatedManagerID = @employee_id
			INNER JOIN PermissionScopeAttribute P ON P.ScopeID = 1024 AND P.AttributeID = TPP.AttributeID AND P.UID = @uid
		
			-- Merge permissions on manager's subordinates
			UPDATE TPP SET [Permission Mask] = TPP.[Permission Mask] | P.[Permission Mask], [Deny Mask] = TPP.[Deny Mask] | P.[Deny Mask]
			FROM TempPersonPermission TPP
			INNER JOIN Employee E ON TPP.BatchID = @batch_id AND TPP.PersonID = E.EmployeeID
			INNER JOIN EmployeeSuperior S ON S.EmployeeID = E.EmployeeID AND S.SuperiorID = @manager_id
			INNER JOIN PermissionScopeAttribute P ON P.ScopeID = 2048 AND P.AttributeID = TPP.AttributeID AND P.UID = @uid

		
			FETCH NEXT FROM user_cursor INTO @uid
		END
		CLOSE user_cursor
		DEALLOCATE user_cursor
	
		-- Any deny overrides every grant
		UPDATE dbo.TempPersonPermission SET [Permission Mask] = [Permission Mask] & ([Deny Mask] ^ 0x7FFFFFFF) WHERE BatchID = @batch_id

		DELETE C FROM dbo.PermissionCached C INNER JOIN dbo.TempPersonPermission T ON C.SID=@sid AND T.BatchID = @batch_id AND T.PersonID=C.PersonID AND T.AttributeID=C.AttributeID

		INSERT dbo.PermissionCached(SID, PersonID, AttributeID, [Permission Mask])
		SELECT @sid, PersonID, AttributeID, [Permission Mask] FROM dbo.TempPersonPermission WHERE BatchID = @batch_id AND PersonID IS NOT NULL
	END
END

DELETE TempPersonPermission WHERE DATEDIFF(hour,Created,GETDATE()) > 1
GO
-- Returns the permission for the current user on one attribute
-- Fill TempX with a random BatchID and the people under consideration
-- TempX.X will return the effective permissions
ALTER PROC dbo.spPermissionGetOnPeopleForCurrentUser2
	@batch_id int,
	@attribute_id int
AS
DECLARE @employee_id int
DECLARE @department_id int
DECLARE @division_id int
DECLARE @location_id int
DECLARE @manager_id int
DECLARE @org_user_field_1 int
DECLARE @sid varbinary(85)
DECLARE @uid int

SET NOCOUNT ON

IF IS_MEMBER('db_owner') = 1
	UPDATE TempX SET X = 0x7FFFFFFF WHERE BatchID = @batch_id
ELSE
BEGIN
	DECLARE @requested_records int, @cached_records int, @cache_expires datetime
	SELECT @sid = SUSER_SID(), @cache_expires = DATEADD(hour,-1,GETDATE())

	UPDATE TempX SET X = 0, Y = 0 WHERE BatchID = @batch_id
	SET @requested_records = @@ROWCOUNT

	DELETE dbo.PermissionCached WHERE Created < @cache_expires

	SELECT @cached_records = COUNT(*) FROM dbo.TempX X INNER JOIN dbo.PermissionCached C ON C.SID = @sid AND X.BatchID = @batch_id AND X.[ID] = C.PersonID AND C.AttributeID = @attribute_id
	
	IF @requested_records = @cached_records
	BEGIN
		UPDATE X SET X = C.[Permission Mask]
		FROM dbo.TempX X
		INNER JOIN dbo.PermissionCached C ON C.SID = @sid AND X.BatchID = @batch_id AND X.[ID] = C.PersonID AND C.AttributeID = @attribute_id
		SET @cached_records = @@ROWCOUNT

		-- Abort cache. Cache changed.
		IF @requested_records <> @cached_records UPDATE dbo.TempX SET X=0 WHERE BatchID = @batch_id
	END
	
	IF @requested_records <> @cached_records
	BEGIN
		SELECT @org_user_field_1 = OrgUserField1, @manager_id = ManagerID, @employee_id = EmployeeID, @division_id = DivisionID, @department_id = DepartmentID, @location_id = LocationID FROM Employee WHERE SID = @sid

		DECLARE user_cursor CURSOR LOCAL FORWARD_ONLY STATIC FOR 
		SELECT U.uid
		FROM sysusers U WHERE U.SID = @sid OR IS_MEMBER(U.[name]) = 1

		-- Loops for every user\account\role to which the current user belongs
		OPEN user_cursor
		FETCH NEXT FROM user_cursor INTO @uid
		WHILE @@FETCH_STATUS = 0
		BEGIN
			-- Merge permissions on all people
			UPDATE TPP SET [X] = TPP.[X] | P.[Permission Mask], Y = TPP.Y | P.[Deny Mask]
			FROM TempX TPP
			INNER JOIN PermissionScopeAttribute P ON TPP.BatchID = @batch_id AND P.ScopeID = 1 AND P.AttributeID = @attribute_id AND P.UID = @uid

			-- Merge permissions on applicants
			UPDATE TPP SET [X] = TPP.[X] | P.[Permission Mask], Y = TPP.Y | P.[Deny Mask]
			FROM TempX TPP
			INNER JOIN Applicant A ON TPP.BatchID = @batch_id AND TPP.[ID] = A.ApplicantID
			INNER JOIN PermissionScopeAttribute P ON P.ScopeID = 128 AND P.AttributeID = @attribute_id AND P.UID = @uid
		
			-- Merge permissions on employees
			UPDATE TPP SET [X] = TPP.[X] | P.[Permission Mask], Y = TPP.Y | P.[Deny Mask]
			FROM TempX TPP
			INNER JOIN Employee E ON TPP.BatchID = @batch_id AND TPP.[ID] = E.EmployeeID
			INNER JOIN PermissionScopeAttribute P ON P.ScopeID = 2 AND P.AttributeID = @attribute_id AND P.UID = @uid
				
			-- Merge permissions on employees (self)
			UPDATE TPP SET [X] = TPP.[X] | P.[Permission Mask], Y = TPP.Y | P.[Deny Mask]
			FROM TempX TPP
			INNER JOIN PermissionScopeAttribute P ON TPP.BatchID = @batch_id AND TPP.[ID]=@employee_id AND P.ScopeID = 4 AND P.AttributeID = @attribute_id AND P.UID = @uid
		
			-- Merge permissions on employees (manager)
			UPDATE TPP SET [X] = TPP.[X] | P.[Permission Mask], Y = TPP.Y | P.[Deny Mask]
			FROM TempX TPP
			INNER JOIN PermissionScopeAttribute P ON TPP.BatchID = @batch_id AND TPP.[ID]=@manager_id AND P.ScopeID = 512 AND P.AttributeID = @attribute_id AND P.UID = @uid

			-- Merge permissions on employees (division)
			UPDATE TPP SET [X] = TPP.[X] | P.[Permission Mask], Y = TPP.Y | P.[Deny Mask]
			FROM TempX TPP
			INNER JOIN Employee E ON TPP.BatchID = @batch_id AND TPP.[ID] = E.EmployeeID AND E.DivisionID = @division_id
			INNER JOIN PermissionScopeAttribute P ON P.ScopeID = 16 AND P.AttributeID = @attribute_id AND P.UID = @uid
		
			-- Merge permissions on employees (orguserfield1)
			UPDATE TPP SET [X] = TPP.[X] | P.[Permission Mask], Y = TPP.Y | P.[Deny Mask]
			FROM TempX TPP
			INNER JOIN Employee E ON TPP.BatchID = @batch_id AND TPP.[ID] = E.EmployeeID AND (
				(@org_user_field_1 IS NOT NULL AND E.OrgUserField1 = @org_user_field_1) OR EXISTS (
					SELECT * FROM dbo.EmployeeUserFieldItem WHERE EmployeeID=@employee_id AND ItemID=E.OrgUserField1
				)
			)
			INNER JOIN PermissionScopeAttribute P ON P.ScopeID = 4096 AND P.AttributeID = @attribute_id AND P.UID = @uid

			-- Merge permissions on employees (inactive employee)
			UPDATE TPP SET [X] = TPP.[X] | P.[Permission Mask], Y = TPP.Y | P.[Deny Mask]
			FROM TempX TPP
			INNER JOIN Employee E ON TPP.BatchID = @batch_id AND TPP.[ID] = E.EmployeeID AND E.[Active Employee] = 0
			INNER JOIN PermissionScopeAttribute P ON P.ScopeID = 8192 AND P.AttributeID = @attribute_id AND P.UID = @uid

			-- Merge permissions on employees (leave keeper -- division)
			UPDATE TPP SET [X] = TPP.[X] | P.[Permission Mask], Y = TPP.Y | P.[Deny Mask]
			FROM TempX TPP
			INNER JOIN Employee E ON TPP.BatchID = @batch_id AND TPP.[ID] = E.EmployeeID
			INNER JOIN dbo.Division V ON E.DivisionID = V.DivisionID AND V.LeaveKeeperID = @employee_id
			INNER JOIN PermissionScopeAttribute P ON P.ScopeID = 16384 AND P.AttributeID = @attribute_id AND P.UID = @uid

			-- Merge permissions on employees (leave keeper -- department)
			UPDATE TPP SET [X] = TPP.[X] | P.[Permission Mask], Y = TPP.Y | P.[Deny Mask]
			FROM TempX TPP
			INNER JOIN Employee E ON TPP.BatchID = @batch_id AND TPP.[ID] = E.EmployeeID
			INNER JOIN dbo.Department D ON E.DepartmentID = D.DepartmentID AND D.LeaveKeeperID = @employee_id
			INNER JOIN PermissionScopeAttribute P ON P.ScopeID = 16384 AND P.AttributeID = @attribute_id AND P.UID = @uid
		
			-- Merge permissions on employees (department)
			UPDATE TPP SET [X] = TPP.[X] | P.[Permission Mask], Y = TPP.Y | P.[Deny Mask]
			FROM TempX TPP
			INNER JOIN Employee E ON TPP.BatchID = @batch_id AND TPP.[ID] = E.EmployeeID AND E.DepartmentID = @department_id
			INNER JOIN PermissionScopeAttribute P ON P.ScopeID = 32 AND P.AttributeID = @attribute_id AND P.UID = @uid
		
			-- Merge permissions on employees (location)
			UPDATE TPP SET [X] = TPP.[X] | P.[Permission Mask], Y = TPP.Y | P.[Deny Mask]
			FROM TempX TPP
			INNER JOIN Employee E ON TPP.BatchID = @batch_id AND TPP.[ID] = E.EmployeeID AND E.LocationID = @location_id
			INNER JOIN PermissionScopeAttribute P ON P.ScopeID = 64 AND P.AttributeID = @attribute_id AND P.UID = @uid
		
			-- Merge permissions on employees (subordinates)
			UPDATE TPP SET [X] = TPP.[X] | P.[Permission Mask], Y = TPP.Y | P.[Deny Mask]
			FROM TempX TPP
			INNER JOIN Employee E ON TPP.BatchID = @batch_id AND TPP.[ID] = E.EmployeeID
			INNER JOIN EmployeeSuperior S ON S.EmployeeID = E.EmployeeID AND S.SuperiorID = @employee_id
			INNER JOIN PermissionScopeAttribute P ON P.ScopeID = 8 AND P.AttributeID = @attribute_id AND P.UID = @uid
		
			-- Merge permissions on employees (delegated subordinates)
			UPDATE TPP SET [X] = TPP.[X] | P.[Permission Mask]
			FROM TempX TPP
			INNER JOIN Employee E ON TPP.BatchID = @batch_id AND TPP.[ID] = E.EmployeeID
			INNER JOIN EmployeeSuperior S ON S.EmployeeID = E.EmployeeID
			INNER JOIN Employee DM ON S.SuperiorID = DM.EmployeeID AND DM.DelegatedManagerID = @employee_id
			INNER JOIN PermissionScopeAttribute P ON P.ScopeID = 256 AND P.AttributeID = @attribute_id AND P.UID = @uid
		
			-- Merge permissions on employees (delegated self)
			UPDATE TPP SET [X] = TPP.[X] | P.[Permission Mask]
			FROM TempX TPP
			INNER JOIN Employee E ON TPP.BatchID = @batch_id AND TPP.[ID] = E.EmployeeID AND E.DelegatedManagerID = @employee_id
			INNER JOIN PermissionScopeAttribute P ON P.ScopeID = 1024 AND P.AttributeID = @attribute_id AND P.UID = @uid
		
			-- Merge permissions on manager's subordinates
			UPDATE TPP SET [X] = TPP.[X] | P.[Permission Mask], Y = TPP.Y | P.[Deny Mask]
			FROM TempX TPP
			INNER JOIN Employee E ON TPP.BatchID = @batch_id AND TPP.[ID] = E.EmployeeID
			INNER JOIN EmployeeSuperior S ON S.EmployeeID = E.EmployeeID AND S.SuperiorID = @manager_id
			INNER JOIN PermissionScopeAttribute P ON P.ScopeID = 2048 AND P.AttributeID = @attribute_id AND P.UID = @uid

			FETCH NEXT FROM user_cursor INTO @uid
		END
		CLOSE user_cursor
		DEALLOCATE user_cursor

		-- Any deny overrides every grant
		UPDATE TempX SET X = X & (Y ^ 0x7FFFFFFF) WHERE BatchID = @batch_id

		DELETE C FROM dbo.PermissionCached C
		INNER JOIN dbo.TempX X ON C.SID = @sid AND C.AttributeID = @attribute_id AND X.BatchID=@batch_id AND X.[ID] = C.PersonID

		INSERT dbo.PermissionCached(SID, PersonID, AttributeID, [Permission Mask])
		SELECT @sid, [ID], @attribute_id, X FROM dbo.TempX WHERE BatchID = @batch_id AND [ID] IS NOT NULL
	END
END

DELETE TempX WHERE DATEDIFF(hour,Created,GETDATE()) > 1
GO
ALTER PROC dbo.spEmployeeLeaveUsedRecalc
	@leave_id int
AS
DECLARE @total_advanced_type_mask int, @item_advanced_type_mask int
DECLARE @total_type_mask int, @item_type_id int
DECLARE @approval_mask int

SELECT @total_advanced_type_mask = 0, @total_type_mask = 0
SELECT @approval_mask = ISNULL(T.[Leave Type Mask],0)
FROM EmployeeLeaveUsed U
LEFT JOIN LeaveApprovalType T ON U.ApprovalTypeID=T.TypeID
WHERE U.LeaveID=@leave_id

DECLARE i_cursor CURSOR LOCAL FORWARD_ONLY STATIC FOR SELECT TypeID, Advanced FROM LeaveType WHERE (TypeID & @approval_mask) != 0
OPEN i_cursor

DECLARE @type_id int, @advanced bit
FETCH i_cursor INTO @type_id, @advanced
WHILE @@FETCH_STATUS = 0
BEGIN
	IF @advanced=1 SELECT @total_advanced_type_mask = @total_advanced_type_mask | @type_id
	ELSE SELECT @total_type_mask = @total_type_mask | @type_id
	FETCH i_cursor INTO @type_id, @advanced
END

CLOSE i_cursor
DEALLOCATE i_cursor

DECLARE i_cursor CURSOR LOCAL FORWARD_ONLY STATIC FOR SELECT DISTINCT [Advanced Type Mask] FROM EmployeeLeaveUsedItem WHERE LeaveID=@leave_id
OPEN i_cursor

FETCH i_cursor INTO @item_advanced_type_mask 
WHILE @@FETCH_STATUS = 0
BEGIN
	SELECT @total_advanced_type_mask = @total_advanced_type_mask | @item_advanced_type_mask
	FETCH i_cursor INTO @item_advanced_type_mask 
END


CLOSE i_cursor
DEALLOCATE i_cursor

DECLARE i_cursor CURSOR LOCAL FORWARD_ONLY STATIC FOR SELECT DISTINCT TypeID FROM EmployeeLeaveUsedItem WHERE LeaveID=@leave_id
OPEN i_cursor

FETCH i_cursor INTO @item_type_id 
WHILE @@FETCH_STATUS = 0
BEGIN
	SELECT @total_type_mask = @total_type_mask | @item_type_id
	FETCH i_cursor INTO @item_type_id 
END

CLOSE i_cursor
DEALLOCATE i_cursor

DECLARE @start int, @stop int, @ppe_start int, @ppe_stop int, @created_start int, @created_stop int, @stop_temp int

SELECT @start = (
	SELECT MIN([Day past 1900]) FROM EmployeeLeaveUsedItem I WHERE I.LeaveID = @leave_id
), @stop = (
	SELECT MAX([Day past 1900]) FROM EmployeeLeaveUsedItem I WHERE I.LeaveID = @leave_id
), @ppe_start = (
	SELECT MIN([PPE Day past 1900]) FROM EmployeeLeaveUsedItem I WHERE I.LeaveID = @leave_id
), @ppe_stop = (
	SELECT MAX([PPE Day past 1900]) FROM EmployeeLeaveUsedItem I WHERE I.LeaveID = @leave_id
), @created_start = (
	SELECT MIN([Created Day past 1900]) FROM EmployeeLeaveUsedItem I WHERE I.LeaveID = @leave_id
), @created_stop = (
	SELECT MAX([Created Day past 1900]) FROM EmployeeLeaveUsedItem I WHERE I.LeaveID = @leave_id
)

SELECT @stop_temp = CASE
	WHEN [Authorization Expires Day past 1900] IS NOT NULL THEN [Authorization Expires Day past 1900]
	WHEN [Expected Return Day past 1900] IS NOT NULL THEN [Expected Return Day past 1900] 
	WHEN [Expected Departure Day past 1900] IS NOT NULL THEN [Expected Departure Day past 1900]
	ELSE NULL
END FROM EmployeeLeaveUsed WHERE LeaveID = @leave_id



UPDATE EmployeeLeaveUsed SET [Start Day past 1900] = CASE 
	WHEN @start IS NOT NULL THEN @start
	WHEN [Expected Departure Day past 1900] IS NOT NULL THEN [Expected Departure Day past 1900]
	WHEN [Requested Day past 1900] IS NOT NULL THEN [Requested Day past 1900]
	ELSE [Created Day past 1900]
END, [Stop Day past 1900] = CASE
	WHEN @stop IS NULL AND @stop_temp IS NULL THEN 2147483647
	WHEN @stop IS NOT NULL THEN @stop
	ELSE @stop_temp
END,
[Last Day Used] = @stop,
[First Day Used] = @start,
[Type Mask] = @total_type_mask,
Seconds = ISNULL((
	SELECT SUM(Seconds) FROM EmployeeLeaveUsedItem I WHERE I.LeaveID = @leave_id
), 0),
[Advanced Seconds] = ISNULL((
	SELECT SUM(Seconds) FROM EmployeeLeaveUsedItem I WHERE I.LeaveID = @leave_id AND [Advanced Type Mask] > 0
), 0),
[Advanced Type Mask] = @total_advanced_type_mask,
[PPE Start Day past 1900] = ISNULL(@ppe_start, [Created Day past 1900]),
[PPE Stop Day past 1900] = ISNULL(@ppe_stop, [Created Day past 1900]),
[Created Start Day past 1900] = ISNULL(@created_start, [Created Day past 1900]),
[Created Stop Day past 1900] = ISNULL(@created_stop, [Created Day past 1900])
FROM EmployeeLeaveUsed U WHERE LeaveID = @leave_id

DECLARE @employee_id int
SELECT @employee_id=EmployeeID FROM EmployeeLeaveUsed WHERE LeaveID=@leave_id
UPDATE E SET LastLeaveID=(SELECT TOP 1 LeaveID FROM EmployeeLeaveUsed U WHERE U.EmployeeID=E.EmployeeID ORDER BY [Stop Day past 1900] DESC)
FROM Employee E WHERE EmployeeID=@employee_id
GO
ALTER PROCEDURE dbo.[spLeaveApprovalTypeInsert]
	@type varchar(50),
	@type_id int OUT,
	@leave_type_mask int = 0x7FFFFFFF
AS
DECLARE @continue bit
DECLARE @error bit

SELECT @type_id = 1, @continue = 0, @error = 0
SELECT @continue = 1 FROM LeaveApprovalType WHERE TypeID = @type_id

WHILE @continue = 1
BEGIN
	SELECT @type_id = @type_id * 2, @continue = 0

	IF @type_id = 0x40000000
		SELECT @error = 1 FROM LeaveApprovalType WHERE TypeID = @type_id
	ELSE
		SELECT @continue = 1 FROM LeaveApprovalType WHERE TypeID = @type_id
END

IF @error = 1 EXEC dbo.spErrorRaise 50006
ELSE
BEGIN
	INSERT LeaveApprovalType(TypeID, [Type], [Leave Type Mask])
	VALUES(@type_id, @type, @leave_type_mask)
END
GO
ALTER PROC dbo.spCustomFieldItemInsert
	@field_id int,
	@text varchar(50),
	@value int = null OUT,
	@item_id int OUT
AS
DECLARE @continue int, @error bit
SELECT @value = 1, @continue = 0, @error = 0
SELECT @continue = 1 FROM CustomFieldItem WHERE FieldID=@field_id AND [Value]=@value
WHILE @continue = 1
BEGIN
	SELECT @value = @value * 2, @continue = 0
	IF @value = 0x40000000 SELECT @error = 1 FROM CustomFieldItem WHERE FieldID=@field_id AND [Value]=@value
	ELSE SELECT @continue = 1 FROM CustomFieldItem WHERE FieldID=@field_id AND [Value]=@value
END
IF @error = 1 EXEC dbo.spErrorRaise 50051
ELSE
BEGIN
	INSERT CustomFieldItem(FieldID, [Value], [Text])
	VALUES(@field_id, @value, @text)

	SET @item_id=SCOPE_IDENTITY()
END
GO
ALTER PROC dbo.[spLeaveApprovalTypeUpdate]
	@type_id int,
	@type varchar(50),
	@leave_type_mask int = 0x7FFFFFFF
AS
SET NOCOUNT ON

UPDATE LeaveApprovalType SET Type = @type, [Leave Type Mask] = @leave_type_mask WHERE TypeID = @type_id
GO
ALTER PROC dbo.[spLeaveApprovalTypeList]
AS
SET NOCOUNT ON

SELECT * FROM LeaveApprovalType ORDER BY [Type]
GO
ALTER PROC dbo.spLeaveApprovalTypeList
AS
SET NOCOUNT ON

SELECT TypeID, Type, [Leave Type Mask], [Leave Types] = CAST('' AS varchar(50)) INTO #LAT FROM LeaveApprovalType
DECLARE @all_leave_types int, @type_id int, @type varchar(50)
SET @all_leave_types = 0

DECLARE LeaveTypeCursor CURSOR LOCAL FORWARD_ONLY STATIC FOR SELECT TypeID, Type FROM LeaveType ORDER BY [Order], [Type]
OPEN LeaveTypeCursor

FETCH LeaveTypeCursor INTO @type_id, @type

WHILE @@FETCH_STATUS = 0
BEGIN
	SET @all_leave_types = @all_leave_types | @type_id
	UPDATE #LAT SET [Leave Types] = SUBSTRING([Leave Types] + CASE [Leave Types] 
		WHEN '' THEN @type
		ELSE ',' + @type
	END, 1, 50)
	WHERE ([Leave Type Mask] & @type_id) > 0

	FETCH LeaveTypeCursor INTO @type_id, @type
END

CLOSE LeaveTypeCursor
DEALLOCATE LeaveTypeCursor

UPDATE #LAT SET [Leave Types] = 'All' WHERE ([Leave Type Mask] & @all_leave_types) = @all_leave_types

SELECT * FROM #LAT ORDER BY [Type]
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spEmployeeTimeTotalPerDay'
GO
ALTER PROC dbo.spEmployeeTimeTotalPerDay
	@employee_id int,
	@start_day int,
	@stop_day int
AS
DECLARE @batch_id int
DECLARE @authorized bit

SET NOCOUNT ON

EXEC dbo.spPermissionInsureForCurrentUserOnPerson @employee_id, 262144, 1, @authorized
IF @authorized=0 RETURN

SET @batch_id = RAND() * 2147483647
INSERT dbo.TempX(BatchID,[ID]) SELECT @batch_id, @employee_id

CREATE TABLE #EMPLOYEE_TIME_ROUNDED(
	TempItemID int NOT NULL IDENTITY(1,1) PRIMARY KEY,
	EmployeeID int NOT NULL,
	OriginalTypeID int NOT NULL, 
	CalculatedTypeID int NOT NULL,
	[In Day past 1900] int NOT NULL, 
	[OT Eligible] bit NOT NULL,
	[OT Disable] bit NOT NULL,
	[Pay Rate] money NOT NULL,
	[Fixed Pay] money NOT NULL DEFAULT(0),
	[Fixed Items] int DEFAULT(0),
	Regular bit DEFAULT(0),
	[In Seconds] int NOT NULL,
	[Out Seconds] int NOT NULL,
	TimeSchemaID int NOT NULL,
	ShiftDiffItemID int NULL,
	TempShiftDiffSeconds int NULL,
	TempShiftDiffItemID int NULL,
	OriginalTimeItemID int NULL,
	CopyTimeItemID int NULL,
	[Time Seconds] int NOT NULL DEFAULT(0),
	[Holiday Seconds] int NOT NULL DEFAULT(0),
	[OT Seconds] int NOT NULL DEFAULT(0),
	Flags int NOT NULL DEFAULT(0),
	[Actual In] datetime NULL,
	[Actual Out] datetime NULL,
	[Base Seconds] int NOT NULL DEFAULT(0),
	[X2 Seconds] int NOT NULL DEFAULT(0)
)

DECLARE @denied_type_id int
EXEC dbo.spEmployeeTimeRoundAndCalcOT @batch_id, 0, @start_day OUT, @stop_day OUT, NULL, NULL, @authorized OUT, 0, @denied_type_id OUT



DELETE dbo.TempX WHERE BatchID=@batch_id OR DATEDIFF(minute,Created,GETDATE()) > 60

CREATE TABLE #T(D int, [Time Seconds] int, [Leave Seconds] int)
INSERT #T
SELECT DISTINCT [In Day past 1900],0,0 FROM #EMPLOYEE_TIME_ROUNDED
UNION -- intrinsic distinct
SELECT DISTINCT [Day past 1900],0,0 FROM vwEmployeeLeaveUsedItemNotDenied WHERE EmployeeID=@employee_id AND [Day past 1900] BETWEEN @start_day AND @stop_day



UPDATE #T SET
[Time Seconds] = ISNULL(
	(SELECT SUM([Base Seconds]) FROM #EMPLOYEE_TIME_ROUNDED WHERE #EMPLOYEE_TIME_ROUNDED.[In Day past 1900]=#T.D AND CalculatedTypeID <> @denied_type_id)
, 0),
[Leave Seconds] =  
ISNULL((SELECT SUM(I.Seconds) FROM vwEmployeeLeaveUsedItem I WHERE I.EmployeeID=@employee_id AND I.[Day past 1900]=#T.D AND (I.Status = 2 OR I.Status = 1)), 0) +
ISNULL((SELECT SUM(-E.Seconds) FROM EmployeeLeaveEarned E WHERE E.EmployeeID=@employee_id AND E.[Day past 1900]=#T.D AND E.Seconds < 0 AND E.[Auto] = 0), 0)


SELECT [Date] = DATEADD(day,D,0), [Time Seconds], [Leave Seconds] FROM #T ORDER BY D
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spPermissionGetOnPersonForCurrentUser'
GO
ALTER PROC dbo.spPermissionGetOnPersonForCurrentUser
	@person_id int,
	@attribute_id int,
	@permission int out
AS
DECLARE @permission_cache_expires datetime, @user_sid varbinary(85)
SELECT  @user_sid = SUSER_SID(), @permission_cache_expires = DATEADD(hour, -1, GETDATE())

DELETE dbo.PermissionCached WHERE Created < @permission_cache_expires
SELECT @permission = [Permission Mask] FROM dbo.PermissionCached WHERE [SID] = @user_sid AND PersonID = @person_id AND AttributeID = @attribute_id
IF @@ROWCOUNT = 0
BEGIN
	EXEC @permission = dbo.fnPermissionGetOnPersonForCurrentUser @person_id, @attribute_id
    
	IF @person_id IS NOT NULL
	INSERT dbo.PermissionCached([SID], PersonID, AttributeID, [Permission Mask])
	VALUES(@user_sid, @person_id, @attribute_id, @permission)
END
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spPermissionGetOnPersonForCurrentUser2'
GO
-- Sets authorized to 1 if the current user has the required permission
-- on a given attribute for a given person (employee\applicant...)
ALTER PROCEDURE dbo.spPermissionGetOnPersonForCurrentUser2
	@person_id int,
	@attribute_id bigint,
	@permission_required int,
	@authorized bit out
AS
DECLARE @permission int

SET NOCOUNT ON

IF IS_MEMBER('db_owner') = 1
	SELECT @authorized = 1
ELSE
BEGIN
	EXEC spPermissionGetOnPersonForCurrentUser @person_id, @attribute_id, @permission out
	SELECT @authorized = CASE WHEN (@permission & @permission_required) = 0 THEN 0 ELSE 1 END
END
GO
ALTER PROC dbo.spPermissionListOnAttributesForUserScope
	@uid int,
	@scope_id int
AS
DECLARE @batch_id int

SET NOCOUNT ON

SELECT @batch_id = RAND() * 2147483647

-- Selects attributes for scope into TempX
INSERT TempX(BatchID, [ID], X, Y)
SELECT @batch_id, A.AttributeID, 0, 0 FROM PermissionAttribute A WHERE ([Scope Possible Mask] & @scope_id) <> 0

-- Looks up the permission mask
UPDATE A SET X = P.[Permission Mask], Y = P.[Deny Mask] FROM PermissionScopeAttribute P 
INNER JOIN TempX A ON A.BatchID = @batch_id AND P.ScopeID = @scope_id AND P.AttributeID = A.[ID] AND P.UID = @uid

-- Returns result
SELECT [Object] = A.Attribute, ObjectID = A.AttributeID, A.[Permission Possible Mask], [Permission Mask] = T.X, [Deny Mask] = T.Y
FROM PermissionAttribute A
INNER JOIN TempX T ON T.BatchID = @batch_id AND T.[ID] = A.AttributeID
ORDER BY A.Attribute

-- Cleans TempX
DELETE TempX WHERE BatchID =@batch_id OR DATEDIFF(hh, Created, GETDATE()) > 1
GO
ALTER PROCEDURE dbo.[spPermissionListPermissionsForScopeUser]
	@scope_id int,
	@uid int
AS
SET NOCOUNT ON

SELECT P.AttributeID, [Permission Mask], [Deny Mask] FROM PermissionScopeAttribute P
INNER JOIN PermissionAttribute A ON P.AttributeID = A.AttributeID AND P.ScopeID = @scope_id AND P.UID = @uid 
ORDER BY A.AttributeID
GO
ALTER PROCEDURE dbo.[spPermissionListForUIDOnStoredProcs]
	@uid int
AS
DECLARE @batch_id int

SET NOCOUNT ON

SELECT @batch_id = RAND() * 214748367

-- Transfers ObjectIDs from PermissionObject to temp table
INSERT TempX(BatchID, [ID], X, Y)
SELECT @batch_id, ObjectID, 0, 0 FROM PermissionObject

-- Read = 1, Write = 2, Create = 4, Delete = 8, List = 16

-- Grant 1 for Select
UPDATE T
SET X = 1
FROM TempX T
INNER JOIN PermissionObject P ON T.[ID] = P.ObjectID
INNER JOIN sysprotects S ON S.[id] = P.SelectObjectID AND S.uid=@uid AND S.[action]=224 AND S.protecttype=205

-- Deny 1 for Select
UPDATE T
SET Y = 1
FROM TempX T
INNER JOIN PermissionObject P ON T.[ID] = P.ObjectID
INNER JOIN sysprotects S ON S.[id] = P.SelectObjectID AND S.uid=@uid AND S.[action]=224 AND S.protecttype=206

-- Grant 2 for Update
UPDATE T
SET X = X | 2
FROM TempX T
INNER JOIN PermissionObject P ON T.[ID] = P.ObjectID
INNER JOIN sysprotects S ON S.[id] = P.UpdateObjectID AND S.uid=@uid AND S.[action]=224 AND S.protecttype=205

-- Deny 2 for Update
UPDATE T
SET Y = Y | 2
FROM TempX T
INNER JOIN PermissionObject P ON T.[ID] = P.ObjectID
INNER JOIN sysprotects S ON S.[id] = P.UpdateObjectID AND S.uid=@uid AND S.[action]=224 AND S.protecttype=206

-- Grant 4 for Insert
UPDATE T
SET X = X | 4
FROM TempX T
INNER JOIN PermissionObject P ON T.[ID] = P.ObjectID
INNER JOIN sysprotects S ON S.[id] = P.InsertObjectID AND S.uid=@uid AND S.[action]=224 AND S.protecttype=205

-- Deny 4 for Insert
UPDATE T
SET Y = Y | 4
FROM TempX T
INNER JOIN PermissionObject P ON T.[ID] = P.ObjectID
INNER JOIN sysprotects S ON S.[id] = P.InsertObjectID AND S.uid=@uid AND S.[action]=224 AND S.protecttype=206

-- Grant 8 for Delete
UPDATE T
SET X = X | 8
FROM TempX T
INNER JOIN PermissionObject P ON T.[ID] = P.ObjectID
INNER JOIN sysprotects S ON S.[id] = P.DeleteObjectID AND S.uid=@uid AND S.[action]=224 AND S.protecttype=205

-- Deny 8 for Delete
UPDATE T
SET Y = Y | 8
FROM TempX T
INNER JOIN PermissionObject P ON T.[ID] = P.ObjectID
INNER JOIN sysprotects S ON S.[id] = P.DeleteObjectID AND S.uid=@uid AND S.[action]=224 AND S.protecttype=206

-- Selects results
SELECT ObjectID = P.ObjectID, P.Object, [Permission Mask] = X, P.[Permission Possible Mask], [Deny Mask] = Y FROM TempX T
INNER JOIN PermissionObject P ON BatchID = @batch_id AND T.[ID] = P.ObjectID
ORDER BY P.Object

-- Removes temporary records
DELETE TempX WHERE BatchID = @batch_id OR DATEDIFF(hh, Created, GETDATE()) > 1
GO

-- Removes entry for Scope\Attribute\User if @permission_mask and @deny_mask is 0
-- Otherwise, if it exists, updates it
-- Otherwise inserts it 
ALTER PROCEDURE dbo.[spPermissionUpdateForUserScopeOnAttribute]
	@scope_id int,
	@attribute_id int,
	@uid int,
	@permission_mask int,
	@deny_mask int = NULL
AS

-- Case 1: Old client does not pass deny mask and @permission_mask is set to 0
IF @permission_mask = 0 AND @deny_mask IS NULL
BEGIN
	-- Delete if permission mask and deny mask are 0
	DELETE PermissionScopeAttribute WHERE ScopeID = @scope_id AND AttributeID = @attribute_id AND UID = @uid AND [Deny Mask] = 0
	
	-- Set permission mask to 0 if deny mask is set
	UPDATE PermissionScopeAttribute SET [Permission Mask] = 0 WHERE ScopeID = @scope_id AND AttributeID = @attribute_id AND UID = @uid
END
-- Case 2: Delete the setting because @permission_mask and @deny_mask are both set to 0
ELSE IF @permission_mask = 0 AND @deny_mask = 0
	DELETE PermissionScopeAttribute WHERE ScopeID = @scope_id AND AttributeID = @attribute_id AND UID = @uid
ELSE
-- Case 3: Normal case. Try to update the setting. Insert it if it does not already exist.
BEGIN
	UPDATE PermissionScopeAttribute SET [Permission Mask] = @permission_mask, [Deny Mask] = CASE WHEN @deny_mask IS NULL THEN [Deny Mask] ELSE @deny_mask END
	WHERE ScopeID = @scope_id AND AttributeID = @attribute_id AND UID = @uid

	IF @@ROWCOUNT = 0
	BEGIN
		INSERT PermissionScopeAttribute(ScopeID, AttributeID, UID, [Permission Mask], [Deny Mask])
		VALUES(@scope_id, @attribute_id, @uid, @permission_mask, ISNULL(@deny_mask, 0))
	END
END
GO
IF OBJECT_id('dbo.spEmployeeTimeList4') IS NOT NULL DROP PROC dbo.spEmployeeTimeList4
GO
CREATE PROC dbo.spEmployeeTimeList4
	@batch_id int,
	@in_start int,
	@in_stop int,
	@created_start int,
	@created_stop int,
	@status_or_mask int,
	@status_and_mask int,
	@item_id int = NULL,
	@ppe_start int = -2147483648,
	@ppe_stop int = 2147483647
AS
DECLARE @temp int
DECLARE @in_start_date datetime, @in_stop_date datetime
DECLARE @wrap_24_hrs int
SELECT @in_start_date = dbo.GetDateFromDaysPast1900(@in_start), @in_stop_date = dbo.GetDateFromDaysPast1900(@in_stop)

SET NOCOUNT ON

EXEC dbo.spPermissionGetOnPeopleForCurrentUser2 @batch_id, 262144

SELECT @wrap_24_hrs = [Timecard Max 24 Hours per Day] FROM dbo.Constant 

SELECT ET.*
FROM dbo.vwEmployeeTime ET 
INNER JOIN dbo.TempX X ON X.BatchID = @batch_id AND ET.EmployeeID = X.[ID] AND (X.X & 1) = 1 AND
(
	(@item_id IS NOT NULL AND ET.ItemID = @item_id)
	OR
	(
		@item_id IS NULL AND (
			((@status_and_mask = 0) OR (@status_and_mask & ET.StatusID) = @status_and_mask) AND
			(StatusID & @status_or_mask) != 0 AND
			(
				CASE WHEN DATEDIFF(hour,dbo.GetDateFromDaysPast1900(ET.[PPE Day past 1900]), ET.[In]) BETWEEN 24 AND 47 THEN -1 ELSE 0 END + ET.[In Day past 1900] 
				BETWEEN @in_start AND @in_stop OR DATEADD(s, ET.Seconds * @wrap_24_hrs, [In]) BETWEEN @in_start_date AND @in_stop_date
			) AND
			(ET.[Created Day past 1900] BETWEEN @created_start AND @created_stop) AND
			(ET.[PPE Day past 1900] BETWEEN @ppe_start AND @ppe_stop)
		)
	)
)
ORDER BY DATEDIFF(d,0,ET.[In]), ET.[Employee], DATEPART(hour,ET.[In]), DATEPART(minute,ET.[In]), DATEPART(second,ET.[In])

DELETE dbo.TempX WHERE (BatchID BETWEEN @batch_id AND @batch_id + 2) OR DATEDIFF(hh, Created, GETDATE()) > 1
GO
GRANT EXEC ON dbo.spEmployeeTimeList4 TO public
GO
-- Updates permissions on select\update\insert\delete stored procs on a given object for a given user
CREATE PROC dbo.spPermissionUpdateObjectStoredProcsForUID
	@object_id int,
	@uid int,
	@permission_mask int,
	@deny_mask int = 0
AS
DECLARE @permission int, @stored_proc_id int
DECLARE @select sysname
DECLARE @insert sysname
DECLARE @update sysname
DECLARE @delete sysname
DECLARE @user sysname
DECLARE @sql nvarchar(4000)
DECLARE @error int

SET NOCOUNT ON

SELECT @error = 0

-- Converts @uid to user's name
SELECT @user = '[' + [name] + ']' FROM sysusers WHERE uid = @uid
SELECT @error = 50012 WHERE @@ROWCOUNT = 0

-- Converts objectids to stored proc names
IF @error = 0
BEGIN
	SELECT @select = CASE WHEN SelectObjectID = 0 THEN NULL ELSE OBJECT_NAME(SelectObjectID) END,
		@insert = CASE WHEN InsertObjectID = 0 THEN NULL ELSE OBJECT_NAME(InsertObjectID) END,
		@update = CASE WHEN UpdateObjectID = 0 THEN NULL ELSE OBJECT_NAME(UpdateObjectID) END,
		@delete = CASE WHEN DeleteObjectID = 0 THEN NULL ELSE OBJECT_NAME(DeleteObjectID) END
		FROM PermissionObject WHERE ObjectID = @object_id
	SELECT @error = 50013 WHERE @@ROWCOUNT = 0
END


-- Builds dynamic sql strings to grant\revoke permissions on related stored procs
-- Must build dynamic sql string because GRANT and REVOKE do not accept variables as parameters
IF @error = 0
BEGIN
	BEGIN TRAN

	IF @select IS NOT NULL 
	BEGIN
		SELECT @sql = CASE 
			WHEN (@deny_mask & 1) = 1 THEN 'DENY'
			WHEN (@permission_mask & 1) = 1 THEN 'GRANT' 
			ELSE 'REVOKE' 
		END  + ' EXECUTE ON ' + @select + ' TO ' + @user
		EXEC sp_executesql @sql
	END

	IF @update IS NOT NULL 
	BEGIN
		SELECT @sql = CASE 
			WHEN (@deny_mask & 2) = 2 THEN 'DENY'
			WHEN (@permission_mask & 2) = 2 THEN 'GRANT' 
			ELSE 'REVOKE' 
		END  + ' EXECUTE ON ' + @update + ' TO ' + @user
		EXEC sp_executesql @sql
	END
	
	IF @insert IS NOT NULL 
	BEGIN
		SELECT @sql =  CASE 
			WHEN (@deny_mask & 4) = 4 THEN 'DENY'
			WHEN (@permission_mask & 4) = 4 THEN 'GRANT' 
			ELSE 'REVOKE' 
		END  + ' EXECUTE ON ' + @insert + ' TO ' + @user
		EXEC sp_executesql @sql
	END

	IF @delete IS NOT NULL 
	BEGIN
		SELECT @sql = CASE 
			WHEN (@deny_mask & 8) = 8 THEN 'DENY'
			WHEN (@permission_mask & 8) = 8 THEN 'GRANT' 
			ELSE 'REVOKE' 
		END  + ' EXECUTE ON ' + @delete + ' TO ' + @user
		EXEC sp_executesql @sql
	END

	DECLARE p_cursor CURSOR LOCAL FORWARD_ONLY STATIC FOR SELECT Permission, StoredProcID FROM PermissionObjectX WHERE ObjectID = @object_id
	OPEN p_cursor	

	FETCH NEXT FROM p_cursor INTO @permission, @stored_proc_id
	WHILE @@FETCH_STATUS = 0
	BEGIN
		SELECT @sql =  CASE WHEN (@permission_mask & @permission) <> 0 THEN 'GRANT' ELSE 'REVOKE' END  + ' EXECUTE ON ' + OBJECt_NAME(@stored_proc_id) + ' TO ' + @user
		EXEC sp_executesql @sql
		FETCH NEXT FROM p_cursor INTO @permission, @stored_proc_id
	END

	CLOSE p_cursor
	DEALLOCATE p_cursor

	COMMIT TRAN
END

IF @error <> 0 EXEC dbo.spErrorRaise @error
GO
IF OBJECT_id('dbo.spPersonListPrepareBatchPOr') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spPersonListPrepareBatchPOr AS SELECT A=0'
GO
ALTER PROC dbo.spPersonListPrepareBatchPOr
	@batch_id int,
	@field_id int, -- ColumnGrid.FieldID
	@operation int,
	@value sql_variant,
	@limit sql_variant
AS
DECLARE @t varchar(50)
DECLARE @i int
DECLARE @f bit
DECLARE @d datetime, @d2 datetime
DECLARE @x int, @y int
DECLARE @type sysname

SET NOCOUNT ON

SELECT @type = CAST(SQL_VARIANT_PROPERTY ( @value, 'BaseType' ) AS sysname), @t = null, @i= null, @f = null, @d = null, @d2 = null, @x = null, @y = null

IF @type IN ('varchar', 'nvarchar') SELECT @t = '%' + CAST(@value AS varchar(50)) + '%'
ELSE IF @type = 'int' SELECT @i = CAST(@value AS int)
ELSE IF @type = 'bit' SELECT @f = CAST(@value AS bit)
ELSE IF @type IN ('datetime', 'smalldatetime') SELECT @d = CAST(@value AS datetime)

IF @limit IS NOT NULL SET @d2 = CAST(@limit AS datetime)

SELECT @x = DATEDIFF(d, 0, @d), @y = DATEDIFF(d, 0, @d2)

-- Active Employee
IF @field_id = 71 INSERT TempX(BatchID, [ID])
SELECT @batch_id, E.EmployeeID FROM Employee E WHERE 
(@operation=0x200 AND E.[Active Employee] = 1) OR 
(@operation=0x400 AND E.[Active Employee] = 0)

ELSE IF @field_id = 72 INSERT TempX(BatchID, [ID])
SELECT @batch_id, E.EmployeeID FROM Employee E WHERE 
(@operation=0x200 AND E.[Salaried] = 1) OR 
(@operation=0x400 AND E.[Salaried] = 0)

-- RaceID
ELSE IF @field_id = 32 INSERT TempX(BatchID, [ID])
SELECT @batch_id, PersonID FROM PersonX P WHERE
(@operation=1 AND P.RaceID=@i) OR
(@operation=2 AND P.RaceID<>@i)

-- FLSA Exempt
ELSE IF @field_id = 1030 INSERT TempX(BatchID, [ID])
SELECT @batch_id, E.EmployeeID FROM Employee E 
INNER JOIN vwEmployeeCompensation C ON E.LastCompensationID = C.CompensationID AND (
	(@operation = 0x200 AND C.[FLSA Exempt] = 1) OR
	(@operation = 0x400 AND C.[FLSA Exempt] = 0)
)

-- Training Began
ELSE IF @field_id = 1031 AND @operation = 0x400 INSERT TempX(BatchID, [ID])
SELECT @batch_id, EmployeeID FROM Employee WHERE EmployeeID NOT IN
(
	SELECT PersonID FROM PersonXTraining
)

ELSE IF @field_id = 1031 INSERT TempX(BatchID, [ID])
SELECT DISTINCT @batch_id, PersonID FROM PersonXTraining WHERE 
(@operation=1 AND TrainingID=@i) OR
(@operation=2 AND TrainingID<>@i) OR
(@operation=0x200)

-- PersonID
ELSE IF @field_id=1003 INSERT TempX(BatchID, [ID])
VALUES(@batch_id, @i)

-- Current Position 56
ELSE IF @field_id=56 INSERT TempX(BatchID, [ID])
SELECT @batch_id, E.EmployeeID FROM Employee E
INNER JOIN EmployeeCompensation EC ON E.LastCompensationID = EC.CompensationID
INNER JOIN Position P ON EC.PositionID = P.PositionID AND
(
	(@operation=1 AND EC.PositionID = @i) OR (@operation=2 AND EC.PositionID <> @i) OR
	(@operation=4 AND P.[Job Title] LIKE @t) OR (@operation=8 AND P.[Job Title] NOT LIKE @t)
)

-- Division 53
ELSE IF @field_id=53 INSERT TempX(BatchID, [ID])
SELECT @batch_id, E.EmployeeID FROM Employee E
INNER JOIN Division V ON E.DivisionID = V.DivisionID AND
(
	(@operation=1 AND E.DivisionID = @i) OR (@operation=2 AND E.DivisionID <> @i) OR
	(@operation=4 AND V.Division LIKE @t) OR (@operation=8 AND V.Division NOT LIKE @t)
)

-- Department 55
ELSE IF @field_id=55 INSERT TempX(BatchID, [ID])
SELECT @batch_id, E.EmployeeID FROM Employee E
INNER JOIN Department D ON E.DepartmentID = D.DepartmentID AND 
(
	(@operation=1 AND E.DepartmentID = @i) OR (@operation=2 AND E.DepartmentID <> @i) OR
	(@operation=4 AND D.Department LIKE @t) OR (@operation=8 AND D.Department NOT LIKE @t)
)


-- Location 54
ELSE IF @field_id=54 INSERT TempX(BatchID, [ID])
SELECT @batch_id, E.EmployeeID FROM Employee E
INNER JOIN Location L ON E.LocationID = L.LocationID AND
(
	(@operation=1 AND E.LocationID = @i) OR (@operation=2 AND E.LocationID <> @i) OR
	(@operation=4 AND L.[List As] LIKE @t) OR (@operation=8 AND L.[List As] NOT LIKE @t)
)

-- Manager 52
ELSE IF @field_id=52 AND @operation=0x200 INSERT TempX(BatchID, [ID]) SELECT DISTINCT @batch_id, E.ManagerID FROM Employee E WHERE E.ManagerID IS NOT NULL
ELSE IF @field_id=52 AND @operation=0x400 INSERT TempX(BatchID, [ID]) SELECT @batch_id, E.EmployeeID FROM Employee E WHERE E.EmployeeID NOT IN (SELECT DISTINCT M.ManagerID FROM Employee M WHERE M.ManagerID IS NOT NULL)
ELSE IF @field_id=52
INSERT TempX(BatchID, [ID])
SELECT @batch_id, E.EmployeeID FROM Employee E
LEFT JOIN vwPersonCalculated M ON E.ManagerID = M.PersonID
WHERE
(
	(E.ManagerID IS NULL AND @i IS NULL AND @operation=1) OR
	(E.ManagerID IS NOT NULL AND @i IS NULL AND @operation=2) OR
	(E.ManagerID IS NULL AND @i IS NOT NULL AND @operation=2) OR
	(@operation=1 AND E.ManagerID = @i) OR (@operation=2 AND E.ManagerID <> @i) OR
	(@operation=4 AND M.[Full Name] LIKE @t) OR (@operation=8 AND M.[Full Name] NOT LIKE @t)
)

-- Note 16
ELSE IF @field_id=16
BEGIN
	INSERT TempX(BatchID, [ID])
	SELECT @batch_id, PersonID
	FROM Person P
	INNER JOIN Employee E ON P.PersonID = E.EmployeeID AND P.Note LIKE @t

	INSERT TempX(BatchID, [ID])
	SELECT DISTINCT @batch_id, PersonID
	FROM Note WHERE Note LIKE @t
END



-- Seniority Begins 58
ELSE IF @field_id = 58
INSERT TempX(BatchID, [ID])
SELECT @batch_id, EmployeeID FROM Employee E WHERE
(
	(@operation=1 AND E.[Seniority Begins Day past 1900] = @x) OR (@operation=2 AND E.[Seniority Begins Day past 1900] <> @x) OR
	(@operation=0x10 AND E.[Seniority Begins Day past 1900] BETWEEN @x AND @y) OR
	(@operation=0x80 AND E.[Seniority Begins Day past 1900] > @x) OR
	(@operation=0x100 AND E.[Seniority Begins Day past 1900] >= @x) OR
	(@operation=0x20 AND E.[Seniority Begins Day past 1900] < @x) OR
	(@operation=0x40 AND E.[Seniority Begins Day past 1900] <= @x)
)

-- Shift 51
ELSE IF @field_id=51
INSERT TempX(BatchID, [ID])
SELECT @batch_id, E.EmployeeID FROM Employee E
INNER JOIN Shift S ON E.ShiftID = S.ShiftID AND
(
	(@operation=1 AND E.ShiftID = @i) OR (@operation=2 AND E.ShiftID <> @i) OR
	(@operation=4 AND S.Shift LIKE @t) OR (@operation=8 AND S.Shift NOT LIKE @t)
)

-- PayGrade 100
ELSE IF @field_id=100 AND @operation=0x200 INSERT TempX(BatchID, [ID]) SELECT @batch_id, E.EmployeeID FROM Employee E WHERE E.LastCompensationID IS NOT NULL
ELSE IF @field_id=100 AND @operation=0x400 INSERT TempX(BatchID, [ID]) SELECT @batch_id, E.EmployeeID FROM Employee E WHERE E.EmployeeID NOT IN (SELECT E.EmployeeID FROM Employee E WHERE E.LastCompensationID IS NOT NULL)
ELSE IF @field_id=100
INSERT TempX(BatchID, [ID])
SELECT @batch_id, E.EmployeeID FROM Employee E
INNER JOIN EmployeeCompensation EC ON E.LastCompensationID=EC.CompensationID
INNER JOIN Position P ON EC.PositionID = P.PositionID
INNER JOIN PayGrade PG ON P.PayGradeID = PG.PayGradeID AND
(
	(@operation=1 AND P.PayGradeID = @i) OR (@operation=2 AND P.PayGradeID <> @i) OR
	(@operation=4 AND PG.[Pay Grade] LIKE @t) OR (@operation=8 AND PG.[Pay Grade] NOT LIKE @t)
)

-- Superior 1029
ELSE IF @field_id = 1029
INSERT TempX(BatchID, [ID])
SELECT DISTINCT @batch_id, ES.EmployeeID
FROM EmployeeSuperior ES
INNER JOIN dbo.vwPersonListAs P ON ES.SuperiorID = P.PersonID AND
(
	(@operation=1 AND ES.SuperiorID = @i) OR (@operation=2 AND ES.SuperiorID <> @i) OR
	(@operation=4 AND P.[List As] LIKE @t) OR (@operation=8 AND P.[List As] NOT LIKE @t)
)

-- Terminated 60
ELSE IF @field_id = 60
INSERT TempX(BatchID, [ID])
SELECT @batch_id, EmployeeID FROM Employee E WHERE
(
	(@operation=1 AND E.[Terminated Day past 1900] = @x) OR 
	(@operation=2 AND E.[Terminated Day past 1900] <> @x) OR
	(@operation=0x10 AND E.[Terminated Day past 1900] BETWEEN @x AND @y) OR
	(@operation=0x80 AND E.[Terminated Day past 1900] > @x) OR
	(@operation=0x100 AND E.[Terminated Day past 1900] >= @x) OR
	(@operation=0x20 AND E.[Terminated Day past 1900] < @x) OR
	(@operation=0x40 AND E.[Terminated Day past 1900] <= @x) OR
	(@operation=0x200 AND E.[Terminated Day past 1900] IS NOT NULL) OR
	(@operation=0x400 AND E.[Terminated Day past 1900] IS NULL)
)

-- COBRA 99
ELSE IF @field_id = 99
INSERT TempX(BatchID, [ID])
SELECT @batch_id, EmployeeID FROM vwEmployeeCOBRA E WHERE
(
	(@operation=1 AND @i=E.EnrollmentID) OR (@operation=2 AND @i<>E.EnrollmentID)
)
	
-- COBRA notified 94
ELSE IF @field_id = 94
INSERT TempX(BatchID, [ID])
SELECT @batch_id, EmployeeID FROM Employee E WHERE
(
	(@operation=1 AND E.[COBRA Notified Day past 1900] = @x) OR 
	(@operation=2 AND E.[COBRA Notified Day past 1900] <> @x) OR
	(@operation=0x10 AND E.[COBRA Notified Day past 1900] BETWEEN @x AND @y) OR
	(@operation=0x80 AND E.[COBRA Notified Day past 1900] > @x) OR
	(@operation=0x100 AND E.[COBRA Notified Day past 1900] >= @x) OR
	(@operation=0x20 AND E.[COBRA Notified Day past 1900] < @x) OR
	(@operation=0x40 AND E.[COBRA Notified Day past 1900] <= @x) )

-- COBRA Eligible 93
ELSE IF @field_id = 93
INSERT TempX(BatchID, [ID])
SELECT @batch_id, EmployeeID FROM Employee E WHERE
(
	(@operation=1 AND E.[COBRA Eligible Day past 1900] = @x) OR 
	(@operation=2 AND E.[COBRA Eligible Day past 1900] <> @x) OR
	(@operation=0x10 AND E.[COBRA Eligible Day past 1900] BETWEEN @x AND @y) OR
	(@operation=0x80 AND E.[COBRA Eligible Day past 1900] > @x) OR
	(@operation=0x100 AND E.[COBRA Eligible Day past 1900] >= @x) OR
	(@operation=0x20 AND E.[COBRA Eligible Day past 1900] < @x) OR
	(@operation=0x40 AND E.[COBRA Eligible Day past 1900] <= @x)
)

-- COBRA Expires 98
ELSE IF @field_id = 98
INSERT TempX(BatchID, [ID])
SELECT @batch_id, EmployeeID FROM Employee E WHERE
(
	(@operation=1 AND E.[COBRA Expires Day past 1900] = @x) OR 
	(@operation=2 AND E.[COBRA Expires Day past 1900] <> @x) OR
	(@operation=0x10 AND E.[COBRA Expires Day past 1900] BETWEEN @x AND @y) OR
	(@operation=0x80 AND E.[COBRA Expires Day past 1900] > @x) OR
	(@operation=0x100 AND E.[COBRA Expires Day past 1900] >= @x) OR
	(@operation=0x20 AND E.[COBRA Expires Day past 1900] < @x) OR
	(@operation=0x40 AND E.[COBRA Expires Day past 1900] <= @x)
)

-- COBRA First Enrolled 95
ELSE IF @field_id = 95
INSERT TempX(BatchID, [ID])
SELECT @batch_id, EmployeeID FROM Employee E WHERE
(
	(@operation=1 AND E.[COBRA First Enrolled Day past 1900] = @x) OR 
	(@operation=2 AND E.[COBRA First Enrolled Day past 1900] <> @x) OR
	(@operation=0x10 AND E.[COBRA First Enrolled Day past 1900] BETWEEN @x AND @y) OR
	(@operation=0x80 AND E.[COBRA First Enrolled Day past 1900] > @x) OR
	(@operation=0x100 AND E.[COBRA First Enrolled Day past 1900] >= @x) OR
	(@operation=0x20 AND E.[COBRA First Enrolled Day past 1900] < @x) OR
	(@operation=0x40 AND E.[COBRA First Enrolled Day past 1900] <= @x)
)

-- COBRA Last Enrolled 96
ELSE IF @field_id = 96
INSERT TempX(BatchID, [ID])
SELECT @batch_id, EmployeeID FROM Employee E WHERE
(
	(@operation=1 AND E.[COBRA First Enrolled Day past 1900] = @x) OR 
	(@operation=2 AND E.[COBRA First Enrolled Day past 1900] <> @x) OR
	(@operation=0x10 AND E.[COBRA First Enrolled Day past 1900] BETWEEN @x AND @y) OR
	(@operation=0x80 AND E.[COBRA First Enrolled Day past 1900] > @x) OR
	(@operation=0x100 AND E.[COBRA First Enrolled Day past 1900] >= @x) OR
	(@operation=0x20 AND E.[COBRA First Enrolled Day past 1900] < @x) OR
	(@operation=0x40 AND E.[COBRA First Enrolled Day past 1900] <= @x)
)

-- COBRA Enrolled 1041
ELSE IF @field_id = 1041
INSERT TempX(BatchID, [ID])
SELECT @batch_id, EmployeeID FROM vwEmployeeCOBRA E WHERE
(
	(@operation=1 AND E.EnrollmentID=@i) OR
	(@operation=2 AND E.EnrollmentID<>@i)
)

-- COBRA Notified 93
ELSE IF @field_id = 93
INSERT TempX(BatchID, [ID])
SELECT @batch_id, EmployeeID FROM Employee E WHERE
(
	(@operation=1 AND E.[COBRA Notified Day past 1900] = @x) OR 
	(@operation=2 AND E.[COBRA Notified Day past 1900] <> @x) OR
	(@operation=0x10 AND E.[COBRA Notified Day past 1900] BETWEEN @x AND @y) OR
	(@operation=0x80 AND E.[COBRA Notified Day past 1900] > @x) OR
	(@operation=0x100 AND E.[COBRA Notified Day past 1900] >= @x) OR
	(@operation=0x20 AND E.[COBRA Notified Day past 1900] < @x) OR
	(@operation=0x40 AND E.[COBRA Notified Day past 1900] <= @x)
)

-- Employment Status 1034 92
ELSE IF @field_id=92 OR @field_id=1034
INSERT TempX(BatchID, [ID])
SELECT @batch_id, E.EmployeeID FROM Employee E
INNER JOIN EmployeeCompensation EC ON E.LastCompensationID = EC.CompensationID
INNER JOIN EmploymentStatus ES ON EC.EmploymentStatusID = ES.StatusID AND
(
	(@operation=1 AND EC.EmploymentStatusID = @i) OR (@operation=2 AND EC.EmploymentStatusID <> @i) OR
	(@operation=4 AND ES.Status LIKE @t) OR (@operation=8 AND ES.Status NOT LIKE @t)
)

-- Position Status 1035 91
ELSE IF @field_id=91 OR @field_id=1035
INSERT TempX(BatchID, [ID])
SELECT @batch_id, E.EmployeeID FROM Employee E
INNER JOIN EmployeeCompensation EC ON E.LastCompensationID = EC.CompensationID
INNER JOIN Position P ON EC.PositionID = P.PositionID
INNER JOIN PositionStatus PS ON P.StatusID = PS.StatusID AND
(
	(@operation=1 AND P.StatusID = @i) OR (@operation=2 AND P.StatusID <> @i) OR
	(@operation=4 AND PS.Status LIKE @t) OR (@operation=8 AND PS.Status NOT LIKE @t)
)

-- Job Category 1036
ELSE IF @field_id=1036
INSERT TempX(BatchID, [ID])
SELECT @batch_id, E.EmployeeID FROM Employee E
INNER JOIN EmployeeCompensation EC ON E.LastCompensationID = EC.CompensationID
INNER JOIN Position P ON EC.PositionID = P.PositionID
INNER JOIN JobCategory JC ON P.CategoryID = JC.CategoryID AND
(
	(@operation=1 AND P.CategoryID = @i) OR (@operation=2 AND P.CategoryID <> @i) OR
	(@operation=4 AND JC.Category LIKE @t) OR (@operation=8 AND JC.Category NOT LIKE @t)
)

-- BatchCreateInvoice 1037
ELSE IF @field_id=1037
INSERT TempX(BatchID, [ID])
SELECT @batch_id, E.EmployeeID FROM Employee E WHERE
(
	(@operation=1 AND E.BatchCreateInvoice=@f) OR
	(@operation=2 AND E.BatchCreateInvoice<>@f) OR
	(@operation=0x200 AND E.BatchCreateInvoice=1) OR
	(@operation=0x400 AND E.BatchCreateInvoice=0)
)

-- NSF
ELSE IF @field_id = 1039 INSERT TempX(BatchID, [ID])
SELECT @batch_id, E.EmployeeID FROM Employee E WHERE
(
	(@operation = 0x200 AND E.NSF = 1) OR
	(@operation = 0x400 AND E.NSF = 0)
)

-- Advance Pay
ELSE IF @field_id = 1040 INSERT TempX(BatchID, [ID])
SELECT @batch_id, E.EmployeeID FROM Employee E WHERE
(
	(@operation = 0x200 AND E.[Advance Pay] = 1) OR
	(@operation = 0x400 AND E.[Advance Pay] = 0)
)
GO
GRANT EXEC ON dbo.spPersonListPrepareBatchPOr TO public
GO
ALTER PROC dbo.spEmployeeUpdateTermination
	@employee_id int,
	@rehire bit,
	@reason text,
	@terminated int,
	@reason_id int = null,
	@exit_interview_day int = null,
	@exit_interview_by_employee_id int = null
AS
DECLARE @authorized bit

IF @reason_id IS NULL SELECT TOP 1 @reason_id = ReasonID FROM TerminationReason WHERE Reason = 'Unspecified'
IF @reason_id IS NULL SELECT TOP 1 @reason_id = ReasonID FROM TerminationReason

EXEC dbo.spPermissionInsureForCurrentUserOnPerson @employee_id, 0x1000000, 2, @authorized out
IF @authorized = 1 UPDATE Employee SET 
	[Reason for Termination] = @reason,
	[Terminated Day past 1900] = @terminated,
	Rehire = @rehire,
	TerminationReasonID = @reason_id,
	[Exit Interview Day past 1900] = @exit_interview_day,
	ExitInterviewByEmployeeID = @exit_interview_by_employee_id
WHERE EmployeeID = @employee_id
GO
-- Inserts limit adjustment or annihilates matching accrued entry
ALTER PROC dbo.spEmployeeLeaveInsertAdjustment
	@employee_id int,
	@type_id int,
	@adjustment int,
	@day int,
	@carryover_type_id int,
	@carryover_multiplier numeric(9,8),
	@carryover_offset_days int,
	@carryover_limit_seconds int
AS
DECLARE @leave_id int
DECLARE @new_amount int

SET NOCOUNT ON

SELECT @leave_id = LeaveID FROM EmployeeLeaveEarned WHERE EmployeeID = @employee_id AND TypeID = @type_id AND [Day past 1900] = @day AND 0 - @adjustment >= Seconds AND [Auto] = 1 -- 1 = Accrued

--DECLARE @a varchar(50)
--SET @a = 'O' + CAST(@adjustment / 3600.0 AS varchar(50))

SET @new_amount = @adjustment
IF @leave_id IS NOT NULL
BEGIN
	-- Annihilate matching accrued entry
	SELECT @new_amount = @adjustment + Seconds FROM EmployeeLeaveEarned WHERE LeaveID = @leave_id
	DELETE EmployeeLeaveEarned WHERE LeaveID = @leave_id

	--SET @a = @a + 'Deleted' + CAST(@leave_id AS varchar(50))
END
ELSE
BEGIN
	SELECT @leave_id = LeaveID FROM EmployeeLeaveEarned WHERE EmployeeID = @employee_id AND TypeID = @type_id AND [Day past 1900] = @day AND 0 - @adjustment < Seconds AND [Auto] = 1 -- 1 = Accrued
	IF @leave_id IS NOT NULL
	BEGIN
		UPDATE EmployeeLeaveEarned SET Seconds = Seconds + @adjustment, Note = Note + ' (' + CAST(CAST(@adjustment / -3600.0 AS numeric(9,2)) AS varchar(50)) + 'hr limit adjustment)' WHERE LeaveID = @leave_id
		SET @new_amount = 0

		--SET @a = @a + 'Adjusted' + CAST(@leave_id AS varchar(50))
	END
END


IF @new_amount <> 0
INSERT EmployeeLeaveEarned(EmployeeID, TypeID, [Note], Seconds, [Day past 1900], [Auto])
--VALUES (@employee_id, @type_id, 'Limit adjustment' + @a, @new_amount, @day, 2)
VALUES (@employee_id, @type_id, 'Limit adjustment', @new_amount, @day, 2)

EXEC dbo.spEmployeeLeaveInsertAdjustmentUnused  @employee_id, @type_id, @adjustment, @day

-- Carryovers unused to other account
IF @carryover_type_id IS NOT NULL
BEGIN
	DECLARE @carryover_day int
	SET @carryover_day = @day + @carryover_offset_days
	SELECT @adjustment = 0 - @adjustment * @carryover_multiplier
	IF @adjustment > @carryover_limit_seconds SET @adjustment = @carryover_limit_seconds

	INSERT EmployeeLeaveEarned(EmployeeID, TypeID, [Note], Seconds, [Day past 1900], [Auto])
	VALUES (@employee_id, @carryover_type_id, 'Carryover', @adjustment, @carryover_day, 3)

	EXEC dbo.spEmployeeLeaveInsertAdjustmentUnused  @employee_id, @carryover_type_id, @adjustment, @carryover_day
END
GO
IF OBJECT_id('dbo.spEmployeeLeaveInsertAdjustmentUnused') IS NULL
EXEC sp_executesql N'CREATE PROC dbo.spEmployeeLeaveInsertAdjustmentUnused AS'
GO
-- Inserts a limit adjustment and keeps EmployeeLeaveUnused accurate
ALTER  PROC dbo.spEmployeeLeaveInsertAdjustmentUnused
	@employee_id int,
	@type_id int,
	@adjustment int,
	@day int
AS
DECLARE @item_id int
DECLARE @unused int

SET NOCOUNT ON

-- Checks if an entry for employe\type\day exists in EmployeeLeaveUnused
SELECT @item_id = ItemID FROM EmployeeLeaveUnused WHERE EmployeeID = @employee_id AND TypeID = @type_id AND [Day past 1900] = @day
IF @@ROWCOUNT = 0
BEGIN
	-- Inserts a new entry into EmployeeLeaveUnused if no prior entry existed
	SELECT @unused = @adjustment
	SELECT TOP 1 @unused = Unused + @unused  FROM EmployeeLeaveUnused WHERE EmployeeID = @employee_id AND TypeID = @type_id AND [Day past 1900] < @day ORDER BY [Day past 1900] DESC

	INSERT EmployeeLeaveUnused(EmployeeID, TypeID, [Limit Adjustment], Unused, [Day past 1900], [Limit Seconds])
	VALUES(@employee_id, @type_id, 1, @unused, @day, 0 - @adjustment)
END
ELSE
BEGIN
	-- Updates entry if it existed
	UPDATE EmployeeLeaveUnused SET [Limit Adjustment] = 1, [Limit Seconds] = 0 - @adjustment, Unused = Unused + @adjustment WHERE ItemID = @item_id
END

UPDATE EmployeeLeaveUnused SET Unused = Unused + @adjustment WHERE EmployeeID = @employee_id AND TypeID = @type_id AND [Day past 1900] > @day
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spEmployeeLeaveSummarizeAccrual2'
GO
ALTER PROC dbo.spEmployeeLeaveSummarizeAccrual2
	@employee_id int,
	@day int,
	@advanced bit,
	@type_mask int,
	@days bit,
	@this_year_start int, @this_year_stop int,
	@last_year_start int, @last_year_stop int,
	@rolling_start int, @rolling_stop int,
	@scheduled_start int, @scheduled_stop int
-- WITH EXECUTE AS 'dbo'
AS
DECLARE @month_seniority int
DECLARE @fmla_rate int
DECLARE @fmla_available int
DECLARE @authorized bit
DECLARE @seconds_per_unit numeric(9,4)

SET NOCOUNT ON

EXEC dbo.spPermissionInsureForCurrentUserOnPerson @employee_id, 10003, 1, @authorized out
IF @authorized = 1
BEGIN
	IF @days=0 SET @seconds_per_unit=3600
	ELSE SELECT @seconds_per_unit=S.[Effective Seconds per Day] FROM dbo.vwEmployeeEffectiveSecondsPerDay S WHERE S.EmployeeID=@employee_id

	SELECT @month_seniority = DATEDIFF(mm, [Seniority Begins Day past 1900], dbo.GetDateFromDaysPast1900(@day)) FROM Employee WHERE EmployeeID = @employee_id

	SELECT TypeID, [Accumulated Day] = NULL, [Limit Day] = NULL, [Available] = NULL, Accumulated = 0, Rolling = 0, [Accumulated Last Year Day] = NULL, [Accumulated Last Year] = 0, [Accumulated This Year Day] = NULL, [Accumulated This Year] = 0 INTO #U FROM LeaveType WHERE (TypeID & @type_mask) != 0 AND (@advanced IS NULL OR Advanced = @advanced)
	CREATE INDEX U08312005 ON #U(TypeID)

	UPDATE #U SET [Accumulated Day] = (
		SELECT MAX(U.[Day past 1900]) FROM dbo.EmployeeLeaveUnused U WHERE U.[Day past 1900] <= @day AND U.EmployeeID = @employee_id AND U.TypeID = #U.TypeID
	), [Accumulated Last Year Day] = (
		SELECT MAX(U.[Day past 1900]) FROM dbo.EmployeeLeaveUnused U WHERE U.[Day past 1900] <= @last_year_stop AND U.EmployeeID = @employee_id AND U.TypeID = #U.TypeID
	), [Accumulated This Year Day] = (
		SELECT MAX(U.[Day past 1900]) FROM dbo.EmployeeLeaveUnused U WHERE U.[Day past 1900] <= @this_year_stop AND U.EmployeeID = @employee_id AND U.TypeID = #U.TypeID
	)


	UPDATE #U SET [Limit Day] = ISNULL((
		SELECT MIN(E.[Day past 1900]) FROM dbo.vwEmployeeLeaveEarned E WHERE E.[Day past 1900] >= @day AND E.EmployeeID = @employee_id AND E.TypeID = #U.TypeID AND E.[Limit Adjustment] = 1
	), 2147483647)

	UPDATE #U SET Accumulated = U.Unused + CASE WHEN U.[Day past 1900]=@day THEN U.[Limit Seconds] ELSE 0 END
	FROM #U INNER JOIN dbo.EmployeeLeaveUnused U ON U.EmployeeID = @employee_id AND U.TypeID = #U.TypeID AND U.[Day past 1900] = #U.[Accumulated Day] 
	INNER JOIN LeaveType T ON #U.TypeID = T.TypeID AND T.Bank = 1

	/* UPDATE #U SET [Accumulated Last Year] = U.Unused + CASE WHEN U.[Day past 1900]=@last_year_stop THEN U.[Limit Seconds] ELSE 0 END
	FROM #U INNER JOIN EmployeeLeaveUnused U ON U.EmployeeID = @employee_id AND U.TypeID = #U.TypeID AND U.[Day past 1900] = #U.[Accumulated Last Year Day] 
	INNER JOIN LeaveType T ON #U.TypeID = T.TypeID AND T.Bank = 1 */

	UPDATE #U SET [Accumulated Last Year] = U.Unused
	FROM #U INNER JOIN dbo.EmployeeLeaveUnused U ON U.EmployeeID = @employee_id AND U.TypeID = #U.TypeID AND U.[Day past 1900] = #U.[Accumulated Last Year Day] 
	INNER JOIN LeaveType T ON #U.TypeID = T.TypeID AND T.Bank = 1

	UPDATE #U SET [Accumulated This Year] = U.Unused + U.[Limit Seconds]
	FROM #U INNER JOIN dbo.EmployeeLeaveUnused U ON U.EmployeeID = @employee_id AND U.TypeID = #U.TypeID AND U.[Day past 1900] = #U.[Accumulated This Year Day] 
	INNER JOIN LeaveType T ON #U.TypeID = T.TypeID AND T.Bank = 1

	UPDATE #U SET [Available] = (
		SELECT MIN(U.Unused + U.[Limit Seconds])
		FROM EmployeeLeaveUnused U WHERE U.[Day past 1900] >= @day AND U.[Day past 1900] <= #U.[Limit Day] AND 
		U.EmployeeID = @employee_id AND U.TypeID = #U.TypeID
	)
	FROM #U
	INNER JOIN LeaveType T ON #U.TypeID = T.TypeID AND T.Bank = 1

	UPDATE #U SET [Available] = Accumulated WHERE Available IS NULL OR Available > Accumulated





	-- Special case: rolling year (38914)

	-- Identify which people have plans of this type that include rolling years as of day
	UPDATE #U SET Rolling = EP.[Effective Seconds] FROM #U
	INNER JOIN dbo.vwEmployeeLeavePlanLeaveRate EP ON 
		EP.EmployeeID = @employee_id AND EP.TypeID = #U.TypeID AND EP.PeriodID = 38914 AND
		@day >= EP.[Start Day past 1900] AND (@day <= EP.[Stop Day past 1900] OR EP.[Stop Day past 1900] IS NULL)
		AND DATEDIFF(mm,EP.[Seniority Begins],dbo.GetDateFromDaysPast1900(@day)) BETWEEN EP.[Start Month] AND EP.[Stop Month]

	-- #R holds available leave based on rolling accrual for a given employee over a variety of days (D)
	CREATE TABLE #R(
		TypeID int,
		D int,
		Available int
	)

	CREATE UNIQUE INDEX R04132005 ON #R(TypeID, D) WITH IGNORE_DUP_KEY 

	INSERT #R
	SELECT #U.TypeID, @day, #U.Rolling FROM #U WHERE #U.Rolling != 0

	INSERT #R
	SELECT #U.TypeID, I.[Day past 1900], #U.Rolling FROM dbo.vwEmployeeLeaveUsedItemApproved I
	INNER JOIN #U ON I.EmployeeID = @employee_id AND I.[Day past 1900] BETWEEN (@day + 1) AND (@day + 364) AND (I.[Extended Type Mask] & #U.TypeID) != 0 AND #U.Rolling != 0

	UPDATE #R SET Available = Available - ISNULL((
		SELECT SUM(U.Seconds) FROM dbo.vwEmployeeLeaveUsedItemApproved U WHERE U.EmployeeID = @employee_id AND (U.[Extended Type Mask] & #R.TypeID) != 0 AND U.[Day past 1900] BETWEEN (#R.D - 364) AND #R.D
	), 0) + ISNULL((
		SELECT SUM(E.Seconds) FROM EmployeeLeaveEarned E WHERE E.Seconds > 0 AND E.EmployeeID = @employee_id AND E.TypeID = #R.TypeID AND E.[Day past 1900] BETWEEN (#R.D - 364) AND #R.D
	), 0)


	-- Updates #U based on #R
	UPDATE #U SET Available = (
		SELECT MIN(Available) FROM #R WHERE #R.TypeID = #U.TypeID
	), Accumulated = (
		SELECT Available FROM #R WHERE #R.TypeID = #U.TypeID AND #R.D = @day
	), [Accumulated Last Year] = 0, [Accumulated This Year] = 0
	WHERE Rolling != 0



	-- Special case: rolling 24 months (2049)
	DELETE #R
	UPDATE #U SET Rolling = 0

	-- Identify which people have plans of this type that include rolling years as of day
	UPDATE #U SET Rolling = EP.[Effective Seconds] FROM #U
	INNER JOIN vwEmployeeLeavePlanLeaveRate EP ON 
		EP.EmployeeID = @employee_id AND EP.TypeID = #U.TypeID AND EP.PeriodID = 2049 AND
		@day >= EP.[Start Day past 1900] AND (@day <= EP.[Stop Day past 1900] OR EP.[Stop Day past 1900] IS NULL) AND
		DATEDIFF(mm,EP.[Seniority Begins],dbo.GetDateFromDaysPast1900(@day)) BETWEEN EP.[Start Month] AND EP.[Stop Month]
		
	INSERT #R
	SELECT #U.TypeID, @day, #U.Rolling FROM #U WHERE #U.Rolling != 0

	INSERT #R
	SELECT I.TypeID, I.[Day past 1900], #U.Rolling FROM vwEmployeeLeaveUsedItemApproved I
	INNER JOIN #U ON I.EmployeeID = @employee_id AND I.[Day past 1900] BETWEEN @day AND (@day + 729) AND (I.[Extended Type Mask] & #U.TypeID) != 0 AND #U.Rolling != 0

	UPDATE #R SET Available = Available - ISNULL((
		SELECT SUM(U.Seconds) FROM vwEmployeeLeaveUsedItemApproved U WHERE U.EmployeeID = @employee_id AND (U.[Extended Type Mask] & #R.TypeID) != 0 AND U.[Day past 1900] BETWEEN (#R.D - 729) AND #R.D
	), 0) + ISNULL((
		SELECT SUM(E.Seconds) FROM EmployeeLeaveEarned E WHERE E.Seconds > 0 AND E.EmployeeID = @employee_id AND E.TypeID = #R.TypeID AND E.[Day past 1900] BETWEEN (#R.D - 729) AND #R.D
	), 0)


	-- Updates #U based on #R
	UPDATE #U SET Available = (
		SELECT MIN(Available) FROM #R WHERE #R.TypeID = #U.TypeID
	), Accumulated = (
		SELECT Available FROM #R WHERE #R.TypeID = #U.TypeID AND #R.D = @day
	), [Accumulated Last Year] = 0, [Accumulated This Year] = 0
	WHERE Rolling != 0


	
	
	
	SELECT T.Paid, T.Advanced, T.TypeID, T.Type, T.Flags, T.Abbreviation, T.FlagsRO, T.[Comp],T.CarryoverTargetLeaveTypeID, T.[Carryover Limit Seconds], T.[Carryover Offset Days], T.[Carryover Multiplier],
	[Annualized Rate] = 
	CASE WHEN R.[Effective Seconds] IS NULL THEN 0 ELSE CAST(R.[Effective Seconds] * (7488000.0 / R.[Seconds in Period]) / 12 * (12 - dbo.fnCountBits(R.ExcludeMonthMask)) AS int) END,
	Rate = ISNULL(R.[Effective Seconds], 0),
	R.PeriodID,
	Period = ISNULL(R.[Group], ''),
	Accumulated = ISNULL(#U.Accumulated, 0),
	Available = #U.Available,
	[Used Last Year] = ISNULL((
		SELECT SUM(I.Seconds) FROM vwEmployeeLeaveUsedItemApproved I WHERE
		I.EmployeeID = @employee_id AND (I.[Extended Type Mask] & T.TypeID) != 0 AND I.[Day past 1900] BETWEEN @last_year_start AND @last_year_stop
	), 0),
	[Used This Year] = ISNULL((
		SELECT SUM(I.Seconds) FROM vwEmployeeLeaveUsedItemApproved I WHERE
		I.EmployeeID = @employee_id AND (I.[Extended Type Mask] & T.TypeID) != 0 AND I.[Day past 1900] BETWEEN @this_year_start AND @this_year_stop
	), 0),
	[Used Rolling Year] = ISNULL((
		SELECT SUM(I.Seconds) FROM vwEmployeeLeaveUsedItemApproved I WHERE
		I.EmployeeID = @employee_id AND (I.[Extended Type Mask] & T.TypeID) != 0 AND I.[Day past 1900] BETWEEN @rolling_start AND @rolling_stop
	), 0),
	Scheduled = ISNULL((
		SELECT SUM(I.Seconds) FROM vwEmployeeLeaveUsedItemApproved I WHERE
		I.EmployeeID = @employee_id AND (I.[Extended Type Mask] & T.TypeID) != 0 AND I.[Day past 1900] BETWEEN @scheduled_start AND @scheduled_stop
	), 0),
	[Used YTD] = ISNULL((
		SELECT SUM(I.Seconds) FROM vwEmployeeLeaveUsedItemApproved I WHERE
		I.EmployeeID = @employee_id AND (I.[Extended Type Mask] & T.TypeID) != 0 AND I.[Day past 1900] BETWEEN @this_year_start AND DATEDIFF(d,0,GETDATE())
	), 0),
	[Earned YTD] = ISNULL((
		SELECT SUM(E.Seconds) FROM EmployeeLeaveEarned E WHERE
		E.EmployeeID = @employee_id AND E.TypeID = T.TypeID AND E.Seconds > 0 AND E.[Day past 1900] BETWEEN @this_year_start AND DATEDIFF(d,0,GETDATE())
	), 0),
	[Earned This Year] = ISNULL((
		SELECT SUM(E.Seconds) FROM EmployeeLeaveEarned E WHERE
		E.EmployeeID = @employee_id AND E.TypeID = T.TypeID AND E.Seconds > 0 AND E.[Day past 1900] BETWEEN @this_year_start AND @this_year_stop
	), 0),
	[Accumulated Last Year] = ISNULL(#U.[Accumulated Last Year], 0),
	[Accumulated This Year] = ISNULL(#U.[Accumulated This Year], 0)
	INTO #Return
	FROM dbo.vwLeaveType T
	INNER JOIN #U ON T.TypeID = #U.TypeID
	LEFT JOIN dbo.vwEmployeeLeavePlanLeaveRate R ON 
		R.EmployeeID = @employee_id AND T.TypeID = R.TypeID AND
		@day >= R.[Start Day past 1900] AND (R.[Stop Day past 1900] IS NULL OR @day <= R.[Stop Day past 1900]) AND
		@month_seniority BETWEEN R.[Start Month] AND R.[Stop Month]
	ORDER BY T.[Order]
	



	SELECT *, 
	[Annualized Hrs] = [Annualized Rate] / @seconds_per_unit,
	[Accumulated Hrs] = Accumulated / @seconds_per_unit,
	[Available Hrs] = Available / @seconds_per_unit,
	[Used Last Year Hrs] = [Used Last Year] / @seconds_per_unit,
	[Used This Year Hrs] = [Used This Year] / @seconds_per_unit,
	[Used Rolling Year Hrs] = [Used Rolling Year] / @seconds_per_unit,
	[Scheduled Hrs] = Scheduled / @seconds_per_unit,
	[Used YTD Hrs] = [Used YTD] / @seconds_per_unit,
	[Earned This Year Hrs] = [Earned This Year] / @seconds_per_unit,
	[Earned YTD Hrs] = [Earned YTD] / @seconds_per_unit,
	[Accumulated Last Year Hrs] = [Accumulated Last Year] / @seconds_per_unit,
	[Rate Hrs] = Rate / @seconds_per_unit,
	[Accumulated This Year Hrs] = [Accumulated This Year] / @seconds_per_unit
	FROM #Return WHERE [Annualized Rate] != 0 OR Accumulated != 0 OR Available != 0 OR [Used Last Year] !=0 OR [Used This Year] !=0 OR [Used Rolling Year] != 0 OR Scheduled != 0
END
GO
GO
ALTER PROC dbo.spEmployeeLeaveSummarizeAccrual
	@employee_id int,
	@day int,
	@advanced bit = NULL,
	@type_mask int = 0x7FFFFFFF,
	@days bit = 0
AS
DECLARE @yy int
SELECT @yy = YEAR(GETDATE())

DECLARE @this_year_start int, @this_year_stop int
DECLARE @last_year_start int, @last_year_stop int
DECLARE @rolling_start int, @rolling_stop int
DECLARE @scheduled_start int, @scheduled_stop int

SELECT @this_year_start = DATEDIFF(dd, 0, dbo.GetYearStart(@yy))
SELECT @this_year_stop = DATEDIFF(dd, 0, dbo.GetYearStart(@yy + 1)) - 1

SELECT @yy = @yy - 1
SELECT @last_year_start = DATEDIFF(dd, 0, dbo.GetYearStart(@yy))
SELECT @last_year_stop = @this_year_start - 1

IF @day > DATEDIFF(d,0,GETDATE()) + 3650
BEGIN
	SELECT @rolling_start = DATEDIFF(dd, 0, DATEADD(yy, -1, GETDATE())) + 1
	SELECT @rolling_stop = DATEDIFF(dd, 0, GETDATE())
END
ELSE
BEGIN
	SELECT @rolling_stop = @day
	SELECT @rolling_start = DATEDIFF(dd,0,DATEADD(yy, -1, DATEADD(d,1,@day)))
END

SELECT @scheduled_start = @day + 1, @scheduled_stop = 0x7FFFFFFF

EXEC dbo.spEmployeeLeaveSummarizeAccrual2 @employee_id, @day, @advanced, @type_mask, @days, 
	@this_year_start, @this_year_stop,
	@last_year_start, @last_year_stop,
	@rolling_start, @rolling_stop,
	@scheduled_start, @scheduled_stop

GO
ALTER PROC dbo.spEmployeeLeaveListInitialBalances
	@batch_id int
AS
SET NOCOUNT ON

EXEC dbo.spPermissionGetOnPeopleForCurrentUser2 @batch_id, 10001
DELETE TempX WHERE BatchID = @batch_id AND (X & 1) = 0

SELECT EmployeeID = X.[ID], TypeID, LeaveID = NULL
INTO #E
FROM TempX X
CROSS JOIN LeaveType
WHERE X.BatchID = @batch_id

UPDATE #E SET LeaveID = (
	SELECT TOP 1 LeaveID FROM vwEmployeeLeaveEarned L WHERE L.EmployeeID = #E.EmployeeID AND L.TypeID = #E.TypeID AND L.Calculated = 0 ORDER BY L.[Day past 1900]
)

SELECT Employee = P.[List As], #E.EmployeeID, T.Type, T.TypeID, L.LeaveID, L.Seconds, L.[Day past 1900], L.Note,
Effective = dbo.GetDateFromDaysPast1900(L.[Day past 1900]), PPE = dbo.GetDateFromDaysPast1900(L.[PPE Day past 1900])
FROM #E
INNER JOIN dbo.vwPersonListAs P ON #E.EmployeeID = P.PersonID
INNER JOIN LeaveType T ON #E.TypeID = T.TypeID
LEFT JOIN EmployeeLeaveEarned L ON #E.LeaveID = L.LeaveID
ORDER BY P.[List As], T.[Order]

DELETE TempX WHERE BatchID = @batch_id OR DATEDIFF(hh, Created, GETDATE()) > 1
GO
ALTER PROC dbo.spLeaveSummarizeUnused
	@day int,
	@batch_id int,
	@days bit = 0,
	@top int = 0x7FFFFFFF
AS
SET NOCOUNT ON

IF @day > 0x7FFF0000 SET @day = 0x7FFF0000

EXEC dbo.spPermissionGetOnPeopleForCurrentUser2 @batch_id, 10003
DELETE TempX WHERE BatchID = @batch_id AND (X & 1) = 0

IF @top > 0 AND @top < 0x7FFFFFFF AND (SELECT COUNT(*) FROM TempX) > @top
BEGIN
	DECLARE @last int

	SET ROWCOUNT @top
	SELECT X.[ID]
	INTO #D
	FROM TempX X
	INNER JOIN dbo.vwPersonListAs P ON X.BatchID=@batch_id AND X.[ID]=P.PersonID
	ORDER BY P.[List As]

	SET ROWCOUNT 0

	DELETE X FROM TempX X
	LEFT JOIN #D ON X.BatchID=@batch_id AND X.[ID]=#D.[ID]
	WHERE #D.[ID] IS NULL
END

-- Calculate Accumulated
SELECT EmployeeID = X.[ID],
T.TypeID,
[Accumulated Day] = ISNULL((
	SELECT MAX(U.[Day past 1900]) FROM EmployeeLeaveUnused U WHERE U.[Day past 1900] <= @day AND U.EmployeeID = X.[ID] AND U.TypeID = T.TypeID
), 0),
[Accumulated] = 0,
[Available] = NULL,
[Limit Day] = NULL,
Rolling = 0,
[Seconds per Unit] = CAST(CASE WHEN @days=1 THEN S.[Effective Seconds per Day] ELSE 3600.0000 END AS numeric(9,4)),
T.[Order]
INTO #U
FROM TempX X
INNER JOIN Employee E ON X.BatchID=@batch_id AND X.[ID]=E.EmployeeID
INNER JOIN vwEmployeeEffectiveSecondsPerDay S ON E.EmployeeID=S.EmployeeID
CROSS JOIN LeaveType T
WHERE X.BatchID = @batch_id AND (T.Bank=1 OR T.TypeID IN
(
	SELECT TypeID FROM LeaveRate
))

UPDATE #U SET [Limit Day] = ISNULL((
	SELECT MIN(E.[Day past 1900]) FROM vwEmployeeLeaveEarned E WHERE E.[Day past 1900] >= @day AND E.EmployeeID = #U.EmployeeID AND E.TypeID = #U.TypeID AND E.[Limit Adjustment] = 1
), 2147483647)

UPDATE #U SET Accumulated = U.Unused -- + CASE WHEN U.[Day past 1900]=@day THEN U.[Limit Seconds] ELSE 0 END
FROM #U
INNER JOIN EmployeeLeaveUnused U ON U.EmployeeID = #U.EmployeeID AND U.TypeID = #U.TypeID AND U.[Day past 1900] = #U.[Accumulated Day]

-- Calculate available
UPDATE #U SET Available = (
	SELECT MIN(U.Unused + U.[Limit Seconds])
	FROM EmployeeLeaveUnused U WHERE U.EmployeeID = #U.EmployeeID AND U.TypeID = #U.TypeID AND U.[Day past 1900] >= @day AND U.[Day past 1900] <= #U.[Limit Day]
) FROM #U

UPDATE #U SET Available = Accumulated WHERE Available IS NULL OR Available > Accumulated



-- Special case: rolling year (38914)

-- Identify which people have plans of this type that include rolling years as of day
UPDATE #U SET Rolling = EP.[Effective Seconds] FROM #U
INNER JOIN vwEmployeeLeavePlanLeaveRate EP ON
#U.EmployeeID = EP.EmployeeID AND EP.TypeID = #U.TypeID AND EP.PeriodID = 38914 AND
@day >= EP.[Start Day past 1900] AND (@day <= EP.[Stop Day past 1900] OR EP.[Stop Day past 1900] IS NULL) AND
DATEDIFF(mm,EP.[Seniority Begins],dbo.GetDateFromDaysPast1900(@day)) BETWEEN EP.[Start Month] AND EP.[Stop Month]


-- #R holds available leave based on rolling accrual for a given employee over a variety of days (D)
CREATE TABLE #R(
	EmployeeID int,
	TypeID int,
	D int,
	Available int
)

CREATE UNIQUE INDEX R04132005 ON #R(EmployeeID, TypeID, D) WITH IGNORE_DUP_KEY 

INSERT #R
SELECT #U.EmployeeID, #U.TypeID, @day, #U.Rolling FROM #U WHERE Rolling != 0

-- Employees with used leave, start day
INSERT #R
SELECT U.EmployeeID, #U.TypeID, U.[Start Day past 1900], #U.Rolling FROM EmployeeLeaveUsed U
INNER JOIN #U ON #U.Rolling != 0 AND U.EmployeeID = #U.EmployeeID AND U.[Start Day past 1900] BETWEEN @day AND (@day + 364) AND 
(U.[Advanced Type Mask] & #U.TypeID) != 0 AND Status = 2

-- Employees with used leave, stop day
INSERT #R
SELECT U.EmployeeID, #U.TypeID, U.[Stop Day past 1900], #U.Rolling FROM EmployeeLeaveUsed U
INNER JOIN #U ON #U.Rolling != 0 AND U.EmployeeID = #U.EmployeeID AND U.[Stop Day past 1900] BETWEEN @day AND (@day + 364) AND 
(U.[Advanced Type Mask] & #U.TypeID) != 0 AND Status = 2

-- Employees with negative earned leave adjustments
INSERT #R
SELECT E.EmployeeID, #U.TypeID, E.[Day past 1900], #U.Rolling FROM EmployeeLeaveEarned E
INNER JOIN #U ON #U.Rolling != 0 AND E.Seconds < 0 AND E.[Day past 1900] BETWEEN @day AND (@day + 364) ANd E.TypeID = #U.TypeID


UPDATE #R SET Available = Available - ISNULL((
	SELECT SUM(U.Seconds) FROM vwEmployeeLeaveUsedItemApproved U WHERE U.EmployeeID = #R.EmployeeID AND (U.[Extended Type Mask] & #R.TypeID) != 0 AND U.[Day past 1900] BETWEEN (#R.D - 364) AND #R.D
), 0) + ISNULL((
	SELECT SUM(E.Seconds) FROM EmployeeLeaveEarned E WHERE E.Seconds > 0 AND E.EmployeeID = #R.EmployeeID AND E.TypeID = #R.TypeID AND E.[Day past 1900] BETWEEN (#R.D - 364) AND #R.D
), 0)

-- Updates #U based on #R
UPDATE #U SET Available = (
	SELECT MIN(Available) FROM #R WHERE #R.EmployeeID = #U.EmployeeID AND #R.TypeID = #U.TypeID
), Accumulated = (
	SELECT Available FROM #R WHERE #R.EmployeeID = #U.EmployeeID AND #R.D = @day AND #R.TypeID = #U.TypeID
)
WHERE Rolling != 0










-- Special case: rolling year (2049)

UPDATE #U SET Rolling = 0
DELETE #R

-- Identify which people have plans of this type that include rolling 24 months as of day
UPDATE #U SET Rolling = EP.[Effective Seconds] FROM #U
INNER JOIN vwEmployeeLeavePlanLeaveRate EP ON 
	#U.EmployeeID = EP.EmployeeID AND EP.TypeID = #U.TypeID AND EP.PeriodID = 2049 AND
	@day >= EP.[Start Day past 1900] AND (@day <= EP.[Stop Day past 1900] OR EP.[Stop Day past 1900] IS NULL) AND
	DATEDIFF(mm,EP.[Seniority Begins],dbo.GetDateFromDaysPast1900(@day)) BETWEEN EP.[Start Month] AND EP.[Stop Month]
 

INSERT #R
SELECT #U.EmployeeID, #U.TypeID, @day, #U.Rolling FROM #U WHERE Rolling != 0

INSERT #R
SELECT U.EmployeeID, #U.TypeID, U.[Start Day past 1900], #U.Rolling FROM EmployeeLeaveUsed U
INNER JOIN #U ON #U.Rolling != 0 AND U.EmployeeID = #U.EmployeeID AND U.[Start Day past 1900] BETWEEN @day AND (@day + 729) AND 
(U.[Advanced Type Mask] & #U.TypeID) != 0 AND Status = 2

INSERT #R
SELECT U.EmployeeID, #U.TypeID, U.[Stop Day past 1900], #U.Rolling FROM EmployeeLeaveUsed U
INNER JOIN #U ON #U.Rolling != 0 AND U.EmployeeID = #U.EmployeeID AND U.[Stop Day past 1900] BETWEEN @day AND (@day + 729) AND 
(U.[Advanced Type Mask] & #U.TypeID) != 0 AND Status = 2

-- Employees with negative earned leave adjustments
INSERT #R
SELECT E.EmployeeID, #U.TypeID, E.[Day past 1900], #U.Rolling FROM EmployeeLeaveEarned E
INNER JOIN #U ON #U.Rolling != 0 AND E.Seconds < 0 AND E.[Day past 1900] BETWEEN @day AND (@day + 364) ANd E.TypeID = #U.TypeID


UPDATE #R SET Available = Available - ISNULL((
	SELECT SUM(U.Seconds) FROM vwEmployeeLeaveUsedItemApproved U WHERE U.EmployeeID = #R.EmployeeID AND (U.[Extended Type Mask] & #R.TypeID) != 0 AND U.[Day past 1900] BETWEEN (#R.D - 729) AND #R.D
), 0) + ISNULL((
	SELECT SUM(E.Seconds) FROM EmployeeLeaveEarned E WHERE E.Seconds > 0 AND E.EmployeeID = #R.EmployeeID AND E.TypeID = #R.TypeID AND E.[Day past 1900] BETWEEN (#R.D - 729) AND #R.D
), 0)

-- Updates #U based on #R
UPDATE #U SET Available = (
	SELECT MIN(Available) FROM #R WHERE #R.EmployeeID = #U.EmployeeID AND #R.TypeID = #U.TypeID
), Accumulated = (
	SELECT Available FROM #R WHERE #R.EmployeeID = #U.EmployeeID AND #R.D = @day AND #R.TypeID = #U.TypeID
)
WHERE Rolling != 0

DELETE TempX WHERE BatchID = @batch_id OR DATEDIFF(hh, Created, GETDATE()) > 1

-- Return results
SELECT
#U.EmployeeID,
--#U.TypeID,
Employee = P.[List As],
E.[Employee Number],
T.Type,
Accumulated = #U.Accumulated / [Seconds per Unit],
Available = #U.Available / [Seconds per Unit],
#U.[Order],
#U.TypeID
FROM #U
INNER JOIN dbo.vwPersonListAs P ON #U.EmployeeID = P.PersonID
INNER JOIN dbo.Employee E ON #U.EmployeeID = E.EmployeeID
INNER JOIN LeaveType T ON #U.TypeID = T.TypeID 
AND 
(
	(T.Advanced = 0 AND T.Bank=1) OR T.TypeID  IN(SELECT TypeID FROM #U WHERE (Accumulated != 0 OR Available != 0))
)
ORDER BY P.[List As], #U.EmployeeID, T.[Order], T.TypeID
GO
IF OBJECT_id('dbo.spLeaveSummarizeUnused2') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spLeaveSummarizeUnused2 AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spLeaveSummarizeUnused2 TO public'
END
GO
ALTER PROC dbo.spLeaveSummarizeUnused2
	@batch_id int,
	@type_id int,
	@day int, -- @stop
	@authorized bit OUT,
	@days bit = 0,
	@flags int = 0, -- 1: exclude employees with no used time between @start and @day
	@start int = -2147483648
AS
DECLARE @plan_id int
DECLARE @month_seniority int
DECLARE @fmla_rate int
DECLARE @fmla_available int

SET NOCOUNT ON

EXEC dbo.spPermissionGetOnPeopleForCurrentUser2 @batch_id, 10003
DELETE TempX WHERE BatchID = @batch_id AND (X & 1) = 0
SELECT @authorized = CASE WHEN @@ROWCOUNT = 0 THEN 1 ELSE 0 END

-- This is a hack to correct an error in an old version of the ISS LeaveSummary report
IF @day = 2147483647 AND @start <> -2147483648 SET @day = @start

DECLARE @yy int, @ly int
SELECT @yy = YEAR(GETDATE())

DECLARE @this_year_start int, @this_year_stop int
DECLARE @last_year_start int, @last_year_stop int
DECLARE @rolling_start int, @rolling_stop int

SELECT @this_year_start = DATEDIFF(dd, 0, dbo.GetDateFromMDY(1, 1, @yy))
SELECT @this_year_stop = DATEDIFF(dd, 0, dbo.GetDateFromMDY(12, 31, @yy))

SELECT @ly = @yy - 1
SELECT @last_year_start = DATEDIFF(dd, 0, dbo.GetDateFromMDY(1, 1, @ly))
SELECT @last_year_stop = DATEDIFF(dd, 0, dbo.GetDateFromMDY(12, 31, @ly))

SELECT @rolling_start = DATEDIFF(dd, 0, DATEADD(yy, -1, GETDATE())) + 1
SELECT @rolling_stop = DATEDIFF(dd, 0, GETDATE())



-- Calculate Accumulated
SELECT EmployeeID = X.[ID],
[Accumulated Day] = ISNULL((
	SELECT MAX(U.[Day past 1900]) FROM EmployeeLeaveUnused U WHERE U.[Day past 1900] <= @day AND U.EmployeeID = X.[ID] AND U.TypeID = @type_id
), 0),
[Accumulated] = 0,
[Accumulated Last Year Day] = ISNULL((
	SELECT MAX(U.[Day past 1900]) FROM EmployeeLeaveUnused U WHERE U.[Day past 1900] <= @last_year_stop AND U.EmployeeID = X.[ID] AND U.TypeID = @type_id
), 0),
[Accumulated Last Year] = 0,
[Accumulated This Year Day] = ISNULL((
	SELECT MAX(U.[Day past 1900]) FROM EmployeeLeaveUnused U WHERE U.[Day past 1900] <= @this_year_stop AND U.EmployeeID = X.[ID] AND U.TypeID = @type_id
), 0),
[Accumulated This Year] = 0,
[Available] = NULL,
[Limit Day] = NULL,
[Recent Day] = ISNULL((
	SELECT TOP 1 U.[Start Day past 1900] FROM EmployeeLeaveUsed U
	WHERE U.EmployeeID = X.[ID] AND U.[Start Day past 1900] > @day AND U.Status = 2 AND U.Seconds > 0
	ORDER BY U.[Start Day past 1900]
),
(
	SELECT TOP 1 U.[Start Day past 1900] FROM EmployeeLeaveUsed U
	WHERE U.EmployeeID = X.[ID] AND U.[Start Day past 1900] <= @day AND U.Status = 2 AND U.Seconds > 0
	ORDER BY U.[Start Day past 1900] DESC
)
),
Rolling = 0,
Recent = CAST('' AS varchar(80)),
[Effective Seconds] = ISNULL(R.[Effective Seconds],0),
[Seconds per Unit] = CASE WHEN @days=1 THEN S.[Effective Seconds per Day] ELSE 3600.0 END,
[Seconds in Period] = R.[Seconds in Period],
R.[Max Seconds],
[Used Seconds] = ISNULL((
	SELECT SUM(I.Seconds) FROM dbo.vwEmployeeLeaveUsedItemApproved I WHERE
	I.EmployeeID = X.[ID] AND (I.[Extended Type Mask] & @type_id) != 0 AND I.[Day past 1900] BETWEEN @start AND @day
), 0)
INTO #U
FROM TempX X 
INNER JOIN vwEmployeeEffectiveSecondsPerDay S ON X.BatchID = @batch_id AND X.[ID] = S.EmployeeID
LEFT JOIN vwEmployeeLeavePlanLeaveRate R ON 
	S.EmployeeID = R.EmployeeID AND R.TypeID=@type_id AND 
	@day >= R.[Start Day past 1900] AND (R.[Stop Day past 1900] IS NULL OR @day <= R.[Stop Day past 1900]) AND
	DATEDIFF(mm, R.[Seniority Begins Day past 1900], dbo.GetDateFromDaysPast1900(@day)) BETWEEN R.[Start Month] AND R.[Stop Month]

DELETE TempX WHERE BatchID = @batch_id OR DATEDIFF(hh, Created, GETDATE()) > 1

UPDATE #U SET [Limit Day] = ISNULL((
	SELECT MIN(E.[Day past 1900]) FROM vwEmployeeLeaveEarned E WHERE E.[Day past 1900] >= @day AND E.EmployeeID = #U.EmployeeID AND E.TypeID = @type_id AND E.[Limit Adjustment] = 1
), 2147483647)

UPDATE #U SET Accumulated = U.Unused -- + CASE WHEN U.[Day past 1900]=@day THEN U.[Limit Seconds] ELSE 0 END
FROM #U
INNER JOIN EmployeeLeaveUnused U ON U.EmployeeID = #U.EmployeeID AND U.TypeID = @type_id AND U.[Day past 1900] = #U.[Accumulated Day]

UPDATE #U SET [Accumulated Last Year] = U.Unused
FROM #U
INNER JOIN EmployeeLeaveUnused U ON U.EmployeeID = #U.EmployeeID AND U.TypeID = @type_id AND U.[Day past 1900] = #U.[Accumulated Last Year Day]

UPDATE #U SET [Accumulated This Year] = U.Unused + CASE WHEN U.[Day past 1900]=@this_year_stop THEN U.[Limit Seconds] ELSE 0 END
FROM #U
INNER JOIN EmployeeLeaveUnused U ON U.EmployeeID = #U.EmployeeID AND U.TypeID = @type_id AND U.[Day past 1900] = #U.[Accumulated This Year Day]


-- Calculate available
UPDATE #U SET Available = (
	SELECT MIN(U.Unused + U.[Limit Seconds]) FROM EmployeeLeaveUnused U WHERE U.EmployeeID = #U.EmployeeID AND U.TypeID = @type_id AND U.[Day past 1900] >= @day AND U.[Day past 1900] <= #U.[Limit Day]
)
FROM #U

UPDATE #U SET Available = Accumulated WHERE Available IS NULL OR Available > Accumulated






-- Special case: rolling year (38914)

-- Identify which people have plans of this type that include rolling years as of day
UPDATE #U SET Rolling = EP.[Effective Seconds] FROM #U
INNER JOIN vwEmployeeLeavePlanLeaveRate EP ON 
#U.EmployeeID = EP.EmployeeID AND EP.TypeID = @type_id AND EP.PeriodID = 38914 AND
@day >= EP.[Start Day past 1900] AND (@day <= EP.[Stop Day past 1900] OR EP.[Stop Day past 1900] IS NULL) AND
DATEDIFF(mm,EP.[Seniority Begins],dbo.GetDateFromDaysPast1900(@day)) BETWEEN EP.[Start Month] AND EP.[Stop Month]

-- #R holds available leave based on rolling accrual for a given employee over a variety of days (D)
CREATE TABLE #R(
	EmployeeID int,
	D int,
	Available int
)

CREATE UNIQUE INDEX R04132005 ON #R(EmployeeID, D) WITH IGNORE_DUP_KEY 

INSERT #R
SELECT #U.EmployeeID, @day, #U.Rolling FROM #U WHERE Rolling != 0

-- Employees with used leave, start day
INSERT #R
SELECT U.EmployeeID, U.[Start Day past 1900], #U.Rolling FROM EmployeeLeaveUsed U
INNER JOIN #U ON #U.Rolling != 0 AND U.EmployeeID = #U.EmployeeID AND U.[Start Day past 1900] BETWEEN @day AND dbo.fnBoundIntAddition(@day,364) AND 
(U.[Advanced Type Mask] & @type_id) != 0 AND Status = 2

-- Employees with used leave, stop day
INSERT #R
SELECT U.EmployeeID, U.[Stop Day past 1900], #U.Rolling FROM EmployeeLeaveUsed U
INNER JOIN #U ON #U.Rolling != 0 AND U.EmployeeID = #U.EmployeeID AND U.[Stop Day past 1900] BETWEEN @day AND dbo.fnBoundIntAddition(@day,364) AND 
(U.[Advanced Type Mask] & @type_id) != 0 AND Status = 2

-- Employees with negative earned leave adjustments
INSERT #R
SELECT E.EmployeeID, E.[Day past 1900], #U.Rolling FROM EmployeeLeaveEarned E
INNER JOIN #U ON #U.Rolling != 0 AND E.Seconds < 0 AND E.[Day past 1900] BETWEEN @day AND dbo.fnBoundIntAddition(@day,364) ANd E.TypeID = @type_id


UPDATE #R SET Available = Available - ISNULL((
	SELECT SUM(U.Seconds) FROM vwEmployeeLeaveUsedItemApproved U WHERE U.EmployeeID = #R.EmployeeID AND (U.[Extended Type Mask] & @type_id) != 0 AND U.[Day past 1900] BETWEEN (#R.D - 364) AND #R.D
), 0) + ISNULL((
	SELECT SUM(E.Seconds) FROM EmployeeLeaveEarned E WHERE E.Seconds > 0 AND E.EmployeeID = #R.EmployeeID AND E.TypeID = @type_id AND E.[Day past 1900] BETWEEN (#R.D - 364) AND #R.D
), 0)

-- Updates #U based on #R
UPDATE #U SET Available = (
	SELECT MIN(Available) FROM #R WHERE #R.EmployeeID = #U.EmployeeID
), Accumulated = (
	SELECT Available FROM #R WHERE #R.EmployeeID = #U.EmployeeID AND #R.D = @day
)
WHERE Rolling != 0






-- Special case: rolling year (2049)

UPDATE #U SET Rolling = 0
DELETE #R

-- Identify which people have plans of this type that include rolling 24 months as of day
UPDATE #U SET Rolling = EP.[Effective Seconds] FROM #U
INNER JOIN vwEmployeeLeavePlanLeaveRate EP ON 
#U.EmployeeID = EP.EmployeeID AND EP.TypeID = @type_id AND EP.PeriodID = 2049 AND
@day >= EP.[Start Day past 1900] AND (@day <= EP.[Stop Day past 1900] OR EP.[Stop Day past 1900] IS NULL) AND
DATEDIFF(mm,EP.[Seniority Begins],dbo.GetDateFromDaysPast1900(@day)) BETWEEN EP.[Start Month] AND EP.[Stop Month]
 

INSERT #R
SELECT #U.EmployeeID, @day, #U.Rolling FROM #U WHERE Rolling != 0

INSERT #R
SELECT U.EmployeeID, U.[Start Day past 1900], #U.Rolling FROM EmployeeLeaveUsed U
INNER JOIN #U ON #U.Rolling != 0 AND U.EmployeeID = #U.EmployeeID AND U.[Start Day past 1900] BETWEEN @day AND dbo.fnBoundIntAddition(@day,729) AND 
(U.[Advanced Type Mask] & @type_id) != 0 AND Status = 2

INSERT #R
SELECT U.EmployeeID, U.[Stop Day past 1900], #U.Rolling FROM EmployeeLeaveUsed U
INNER JOIN #U ON #U.Rolling != 0 AND U.EmployeeID = #U.EmployeeID AND U.[Stop Day past 1900] BETWEEN @day AND dbo.fnBoundIntAddition(@day,729) AND 
(U.[Advanced Type Mask] & @type_id) != 0 AND Status = 2

-- Employees with negative earned leave adjustments
INSERT #R
SELECT E.EmployeeID, E.[Day past 1900], #U.Rolling FROM EmployeeLeaveEarned E
INNER JOIN #U ON #U.Rolling != 0 AND E.Seconds < 0 AND E.[Day past 1900] BETWEEN @day AND dbo.fnBoundIntAddition(@day,364) ANd E.TypeID = @type_id


UPDATE #R SET Available = Available - ISNULL((
	SELECT SUM(U.Seconds) FROM vwEmployeeLeaveUsedItemApproved U WHERE U.EmployeeID = #R.EmployeeID AND (U.[Extended Type Mask] & @type_id) != 0 AND U.[Day past 1900] BETWEEN (#R.D - 729) AND #R.D
), 0) + ISNULL((
	SELECT SUM(E.Seconds) FROM EmployeeLeaveEarned E WHERE E.Seconds > 0 AND E.EmployeeID = #R.EmployeeID AND E.TypeID = @type_id AND E.[Day past 1900] BETWEEN (#R.D - 729) AND #R.D
), 0)

-- Updates #U based on #R
UPDATE #U SET Available = (
	SELECT MIN(Available) FROM #R WHERE #R.EmployeeID = #U.EmployeeID
), Accumulated = (
	SELECT Available FROM #R WHERE #R.EmployeeID = #U.EmployeeID AND #R.D = @day
)
WHERE Rolling != 0





DECLARE @rows int
SET @rows = 1

WHILE @rows > 0
BEGIN
	UPDATE #U SET Recent = SUBSTRING(
		Recent +
		CASE WHEN Recent = '' THEN '' ELSE ', ' END +
		CASE WHEN YEAR(dbo.GetDateFromDaysPast1900([Start Day past 1900])) = @yy THEN CAST(dbo.GetDateFromDaysPast1900([Start Day past 1900]) AS varchar(6))
		ELSE CAST(dbo.GetDateFromDaysPast1900([Start Day past 1900]) AS varchar(11)) END
		+
		CASE WHEN [Start Day past 1900] != [Stop Day past 1900] THEN ' to ' + CAST(dbo.GetDateFromDaysPast1900([Stop Day past 1900]) AS varchar(6))
		ELSE '' END,
		0, 80
	)
	, [Recent Day] = (
		SELECT TOP 1 [Start Day past 1900] FROM EmployeeLeaveUsed U2
		WHERE U2.EmployeeID = #U.EmployeeID AND U2.[Start Day past 1900] < #U.[Recent Day] AND U2.Status = 2 AND U2.Seconds > 0
		ORDER BY U2.[Start Day past 1900] DESC
	)
	FROM #U
	INNER JOIN EmployeeLeaveUsed U ON #U.[Recent Day] = U.[Start Day past 1900] AND #U.EmployeeID = U.EmployeeID AND ((U.[Type Mask] | U.[Advanced Type Mask]) & @type_id) != 0  AND LEN(Recent) < 80

	SET @rows = @@ROWCOUNT
END

EXEC dbo.spCustomFieldClean

-- Return results
SELECT
#U.EmployeeID,
#U.Recent,
Employee = E.[Person List As],
[Last Date Used] = dbo.GetDateFromDaysPast1900((
	SELECT MAX(I.[Day past 1900]) FROM dbo.EmployeeLeaveUsedItem I
	INNER JOIN dbo.EmployeeLeaveUsed U ON I.LeaveID=U.LeaveID AND I.[Day past 1900] <= @day AND U.EmployeeID = E.EID AND (I.TypeID=@type_id OR (I.[Advanced Type Mask] & @type_id) != 0)
)),

[Annualized Hrs] = CASE WHEN #U.[Effective Seconds] IS NULL OR #U.[Seconds in Period]=0 THEN 0 ELSE #U.[Effective Seconds] * (2080.0 / #U.[Seconds in Period]) END,
[Accumulated Hrs] = CASE WHEN #U.[Seconds per Unit]=0 THEN 0 ELSE #U.Accumulated / #U.[Seconds per Unit] END,
[Accumulated Last Year Hrs] = CASE WHEN #U.[Seconds per Unit]=0 THEN 0 ELSE #U.[Accumulated Last Year] / #U.[Seconds per Unit] END,
[Accumulated This Year Hrs] = CASE WHEN #U.[Seconds per Unit]=0 THEN 0 ELSE #U.[Accumulated This Year] / #U.[Seconds per Unit] END,
[Available Hrs] = CASE WHEN #U.[Seconds per Unit]=0 THEN 0 ELSE #U.Available / #U.[Seconds per Unit] END,
[Used Last Year Hrs] = CASE WHEN #U.[Seconds per Unit]=0 THEN 0 ELSE ISNULL((
	SELECT SUM(I.Seconds) FROM vwEmployeeLeaveUsedItemApproved I WHERE
	I.EmployeeID = #U.EmployeeID AND (I.[Extended Type Mask] & @type_id) != 0 AND I.[Day past 1900] BETWEEN @last_year_start AND @last_year_stop
), 0) / #U.[Seconds per Unit] END,
[Used This Year Hrs] = CASE WHEN #U.[Seconds per Unit]=0 THEN 0 ELSE ISNULL((
	SELECT SUM(I.Seconds) FROM dbo.vwEmployeeLeaveUsedItemApproved I WHERE
	I.EmployeeID = #U.EmployeeID AND (I.[Extended Type Mask] & @type_id) != 0 AND I.[Day past 1900] BETWEEN @this_year_start AND @this_year_stop
), 0) / #U.[Seconds per Unit] END,
[Used Rolling Year Hrs] = CASE WHEN #U.[Seconds per Unit]=0 THEN 0 ELSE ISNULL((
	SELECT SUM(I.Seconds) FROM dbo.vwEmployeeLeaveUsedItemApproved I WHERE
	I.EmployeeID = #U.EmployeeID AND (I.[Extended Type Mask] & @type_id) != 0 AND I.[Day past 1900] BETWEEN @rolling_start AND @rolling_stop
), 0) / #U.[Seconds per Unit] END,
[Scheduled Hrs] = CASE WHEN #U.[Seconds per Unit]=0 THEN 0 ELSE ISNULL((
	SELECT SUM(I.Seconds) FROM dbo.vwEmployeeLeaveUsedItemApproved I WHERE
	I.EmployeeID = #U.EmployeeID AND (I.[Extended Type Mask] & @type_id) != 0 AND I.[Day past 1900] > @day
), 0) / #U.[Seconds per Unit] END,
[Maximum Hrs] = CASE WHEN #U.[Max Seconds] IS NULL OR #U.[Seconds per Unit]=0 THEN 0 ELSE #U.[Max Seconds] / #U.[Seconds per Unit] END,
[Used Hrs] = CASE WHEN #U.[Seconds per Unit]=0 THEN 0 ELSE #U.[Used Seconds] / #U.[Seconds per Unit] END,

[Annualized Days] = CASE WHEN #U.[Effective Seconds] IS NULL OR #U.[Seconds in Period]=0 THEN 0 ELSE #U.[Effective Seconds] * (2080.0 / #U.[Seconds in Period]) END,
[Accumulated Days] = CASE WHEN E.[Effective Seconds per Day]=0 THEN 0 ELSE 1.0000 * #U.Accumulated / E.[Effective Seconds per Day] END,
[Accumulated Last Year Days] = CASE WHEN E.[Effective Seconds per Day]=0 THEN 0 ELSE 1.0000 * #U.[Accumulated Last Year] / E.[Effective Seconds per Day] END,
[Accumulated This Year Days] = CASE WHEN E.[Effective Seconds per Day]=0 THEN 0 ELSE 1.0000 * #U.[Accumulated This Year] / E.[Effective Seconds per Day] END,
[Available Days] = CASE WHEN E.[Effective Seconds per Day]=0 THEN 0 ELSE 1.0000 * #U.Available / E.[Effective Seconds per Day] END,
[Used Last Year Days] = CASE WHEN E.[Effective Seconds per Day]=0 THEN 0 ELSE 1.0000 * ISNULL((
	SELECT SUM(I.Seconds) FROM vwEmployeeLeaveUsedItemApproved I WHERE
	I.EmployeeID = #U.EmployeeID AND (I.[Extended Type Mask] & @type_id) != 0 AND I.[Day past 1900] BETWEEN @last_year_start AND @last_year_stop
), 0) / E.[Effective Seconds per Day] END,
[Used This Year Days] = CASE WHEN E.[Effective Seconds per Day]=0 THEN 0 ELSE 1.0000 * ISNULL((
	SELECT SUM(I.Seconds) FROM vwEmployeeLeaveUsedItemApproved I WHERE
	I.EmployeeID = #U.EmployeeID AND (I.[Extended Type Mask] & @type_id) != 0 AND I.[Day past 1900] BETWEEN @this_year_start AND @this_year_stop
), 0) / E.[Effective Seconds per Day] END,
[Used Rolling Year Days] = CASE WHEN E.[Effective Seconds per Day]=0 THEN 0 ELSE 1.0000 * ISNULL((
	SELECT SUM(I.Seconds) FROM vwEmployeeLeaveUsedItemApproved I WHERE
	I.EmployeeID = #U.EmployeeID AND (I.[Extended Type Mask] & @type_id) != 0 AND I.[Day past 1900] BETWEEN @rolling_start AND @rolling_stop
), 0) / E.[Effective Seconds per Day] END,
[Scheduled Days] = CASE WHEN E.[Effective Seconds per Day]=0 THEN 0 ELSE 1.0000 * ISNULL((
	SELECT SUM(I.Seconds) FROM vwEmployeeLeaveUsedItemApproved I WHERE
	I.EmployeeID = #U.EmployeeID AND (I.[Extended Type Mask] & @type_id) != 0 AND I.[Day past 1900] > @day
), 0) / E.[Effective Seconds per Day] END,
[Maximum Days] = CASE WHEN #U.[Max Seconds] IS NULL OR E.[Effective Seconds per Day]=0 THEN 0 ELSE 1.0000 * #U.[Max Seconds] / E.[Effective Seconds per Day] END,
[Used Days] = CASE WHEN E.[Effective Seconds per Day]=0 THEN 0 ELSE 1.0000 * #U.[Used Seconds] / E.[Effective Seconds per Day] END,

EC.*, E.*

FROM #U
INNER JOIN dbo.vwEmployeeSecure E ON #U.EmployeeID=E.EID AND (
	(@flags & 1) = 0 OR #U.[Used Seconds] > 0
)
LEFT JOIN dbo.vwEmployeeCompensation EC ON (E.[Compensation Permission Mask] & 1) = 1 AND #U.EmployeeID=EC.EmployeeID AND @day BETWEEN EC.[Start Day past 1900] AND ISNULL(EC.[Stop Day past 1900], 0x7FFFFFFF)
ORDER BY E.[Person List As], #U.EmployeeID
GO
ALTER PROC dbo.spEmployeeLeaveEarnMapWeek
	@increment int,
	@seniority_begins datetime,
	@start_date datetime,
	@stop_date datetime,
	@employee_id int,
	@type_id int,
	@seconds int,
	@note varchar(4000)
AS
DECLARE @temp datetime

SET NOCOUNT ON

IF @seniority_begins < @start_date
BEGIN
	DECLARE @wk int
	SELECT @temp = dbo.GetDateFromMDY(MONTH(@seniority_begins), DAY(@seniority_begins), YEAR(@start_date) - 1)

	SELECT @wk = DATEDIFF(wk, @temp, @start_date) / @increment
	SELECT @temp = DATEADD(wk, @wk * @increment, @temp)

	WHILE @temp < @start_date SELECT @temp = DATEADD(wk, @increment, @temp)
END
ELSE SELECT @temp = @seniority_begins

WHILE @temp <= @stop_date
BEGIN
	INSERT EmployeeLeaveEarned(EmployeeID, TypeID, Seconds, [Day past 1900], [PPE Day past 1900], Note, [Auto]) 
	VALUES (@employee_id, @type_id, @seconds, DATEDIFF(d, 0, @temp), DATEDIFF(d, 0, @temp), @note, 1)

	SELECT @temp = DATEADD(wk, @increment, @temp)	
END
GO
ALTER PROC dbo.spEmployeeLeaveEarnMapWeek2
	@increment int,
	@seniority_begins datetime,
	@start_date datetime,
	@stop_date datetime,
	@employee_id int,
	@type_id int,
	@seconds int,
	@note varchar(4000)
AS
DECLARE @temp datetime, @temp2 datetime

IF @seniority_begins < @start_date
BEGIN
	DECLARE @wk int
	SELECT @temp = dbo.GetDateFromMDY(MONTH(@seniority_begins), DAY(@seniority_begins), YEAR(@start_date) - 1)

	SELECT @wk = DATEDIFF(wk, @temp, @start_date) / @increment
	SELECT @temp = DATEADD(wk, @wk * @increment, @temp)

	WHILE @temp < @start_date SELECT @temp = DATEADD(wk, @increment, @temp)
END
ELSE IF @seniority_begins <= @stop_date
BEGIN
	INSERT EmployeeLeaveEarned(EmployeeID, TypeID, Seconds, [Day past 1900], Note, [Auto]) 
	VALUES (@employee_id, @type_id, @seconds, DATEDIFF(d, 0, @seniority_begins), @note, 1)

	SELECT @temp = DATEADD(wk, @increment, @seniority_begins)
END
ELSE SELECT @temp = @seniority_begins

SELECT @temp = DATEADD(d, -1, @temp)	

WHILE @temp <= @stop_date
BEGIN
	INSERT EmployeeLeaveEarned(EmployeeID, TypeID, Seconds, [Day past 1900], [PPE Day past 1900], Note, [Auto]) 
	VALUES (@employee_id, @type_id, @seconds, DATEDIFF(d, 0, @temp), DATEDIFF(d, 0, @temp), @note, 1)

	SELECT @temp = DATEADD(wk, @increment, @temp)	
END
GO
ALTER PROC dbo.spEmployeeLeaveEarnMapMonth2
	@increment int,
	@seniority_begins datetime,
	@start_date datetime,
	@stop_date datetime,
	@eligible_start datetime,
	@employee_id int,
	@type_id int,
	@seconds int,
	@note varchar(4000)
AS
DECLARE @month int, @ineligible_seconds int
DECLARE @temp datetime, @temp2 datetime

SELECT @month = 0, @ineligible_seconds = 0
IF @seniority_begins < @start_date
BEGIN
	SELECT @temp = dbo.GetDateFromMDY(MONTH(@seniority_begins), DAY(@seniority_begins), YEAR(@start_date) - 1)
	SELECT @temp2 = @temp

	DECLARE @mnths int
	SELECT @mnths = DATEDIFF(m, @temp2, @start_date) / @increment - 1
	IF @mnths > 0 SELECT @month = @month + @mnths * @increment

	WHILE @temp2 < @start_date
	BEGIN
		SELECT @month = @month + @increment -- Handles 12/31/04 --> 6/30/05 --> 12/31/05
		SELECT @temp2 = DATEADD(m, @month, @temp)
	END
END
ELSE IF @seniority_begins <= @stop_date
BEGIN
	IF @seniority_begins < @eligible_start SET @ineligible_seconds = @ineligible_seconds + @seconds
	ELSE INSERT EmployeeLeaveEarned(EmployeeID, TypeID, Seconds, [Day past 1900], Note, [Auto]) 
	VALUES (@employee_id, @type_id, @seconds, DATEDIFF(d, 0, @seniority_begins), @note, 1)
	SELECT @temp = @seniority_begins, @month = @increment
END
ELSE SELECT @temp = @seniority_begins

SELECT @temp = DATEADD(d, -1, @temp)	

SELECT @start_date = DATEADD(m, @month, @temp)
WHILE @start_date <= @stop_date
BEGIN
	IF @start_date < @eligible_start SET @ineligible_seconds = @ineligible_seconds + @seconds
	ELSE
	BEGIN
		INSERT EmployeeLeaveEarned(EmployeeID, TypeID, Seconds, [Day past 1900], [PPE Day past 1900], Note, [Auto]) 
		VALUES (@employee_id, @type_id, @seconds + @ineligible_seconds, DATEDIFF(d, 0, @start_date), DATEDIFF(d, 0, @start_date), @note, 1)
		SET @ineligible_seconds = 0
	END
	
	SELECT @month = @month + @increment -- Handles 12/31/04 --> 2/28/05 --> 4/30/05
	SELECT @start_date = DATEADD(m, @month, @temp)	
END
GO
ALTER PROC [dbo].[spEmployeeLeaveEarnMapFromPlan]
	@employee_id int,
	@start_day int,
	@stop_day int,
	@period_id int,
	@type_id int,
	@seconds int,
	@seniority_start datetime,
	@seniority_stop datetime,
	@employee_plan_start_day int,
	@employee_plan_stop_day int,
	@eligible_start datetime,
	@flags int,
	@seniority_begins_day int,
	@rounding_seconds int,
	@exclude_month_mask int
AS
IF @period_id IN (38914, 2049, 281088, 279040) OR @stop_day < @start_day OR @seconds = 0 RETURN

DECLARE @plan_seniority_start datetime
DECLARE @adjusted_credit int, @adjusted_note varchar(4000)
DECLARE @note varchar(4000), @note2 varchar(4000), @day_offset int
DECLARE @ineligible_seconds int, @prorated_seconds int, @eligible_seconds int
DECLARE @error_msg varchar(100), @period_stop datetime

SET NOCOUNT ON

SELECT @plan_seniority_start = CASE 
	WHEN DATEADD(d,0,@employee_plan_start_day) > @seniority_start THEN DATEADD(d,0,@employee_plan_start_day) 
	ELSE @seniority_start 
END

IF @employee_plan_stop_day IS NOT NULL AND DATEDIFF(d,0,@eligible_start) > @employee_plan_stop_day
SET @eligible_start = dbo.GetDateFromDaysPast1900(@employee_plan_stop_day)

SELECT @day_offset = 0, @error_msg = 'Case does not switch PeriodID (' + CAST(@period_id AS varchar(50)) + ')'

IF @seconds % 3600 = 0
	SELECT @note = @seconds / 3600
ELSE
	SELECT @note = CAST((@seconds / 3600.0) AS numeric(9,2))

SELECT @note = @note + ' hr'

IF @seconds != 3600 SELECT @note = @note + 's'

SELECT @note2 = 'Resets to ' + @note

SELECT @note = 'Earns ' + @note 

SELECT @note = @note + ' ' + G.[Period] FROM LeaveRatePeriod P
INNER JOIN Period G ON P.PeriodID = @period_id AND P.GroupID = G.PeriodID

DECLARE @wk0 datetime
SELECT @wk0 = CONVERT(datetime, '20031228', 112) -- Sunday dec 28 2003 is the reference day for biweekly calculations

DECLARE @dayOfWeek int, @wk int

DECLARE @seniority_begins datetime

SELECT @seniority_begins = dbo.GetDateFromDaysPast1900(@seniority_begins_day)


DECLARE @month int, @day int, @year int
DECLARE @start_date datetime, @stop_date datetime, @temp datetime, @d datetime, @period_start datetime
SELECT @start_date = dbo.GetDateFromDaysPast1900(@start_day), @stop_date = dbo.GetDateFromDaysPast1900(@stop_day)
SELECT @d = @start_date

-- First incident
IF @period_id=49154
BEGIN

/*DECLARE @t nvarchar(500)
SET @t = 's:' + CAST(dateadd(d,0,@start_day) as varchar(11)) + ' ps:' + CAST(@plan_seniority_start as varchar(11)) + ' e:' + CAST(@eligible_start as varchar(11))
RAISERROR(@t,16,1)*/

	DECLARE @total_seconds int --, @first_adjustment int
	
	-- Find first ever leave (@day). Find one year past last ever leave (@d)
	SELECT @day = MIN([Day past 1900]), @d = DATEADD(d, 0, MAX([Day past 1900]) + 367) FROM dbo.vwEmployeeLeaveApproved A
	WHERE EmployeeID=@employee_id AND ([Extended Type Mask] & @type_id) != 0
	
	SET @temp  = DATEADD(d, 0, @day)
	IF @d IS NULL SET @d = DATEADD(year, 3, GETDATE())
	
	-- Special case: leave occured before any plan started
	IF NOT EXISTS(SELECT * FROM dbo.EmployeeLeavePlan WHERE EmployeeID=@employee_id AND [Start Day past 1900] < @employee_plan_start_day) AND @day IS NOT NULL AND @day < @employee_plan_start_day
	BEGIN
		INSERT EmployeeLeaveEarned(EmployeeID, TypeID, Seconds, [Day past 1900], [PPE Day past 1900], Note, [Auto]) 
		SELECT @employee_id, @type_id, @seconds, @employee_plan_start_day, @employee_plan_start_day, @note2, 1

		SET @temp = DATEADD(year, 1, @temp)
		IF @temp > @d RETURN
		
		SELECT @total_seconds = ISNULL(SUM(Seconds), 0) FROM dbo.vwEmployeeLeaveApproved A
		WHERE EmployeeID=@employee_id AND ([Extended Type Mask] & @type_id) != 0 AND [Date] < @temp -- <= @temp DATEADD(d, @first_adjustment, @temp)
		--SET @first_adjustment = 0

		INSERT EmployeeLeaveEarned(EmployeeID, TypeID, Seconds, [Day past 1900], [PPE Day past 1900], Note, [Auto]) 
		SELECT @employee_id, @type_id, @seconds - @total_seconds, DATEDIFF(d, 0, @temp), DATEDIFF(d, 0, @temp), @note2, 1 WHERE @seconds <> @total_seconds

		SELECT @temp = DATEADD(d,0,MIN([Day past 1900])) FROM dbo.vwEmployeeLeaveApproved A
		WHERE EmployeeID=@employee_id AND ([Extended Type Mask] & @type_id) != 0 AND [Date] > @temp
	END	
	
	-- Iterate through each year until the end of the plan or one year past the last used leave
	IF @stop_date < @d SET @d = @stop_date
	
	IF @day IS NULL SET @temp = DATEADD(d,0,@employee_plan_start_day)


	--SET @first_adjustment = -1
	WHILE @temp IS NOT NULL AND @temp <= @d
	BEGIN
		SELECT @total_seconds = ISNULL(SUM(Seconds), 0) FROM dbo.vwEmployeeLeaveApproved A
		WHERE EmployeeID=@employee_id AND ([Extended Type Mask] & @type_id) != 0 AND [Date] < @temp --<= @temp DATEADD(d, @first_adjustment, @temp)
		--SET @first_adjustment = 0

		IF DATEDIFF(d,0,@temp) >= @employee_plan_start_day
		INSERT EmployeeLeaveEarned(EmployeeID, TypeID, Seconds, [Day past 1900], [PPE Day past 1900], Note, [Auto]) 
		SELECT @employee_id, @type_id, @seconds - @total_seconds, DATEDIFF(d, 0, @temp), DATEDIFF(d, 0, @temp), @note2, 1 WHERE @seconds <> @total_seconds

		SET @temp = DATEADD(year, 1, @temp)
		IF @temp > @d RETURN
		
		SELECT @total_seconds = ISNULL(SUM(Seconds), 0) FROM dbo.vwEmployeeLeaveApproved A
		WHERE EmployeeID=@employee_id AND ([Extended Type Mask] & @type_id) != 0 AND [Date] < @temp -- <= @temp

		IF DATEDIFF(d,0,@temp) >= @employee_plan_start_day
		INSERT EmployeeLeaveEarned(EmployeeID, TypeID, Seconds, [Day past 1900], [PPE Day past 1900], Note, [Auto]) 
		SELECT @employee_id, @type_id, @seconds - @total_seconds, DATEDIFF(d, 0, @temp), DATEDIFF(d, 0, @temp), @note2, 1 WHERE @seconds <> @total_seconds

		SELECT @temp = DATEADD(d,0,MIN([Day past 1900])) FROM dbo.vwEmployeeLeaveApproved A
		WHERE EmployeeID=@employee_id AND ([Extended Type Mask] & @type_id) != 0 AND [Date] > @temp
	END
END

-- Annual accrual (non anniversaries -- except for 18434 and 16383)
ELSE IF @period_id IN (16386, 18434, 22530, 24578, 26626, 28674, 40962, 43010, 45058, 47106)
BEGIN
	DECLARE @current_year int
	SET @current_year = YEAR(@start_date)
	IF @period_id = 22530 EXEC dbo.spGetYearStart @current_year, @month out, @day out
	ELSE IF @period_id = 16386 EXEC dbo.spGetYearStart @current_year, @month out, @day out
	ELSE IF @period_id = 18434 EXEC dbo.spGetYearStart @current_year, @month out, @day out
	ELSE IF @period_id = 24578 EXEC dbo.spGetYearStop @current_year, @month out, @day out
	ELSE IF @period_id = 26626 SELECT @month = [Fiscal Year Start Month], @day = [Fiscal Year Start Day] FROM dbo.Constant
	ELSE IF @period_id = 28674 SELECT @month = [Fiscal Year Start Month], @day = [Fiscal Year Start Day] - 1 FROM dbo.Constant
	ELSE IF @period_id = 40962 SELECT @month = [Operational Year Start Month], @day = [Operational Year Start Day] FROM dbo.Constant
	ELSE IF @period_id = 43010 SELECT @month = [Administrative Year Start Month], @day = [Administrative Year Start Day] FROM dbo.Constant
	ELSE IF @period_id = 45058 SELECT @month = [Operational Year Start Month], @day = [Operational Year Start Day] - 1 FROM dbo.Constant
	ELSE IF @period_id = 47106 SELECT @month = [Administrative Year Start Month], @day = [Administrative Year Start Day] - 1 FROM dbo.Constant
	ELSE RAISERROR(@error_msg,16,1)

	SELECT @temp = dbo.GetDateFromMDY(@month, @day, @current_year)
	IF @period_id = 18434 AND (MONTH(@seniority_begins) <> @month OR DAY(@seniority_begins) <> @day)
	BEGIN
		DECLARE @note3 varchar(50)
		SET @note3 = 'Earns 40 hrs on anniversary ' + cast(@seniority_begins as varchar(7))
		EXEC dbo.spEmployeeLeaveEarnMapMonth 0, 12, @seniority_begins, @start_date, @stop_date, @eligible_start, @employee_id, @type_id, 144000, @note3, 0	
	END
	ELSE IF @period_id = 16386 AND @start_date = @seniority_begins
	BEGIN
		EXEC dbo.spEmployeeLeaveEarnMapMonth 0, 12, @seniority_begins, @start_date, @start_date, @eligible_start, @employee_id, @type_id, @seconds, @note, 0
	END
	/*IF @temp < @start_date
	BEGIN
		SET @current_year = YEAR(@temp) + 1
		IF @period_id = 22530 SET @temp = dbo.GetYearStart(@current_year)
		ELSE IF @period_id = 24578 SET @temp = DATEADD(d,-1,dbo.GetYearStart(@current_year + 1))
		ELSE SET @temp = DATEADD(yy, 1, @temp)
	END*/
	
	WHILE @temp <= @stop_date
	BEGIN
		IF @temp >= @eligible_start AND @temp >= @start_date
		INSERT EmployeeLeaveEarned(EmployeeID, TypeID, Seconds, [Day past 1900], [PPE Day past 1900], Note, [Auto]) 
		VALUES (@employee_id, @type_id, @seconds, DATEDIFF(d, 0, @temp), DATEDIFF(d, 0, @temp), @note, 1) -- Accrual = 1
	
		SET @current_year = YEAR(@temp) + 1
		DECLARE @last_temp datetime
		SET @last_temp = @temp
		IF @period_id IN (22530, 18434, 16386) SET @temp = dbo.GetYearStart(@current_year)
		ELSE IF @period_id = 24578 SET @temp = DATEADD(d,-1,dbo.GetYearStart(@current_year + 1))
		ELSE SET @temp = DATEADD(yy, 1, @temp)
		
		IF @last_temp = @eligible_start AND @temp <= @stop_date AND @eligible_start > @start_date -- first eligible credit
		INSERT EmployeeLeaveEarned(EmployeeID, TypeID, Seconds, [Day past 1900], [PPE Day past 1900], Note, [Auto]) 
		VALUES (@employee_id, @type_id, @seconds, DATEDIFF(d,0,@eligible_start), DATEDIFF(d,0,@eligible_start), @note, 1)

	END
END

-- Seniority Anniversary I : If seniority starts 1/3/00 then credit 1/3/00, 1/3/01, 1/3/02 ..
-- Seniority Anniversary III : If seniority starts 1/3/00 then credit 1/3/01, 1/3/02 ..
-- Seniority Anniversary IV : If seniority starts 1/3/00 then credit 1/2/01, 1/2/02 ..
-- One Time Annual Credit : If seniority starts Jan 3 then credit on 3rd day of month
ELSE IF @period_id IN (30722, 34818, 36866, 20482)
BEGIN
	IF @period_id = 20482
	BEGIN
		SELECT @seniority_begins = DATEADD(d, DAY(@seniority_begins) - DAY(@seniority_start), @seniority_start)
	END
	ELSE
	BEGIN
		IF @period_id <> 30722 SELECT @seniority_begins = DATEADD(yy, 1, @seniority_begins)
		IF @period_id = 36866 SET @day_offset = -1
	END

	EXEC dbo.spEmployeeLeaveEarnMapMonth 0, 12, @seniority_begins, @start_date, @stop_date, @eligible_start, @employee_id, @type_id, @seconds, @note, @day_offset
END

-- Seniority Anniversary II : If seniority starts 1/3/00 then credit 1/3/00, 1/2/01, 1/2/02 ..
ELSE IF @period_id = 32770
BEGIN
	EXEC dbo.spEmployeeLeaveEarnMapMonth2 12, @seniority_begins, @start_date, @stop_date, @eligible_start, @employee_id, @type_id, @seconds, @note
END

-- Seniority Anniversary V (Year 1 Credit) : If seniority starts Jan 3,2000 then credit July 3,2000
ELSE IF @period_id = 51202
BEGIN
	SELECT @seniority_begins = DATEADD(month, 6, @seniority_begins)
	EXEC dbo.spEmployeeLeaveEarnMapMonth2 12, @seniority_begins, @start_date, @stop_date, @eligible_start, @employee_id, @type_id, @seconds, @note
END

/*
-- Seniority Anniversary VI (Year 1 Credit) : If seniority starts Jan 13,2000 then credit July 1,2000
ELSE IF @period_id = 53250
BEGIN
	SELECT @seniority_begins = DATEADD(month, 6, @seniority_begins)
	SELECT @seniority_begins = DATEADD(day, 1 - DAY(@seniority_begins), @seniority_begins)

	EXEC dbo.spEmployeeLeaveEarnMapMonth2 12, @seniority_begins, @start_date, @stop_date, @eligible_start, @employee_id, @type_id, @seconds, @note
END */

-- Semiannually I and II
ELSE IF @period_id IN (53252, 55300)
BEGIN
	IF @period_id = 53252 SELECT @temp = dbo.GetDateFromMDY(1, 1, YEAR(@start_date))
	ELSE SELECT @temp = dbo.GetDateFromMDY(6, 30, YEAR(@start_date))

	IF @temp < @start_date SELECT @temp = DATEADD(m, 6, @temp)
	IF MONTH(@temp) = 12 SELECT @temp = DATEADD(d, 1, @temp) -- takes 12/30 to 12/31

	IF @temp < @start_date SELECT @temp = DATEADD(m, 6, @temp) -- never happens for @period_id = 55300

	SELECT @start_date = @temp

	WHILE @start_date <= @stop_date
	BEGIN
		INSERT EmployeeLeaveEarned(EmployeeID, TypeID, Seconds, [Day past 1900], [PPE Day past 1900], Note, [Auto]) 
		VALUES (@employee_id, @type_id, @seconds, DATEDIFF(d, 0, @start_date), DATEDIFF(d, 0, @start_date), @note, 1)

		SELECT @start_date = DATEADD(m, 6, @start_date) -- adds 6 months
		IF MONTH(@start_date) = 12 SELECT @start_date = DATEADD(d, 1, @start_date) -- takes 12/30 to 12/31
	END
END

-- Every 6 Months of Seniority I : If seniority starts 1/3/00 then credit 1/3/00, 7/3/00, 1/3/01 ..
-- Every 6 Months of Seniority III : If seniority starts 1/3/00 then credit 7/3/00, 1/3/01 ..
-- Every 6 Months of Seniority IV : If seniority starts 1/3/00 then credit 7/2/00, 1/2/01 ..
ELSE IF @period_id IN (57348, 61444, 63492)
BEGIN
	SELECT @month = CASE WHEN @period_id = 57348 THEN 0 ELSE 6 END
	IF @period_id = 63492 SELECT @day_offset = -1

	EXEC dbo.spEmployeeLeaveEarnMapMonth @month, 6, @seniority_begins, @start_date, @stop_date, @eligible_start, @employee_id, @type_id, @seconds, @note, @day_offset
END

-- Jan 2, Aug 2
ELSE IF @period_id=65540
BEGIN
	SELECT @temp = dbo.GetDateFromMDY(1, 2, YEAR(@start_date)), @month=7
	IF @temp < @start_date SELECT @temp = dbo.GetDateFromMDY(8, 2, YEAR(@start_date)), @month=5
	IF @temp < @start_date SELECT @temp = dbo.GetDateFromMDY(1, 2, YEAR(@start_date) + 1), @month=7
	SELECT @start_date = @temp

	WHILE @start_date <= @stop_date
	BEGIN
		INSERT EmployeeLeaveEarned(EmployeeID, TypeID, Seconds, [Day past 1900], [PPE Day past 1900], Note, [Auto]) 
		VALUES (@employee_id, @type_id, @seconds, DATEDIFF(d, 0, @start_date), DATEDIFF(d, 0, @start_date), @note, 1)

		SELECT @start_date = DATEADD(m, @month, @start_date) -- adds 5 or 7 months
		SELECT @month=CASE @month WHEN 5 THEN 7 ELSE 5 END
	END
END

-- Every 6 Months of Seniority II : If seniority starts 1/3/00 then credit 1/3/00, 7/2/00, 1/2/01 ..
ELSE IF @period_id = 59396
BEGIN
	EXEC dbo.spEmployeeLeaveEarnMapMonth2 6, @seniority_begins, @start_date, @stop_date, @eligible_start, @employee_id, @type_id, @seconds, @note
END


--Bimonthly I : 1,1, 3/1, 5/1, 7/1, 9/1, 11/1
--Bimonthly II : 2/28|29, 4/30,  6/30, 8/31, 10/31, 12/31
ELSE IF @period_id IN (90120, 92168)
BEGIN
	SELECT @temp = dbo.GetDateFromMDY(1, 1, YEAR(@start_date))
	IF @period_id = 92168 SELECT @temp = DATEADD(d, -1, @temp)

	SELECT @month = 0
	WHILE DATEADD(m, @month, @temp) < @start_date
	BEGIN
		SELECT @month = @month + 2
	END

	SELECT @start_date = DATEADD(m, @month, @temp)
	WHILE @start_date <= @stop_date
	BEGIN
		INSERT EmployeeLeaveEarned(EmployeeID, TypeID, Seconds, [Day past 1900], [PPE Day past 1900], Note, [Auto]) 
		VALUES (@employee_id, @type_id, @seconds, DATEDIFF(d, 0, @start_date), DATEDIFF(d, 0, @start_date), @note, 1)

		SELECT @month = @month + 2
		SELECT @start_date = DATEADD(m, @month, @temp)
	END
END

-- Every 2 Months of Seniority I : If seniority starts 1/3 then credit 1/3, 3/3, 5/3 ..
-- Every 2 Months of Seniority III : If seniority starts 1/3 then credit 3/3, 5/3 ..
-- Every 2 Months of Seniority IV : If seniority starts 1/3 then credit 3/2, 5/2 ..
ELSE IF @period_id IN (94216, 98312, 100360)
BEGIN
	SELECT @month = CASE WHEN @period_id = 94216 THEN 0 ELSE 2 END
	IF @period_id = 100360 SELECT @day_offset = -1

	EXEC dbo.spEmployeeLeaveEarnMapMonth @month, 2, @seniority_begins, @start_date, @stop_date, @eligible_start, @employee_id, @type_id, @seconds, @note, @day_offset
END

--Every 2 Months of Seniority II : If seniority starts 1/3 then credit 1/3, 3/2, 5/2 ..
ELSE IF @period_id = 96264
BEGIN
	EXEC dbo.spEmployeeLeaveEarnMapMonth2 2, @seniority_begins, @start_date, @stop_date, @eligible_start, @employee_id, @type_id, @seconds, @note
END

--Quarterly I : Jan 1,Apr 1,Jul 1,Oct 1
--Quarterly II : Mar 31,Jun 30,Sep 30,Dec 31
--Quarterly III : Jan 1,Mar 1,Jul 1,Oct 1
ELSE IF @period_id IN (281600, 283648, 293888)
BEGIN
	SELECT @temp = dbo.GetDateFromMDY(1, 1, YEAR(@start_date))
	IF @period_id = 283648 SELECT @temp = DATEADD(d, -1, @temp)

	SELECT @month = 0
	WHILE DATEADD(m, @month, @temp) < @start_date
	BEGIN
		IF @period_id = 293888 AND @month % 12 = 0 SET @month = @month + 2
		ELSE IF @period_id = 293888 AND @month % 12 = 2 SET @month = @month + 4
		ELSE SET @month = @month + 3
	END

	SELECT @start_date = DATEADD(m, @month, @temp)
	WHILE @start_date <= @stop_date
	BEGIN
		INSERT EmployeeLeaveEarned(EmployeeID, TypeID, Seconds, [Day past 1900], [PPE Day past 1900], Note, [Auto]) 
		VALUES (@employee_id, @type_id, @seconds, DATEDIFF(d, 0, @start_date), DATEDIFF(d, 0, @start_date), @note, 1)
		
		IF @period_id = 293888 AND @month % 12 = 0 SET @month = @month + 2
		ELSE IF @period_id = 293888 AND @month % 12 = 2 SET @month = @month + 4
		ELSE SET @month = @month + 3

		SELECT @start_date = DATEADD(m, @month, @temp)
	END
END


-- Every 3 Months of Seniority I
-- Every 3 Months of Seniority III
-- Every 3 Months of Seniority IV
ELSE IF @period_id IN (285696, 289792, 291840)
BEGIN
	SELECT @month = CASE WHEN @period_id = 285696 THEN 0 ELSE 3 END
	IF @period_id = 291840 SELECT @day_offset = -1

	EXEC dbo.spEmployeeLeaveEarnMapMonth @month, 3, @seniority_begins, @start_date, @stop_date, @eligible_start, @employee_id, @type_id, @seconds, @note, @day_offset
END

--Every 3 Months of Seniority II : If seniority starts Jan 3 then credit Apr 3, Jul 3, Oct 3
ELSE IF @period_id = 287744
BEGIN
	EXEC dbo.spEmployeeLeaveEarnMapMonth2 3, @seniority_begins, @start_date, @stop_date, @eligible_start, @employee_id, @type_id, @seconds, @note
END

-- 126992 1st of each month
-- 129040 31st
-- 131088 28th
-- 141328 15th
-- 143376 16th
-- 145424 30th
ELSE IF @period_id IN (126992, 129040, 131088, 141328, 143376, 145424)
BEGIN
	SELECT @month = MONTH(@d), @year=YEAR(@d),
		@day = CASE WHEN @period_id = 126992 THEN 1
			WHEN @period_id = 129040 THEN 31
			WHEN @period_id = 131088 THEN 28
			WHEN @period_id = 141328 THEN 15
			WHEN @period_id = 143376 THEN 16
			WHEN @period_id = 145424 THEN 30
		END


		SELECT @ineligible_seconds = 0, @period_start = DATEADD(d,1,dbo.AddMonthsToDY(@month - 1, @day, @year))
		--DELETE EmployeeLeaveEarned WHERE EmployeeID = @employee_id AND TypeID = @type_id AND [Day past 1900] >= DATEDIFF(d,0,@period_start) AND [Auto] = 1 -- Accrual = 1

		SELECT @d = dbo.AddMonthsToDY(@month, @day, @year)
		IF @d >= @plan_seniority_start AND (@flags & 1) = 1 -- Prorate first period
		BEGIN
			SET @period_stop = dbo.AddMonthsToDY(@month, @day, @year)
			SELECT @d = CASE WHEN @period_stop < @stop_date THEN @period_stop ELSE @stop_date END, @day_offset = DATEDIFF(d, 0, @period_stop)
			IF (POWER(2, MONTH(@d) - 1) & @exclude_month_mask) = 0 EXEC dbo.spEmployeeLeaveEarnSuspend @employee_id, @type_id, @period_start, @period_stop, @plan_seniority_start, @d, @eligible_start, @day_offset, @seconds, @rounding_seconds, @note, @ineligible_seconds out

			SET @month = @month + 1
		END
		ELSE IF @start_date > @d
		BEGIN
			SET @month = @month + 1
		END

		
		SELECT @d = dbo.AddMonthsToDY(@month, @day, @year)
		WHILE @d <= @stop_date
		BEGIN
			SELECT @period_start = DATEADD(d,1,dbo.AddMonthsToDY(@month - 1, @day, @year)), @day_offset = DATEDIFF(D, 0, @d)

			IF (POWER(2, MONTH(@d) - 1) & @exclude_month_mask) = 0 EXEC dbo.spEmployeeLeaveEarnSuspend @employee_id, @type_id, @period_start, @d, @period_start, @d, @eligible_start, @day_offset, @seconds, @rounding_seconds, @note, @ineligible_seconds out
			SET @month = @month + 1
			SELECT @d = dbo.AddMonthsToDY(@month, @day, @year)
		END
		
		IF @d = @stop_date 
		BEGIN
			SELECT @period_start = dbo.AddMonthsToDY(@month - 1, @day + 1, @year), @day_offset = DATEDIFF(D, 0, @d)
			IF (POWER(2, MONTH(@d) - 1) & @exclude_month_mask) = 0 EXEC dbo.spEmployeeLeaveEarnSuspend @employee_id, @type_id, @period_start, @d, @period_start, @d, @eligible_start, @day_offset, @seconds, @rounding_seconds, @note, @ineligible_seconds out
		END
		ELSE IF (@flags & 4) = 4 AND @stop_date < @d -- Prorate last period
		BEGIN
			SELECT @period_start = DATEADD(d,1,dbo.AddMonthsToDY(@month - 1, @day, @year)), @day_offset = DATEDIFF(D, 0, @stop_date)
			IF (POWER(2, MONTH(@d) - 1) & @exclude_month_mask) = 0 EXEC dbo.spEmployeeLeaveEarnSuspend @employee_id, @type_id, @period_start, @d, @period_start, @stop_date, @eligible_start, @day_offset, @seconds, @rounding_seconds, @note, @ineligible_seconds out
		END

END

-- Every Month of Seniority I : If seniority starts 1/3 then credit 1/3, 2/3, 3/3 ..
-- Every Month of Seniority III : If seniority starts 1/3 then credit 2/3, 3/3 ..
-- Every Month of Seniority IV : If seniority starts 1/3 then credit 2/2, 3/2 ..
ELSE IF @period_id IN (133136, 137232, 139280)
BEGIN
	SELECT @month = CASE WHEN @period_id = 133136 THEN 0 ELSE 1 END
	IF @period_id = 139280 SELECT @day_offset = -1

	EXEC dbo.spEmployeeLeaveEarnMapMonth @month, 1, @seniority_begins, @start_date, @stop_date, @eligible_start, @employee_id, @type_id, @seconds, @note, @day_offset

END

-- Every Month of Seniority II : If seniority starts 1/3 then credit 1/3, 2/2, 3/2 ..
ELSE IF @period_id = 135184
BEGIN
	EXEC dbo.spEmployeeLeaveEarnMapMonth2 1, @seniority_begins, @start_date, @stop_date, @eligible_start, @employee_id, @type_id, @seconds, @note
END
-- 178208 10th and 25th
-- 176160 5th and 20th
-- 163872 1st 15th
-- 165920 1st 16th
-- 167968 14th 28th
-- 170016 15th 28th
-- 172064 15th 30th
-- 174112 15th 31st
-- 180256 11th 27th
ELSE IF @period_id IN (163872, 165920, 167968, 170016, 172064, 174112, 176160, 178208, 180256)
BEGIN
	DECLARE @d1 int, @d2 int

	IF @period_id = 163872 SELECT @d1 = 1, @d2 = 15
	ELSE IF @period_id = 165920 SELECT @d1 = 1, @d2 = 16
	ELSE IF @period_id = 167968 SELECT @d1 = 14, @d2 = 28
	ELSE IF @period_id = 170016 SELECT @d1 = 15, @d2 = 28
	ELSE IF @period_id = 172064 SELECT @d1 = 15, @d2 = 30
	ELSE IF @period_id = 174112 SELECT @d1 = 15, @d2 = 31
	ELSE IF @period_id = 176160 SELECT @d1 = 5, @d2 = 20
	ELSE IF @period_id = 178208 SELECT @d1 = 10, @d2 = 25
	ELSE IF @period_id = 180256 SELECT @d1 = 11, @d2 = 27
	
	ELSE RAISERROR(@error_msg,16,1)
	
	SELECT @period_stop = dbo.fnGetEndOfSemiMonthlyPeriod(@start_date, 0, @d1, @d2), @ineligible_seconds  = 0

	IF @period_stop >= @plan_seniority_start AND (@flags & 1) = 1 -- Prorate first period
	BEGIN
		SELECT @period_start = dbo.fnGetBeginningOfSemiMonthlyPeriod(@d, 0, @d1, @d2), @day_offset = DATEDIFF(d, 0, @period_stop)
		SELECT @d = CASE WHEN @period_stop < @stop_date THEN @period_stop ELSE @stop_date END, @day_offset = DATEDIFF(d, 0, @period_stop)
		EXEC dbo.spEmployeeLeaveEarnSuspend @employee_id, @type_id, @period_start, @period_stop, @plan_seniority_start, @d, @eligible_start, @day_offset, @seconds, @rounding_seconds, @note, @ineligible_seconds out
		SET @d = dbo.fnGetEndOfSemiMonthlyPeriod(@start_date, 16, @d1, @d2)
	END
	ELSE
	BEGIN
		SET @d = dbo.fnGetEndOfSemiMonthlyPeriod(@start_date, 0, @d1, @d2)
	END
	

	WHILE @d <= @stop_date
	BEGIN
		SELECT @period_start = dbo.fnGetBeginningOfSemiMonthlyPeriod(@d, 0, @d1, @d2), @day_offset = DATEDIFF(d, 0, @d)
		EXEC dbo.spEmployeeLeaveEarnSuspend @employee_id, @type_id, @period_start, @d, @period_start, @d, @eligible_start, @day_offset, @seconds, @rounding_seconds, @note, @ineligible_seconds out

		SET @d = dbo.fnGetEndOfSemiMonthlyPeriod(@d, 1, @d1, @d2)
	END

	/*IF @d = @stop_date 
	BEGIN
		SELECT @period_start = dbo.AddMonthsToDY(@month - 1, @day + 1, @year), @day_offset = DATEDIFF(D, 0, @d)
		EXEC dbo.spEmployeeLeaveEarnSuspend @employee_id, @type_id, @period_start, @d, @period_start, @d, @eligible_start, @day_offset, @seconds, @rounding_seconds, @note, @ineligible_seconds out
	END
	ELSE*/ 

	IF (@flags & 4) = 4 AND @stop_date < @d -- Prorate last period
	BEGIN
		SELECT @period_start = dbo.fnGetBeginningOfSemiMonthlyPeriod(@d, 0, @d1, @d2), @day_offset = DATEDIFF(d, 0, @stop_date)
		EXEC dbo.spEmployeeLeaveEarnSuspend @employee_id, @type_id, @period_start, @d, @period_start, @stop_date, @eligible_start, @day_offset, @seconds, @rounding_seconds, @note, @ineligible_seconds out
	END
	
END

-- Biweekly
ELSE IF @period_id IN (200768, 202816, 204864, 206912, 208960, 211008, 213056,
	215104, 217152, 219200, 221248, 223296, 225344, 227392)
BEGIN
	SELECT @dayOfWeek = CASE @period_id 
		WHEN 200768 THEN 0
		WHEN 202816 THEN 1
		WHEN 204864 THEN 2
		WHEN 206912 THEN 3
		WHEN 208960 THEN 4
		WHEN 211008 THEN 5
		WHEN 213056 THEN 6

		WHEN 215104 THEN 7
		WHEN 217152 THEN 8
		WHEN 219200 THEN 9
		WHEN 221248 THEN 10
		WHEN 223296 THEN 11
		WHEN 225344 THEN 12
		ELSE 13
	END
		
	SELECT @wk = DATEDIFF(wk, @wk0, @start_date) / 2
	SELECT @temp = DATEADD(wk, @wk * 2, @wk0)
	SELECT @temp = DATEADD(d, @dayOfWeek, @temp)

	IF @temp < @start_date SELECT @temp = DATEADD(wk, 2, @temp)
	

	SET @ineligible_seconds = 0
	WHILE @temp <= @stop_date
	BEGIN
		IF (@flags & 1) = 1 AND @seniority_begins > DATEADD(wk, -2, @temp) SET @prorated_seconds = dbo.fnProrateTime(@seconds, 10, @seniority_begins, @temp)
		ELSE SET @prorated_seconds = @seconds

		IF @temp < @eligible_start SET @ineligible_seconds = @ineligible_seconds + @prorated_seconds
		ELSE
		BEGIN
			-- SET @eligible_seconds = @prorated_seconds + @ineligible_seconds

	
			--INSERT EmployeeLeaveEarned(EmployeeID, TypeID, Seconds, [Day past 1900], [PPE Day past 1900], Note, [Auto]) 
			--VALUES (@employee_id, @type_id, @eligible_seconds, DATEDIFF(d, 0, @temp), DATEDIFF(d, 0, @temp), @note, 1)

			DECLARE @credit_day int
			SELECT @period_start =DATEADD(d, -13, @temp), @credit_day = DATEDIFF(d,0,@temp)
	
			EXEC dbo.spEmployeeLeaveEarnSuspend @employee_id, @type_id, 
				@period_start, @temp, 
				@period_start, @temp, 
				@eligible_start, 
				@credit_day, 
				@seconds, -- @eligible_seconds,
				@rounding_seconds,
				@note, @ineligible_seconds out
			
			-- IF @ineligible_seconds > 0 SET @ineligible_seconds = 0
		END
		SELECT @temp = DATEADD(wk, 2, @temp)
	END	

END

-- Every 2 Weeks of Seniority I : If seniority starts 1/3 then credit 1/3, 1/17, 1/31 ..
-- Every 2 Weeks of Seniority III : If seniority starts 1/3 then credit 1/17, 1/31 ..
-- Every 2 Weeks of Seniority IV : If seniority starts 1/3 then credit 1/16, 1/30 ..
ELSE IF @period_id IN (229440, 233536, 235584)
BEGIN
	IF @period_id <> 229440 SELECT @seniority_begins = DATEADD(wk, 2, @seniority_begins)
	IF @period_id = 100360 SELECT @seniority_begins = DATEADD(d, -1, @seniority_begins)

	EXEC dbo.spEmployeeLeaveEarnMapWeek 2, @seniority_begins, @start_date, @stop_date, @employee_id, @type_id, @seconds, @note 
END

-- Every 2 Weeks of Seniority II : If seniority starts 1/3 then credit 1/3, 1/16, 1/30 ..
ELSE IF @period_id = 231488
BEGIN
	EXEC dbo.spEmployeeLeaveEarnMapWeek2 2, @seniority_begins, @start_date, @stop_date, @employee_id, @type_id, @seconds, @note 
END

-- Every week
ELSE IF @period_id IN (258176, 260224, 262272, 264320, 266368, 268416, 270464)
BEGIN
	SELECT @dayOfWeek = CASE @period_id 
		WHEN 258176 THEN 0
		WHEN 260224 THEN 1
		WHEN 262272 THEN 2
		WHEN 264320 THEN 3
		WHEN 266368 THEN 4
		WHEN 268416 THEN 5
		ELSE 6
	END
		
	SELECT @wk = DATEDIFF(wk, @wk0, @start_date)
	SELECT @temp = DATEADD(wk, @wk, @wk0)
	SELECT @temp = DATEADD(d, @dayOfWeek, @temp)

	IF @temp < @start_date SELECT @temp = DATEADD(wk, 1, @temp)
	
	SET @ineligible_seconds = 0
	WHILE @temp <= @stop_date
	BEGIN
		IF (@flags & 1) = 1 AND @seniority_begins > DATEADD(wk, -1, @temp) SET @prorated_seconds = dbo.fnProrateTime(@seconds, 5, @seniority_begins, @temp)
		ELSE SET @prorated_seconds = @seconds

		IF @temp < @eligible_start SET @ineligible_seconds = @ineligible_seconds + @prorated_seconds
		ELSE
		BEGIN
			SELECT @eligible_seconds = @prorated_seconds + @ineligible_seconds

			INSERT EmployeeLeaveEarned(EmployeeID, TypeID, Seconds, [Day past 1900], [PPE Day past 1900], Note, [Auto]) 
			VALUES (@employee_id, @type_id, @eligible_seconds, DATEDIFF(d, 0, @temp), DATEDIFF(d, 0, @temp), @note, 1)

			IF @ineligible_seconds > 0 SET @ineligible_seconds = 0
		END

		SELECT @temp = DATEADD(wk, 1, @temp)
	END	
END
	
-- Every Week of Seniority I : If seniority starts 1/3 then credit 1/3, 1/10, 1/17 ..
-- Every Week of Seniority III : If seniority starts 1/3 then credit 1/10, 1/17 ..
-- Every Week of Seniority IV : If seniority starts 1/3 then credit 1/9, 1/16 ..
ELSE IF @period_id IN (272512, 276608, 278656)
BEGIN
	IF @period_id <> 272512 SELECT @seniority_begins = DATEADD(wk, 1, @seniority_begins)
	IF @period_id = 278656 SELECT @seniority_begins = DATEADD(d, -1, @seniority_begins)

	EXEC dbo.spEmployeeLeaveEarnMapWeek 2, @seniority_begins, @start_date, @stop_date, @employee_id, @type_id, @seconds, @note 
END
-- Every Week of Seniority II : If seniority starts 1/3 then credit 1/3, 1/9, 1/16 ..
ELSE IF @period_id = 274560
BEGIN
	EXEC dbo.spEmployeeLeaveEarnMapWeek2 1, @seniority_begins, @start_date, @stop_date, @employee_id, @type_id, @seconds, @note 
END

ELSE RAISERROR(@error_msg,16,1)
GO

-- Accrues leave for all employee leave plans on/after @start_day
-- Does NOT update EmployeeLeaveUnused
ALTER PROC dbo.spEmployeeLeaveAccrue
	@employee_id int,
	@type_id int,
	@start_day int
AS
DECLARE @seconds int
DECLARE @period_id int
--DECLARE @start2_month int
--DECLARE @stop_month int
DECLARE @effective_start datetime
DECLARE @effective_stop datetime
DECLARE @seniority_start datetime
DECLARE @seniority_stop datetime
DECLARE @limit_id int
DECLARE @infinity datetime
DECLARE @infinity_day int
DECLARE @seniority_day int, @seniority datetime
DECLARE @start2 datetime, @stop datetime, @start datetime, @eligible_start datetime
DECLARE @start2_day int, @stop_day int, @exclude_month_mask int
DECLARE @max_year int, @flags int, @rounding_seconds int, @employee_plan_start_day int, @employee_plan_stop_day int

SET NOCOUNT ON

SELECT @max_year = [Leave Seer Years] FROM dbo.Constant
SELECT @infinity = DATEADD(yy, @max_year, GETDATE()), @start = dbo.GetDateFromDaysPast1900(@start_day)
SELECT @seniority_day = [Seniority Begins Day past 1900] FROM Employee WHERE EmployeeID = @employee_id
SELECT @seniority = dbo.GetDateFromDaysPast1900(@seniority_day), @infinity_day = DATEDIFF(d, 0, @infinity)

DECLARE emplan_cursor  CURSOR LOCAL FAST_FORWARD
FOR SELECT EP.[Effective Seconds],
		EP.PeriodID,
		--LR.[Start Month],
		--LR.[Stop Month],
		[Effective Start] = dbo.GetDateFromDaysPast1900(EP.[Start Day past 1900]),
		[Seniority Start] = DATEADD(m, EP.[Start Month], @seniority),
		[Effective Stop] = ISNULL(dbo.GetDateFromDaysPast1900(EP.[Stop Day past 1900]), @infinity),
		[Seniority Stop] = CASE WHEN EP.[Stop Month] > 4000000 THEN @infinity ELSE DATEADD(d, -1, DATEADD(m, EP.[Stop Month] + 1, @seniority)) END,
		[Eligible Start] = DATEADD(m, EP.[Ineligible Months], @seniority),
		Flags = EP.Flags,
		[Prorate Accrual Rounding Seconds],
		EP.[Start Day past 1900],
		EP.[Stop Day past 1900],
		EP.ExcludeMonthMask
	FROM dbo.vwEmployeeLeavePlanLeaveRate EP WHERE
		EP.EmployeeID = @employee_id AND EP.TypeID = @type_id AND 
		EP.[Start Day past 1900] <= @infinity_day AND (EP.[Stop Day past 1900] IS NULL OR EP.[Stop Day past 1900] >= @start)
	ORDER BY EP.[Start Day past 1900], EP.[Start Month]

DELETE EmployeeLeaveEarned WHERE EmployeeID = @employee_id AND TypeID = @type_id AND [Day past 1900] >= @start_day AND [Auto] = 1 -- Accrual = 1

OPEN emplan_cursor
FETCH NEXT FROM emplan_cursor INTO @seconds, @period_id, @effective_start, @seniority_start, @effective_stop, @seniority_stop, @eligible_start, @flags, @rounding_seconds, @employee_plan_start_day, @employee_plan_stop_day, @exclude_month_mask
WHILE @@FETCH_STATUS = 0
BEGIN
	SELECT @start2 = CASE WHEN @seniority_start > @effective_start THEN @seniority_start ELSE @effective_start END
	SELECT @stop = CASE WHEN @seniority_stop < @effective_stop THEN @seniority_stop ELSE @effective_stop END
	
	IF @start2 < @start SELECT @start2 = @start
	IF @stop >= @infinity SELECT @stop = @infinity, @flags = @flags & 0x7FFFFFFB -- Caps stop date and turns off tail-end prorating if stop=infinity

	SELECT @start2_day = DATEDIFF(dd, 0, @start2), @stop_day = DATEDIFF(dd, 0, @stop)

	IF @start2_day <= @stop_day EXEC dbo.spEmployeeLeaveEarnMapFromPlan @employee_id, @start2_day, @stop_day, @period_id, @type_id, @seconds, @seniority_start, @seniority_stop, @employee_plan_start_day, @employee_plan_stop_day, @eligible_start, @flags, @seniority_day, @rounding_seconds, @exclude_month_mask

	FETCH NEXT FROM emplan_cursor INTO @seconds, @period_id, @effective_start, @seniority_start, @effective_stop, @seniority_stop, @eligible_start, @flags, @rounding_seconds, @employee_plan_start_day, @employee_plan_stop_day, @exclude_month_mask
END
CLOSE emplan_cursor
DEALLOCATE emplan_cursor
GO
ALTER PROC dbo.spLeaveRatePeriodList
	@group_id int,
	@payroll bit
AS
SET NOCOUNT ON

IF @group_id = 2 OR @group_id = 64 SELECT * INTO #Temp FROM LeaveRatePeriod WHERE GroupID = @group_id AND (@payroll IS NULL OR Payroll = @payroll) ORDER BY [Order]

IF @group_id = 2
BEGIN
	DECLARE @i int
	DECLARE @y int

	SELECT @i = 0, @y = YEAR(GETDATE())
	WHILE @i < 3
	BEGIN
		IF @i > 0 UPDATE #Temp SET Example = Example + '; ' WHERE PeriodID IN (43010, 26626, 40962, 47106, 28674, 45058)

		UPDATE #Temp SET Example = Example + CAST(dbo.GetDateFromMDY(C.[Administrative Year Start Month], C.[Administrative Year Start Day], @y) as varchar(11))
		FROM #Temp CROSS JOIN Constant C WHERE #Temp.PeriodID = 43010

		UPDATE #Temp SET Example = Example + CAST(dbo.GetDateFromMDY(C.[Fiscal Year Start Month], C.[Fiscal Year Start Day], @y) as varchar(11))
		FROM #Temp CROSS JOIN Constant C WHERE #Temp.PeriodID = 26626

		UPDATE #Temp SET Example = Example + CAST(dbo.GetDateFromMDY(C.[Operational Year Start Month], C.[Operational Year Start Day], @y) as varchar(11))
		FROM #Temp CROSS JOIN Constant C WHERE #Temp.PeriodID = 40962

		UPDATE #Temp SET Example = Example + CAST(dbo.GetDateFromMDY(C.[Administrative Year Start Month], C.[Administrative Year Start Day] - 1, @y) as varchar(11))
		FROM #Temp CROSS JOIN Constant C WHERE #Temp.PeriodID = 47106

		UPDATE #Temp SET Example = Example + CAST(dbo.GetDateFromMDY(C.[Fiscal Year Start Month], C.[Fiscal Year Start Day] - 1, @y) as varchar(11))
		FROM #Temp CROSS JOIN Constant C WHERE #Temp.PeriodID = 28674

		UPDATE #Temp SET Example = Example + CAST(dbo.GetDateFromMDY(C.[Operational Year Start Month], C.[Operational Year Start Day] - 1, @y) as varchar(11))
		FROM #Temp CROSS JOIN Constant C WHERE #Temp.PeriodID = 45058

		SELECT @y = @y + 1, @i = @i + 1
	END
	UPDATE #Temp SET Example = Example + ' ..' WHERE PeriodID IN (43010, 26626, 40962, 47106, 28674, 45058)

	SELECT * FROM #Temp
END
ELSE IF @group_id = 64
BEGIN
	IF @payroll = 1 OR @payroll IS NULL
	BEGIN
		DECLARE @wk0 datetime, @wk int
		SELECT @wk0 = CONVERT(datetime, '20040101', 112)
		SELECT @wk0 = DATEADD(d,0 - DATEPART(dw, @wk0), @wk0)

		-- Go to first occurence of the week, with ref point 01/01/04
		SELECT @wk = DATEDIFF(wk, @wk0, GETDATE()) / 2
		SELECT @wk0 = DATEADD(wk, @wk * 2, @wk0)

		CREATE TABLE #P(PeriodID int, DD int)

		INSERT #P
		SELECT PeriodID, DD = CASE WHEN PeriodID < 215104 THEN 0 ELSE 7 END + Weekday
		FROM LeaveRatePeriod WHERE Weekday > 0

		UPDATE #Temp SET Example = '' WHERE Payroll = 1
		
		SELECT @wk = 0
		WHILE @wk < 4
		BEGIN
			UPDATE #Temp SET Example = Example + CASE WHEN LEN([Example]) = 0 THEN '' ELSE ', ' END + CAST(DATEADD(d, #P.DD, @wk0) AS char(6))
			FROM #Temp INNER JOIN #P ON #Temp.PeriodID = #P.PeriodID

			SELECT @wk = @wk + 1, @wk0 = DATEADD(wk, 2, @wk0)
		END
	END

	SELECT * FROM #Temp
END
ELSE
SELECT * FROM LeaveRatePeriod WHERE GroupID = @group_id AND (@payroll IS NULL OR Payroll = @payroll) ORDER BY [Order]
GO
GRANT EXEC ON dbo.spLeaveSummarizeUnused2 TO public
GO
IF OBJECT_ID('dbo.spEmployeeCompensationDelete') IS NOT NULL DROP PROC dbo.spEmployeeCompensationDelete
GO
CREATE PROC dbo.spEmployeeCompensationDelete
	@compensation_id int
AS
DECLARE @employee_id int
DECLARE @authorized bit

SET NOCOUNT ON

SELECT @employee_id = EmployeeID FROM EmployeeCompensation WHERE CompensationID = @compensation_id
EXEC dbo.spPermissionInsureForCurrentUserOnPerson @employee_id, 1024, 8, @authorized out
IF @authorized = 1
BEGIN
	DECLARE @e int

	BEGIN TRAN

	UPDATE Employee SET LastCompensationID=NULL WHERE EmployeeID=@employee_id
	SELECT @e=@@ERROR

	IF @e=0 
	BEGIN
		DELETE EmployeeCompensation WHERE CompensationID = @compensation_id
		SELECT @e=@@ERROR
	END

	IF @e=0 COMMIT TRAN
	ELSE ROLLBACK TRAN
END
GO
GRANT EXEC ON dbo.spEmployeeCompensationDelete TO public
GO
IF OBJECT_id('dbo.spLeaveSummarizeUnused3') IS NOT NULL DROP PROC dbo.spLeaveSummarizeUnused3
GO
CREATE PROC dbo.spLeaveSummarizeUnused3
	@batch_id int,
	@type_id int,
	@start int,
	@stop int,
	@days bit,
	@authorized bit out
AS
SET NOCOUNT ON

EXEC dbo.spPermissionGetOnPeopleForCurrentUser2 @batch_id, 10003
DELETE TempX WHERE BatchID = @batch_id AND (X & 1) = 0
SELECT @authorized = CASE WHEN @@ROWCOUNT = 0 THEN 1 ELSE 0 END

SELECT EmployeeID=X.[ID],
[Previous Day] = (
	SELECT MAX(U.[Day past 1900]) FROM EmployeeLeaveUnused U WHERE U.[Day past 1900] < @start AND U.EmployeeID = X.[ID] AND U.TypeID = @type_id
),
[Accumulated Day] = (
	SELECT MAX(U.[Day past 1900]) FROM EmployeeLeaveUnused U WHERE U.[Day past 1900] <= @stop AND U.EmployeeID = X.[ID] AND U.TypeID = @type_id
),
[Seconds per Unit] = CAST(CASE WHEN @days=0 THEN 3600 ELSE S.[Effective Seconds per Day] END AS numeric(9,4))
INTO #T
FROM dbo.TempX X
INNER JOIN dbo.Employee E ON X.BatchID=@batch_id AND X.[ID]=E.EmployeeID
INNER JOIN dbo.vwEmployeeEffectiveSecondsPerDay S ON E.EmployeeID=S.EmployeeID


DELETE TempX WHERE BatchID = @batch_id OR DATEDIFF(hh, Created, GETDATE()) > 1

SELECT #T.EmployeeID, Employee=P.[List As],
Used = (
		ISNULL((SELECT SUM(U.Seconds) FROM vwEmployeeLeaveUsedItemApproved U WHERE U.EmployeeID=#T.EmployeeID AND (U.[Extended Type Mask] & @type_id) != 0 AND U.[Day past 1900] BETWEEN @start AND @stop), 0)  
	) / #T.[Seconds per Unit],
Earned = ISNULL((
	SELECT SUM(E.Seconds) FROM vwEmployeeLeaveEarned E WHERE E.Seconds > 0 AND E.EmployeeID=#T.EmployeeID AND E.TypeID=@type_id AND E.[Day past 1900] BETWEEN @start AND @stop
), 0) / #T.[Seconds per Unit],
Previous = ISNULL(PREV.Unused + PREV.[Limit Seconds], 0) / #T.[Seconds per Unit],
Accumulated = ISNULL(A.Unused /*+ CASE WHEN A.[Day past 1900]=@stop THEN A.[Limit Seconds] ELSE 0 END */, 0) / #T.[Seconds per Unit]
FROM dbo.vwPersonListAs P
INNER JOIN #T ON P.PersonID=#T.EmployeeID 
LEFT JOIN EmployeeLeaveUnused PREV ON PREV.EmployeeID=#T.EmployeeID AND PREV.TypeID=@type_id AND PREV.[Day past 1900]=#T.[Previous Day]
LEFT JOIN EmployeeLeaveUnused A ON A.EmployeeID=#T.EmployeeID AND A.TypeID=@type_id AND A.[Day past 1900]=#T.[Accumulated Day]
ORDER BY P.[List As]
GO
GRANT EXEC ON dbo.spLeaveSummarizeUnused3 To public
GO
ALTER PROCEDURE dbo.spEmployeeChecklistNewHireList
	@employee_id int = NULL,
	@batch_id int = NULL,
	@check_id int = NULL,
	@completed bit = NULL,
	@completed_start int = -2147483648,
	@completed_stop int = 2147483647,
	@sort_by int = 0, -- 1 employee, 2 check item name, 4 date completed
	@hidden bit = NULL out
AS
DECLARE @authorized bit

SET NOCOUNT ON

IF @batch_id IS NULL
BEGIN
	SELECT @batch_id = RAND() * 2147483647
	INSERT TempX(BatchID,[ID]) SELECT @batch_id, @employee_id WHERE @employee_id IS NOT NULL
END

EXEC dbo.spPermissionInsureForCurrentUserOnPeople @batch_id, 1048577, 1, @hidden out

SELECT C.*, [Permission Mask]=X.X FROM vwEmployeeCheckListNewHire C
INNER JOIN TempX X ON X.BatchID=@batch_id AND X.[ID]=C.EmployeeID AND 
(@check_id IS NULL OR C.CheckID=@check_id) AND
(@completed IS NULL OR @completed = C.[Was Completed]) AND
([Completed Day past 1900] IS NULL OR C.[Completed Day past 1900] BETWEEN @completed_start AND @completed_stop)
ORDER BY 
CASE @sort_by WHEN 1 THEN C.[Employee Name] WHEN 2 THEN C.[Check] ELSE '' END,
CASE @sort_by WHEN 4 THEN C.[Completed Day past 1900] ELSE 0 END,
CASE @sort_by WHEN 4 THEN C.[Employee Name] ELSE '' END,
[Order]

DELETE TempX WHERE BatchID=@batch_id OR DATEDIFF(hour,Created,GETDATE())>1
GO
IF OBJECT_id('dbo.spEmployeeListNSF') IS NOT NULL DROP PROC dbo.spEmployeeListNSF
GO
CREATE PROC dbo.spEmployeeListNSF
	@batch_id int,
	@nsf bit,
	@authorized bit = 1 OUT -- legacy
AS
SET NOCOUNT ON

EXEC dbo.spCustomFieldClean

DELETE X FROM TempX X
INNER JOIN Employee E ON X.BatchID=@batch_id AND X.[ID]=E.EmployeeID AND @nsf IS NOT NULL AND E.NSF != @nsf

SELECT T.* FROM vwEmployeeSecure T
INNER JOIN TempX X ON X.BatchID=@batch_id AND X.[ID] = T.EID

DELETE dbo.TempX WHERE BatchID=@batch_id OR DATEDIFF(minute, Created, GETDATE()) > 30
GO
GRANT EXEC ON dbo.spEmployeeListNSF TO public
GO
IF OBJECT_id('dbo.spEmployeeListAdvancePay') IS NOT NULL DROP PROC dbo.spEmployeeListAdvancePay
GO
CREATE PROC dbo.spEmployeeListAdvancePay
	@batch_id int,
	@advance_pay bit,
	@authorized bit =1 OUT
AS
SET NOCOUNT ON

EXEC dbo.spCustomFieldClean

DELETE X FROM TempX X
INNER JOIN Employee E ON X.BatchID=@batch_id AND X.[ID]=E.EmployeeID AND @advance_pay IS NOT NULL AND E.[Advance Pay] != @advance_pay

UPDATE X SET Y = (SELECT TOP 1 I.InvoiceID FROM dbo.Invoice I WHERE I.EmployeeID=X.[ID] ORDER BY I.[Created Day past 1900] DESC, I.InvoiceID DESC) FROM TempX X WHERE X.BatchID=@batch_id

SELECT T.*,
[Last InvoiceID] = X.Y,
[Last Invoice Total] = I.Total,
[Last Invoice Created] = dbo.GetDateFromDaysPast1900(I.[Created Day past 1900]),
[Last Invoice Due] = dbo.GetDateFromDaysPast1900(I.[Due Day past 1900])
FROM dbo.vwEmployeeSecure T
INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID] = T.EID
LEFT JOIN dbo.Invoice I ON X.Y=I.InvoiceID

DELETE dbo.TempX WHERE BatchID=@batch_id OR DATEDIFF(minute, Created, GETDATE()) > 30
GO
GRANT EXEC ON dbo.spEmployeeListAdvancePay TO public
GO
IF OBJECT_ID('dbo.spTaskList01') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spTaskList01 AS'
GO
--************************************** (1) ************************************************ Reviews
ALTER PROC dbo.spTaskList01 @due_start int, @due_stop int, @today0 int, @todaym4 int, @todaym7 int, @today datetime, @yesterday datetime AS INSERT #Tasks
SELECT R.[Reminder Type], R.ReminderTypeID, R.OwnerEmployeeID, RegardingPersonID = E.EmployeeID, [Text] = 'Review scheduled. ' +  R.[Regarding Full Name] + dbo.fnPrefixSuffixIfNotEmpty(' (', R.[Employee Number], ')', '''s') + ' next review is ' + CAST(dbo.GetDateFromDaysPast1900([Next Performance Review Day past 1900]) AS varchar(6)),
Due = dbo.GetDateFromDaysPast1900(E.[Next Performance Review Day past 1900]), R.Urgent, R.[Owner Initials], [Regarding Initials] =  R.[Regarding Initials],
R.Owner ,Regarding = R.Regarding, TaskID = NULL, CreatorEmployeeID = NULL, [Created Day after 1900] = NULL, ItemID = NULL, Completed  = NULL, [Creator Initials] = 'System', Creator = 'System',
R.[To Lower], R.CC, Created = CAST(NULL AS datetime), E.[Employee Number], E.EmployeeNumberNumeric
FROM #R R
INNER JOIN dbo.Employee E ON R.ReminderTypeID = 1 AND E.EmployeeID = R.EmployeeID AND E.[Next Performance Review Day past 1900] IS NOT NULL AND E.[Active Employee] = 1 AND E.ManagerID IS NOT NULL AND
dbo.DoRaysIntersect(E.[Next Performance Review Day past 1900] - R.Days, E.[Next Performance Review Day past 1900],  @due_start, @due_stop) = 1
GO
IF OBJECT_ID('dbo.spTaskList02') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spTaskList02 AS'
GO
--************************************** (2) ************************************************
ALTER PROC dbo.spTaskList02 @due_start int, @due_stop int, @today0 int, @todaym4 int, @todaym7 int, @today datetime, @yesterday datetime AS INSERT #Tasks
SELECT R.[Reminder Type], R.ReminderTypeID, R.OwnerEmployeeID, RegardingPersonID = R.EmployeeID, [Text] = 'No review scheduled. ' +  R.[Regarding Full Name] + dbo.fnPrefixSuffixIfNotEmpty(' (', R.[Employee Number], ')', '') + ' has no reviews scheduled', Due = GETDATE(), R.Urgent, R.[Owner Initials], R.[Regarding Initials],
R.Owner, R.Regarding, TaskID = NULL, CreatorEmployeeID = NULL, [Created Day after 1900] = NULL, ItemID = NULL, Completed  = NULL, [Creator Initials] = 'System', Creator = 'System',
R.[To Lower], R.CC, Created = CAST(NULL AS datetime), R.[Employee Number], R.EmployeeNumberNumeric
FROM #R R
INNER JOIN dbo.Employee E ON R.ReminderTypeID = 2 AND E.EmployeeID = R.EmployeeID AND R.[Active Employee] = 1 AND E.[Next Performance Review Day past 1900] IS NULL AND E.ManagerID IS NOT NULL
GO
IF OBJECT_ID('dbo.spTaskList03') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spTaskList03 AS'
GO
--************************************** (3) ************************************************
ALTER PROC dbo.spTaskList03 @due_start int, @due_stop int, @today0 int, @todaym4 int, @todaym7 int, @today datetime, @yesterday datetime AS INSERT #Tasks
SELECT R.[Reminder Type], R.ReminderTypeID, R.OwnerEmployeeID, RegardingPersonID = P.PersonID, [Text] = 'Certification expires. ' +  R.[Regarding Full Name] + dbo.fnPrefixSuffixIfNotEmpty(' (', R.[Employee Number], ')', '''s') + ' ' + C.Certification + ' expires on '+ CAST(dbo.GetDateFromDaysPast1900([Expires Day past 1900]) AS varchar(6)),  Due = dbo.GetDateFromDaysPast1900(P.[Expires Day past 1900]), R.Urgent, R.[Owner Initials], R.[Regarding Initials],
R.Owner ,R.Regarding, TaskID = NULL, CreatorEmployeeID = NULL, [Created Day after 1900] = NULL, ItemID = NULL, Completed  = NULL, [Creator Initials] = 'System', Creator = 'System',
R.[To Lower], R.CC, Created = CAST(NULL AS datetime), R.[Employee Number], R.EmployeeNumberNumeric
FROM #R R
INNER JOIN dbo.PersonXCertification P ON R.ReminderTypeID = 3 AND P.PersonID = R.EmployeeID AND R.[Active Employee] = 1 AND P.[Expires Day past 1900] IS NOT NULL AND dbo.DoRaysIntersect(P.[Expires Day past 1900] - R.Days, P.[Expires Day past 1900], @due_start, @due_stop) =  1
INNER JOIN dbo.Certification C ON P.CertificationID = C.CertificationID
GO
IF OBJECT_ID('dbo.spTaskList04') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spTaskList04 AS'
GO
--************************************** (4) ************************************************
ALTER PROC dbo.spTaskList04 @due_start int, @due_stop int, @today0 int, @todaym4 int, @todaym7 int, @today datetime, @yesterday datetime AS INSERT #Tasks
SELECT R.[Reminder Type], R.ReminderTypeID, R.OwnerEmployeeID, RegardingPersonID = P.PersonID, [Text] = 'Renew I9 status . ' +  R.[Regarding Full Name] + dbo.fnPrefixSuffixIfNotEmpty(' (', R.[Employee Number], ')', '''s') + ' is scheduled to be renewed on '+ CAST(dbo.GetDateFromDaysPast1900([Renew I9 Status Day past 1900]) AS  varchar(6)), Due = dbo.GetDateFromDaysPast1900(P.[Renew I9 Status Day past 1900]), R.Urgent, R.[Owner Initials], R.[Regarding Initials],
R.Owner ,R.Regarding, TaskID = NULL, CreatorEmployeeID = NULL, [Created Day after 1900] = NULL, ItemID = NULL, Completed  = NULL, [Creator Initials] = 'System', Creator = 'System',
R.[To Lower], R.CC, Created = CAST(NULL AS datetime), R.[Employee Number], R.EmployeeNumberNumeric
FROM #R R
INNER JOIN dbo.PersonX P ON R.ReminderTypeID = 4 AND P.PersonID = R.EmployeeID AND R.[Active Employee] = 1 AND P.[Renew I9 Status Day past 1900] IS NOT NULL AND
	dbo.DoRaysIntersect(P.[Renew I9 Status Day past 1900] - R.Days, P.[Renew I9 Status Day past 1900], @due_start, @due_stop) =  1
GO
IF OBJECT_ID('dbo.spTaskList05') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spTaskList05 AS'
GO
--************************************** (5) ************************************************
ALTER PROC dbo.spTaskList05 @due_start int, @due_stop int, @today0 int, @todaym4 int, @todaym7 int, @today datetime, @yesterday datetime AS INSERT #Tasks
SELECT R.[Reminder Type], R.ReminderTypeID, R.OwnerEmployeeID, RegardingPersonID = P.PersonID, [Text] = 'Visa expires. ' +  R.[Regarding Full Name] + dbo.fnPrefixSuffixIfNotEmpty(' (', R.[Employee Number], ')', '''s') + ' visa expires '+ CAST(dbo.GetDateFromDaysPast1900([Visa Expires Day past 1900]) AS varchar(6)), Due =  dbo.GetDateFromDaysPast1900(P.[Visa Expires Day past 1900]), R.Urgent, R.[Owner Initials], R.[Regarding Initials],
R.Owner ,R.Regarding, TaskID = NULL, CreatorEmployeeID = NULL, [Created Day after 1900] = NULL, ItemID = NULL, Completed  = NULL, [Creator Initials] = 'System', Creator = 'System',
R.[To Lower], R.CC, Created = CAST(NULL AS datetime), R.[Employee Number], R.EmployeeNumberNumeric
FROM #R R
INNER JOIN dbo.PersonX P ON R.ReminderTypeID = 5 AND P.PersonID = R.EmployeeID AND R.[Active Employee] = 1 AND P.[Visa Expires Day past 1900] IS NOT NULL AND
	dbo.DoRaysIntersect(P.[Visa Expires Day past 1900] - R.Days, P.[Visa Expires Day past 1900], @due_start, @due_stop) = 1
GO
IF OBJECT_ID('dbo.spTaskList06') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spTaskList06 AS'
GO
--************************************** (6) ************************************************
ALTER PROC dbo.spTaskList06 @due_start int, @due_stop int, @today0 int, @todaym4 int, @todaym7 int, @today datetime, @yesterday datetime AS INSERT #Tasks
SELECT R.[Reminder Type], R.ReminderTypeID, R.OwnerEmployeeID, RegardingPersonID = P.PersonID, [Text] = 'Passport expires. ' +  R.[Regarding Full Name] + dbo.fnPrefixSuffixIfNotEmpty(' (', R.[Employee Number], ')', '''s') + ' passport expires '+ CAST(dbo.GetDateFromDaysPast1900([Passport Expires Day past 1900]) AS varchar(6)), Due =  dbo.GetDateFromDaysPast1900(P.[Passport Expires Day past 1900]), R.Urgent, R.[Owner Initials], R.[Regarding Initials],
R.Owner ,R.Regarding, TaskID = NULL, CreatorEmployeeID = NULL, [Created Day after 1900] = NULL, ItemID = NULL, Completed  = NULL, [Creator Initials] = 'System', Creator = 'System',
R.[To Lower], R.CC, Created = CAST(NULL AS datetime), R.[Employee Number], R.EmployeeNumberNumeric
FROM #R R
INNER JOIN dbo.PersonX P ON R.ReminderTypeID = 6 AND P.PersonID = R.EmployeeID AND R.[Active Employee] = 1 AND P.[Passport Expires Day past 1900] IS NOT NULL AND dbo.DoRaysIntersect(P.[Passport Expires Day past 1900] - R.Days, P.[Passport Expires Day past 1900], @due_start, @due_stop)  = 1
GO
IF OBJECT_ID('dbo.spTaskList07') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spTaskList07 AS'
GO
--************************************** (7) ************************************************
ALTER PROC dbo.spTaskList07 @due_start int, @due_stop int, @today0 int, @todaym4 int, @todaym7 int, @today datetime, @yesterday datetime AS INSERT #Tasks
SELECT R.[Reminder Type], R.ReminderTypeID, R.OwnerEmployeeID, RegardingPersonID = P.PersonID, [Text] = 'Driver license expires. ' +  R.[Regarding Full Name] + dbo.fnPrefixSuffixIfNotEmpty(' (', R.[Employee Number], ')', '''s') + ' driver''s license expires '+ CAST(dbo.GetDateFromDaysPast1900([Driver License Expires Day past 1900]) AS  varchar(6)), Due = dbo.GetDateFromDaysPast1900(P.[Driver License Expires Day past 1900]), R.Urgent, R.[Owner Initials], R.[Regarding Initials],
R.Owner ,R.Regarding, TaskID = NULL, CreatorEmployeeID = NULL, [Created Day after 1900] = NULL,  ItemID = NULL, Completed = NULL, [Creator Initials] = 'System', Creator = 'System',
R.[To Lower], R.CC, Created = CAST(NULL AS datetime), R.[Employee Number], R.EmployeeNumberNumeric
FROM #R R
INNER JOIN dbo.PersonX P ON R.ReminderTypeID = 7 AND P.PersonID = R.EmployeeID AND R.[Active Employee] = 1 AND P.[Driver License Expires Day past 1900] IS NOT NULL AND
	dbo.DoRaysIntersect(P.[Driver License Expires Day past 1900] - R.Days, P.[Driver License Expires Day past 1900], @due_start,  @due_stop) = 1
GO
IF OBJECT_ID('dbo.spTaskList08') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spTaskList08 AS'
GO
--************************************** (8) ************************************************
ALTER PROC dbo.spTaskList08 @due_start int, @due_stop int, @today0 int, @todaym4 int, @todaym7 int, @today datetime, @yesterday datetime AS INSERT #Tasks
SELECT R.[Reminder Type], R.ReminderTypeID, R.OwnerEmployeeID, RegardingPersonID = P.PersonID, [Text] = 'Driver insurance expires. '  +  R.[Regarding Full Name] + dbo.fnPrefixSuffixIfNotEmpty(' (', R.[Employee Number], ')', '''s') + ' insurance expires  '+ CAST(dbo.GetDateFromDaysPast1900([Driver Insurance Expires Day past 1900]) AS  varchar(6)), Due = dbo.GetDateFromDaysPast1900(P.[Driver Insurance Expires Day past 1900]), R.Urgent, R.[Owner Initials], R.[Regarding Initials],
R.Owner ,R.Regarding, TaskID = NULL, CreatorEmployeeID = NULL, [Created Day after 1900] = NULL, ItemID = NULL, Completed  = NULL, [Creator Initials] = 'System', Creator = 'System',
R.[To Lower], R.CC, Created = CAST(NULL AS datetime), R.[Employee Number], R.EmployeeNumberNumeric
FROM #R R
INNER JOIN dbo.PersonX P ON R.ReminderTypeID = 8 AND P.PersonID = R.EmployeeID AND R.[Active Employee] = 1 AND P.[Driver Insurance Expires Day past 1900] IS NOT NULL AND
	dbo.DoRaysIntersect(P.[Driver Insurance Expires Day past 1900] - R.Days, P.[Driver Insurance Expires Day past 1900],  @due_start, @due_stop) = 1
GO
IF OBJECT_ID('dbo.spTaskList09') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spTaskList09 AS'
GO
--************************************** (9) ************************************************
ALTER PROC dbo.spTaskList09 @due_start int, @due_stop int, @today0 int, @todaym4 int, @todaym7 int, @today datetime, @yesterday datetime AS INSERT #Tasks
SELECT R.[Reminder Type], ReminderTypeID = 9, R.OwnerEmployeeID, RegardingPersonID = P.PersonID, [Text] = 'Birthday. ' +  R.[Regarding Full Name] + dbo.fnPrefixSuffixIfNotEmpty(' (', R.[Employee Number], ')', '''s') + ' birthday is '+ CAST(dbo.GetDateFromDaysPast1900([DOB Day past 1900]) AS varchar(6)), Due  =DATEADD(yyyy,DATEPART(yyyy,GETDATE())-DATEPART(yyyy,dbo.GetDateFromDaysPast1900(P.[DOB Day past 1900])),dbo.GetDateFromDaysPast1900(P.[DOB Day past 1900])), R.Urgent, R.[Owner Initials],  R.[Regarding Initials],
R.Owner ,R.Regarding, TaskID = NULL, CreatorEmployeeID = NULL, [Created Day after 1900] = NULL, ItemID = NULL, Completed  = NULL, [Creator Initials] = 'System', Creator = 'System',
R.[To Lower], R.CC, Created = CAST(NULL AS datetime), R.[Employee Number], R.EmployeeNumberNumeric
FROM #R R
INNER JOIN dbo.PersonX P ON R.ReminderTypeID = 9 AND P.PersonID = R.EmployeeID AND R.[Active Employee] = 1 AND P.[DOB Day past 1900] IS NOT NULL AND
(
	(MONTH(dbo.GetBirthdayFromDOB(P.[DOB Day past 1900], GETDATE())) * 100 + DAY(dbo.GetBirthdayFromDOB(P.[DOB Day past 1900], GETDATE()))) BETWEEN
	MONTH(GETDATE()) * 100 + DAY(GETDATE()) AND
	MONTH(DATEADD(d, R.Days, GETDATE())) * 100 + DAY(DATEADD(d, R.Days, GETDATE()))
)
GO
IF OBJECT_ID('dbo.spTaskList10') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spTaskList10 AS'
GO
--************************************** (10) ************************************************
ALTER PROC dbo.spTaskList10 @due_start int, @due_stop int, @today0 int, @todaym4 int, @todaym7 int, @today datetime, @yesterday datetime AS INSERT #Tasks
SELECT R.[Reminder Type], R.ReminderTypeID, R.OwnerEmployeeID, RegardingPersonID = P.PersonID, [Text] = 'License expires. ' +  R.[Regarding Full Name] + dbo.fnPrefixSuffixIfNotEmpty(' (', R.[Employee Number], ')', '''s') + ' ' + L.License + ' license expires on ' + CAST(dbo.GetDateFromDaysPast1900([Expires Day past 1900]) AS  varchar(6)), Due = dbo.GetDateFromDaysPast1900(P.[Expires Day past 1900]), R.Urgent, R.[Owner Initials], R.[Regarding Initials],
R.Owner ,R.Regarding, TaskID = NULL, CreatorEmployeeID = NULL, [Created Day after 1900] = NULL, ItemID = NULL, Completed  = NULL, [Creator Initials] = 'System', Creator = 'System',
R.[To Lower], R.CC, Created = CAST(NULL AS datetime), R.[Employee Number], R.EmployeeNumberNumeric
FROM #R R
INNER JOIN dbo.PersonXLicense P ON R.ReminderTypeID = 10 AND P.PersonID = R.EmployeeID AND R.[Active Employee] = 1 AND P.[Expires Day past 1900] IS NOT NULL AND dbo.DoRaysIntersect(P.[Expires Day past 1900] - R.Days, P.[Expires Day past 1900], @due_start, @due_stop) = 1 
INNER JOIN dbo.License L ON P.LicenseID = L.LicenseID
GO
IF OBJECT_ID('dbo.spTaskList11') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spTaskList11 AS'
GO
--************************************** (11) ************************************************
ALTER PROC dbo.spTaskList11 @due_start int, @due_stop int, @today0 int, @todaym4 int, @todaym7 int, @today datetime, @yesterday datetime AS INSERT #Tasks
SELECT R.[Reminder Type], R.ReminderTypeID, R.OwnerEmployeeID, RegardingPersonID = U.EmployeeID, [Text] = 'Approve or Deny Leave. '  +  R.[Regarding Full Name] + dbo.fnPrefixSuffixIfNotEmpty(' (', R.[Employee Number], ')', '') + ' requested leave starting ' + CAST(dbo.GetDateFromDaysPast1900(U.[Start Day past 1900]) AS varchar(6)) + ', but the request has not been approved or denied.', Due = dbo.GetDateFromDaysPast1900(U.[Start Day past 1900] + 1), R.Urgent, R.[Owner Initials], R.[Regarding Initials],
R.Owner ,R.Regarding, TaskID = NULL, CreatorEmployeeID = NULL, [Created Day after 1900] = NULL, ItemID = NULL, Completed  = NULL, [Creator Initials] = 'System', Creator = 'System',
R.[To Lower], R.CC, Created = CAST(NULL AS datetime), R.[Employee Number], R.EmployeeNumberNumeric
FROM #R R
INNER JOIN dbo.EmployeeLeaveUsed U ON R.ReminderTypeID = 11 AND U.EmployeeID = R.EmployeeID AND U.[Status] = 1 AND R.[Active Employee] = 1
GO
IF OBJECT_ID('dbo.spTaskList12') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spTaskList12 AS'
GO
--************************************** (12) ************************************************
ALTER PROC dbo.spTaskList12 @due_start int, @due_stop int, @today0 int, @todaym4 int, @todaym7 int, @today datetime, @yesterday datetime AS INSERT #Tasks
SELECT R.[Reminder Type], R.ReminderTypeID, R.OwnerEmployeeID, RegardingPersonID = U.EmployeeID, [Text] = 'Returning from Leave. ' +  R.[Regarding Full Name] + dbo.fnPrefixSuffixIfNotEmpty(' (', R.[Employee Number], ')', '') + ' last day on leave is ' + CAST(dbo.GetDateFromDaysPast1900(U.[Stop Day past 1900]) AS varchar(6)) + '.', Due =  dbo.GetDateFromDaysPast1900(U.[Stop Day past 1900]), R.Urgent, R.[Owner Initials], R.[Regarding Initials],
R.Owner ,R.Regarding, TaskID = NULL, CreatorEmployeeID = NULL, [Created Day after 1900] = NULL, ItemID = NULL, Completed  = NULL, [Creator Initials] = 'System', Creator = 'System',
R.[To Lower], R.CC, Created = CAST(NULL AS datetime), R.[Employee Number], R.EmployeeNumberNumeric
FROM #R R
INNER JOIN dbo.EmployeeLeaveUsed U ON R.ReminderTypeID = 12 AND U.EmployeeID = R.EmployeeID AND U.[Status] = 2 AND R.[Active Employee] = 2 AND U.[Stop Day past 1900] > @todaym4 AND
	dbo.DoRaysIntersect(U.[Stop Day past 1900] - R.Days, U.[Stop Day past 1900], @due_start, @due_stop) = 1
GO
IF OBJECT_ID('dbo.spTaskList13') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spTaskList13 AS'
GO
--************************************** (13) ************************************************
ALTER PROC dbo.spTaskList13 @due_start int, @due_stop int, @today0 int, @todaym4 int, @todaym7 int, @today datetime, @yesterday datetime AS INSERT #Tasks
SELECT R.[Reminder Type], R.ReminderTypeID, R.OwnerEmployeeID, RegardingPersonID = U.EmployeeID, [Text] = 'Departing for Leave. ' +  R.[Regarding Full Name] + dbo.fnPrefixSuffixIfNotEmpty(' (', R.[Employee Number], ')', '''s') + ' scheduled leave starts ' + CAST(dbo.GetDateFromDaysPast1900(U.[Start Day past 1900]) AS varchar(6)) + '.', Due  = dbo.GetDateFromDaysPast1900(U.[Start Day past 1900]), R.Urgent, R.[Owner Initials], R.[Regarding Initials],
R.Owner ,R.Regarding, TaskID = NULL, CreatorEmployeeID = NULL, [Created Day after 1900] = NULL, ItemID = NULL, Completed  = NULL, [Creator Initials] = 'System', Creator = 'System',
R.[To Lower], R.CC, Created = CAST(NULL AS datetime), R.[Employee Number], R.EmployeeNumberNumeric
FROM #R R
INNER JOIN dbo.EmployeeLeaveUsed U ON R.ReminderTypeID = 13 AND U.EmployeeID = R.EmployeeID AND U.[Status] = 2 AND U.[Start Day past 1900] > @todaym7 AND
dbo.DoRaysIntersect(U.[Start Day past 1900] - R.Days, U.[Start Day past 1900], @due_start, @due_stop) = 1 
GO
IF OBJECT_ID('dbo.spTaskList14A') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spTaskList14A AS'
GO
--************************************** (14A) ************************************************
ALTER PROC dbo.spTaskList14A @due_start int, @due_stop int, @today0 int, @todaym4 int, @todaym7 int, @today datetime, @yesterday datetime AS INSERT #Tasks
SELECT R.[Reminder Type], R.ReminderTypeID, R.OwnerEmployeeID, RegardingPersonID = E.EmployeeID, [Text] =  'Recertification for Ongoing Condition. ' +  R.[Regarding Full Name] + dbo.fnPrefixSuffixIfNotEmpty(' (', R.[Employee Number], ')', '''s') + ' medical recertification is due by ' + CAST(dbo.GetDateFromDaysPast1900([Recertify Condition Day past 1900]) AS varchar(6)) + '.',
Due = dbo.GetDateFromDaysPast1900(E.[Recertify Condition Day past 1900]), R.Urgent, R.[Owner Initials], R.[Regarding Initials],
R.Owner ,R.Regarding, TaskID = NULL, CreatorEmployeeID = NULL, [Created Day after 1900] = NULL, ItemID = NULL, Completed  = NULL, [Creator Initials] = 'System', Creator = 'System',
R.[To Lower], R.CC, Created = CAST(NULL AS datetime), R.[Employee Number], R.EmployeeNumberNumeric
FROM #R R
INNER JOIN dbo.Employee E ON R.ReminderTypeID = 14 AND E.EmployeeID = R.EmployeeID AND R.[Active Employee] = 1 AND E.[Recertify Condition Day past 1900] IS NOT NULL AND dbo.DoRaysIntersect(E.[Recertify Condition Day past 1900] - R.Days, E.[Recertify Condition Day past 1900], @due_start, @due_stop) = 1
GO
IF OBJECT_ID('dbo.spTaskList14B') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spTaskList14B AS'
GO
--************************************** (14B) ************************************************
ALTER PROC dbo.spTaskList14B @due_start int, @due_stop int, @today0 int, @todaym4 int, @todaym7 int, @today datetime, @yesterday datetime AS INSERT #Tasks
SELECT R.[Reminder Type], R.ReminderTypeID, R.OwnerEmployeeID, RegardingPersonID = U.EmployeeID, [Text] = 'Recertification for Ongoing Condition. ' +  R.[Regarding Full Name] + dbo.fnPrefixSuffixIfNotEmpty(' (', R.[Employee Number], ')', '''s') + ' medical recertification is due by ' + CAST(dbo.GetDateFromDaysPast1900(U.[Recertify Day past 1900]) AS varchar(6)) + '.', Due =  dbo.GetDateFromDaysPast1900(U.[Recertify Day past 1900]), R.Urgent, R.[Owner Initials], R.[Regarding Initials],
R.Owner ,R.Regarding, TaskID = NULL, CreatorEmployeeID = NULL, [Created Day after 1900] = NULL, ItemID = NULL, Completed  = NULL, [Creator Initials] = 'System', Creator = 'System',
R.[To Lower], R.CC, Created = CAST(NULL AS datetime), R.[Employee Number], R.EmployeeNumberNumeric
FROM #R R
INNER JOIN dbo.EmployeeLeaveUsed U ON R.ReminderTypeID = 14 AND U.EmployeeID = R.EmployeeID AND R.[Active Employee] = 1 AND U.[Recertify Day past 1900] IS NOT NULL AND dbo.DoRaysIntersect(U.[Recertify Day past 1900] - R.Days, U.[Recertify Day past 1900], @due_start, @due_stop) = 1
GO
IF OBJECT_ID('dbo.spTaskList15') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spTaskList15 AS'
GO
--************************************** (15) ************************************************
ALTER PROC dbo.spTaskList15 @due_start int, @due_stop int, @today0 int, @todaym4 int, @todaym7 int, @today datetime, @yesterday datetime AS INSERT #Tasks
SELECT R.[Reminder Type], ReminderTypeID = 15, R.OwnerEmployeeID, RegardingPersonID = O.EmployeeID, [Text] = 'Anniversary. ' +  R.[Regarding Full Name] + dbo.fnPrefixSuffixIfNotEmpty(' (', O.[Employee Number], ') ', '''s ') + 

	CASE WHEN DATEDIFF(year,dbo.GetDateFromDaysPast1900(O.[Seniority Begins Day past 1900]),GETDATE())=0 THEN 'date of hire'
	ELSE CAST(DATEDIFF(year,dbo.GetDateFromDaysPast1900(O.[Seniority Begins Day past 1900]),GETDATE()) AS varchar(50)) + ' year anniversary'
	END

+ ' is ' + CAST(dbo.GetDateFromDaysPast1900(O.[Seniority Begins Day past 1900]) AS varchar(6)), Due = dbo.GetBirthdayFromDOB(O.[Seniority Begins Day past 1900], GETDATE()), R.Urgent, R.[Owner Initials],  R.[Regarding Initials],
R.Owner ,R.Regarding, TaskID = NULL, CreatorEmployeeID = NULL, [Created Day after 1900] = NULL, ItemID = NULL, Completed  = NULL, [Creator Initials] = 'System', Creator = 'System',
R.[To Lower], R.CC, Created = CAST(NULL AS datetime), R.[Employee Number], R.EmployeeNumberNumeric
FROM #R R
INNER JOIN dbo.Employee O ON R.ReminderTypeID = 15 AND O.EmployeeID = R.EmployeeID AND R.[Active Employee] = 1 AND
(
	(MONTH(dbo.GetBirthdayFromDOB(O.[Seniority Begins Day past 1900], GETDATE())) * 100 + DAY(dbo.GetBirthdayFromDOB(O.[Seniority Begins Day past 1900], GETDATE()))) BETWEEN
	MONTH(GETDATE()) * 100 + DAY(GETDATE()) AND
	MONTH(DATEADD(d, R.Days, GETDATE())) * 100 + DAY(DATEADD(d, R.Days, GETDATE()))
)
GO
IF OBJECT_ID('dbo.spTaskList16') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spTaskList16 AS'
GO
--************************************** (16) ************************************************
ALTER PROC dbo.spTaskList16 @due_start int, @due_stop int, @today0 int, @todaym4 int, @todaym7 int, @today datetime, @yesterday datetime AS INSERT #Tasks
SELECT R.[Reminder Type], ReminderTypeID = 16, R.OwnerEmployeeID, RegardingPersonID = O.EmployeeID, [Text] = 'Hire. ' +  R.[Regarding Full Name] + dbo.fnPrefixSuffixIfNotEmpty(' (', O.[Employee Number], ') ', '''s ') + 
'date of hire is '+ CAST(
	CASE WHEN O.[DOH Day past 1900] IS NULL THEN O.[Seniority Begins] 
	ELSE O.DOH END
AS varchar(6)), 
Due = CASE WHEN O.[DOH Day past 1900] IS NULL THEN O.[Seniority Begins] 
	ELSE O.DOH END, 
R.Urgent, R.[Owner Initials],  R.[Regarding Initials],
R.Owner ,R.Regarding, TaskID = NULL, CreatorEmployeeID = NULL, [Created Day after 1900] = NULL, ItemID = NULL, Completed  = NULL, [Creator Initials] = 'System', Creator = 'System',
R.[To Lower], R.CC, Created = CAST(NULL AS datetime), R.[Employee Number], R.EmployeeNumberNumeric
FROM #R R
INNER JOIN dbo.vwEmployeeOrg O ON R.ReminderTypeID = 16 AND O.EmployeeID = R.EmployeeID AND CASE WHEN O.[DOH Day past 1900] IS NULL THEN O.[Seniority Begins Day past 1900] ELSE O.[DOH Day past 1900] END > @todaym7 AND
dbo.DoRaysIntersect(
	CASE WHEN O.[DOH Day past 1900] IS NULL THEN O.[Seniority Begins Day past 1900] ELSE O.[DOH Day past 1900] END - R.Days, 
	CASE WHEN O.[DOH Day past 1900] IS NULL THEN O.[Seniority Begins Day past 1900] ELSE O.[DOH Day past 1900] END + R.Days, 
	@due_start, 
	@due_stop
) = 1 
GO
IF OBJECT_ID('dbo.spTaskList17') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spTaskList17 AS'
GO
--************************************** (17) ************************************************
ALTER PROC dbo.spTaskList17 @due_start int, @due_stop int, @today0 int, @todaym4 int, @todaym7 int, @today datetime, @yesterday datetime AS INSERT #Tasks
SELECT R.[Reminder Type], ReminderTypeID = 17, R.OwnerEmployeeID, RegardingPersonID = E.EmployeeID, [Text] = 'Termination. ' +  R.[Regarding Full Name] + dbo.fnPrefixSuffixIfNotEmpty(' (', R.[Employee Number], ')', '''s') + ' date of termination is '+ 
CAST(dbo.GetDateFromDaysPast1900(E.[Terminated Day past 1900]) AS varchar(6)), 
Due = dbo.GetDateFromDaysPast1900(E.[Terminated Day past 1900]), 
R.Urgent, R.[Owner Initials],  R.[Regarding Initials],
R.Owner ,R.Regarding, TaskID = NULL, CreatorEmployeeID = NULL, [Created Day after 1900] = NULL, ItemID = NULL, Completed  = NULL, [Creator Initials] = 'System', Creator = 'System',
R.[To Lower], R.CC, Created = CAST(NULL AS datetime), R.[Employee Number], R.EmployeeNumberNumeric
FROM #R R
INNER JOIN dbo.Employee E ON R.ReminderTypeID = 17 AND E.EmployeeID = R.EmployeeID AND E.[Terminated Day past 1900] IS NOT NULL AND E.[Terminated Day past 1900] > @todaym7 AND
dbo.DoRaysIntersect(
	E.[Terminated Day past 1900] - R.Days, 
	E.[Terminated Day past 1900] + R.Days, 
	@due_start, 
	@due_stop
) = 1
GO
IF OBJECT_ID('dbo.spTaskList19') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spTaskList19 AS'
GO
--************************************** (19) ************************************************
ALTER PROC dbo.spTaskList19 @due_start int, @due_stop int, @today0 int, @todaym4 int, @todaym7 int, @today datetime, @yesterday datetime AS INSERT #Tasks
SELECT R.[Reminder Type], R.ReminderTypeID, R.OwnerEmployeeID, RegardingPersonID = P.PersonID, [Text] = 'Training expires. ' +  R.[Regarding Full Name] + dbo.fnPrefixSuffixIfNotEmpty(' (', R.[Employee Number], ') ', '''s ') + T.Training + ' expires on '+ CAST(dbo.GetDateFromDaysPast1900([Expires Day past 1900]) AS varchar(6)),  Due = dbo.GetDateFromDaysPast1900(P.[Expires Day past 1900]), R.Urgent, R.[Owner Initials], R.[Regarding Initials],
R.Owner ,R.Regarding, TaskID = NULL, CreatorEmployeeID = NULL, [Created Day after 1900] = NULL, ItemID = NULL, Completed  = NULL, [Creator Initials] = 'System', Creator = 'System',
R.[To Lower], R.CC, Created = CAST(NULL AS datetime), R.[Employee Number], R.EmployeeNumberNumeric
FROM #R R
INNER JOIN dbo.PersonXTraining P ON R.ReminderTypeID = 19 AND P.PersonID = R.EmployeeID AND R.[Active Employee] = 1 AND P.[Expires Day past 1900] IS NOT NULL AND
	dbo.DoRaysIntersect(P.[Expires Day past 1900] - R.Days, P.[Expires Day past 1900], @due_start, @due_stop) = 1
	
	
	AND NOT EXISTS (
		SELECT * FROM dbo.PersonXTraining P2 WHERE P.PersonID=P2.PersonID AND P.TrainingID=P2.TrainingID AND P2.[Completed Day past 1900] > P.[Expires Day past 1900]
	)
INNER JOIN dbo.Training T ON P.TrainingID = T.TrainingID

INSERT #Tasks
SELECT R.[Reminder Type], R.ReminderTypeID, R.OwnerEmployeeID, RegardingPersonID = P.EmployeeID, [Text] = 'Training expires. ' +  R.[Regarding Full Name] + dbo.fnPrefixSuffixIfNotEmpty(' (', R.[Employee Number], ') ', '''s ') + T.Course + ' expires on '+ CAST(dbo.GetDateFromDaysPast1900([Expires Day past 1900]) AS varchar(6)),  Due = dbo.GetDateFromDaysPast1900(P.[Expires Day past 1900]), R.Urgent, R.[Owner Initials], R.[Regarding Initials],
R.Owner ,R.Regarding, TaskID = NULL, CreatorEmployeeID = NULL, [Created Day after 1900] = NULL, ItemID = NULL, Completed  = NULL, [Creator Initials] = 'System', Creator = 'System',
R.[To Lower], R.CC, Created = CAST(NULL AS datetime), R.[Employee Number], R.EmployeeNumberNumeric
FROM #R R
INNER JOIN dbo.EmployeeCourse P ON R.ReminderTypeID = 19 AND P.EmployeeID = R.EmployeeID AND R.[Active Employee] = 1 AND P.[Expires Day past 1900] IS NOT NULL AND 
dbo.DoRaysIntersect(P.[Expires Day past 1900] - R.[Days], P.[Expires Day past 1900], @due_start, @due_stop) = 1 

	AND NOT EXISTS (
		SELECT * FROM dbo.EmployeeCourseEvent P2 WHERE P.EmployeeCourseID=P2.EmployeeCourseID AND P2.[Completed Day past 1900] >= P.[Expires Day past 1900]
	)
INNER JOIN dbo.Course T ON P.CourseID = T.CourseID
GO
IF OBJECT_ID('dbo.spTaskList18') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spTaskList18 AS'
GO
--************************************** (18) ************************************************
ALTER PROC dbo.spTaskList18 @due_start int, @due_stop int, @today0 int, @todaym4 int, @todaym7 int, @today datetime, @yesterday datetime AS INSERT #Tasks
SELECT R.[Reminder Type], R.ReminderTypeID, R.OwnerEmployeeID, RegardingPersonID = E.EmployeeID, [Text] = 'Yesterday''s timecard may be incomplete. Expected 4 punches: in, lunch out, lunch in, out. ' +  R.[Regarding Full Name] + dbo.fnPrefixSuffixIfNotEmpty(' (', R.[Employee Number], ')', '''s') + ' timecard is incomplete.', Due =  @yesterday, R.Urgent, R.[Owner Initials], R.[Regarding Initials],
R.Owner, R.Regarding, TaskID = NULL, CreatorEmployeeID = NULL, [Created Day after 1900] = NULL, ItemID = NULL, Completed  = NULL, [Creator Initials] = 'System', Creator = 'System',
R.[To Lower], R.CC, Created = CAST(NULL AS datetime), R.[Employee Number], R.EmployeeNumberNumeric
FROM #R R
INNER JOIN dbo.Employee E ON DATEPART(dw,@yesterday) BETWEEN 2 AND 6 AND R.ReminderTypeID = 18 AND E.EmployeeID = R.EmployeeID AND R.[Active Employee] = 1 AND E.Salaried=0 AND E.EmployeeID NOT IN
(
	SELECT DISTINCT EmployeeID FROM dbo.EmployeeTime WHERE [In] BETWEEN @yesterday AND @today AND Seconds > 0 GROUP BY EmployeeID HAVING COUNT(*) >= 2
	UNION
	SELECT DISTINCT EmployeeID FROM dbo.vwEmployeeLeaveApproved WHERE dbo.GetDateFromDaysPast1900([Day past 1900]) = @yesterday
)
GO
IF OBJECT_ID('dbo.spTaskList20') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spTaskList20 AS'
GO
--************************************** (20) ************************************************
-- Waits an hour for the terminals to sync before raising the alert
ALTER PROC dbo.spTaskList20 @due_start int, @due_stop int, @today0 int, @todaym4 int, @todaym7 int, @today datetime, @yesterday datetime AS INSERT #Tasks
SELECT R.[Reminder Type], R.ReminderTypeID, R.OwnerEmployeeID, RegardingPersonID = E.EmployeeID, [Text] = 'Today''s timecard: no in punch for ' +  R.[Regarding Full Name] + dbo.fnPrefixSuffixIfNotEmpty(' (', R.[Employee Number], ').', '.'), Due =  @today, R.Urgent, R.[Owner Initials], R.[Regarding Initials],
R.Owner, R.Regarding, TaskID = NULL, CreatorEmployeeID = NULL, [Created Day after 1900] = NULL, ItemID = NULL, Completed  = NULL, [Creator Initials] = 'System', Creator = 'System',
R.[To Lower], R.CC, Created = CAST(NULL AS datetime), R.[Employee Number], R.EmployeeNumberNumeric
FROM #R R
INNER JOIN dbo.Employee E ON R.ReminderTypeID = 20 AND E.EmployeeID = R.EmployeeID AND R.[Active Employee] = 1 AND E.Salaried=0
INNER JOIN dbo.Shift S ON E.ShiftID = S.ShiftID AND DATEDIFF(second, @today,GETDATE()) > S.[Start Seconds] + 3600 AND dbo.fnIsShiftOnDay(@today0, S.ShiftID, S.[Start Day past 1900], S.[Days On], S.[Days Off], S.DaysOn2, S.DaysOff2)=1 AND E.EmployeeID NOT IN
(
	SELECT DISTINCT EmployeeID FROM EmployeeTime WHERE [In] BETWEEN @today AND DATEADD(d,1,@today)
	UNION
	SELECT DISTINCT EmployeeID FROM dbo.vwEmployeeLeaveApproved WHERE dbo.GetDateFromDaysPast1900([Day past 1900]) = @today
)
LEFT JOIN dbo.HolidayCalculated HC ON E.HolidayPlanID=HC.PlanID AND @today0 BETWEEN HC.A AND HC.B WHERE HC.ItemID IS NULL
GO
IF OBJECT_ID('dbo.spTaskList21') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spTaskList21 AS'
GO
--************************************** (21) ************************************************
ALTER PROC dbo.spTaskList21 @due_start int, @due_stop int, @today0 int, @todaym4 int, @todaym7 int, @today datetime, @yesterday datetime AS INSERT #Tasks

SELECT R.[Reminder Type], R.ReminderTypeID, R.OwnerEmployeeID, RegardingPersonID = E.EmployeeID, [Text] = 'Yesterday''s timecard: no out punch. ' +  R.[Regarding Full Name] + dbo.fnPrefixSuffixIfNotEmpty(' (', R.[Employee Number], ')', '''s') + ' timecard is incomplete.', Due =  @yesterday, R.Urgent, R.[Owner Initials], R.[Regarding Initials],
R.Owner, R.Regarding, TaskID = NULL, CreatorEmployeeID = NULL, [Created Day after 1900] = NULL, ItemID = NULL, Completed  = NULL, [Creator Initials] = 'System', Creator = 'System',
R.[To Lower], R.CC, Created = CAST(NULL AS datetime), R.[Employee Number], R.EmployeeNumberNumeric
FROM #R R
INNER JOIN dbo.Employee E ON DATEPART(dw,@yesterday) BETWEEN 2 AND 6 AND R.ReminderTypeID = 21 AND E.EmployeeID = R.EmployeeID AND R.[Active Employee] = 1 AND E.Salaried=0 AND E.EmployeeID NOT IN
(
	SELECT DISTINCT EmployeeID FROM dbo.vwEmployeeLeaveApproved WHERE dbo.GetDateFromDaysPast1900([Day past 1900]) = @yesterday
) AND E.EmployeeID IN
(
	SELECT DISTINCT EmployeeID FROM EmployeeTime WHERE [In] BETWEEN @yesterday AND @today AND Seconds = 0
)
GO
IF OBJECT_ID('dbo.spTaskList22A') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spTaskList22A AS'
GO
--************************************** (22A) ************************************************
ALTER PROC dbo.spTaskList22A @due_start int, @due_stop int, @today0 int, @todaym4 int, @todaym7 int, @today datetime, @yesterday datetime AS INSERT #Tasks
SELECT R.[Reminder Type], R.ReminderTypeID, R.OwnerEmployeeID, RegardingPersonID = E.EmployeeID, [Text] = 'OT warning: 32+hrs as of Wed. ' +  R.[Regarding Full Name] + dbo.fnPrefixSuffixIfNotEmpty(' (', R.[Employee Number], ')', '''s') + ' may go into OT.', Due =  @yesterday, R.Urgent, R.[Owner Initials], R.[Regarding Initials],
R.Owner, R.Regarding, TaskID = NULL, CreatorEmployeeID = NULL, [Created Day after 1900] = NULL, ItemID = NULL, Completed  = NULL, [Creator Initials] = 'System', Creator = 'System',
R.[To Lower], R.CC, Created = CAST(NULL AS datetime), R.[Employee Number], R.EmployeeNumberNumeric
FROM #R R
INNER JOIN dbo.Employee E ON DATEPART(dw,@today) BETWEEN 4 AND 5 AND R.ReminderTypeID = 22 AND E.EmployeeID = R.EmployeeID AND R.[Active Employee] = 1 AND E.Salaried = 0 AND E.EmployeeID IN
(
	SELECT EmployeeID FROM EmployeeTime WHERE [In] BETWEEN DATEADD(d, -1 - DATEPART(dw,@yesterday),@today) AND DATEADD(d,4 - DATEPART(dw,@yesterday),@today) GROUP BY EmployeeID HAVING SUM(Seconds) >= 32 * 3600
)
GO
IF OBJECT_ID('dbo.spTaskList22B') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spTaskList22B AS'
GO
--************************************** (22B) ************************************************
ALTER PROC dbo.spTaskList22B @due_start int, @due_stop int, @today0 int, @todaym4 int, @todaym7 int, @today datetime, @yesterday datetime AS INSERT #Tasks
SELECT R.[Reminder Type], R.ReminderTypeID, R.OwnerEmployeeID, RegardingPersonID = E.EmployeeID, [Text] = 'OT warning: 40+hrs as of Thurs. ' +  R.[Regarding Full Name] + dbo.fnPrefixSuffixIfNotEmpty(' (', R.[Employee Number], ')', '''s') + ' may go into OT.', Due =  @yesterday, R.Urgent, R.[Owner Initials], R.[Regarding Initials],
R.Owner, R.Regarding, TaskID = NULL, CreatorEmployeeID = NULL, [Created Day after 1900] = NULL, ItemID = NULL, Completed  = NULL, [Creator Initials] = 'System', Creator = 'System',
R.[To Lower], R.CC, Created = CAST(NULL AS datetime), R.[Employee Number], R.EmployeeNumberNumeric
FROM #R R
INNER JOIN dbo.Employee E ON DATEPART(dw,@today) BETWEEN 5 AND 6 AND R.ReminderTypeID = 22 AND E.EmployeeID = R.EmployeeID AND R.[Active Employee] = 1 AND E.Salaried = 0 AND E.EmployeeID IN
(
	SELECT EmployeeID FROM dbo.EmployeeTime WHERE [In] BETWEEN @today - 1 - DATEPART(dw,@yesterday) AND @today + 5 - DATEPART(dw,@yesterday) GROUP BY EmployeeID HAVING SUM(Seconds) >= 40 * 3600
)
GO
IF OBJECT_ID('dbo.spTaskList23') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spTaskList23 AS'
GO
--************************************** (23) ************************************************
ALTER PROC dbo.spTaskList23 @due_start int, @due_stop int, @today0 int, @todaym4 int, @todaym7 int, @today datetime, @yesterday datetime AS INSERT #Tasks

SELECT R.[Reminder Type], R.ReminderTypeID, R.OwnerEmployeeID, RegardingPersonID = E.EmployeeID, [Text] = 'Late in-punch. ' +  R.[Regarding Full Name] + dbo.fnPrefixSuffixIfNotEmpty(' (', R.[Employee Number], ')', '') + ' punched in at ' +
	(SELECT TOP 1 SUBSTRING(CONVERT(VARCHAR(50),[In],100), 13, 7) FROM EmployeeTime WHERE EmployeeID=E.EmployeeID AND [In] BETWEEN @today AND @today + 1) + ' (' +
	CAST((
		SELECT COUNT(*) FROM EmployeeTime ET2
		WHERE ET2.EmployeeID=E.EmployeeID AND ET2.[In] BETWEEN @today - 29 AND @today + 1 AND dbo.fnIsShiftOnDay(DATEDIFF(day,0,ET2.[In]), E.ShiftID, S.[Start Day past 1900], S.[Days On], S.[Days Off], S.DaysOn2, S.DaysOff2)=1 AND
		DATEDIFF(second, DATEDIFF(day,0,ET2.[In]), ET2.[In]) > S.[Start Seconds] + S.[Grace Seconds]
		AND NOT EXISTS
		(
			SELECT DISTINCT A.EmployeeID FROM dbo.vwEmployeeLeaveApproved A WHERE A.EmployeeID=ET2.EmployeeID AND A.[Day past 1900] = DATEDIFF(day,0,ET2.[In])
		)
		AND NOT EXISTS
		(
			SELECT * FROM EmployeeTime ET3 WHERE ET3.EmployeeID=ET2.EmployeeID AND DATEDIFF(day,0,ET2.[In])=DATEDIFF(day,0,ET3.[In]) AND ET3.[In] < ET2.[In]
		)
		
	)  AS varchar(50))
	+ ' late punche(s) in 30 days).'
, Due =  @today, R.Urgent, R.[Owner Initials], R.[Regarding Initials],
R.Owner, R.Regarding, TaskID = NULL, CreatorEmployeeID = NULL, [Created Day after 1900] = NULL, ItemID = NULL, Completed  = NULL, [Creator Initials] = 'System', Creator = 'System',
R.[To Lower], R.CC, Created = CAST(NULL AS datetime), R.[Employee Number], R.EmployeeNumberNumeric
FROM #R R
INNER JOIN dbo.Employee E ON R.ReminderTypeID = 23 AND E.EmployeeID = R.EmployeeID AND R.[Active Employee] = 1 AND E.Salaried = 0
INNER JOIN dbo.Shift S ON E.ShiftID = S.ShiftID AND
(
	dbo.fnIsShiftOnDay(@today0, E.ShiftID, S.[Start Day past 1900], S.[Days On], S.[Days Off], S.DaysOn2, S.DaysOff2)=1
) AND E.EmployeeID IN
(
	SELECT DISTINCT EmployeeID FROM dbo.EmployeeTime WHERE [In] BETWEEN @today AND @today + 1
) AND E.EmployeeID NOT IN
(
	SELECT DISTINCT EmployeeID FROM dbo.vwEmployeeLeaveApproved WHERE [Day past 1900] = @today0
)
AND E.EmployeeID NOT IN
(
	SELECT DISTINCT EmployeeID FROM dbo.EmployeeTime WHERE [In] BETWEEN @today AND DATEADD(second, S.[Start Seconds] + S.[Grace Seconds], @today)
)

GO
IF OBJECT_ID('dbo.spTaskList24A') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spTaskList24A AS'
GO
--************************************** (24A) ************************************************
ALTER PROC [dbo].[spTaskList24A] @due_start int, @due_stop int, @today0 int, @todaym4 int, @todaym7 int, @today datetime, @yesterday datetime AS 



CREATE TABLE #TEB(EmployeeID int, D int, LastBenefitID int, Benefits varchar(MAX), [Open] bit)
INSERT #TEB
SELECT DISTINCT EB.EmployeeID, EB.[Eligible Day past 1900], LastBenefitID = NULL, Benefits = '', 1
FROM #R R
INNER JOIN dbo.EmployeeBenefit EB ON R.ReminderTypeID = 24 AND EB.EmployeeID = R.EmployeeID AND R.[Active Employee] = 1 AND EB.[Eligible Day past 1900] BETWEEN @today0 - R.[Days] AND @today0 + R.[Days] AND
	EB.[First Enrolled Day past 1900] IS NULL AND
	EB.[Last Enrolled Day past 1900] IS NULL AND
	EB.[Declined Day past 1900] IS NULL
INNER JOIN dbo.Employee E ON EB.EmployeeID=E.EmployeeID

DECLARE @r int
SET @r = 1
WHILE @r > 0
BEGIN
	UPDATE #TEB SET LastBenefitID = (SELECT TOP 1 EB.BenefitID FROM dbo.EmployeeBenefit EB WHERE EB.EmployeeID=#TEB.EmployeeID AND EB.[Eligible Day past 1900] = D AND #TEB.[Open]=1 AND (#TEB.LastBenefitID IS NULL OR EB.BenefitID > #TEB.LastBenefitID) ORDER BY EB.BenefitID)
	UPDATE #TEB SET [Open] = 0 WHERE LastBenefitID IS NULL
	UPDATE #TEB SET Benefits = Benefits + ', ' + B.[Benefit]
	FROM #TEB INNER JOIN dbo.Benefit B ON #TEB.LastBenefitID = B.BenefitID
	
	SET @r = @@ROWCOUNT
END

INSERT #Tasks
SELECT R.[Reminder Type], ReminderTypeID = 24, R.OwnerEmployeeID, RegardingPersonID = #TEB.EmployeeID,
[Text] = 'Benefit Eligible. ' +  R.[Regarding Full Name] + dbo.fnPrefixSuffixIfNotEmpty(' (', R.[Employee Number], ')', '') + ' is eligible for ' + SUBSTRING(#TEB.Benefits, 3, 9999) + ' on ' + CAST(dbo.GetDateFromDaysPast1900(#TEB.D) AS varchar(6)),
Due = dbo.GetDateFromDaysPast1900(#TEB.D), 
R.Urgent, R.[Owner Initials],  R.[Regarding Initials],
R.Owner ,R.Regarding, TaskID = NULL, CreatorEmployeeID = NULL, [Created Day after 1900] = NULL, ItemID = NULL, Completed  = NULL, [Creator Initials] = 'System', Creator = 'System',
R.[To Lower], R.CC, Created = CAST(NULL AS datetime), R.[Employee Number], R.EmployeeNumberNumeric
FROM #R R
INNER JOIN #TEB ON R.EmployeeID = #TEB.EmployeeID AND R.ReminderTypeID = 24
GO
IF OBJECT_ID('dbo.spTaskList24B') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spTaskList24B AS'
GO
--************************************** (24B) ************************************************
ALTER PROC dbo.spTaskList24B @due_start int, @due_stop int, @today0 int, @todaym4 int, @todaym7 int, @today datetime, @yesterday datetime AS INSERT #Tasks
SELECT R.[Reminder Type], ReminderTypeID = 24, R.OwnerEmployeeID, RegardingPersonID = EB.EmployeeID,
[Text] = 'Benefit Eligible. ' +  R.[Regarding Full Name] + dbo.fnPrefixSuffixIfNotEmpty(' (', R.[Employee Number], ')', '') + ' is eligible for ' + B.TDRP + ' on ' + CAST(dbo.GetDateFromDaysPast1900(EB.[Eligible Day past 1900]) AS varchar(6)),
Due = dbo.GetDateFromDaysPast1900(EB.[Eligible Day past 1900]), 
R.Urgent, R.[Owner Initials],  R.[Regarding Initials],
R.Owner ,R.Regarding, TaskID = NULL, CreatorEmployeeID = NULL, [Created Day after 1900] = NULL, ItemID = NULL, Completed  = NULL, [Creator Initials] = 'System', Creator = 'System',
R.[To Lower], R.CC, Created = CAST(NULL AS datetime), R.[Employee Number], R.EmployeeNumberNumeric
FROM #R R
INNER JOIN dbo.EmployeeTDRP EB ON R.ReminderTypeID = 24 AND EB.EmployeeID = R.EmployeeID AND R.[Active Employee] = 1 AND EB.[Eligible Day past 1900] BETWEEN @today0 - R.[Days] AND @today0 + R.[Days] AND
	EB.[First Enrolled Day past 1900] IS NULL AND
	EB.[Last Enrolled Day past 1900] IS NULL AND
	EB.[Declined Day past 1900] IS NULL
INNER JOIN dbo.TDRP B ON EB.TDRPID=B.TDRPID
INNER JOIN dbo.Employee E ON EB.EmployeeID = E.EmployeeID
GO
IF OBJECT_ID('dbo.spTaskList25') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spTaskList25 AS'
GO
--************************************** (25) ************************************************
ALTER PROC dbo.spTaskList25 @due_start int, @due_stop int, @today0 int, @todaym4 int, @todaym7 int, @today datetime, @yesterday datetime AS INSERT #Tasks
SELECT R.[Reminder Type], ReminderTypeID = 17, R.OwnerEmployeeID, RegardingPersonID = E.EmployeeID, [Text] = 'Employment ending. ' +  R.[Regarding Full Name] + dbo.fnPrefixSuffixIfNotEmpty(' (', R.[Employee Number], ')', '''s') + ' employment ends '+ 
CAST(dbo.GetDateFromDaysPast1900(ELC.[Stop Day past 1900]) AS varchar(6)), 
Due = dbo.GetDateFromDaysPast1900(ELC.[Stop Day past 1900]), 
R.Urgent, R.[Owner Initials],  R.[Regarding Initials],
R.Owner ,R.Regarding, TaskID = NULL, CreatorEmployeeID = NULL, [Created Day after 1900] = NULL, ItemID = NULL, Completed  = NULL, [Creator Initials] = 'System', Creator = 'System',
R.[To Lower], R.CC, Created = CAST(NULL AS datetime), R.[Employee Number], R.EmployeeNumberNumeric
FROM #R R
INNER JOIN dbo.Employee E ON R.ReminderTypeID = 25 AND R.EmployeeID = E.EmployeeID
INNER JOIN dbo.vwEmployeeLastCompensation ELC ON ELC.EmployeeID = E.EmployeeID AND ELC.[Stop Day past 1900] IS NOT NULL AND ELC.[Stop Day past 1900] > @todaym7 AND
dbo.DoRaysIntersect(
	ELC.[Stop Day past 1900] - R.Days, 
	ELC.[Stop Day past 1900] + R.Days, 
	@due_start, 
	@due_stop
) = 1
GO
IF OBJECT_ID('dbo.spTaskList') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spTaskList AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spTaskList TO public'
END
GO
ALTER PROC dbo.spTaskList
	@owner_id int,
	@regarding_id int,
	@regarding_none bit,
	@due_start int,
	@due_stop int,
	@completed_start int,
	@completed_stop int,
	@complete bit,
	@first_task_id int
AS
DECLARE @batch_id int
DECLARE @show_reminders bit
DECLARE @todaym7 int
DECLARE @todaym4 int

SET NOCOUNT ON

IF OBJECT_ID('dbo.spTaskListOverride') IS NOT NULL
BEGIN
	
	EXEC sp_executesql N'EXEC dbo.spTaskListOverride @owner_id,@regarding_id,@regarding_none,@due_start,@due_stop,@completed_start,@completed_stop,@complete,@first_task_id',
		N'@owner_id int, @regarding_id int, @regarding_none bit, @due_start int, @due_stop int, @completed_start int, @completed_stop int, @complete bit, @first_task_id int',
		@owner_id=@owner_id, @regarding_id=@regarding_id, @regarding_none=@regarding_none, @due_start=@due_start, @due_stop=@due_stop, @completed_start=@completed_start, @completed_stop=@completed_stop, @complete=@complete, @first_task_id=@first_task_id
	RETURN
END

-- Gets permissions on tasks
SELECT @batch_id = RAND() * 2147483647

DECLARE @date_first int, @yesterday datetime, @today datetime, @today0 int
SELECT @today = CAST(GETDATE() as char(11)), @yesterday = DATEADD(d,-1,@today)
SELECT @today0 = DATEDIFF(d,0, @today)
SELECT @date_first=DatePartDW FROM vwDateFirst

EXEC dbo.spHolidayRecalc @force_recalc = 0, @stop_date = @today

INSERT dbo.TempX(BatchID, [ID])
SELECT @batch_id, EmployeeID FROM Employee WHERE @owner_id IS NULL OR @owner_id = EmployeeID

EXEC dbo.spPermissionGetOnPeopleForCurrentUser2 @batch_id, 10005
DELETE TempX WHERE BatchID = @batch_id AND (TempX.X & 1) = 0

DECLARE @payroll_ending datetime, @now datetime
-- Gets payroll period start/stop dates
SELECT @now = GETDATE()
CREATE TABLE #P(StartDate datetime, StopDate datetime)
INSERT #P(StartDate, StopDate)
EXEC dbo.spEmployeeTimeCalculateFilterInverse @now, 1
SELECT @payroll_ending = StopDate FROM #P

-- Some alerts like returning from leave are only interesting for a week
SELECT @todaym7 = DATEDIFF(d, 0, GETDATE()) - 7
SELECT @todaym4 = DATEDIFF(d, 0, GETDATE()) - 4

SELECT @first_task_id = -2147483648 WHERE @first_task_id IS NULL
SELECT @completed_start = -2147483648 WHERE @completed_start IS NULL
SELECT @completed_stop = 0x7FFFFFFF WHERE @completed_stop IS NULL
SELECT @due_start = -2147483648 WHERE @due_start IS NULL
SELECT @due_stop = 0x7FFFFFFF WHERE @due_stop IS NULL

SELECT @show_reminders = CASE WHEN @first_task_id IS NULL OR @first_task_id = -2147483648 THEN 1 ELSE 0 END

CREATE TABLE #R(
	ReminderTypeID int,
	EmployeeID int,
	[Reminder Type] varchar(50) COLLATE SQL_Latin1_General_CP1_CI_AS,
	[Days] int,
	OwnerEmployeeID int,
	[Owner Initials] varchar(50) COLLATE SQL_Latin1_General_CP1_CI_AS,
	[Owner] varchar(400) COLLATE SQL_Latin1_General_CP1_CI_AS,
	Urgent bit,
	[To Lower] varchar(400) COLLATE SQL_Latin1_General_CP1_CI_AS,
	[Active Employee] bit,
	CC varchar(400) COLLATE SQL_Latin1_General_CP1_CI_AS,
	[Employee Number] varchar(50) COLLATE SQL_Latin1_General_CP1_CI_AS,
	EmployeeNumberNumeric numeric(38,6),
	Regarding varchar(400) COLLATE SQL_Latin1_General_CP1_CI_AS,
	[Regarding Initials] varchar(50) COLLATE SQL_Latin1_General_CP1_CI_AS,
	[Regarding Full Name] varchar(400) COLLATE SQL_Latin1_General_CP1_CI_AS
)

IF @complete IS NOT NULL AND @complete = 1 SET @show_reminders = 0

IF @show_reminders=1 INSERT #R
-- Reminders for specific owner
SELECT R.ReminderTypeID, E.EmployeeID, R.[Reminder Type], [Days] = R.[Days before Due Day], OwnerEmployeeID = R.OwnerID, 
[Owner Initials] = dbo.fnGetInitials(P.[First Name], P.[Middle Name], P.[Last Name]),
[Owner] = dbo.fnGetListAs(P.[First Name], P.[Middle Name], P.[Last Name], P.Suffix),
R.Urgent, R.[To Lower], E.[Active Employee], R.CC,
E.[Employee Number], E.EmployeeNumberNumeric,
Regarding = dbo.fnGetListAs(P2.[First Name], P2.[Middle Name], P2.[Last Name], P2.Suffix),
[Regarding Initials] = dbo.fnGetInitials(P2.[First Name], P2.[Middle Name], P2.[Last Name]),
[Regarding Full Name] = dbo.fnGetFullName(P2.[First Name], P2.[Middle Name], P2.[Last Name], P2.Suffix)

FROM dbo.ReminderType R 
INNER JOIN dbo.TempX X ON (@owner_id IS NULL OR R.OwnerID = @owner_id) AND X.BatchID = @batch_id AND R.OwnerID = X.[ID] AND (@regarding_none = 0) AND (@regarding_id IS NULL OR X.[ID] = @regarding_id)
INNER JOIN dbo.Person P ON R.OwnerID = P.PersonID
CROSS JOIN dbo.Employee E
INNER JOIN dbo.Person P2 ON E.EmployeeID = P2.PersonID
UNION -- Reminders for managers
SELECT R.ReminderTypeID, E.EmployeeID, R.[Reminder Type], R.[Days before Due Day], E.ManagerID, 
[Owner Initials] = dbo.fnGetInitials(P.[First Name], P.[Middle Name], P.[Last Name]),
[Owner] = dbo.fnGetListAs(P.[First Name], P.[Middle Name], P.[Last Name], P.Suffix),
R.Urgent, R.[To Lower], E.[Active Employee], R.CC ,
E.[Employee Number], E.EmployeeNumberNumeric,
Regarding = dbo.fnGetListAs(P2.[First Name], P2.[Middle Name], P2.[Last Name], P2.Suffix),
[Regarding Initials] = dbo.fnGetInitials(P2.[First Name], P2.[Middle Name], P2.[Last Name]),
[Regarding Full Name] = dbo.fnGetFullName(P2.[First Name], P2.[Middle Name], P2.[Last Name], P2.Suffix)
FROM dbo.ReminderType R
INNER JOIN dbo.Employee E ON R.Manager = 1
INNER JOIN dbo.TempX X ON (@owner_id IS NULL OR E.ManagerID = @owner_id) AND X.BatchID = @batch_id AND E.ManagerID = X.[ID] AND (@regarding_none = 0) AND (@regarding_id IS NULL OR X.[ID] = @regarding_id)
INNER JOIN dbo.Person P ON E.ManagerID = P.PersonID
INNER JOIN dbo.Person P2 ON E.EmployeeID = P2.PersonID
UNION -- Reminders of self\employees
SELECT R.ReminderTypeID, E.EmployeeID, R.[Reminder Type], R.[Days before Due Day], E.EmployeeID, 
[Owner Initials] = dbo.fnGetInitials(P.[First Name], P.[Middle Name], P.[Last Name]),
[Owner] = dbo.fnGetListAs(P.[First Name], P.[Middle Name], P.[Last Name], P.Suffix),
R.Urgent, R.[To Lower], E.[Active Employee], R.CC ,
E.[Employee Number], E.EmployeeNumberNumeric,
Regarding = dbo.fnGetListAs(P.[First Name], P.[Middle Name], P.[Last Name], P.Suffix),
[Regarding Initials] = dbo.fnGetInitials(P.[First Name], P.[Middle Name], P.[Last Name]),
[Regarding Full Name] = dbo.fnGetFullName(P.[First Name], P.[Middle Name], P.[Last Name], P.Suffix)
FROM dbo.ReminderType R
INNER JOIN dbo.TempX X ON R.Employee = 1 AND X.BatchID = @batch_id AND (@owner_id IS NULL OR X.[ID] = @owner_id) AND (@regarding_none = 0) AND (@regarding_id IS NULL OR X.[ID] = @regarding_id)
INNER JOIN dbo.Employee E ON E.EmployeeID = X.[ID]
INNER JOIN dbo.Person P ON E.EmployeeID = P.PersonID
UNION -- Reminders for leave keepers (division)
SELECT R.ReminderTypeID, E.EmployeeID, R.[Reminder Type], R.[Days before Due Day], V.LeaveKeeperID, 
[Owner Initials] = dbo.fnGetInitials(P.[First Name], P.[Middle Name], P.[Last Name]),
[Owner] = dbo.fnGetListAs(P.[First Name], P.[Middle Name], P.[Last Name], P.Suffix),
R.Urgent, R.[To Lower], E.[Active Employee], R.CC ,
E.[Employee Number], E.EmployeeNumberNumeric,
Regarding = dbo.fnGetListAs(P2.[First Name], P2.[Middle Name], P2.[Last Name], P2.Suffix),
[Regarding Initials] = dbo.fnGetInitials(P2.[First Name], P2.[Middle Name], P2.[Last Name]),
[Regarding Full Name] = dbo.fnGetFullName(P2.[First Name], P2.[Middle Name], P2.[Last Name], P2.Suffix)
FROM dbo.ReminderType R
INNER JOIN dbo.TempX X ON R.[Leave Keeper] = 1 AND X.BatchID = @batch_id AND (@regarding_none = 0) AND (@regarding_id IS NULL OR X.[ID] = @regarding_id)
INNER JOIN dbo.Employee E ON E.EmployeeID = X.[ID]
INNER JOIN dbo.Division V ON E.DivisionID = V.DivisionID AND (@owner_id IS NULL OR V.LeaveKeeperID = @owner_id)
INNER JOIN dbo.Person P ON V.LeaveKeeperID = P.PersonID
INNER JOIN dbo.Person P2 ON E.EmployeeID = P2.PersonID

CREATE INDEX R_ReminderTypeID_EmployeeID ON #R(ReminderTypeID, EmployeeID)
CREATE INDEX IX_04302010_ReminderTypes ON #R(ReminderTypeID)

CREATE TABLE #Tasks (
	[Reminder Type] varchar(50) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	ReminderTypeID int NULL,
	OwnerEmployeeID int NULL,
	RegardingPersonID int NULL,
	[Text] varchar(MAX) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	Due datetime NULL,
	Urgent bit,
	[Owner Initials] varchar(50) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[Regarding Initials] varchar(50) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[Owner] varchar(400) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[Regarding] varchar(400) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	TaskID int NULL,
	CreatorEmployeeID int NULL,
	[Created Day after 1900] datetime NULL,
	ItemID int NULL,
	Completed datetime NULL,
	[Creator Initials] varchar(40) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[Creator] varchar(400) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[To Lower] varchar(400) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	CC varchar(400) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	Created datetime NULL,
	[Regarding Employee Number] varchar(40) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	EmployeeNumberNumeric numeric(38,6) NULL
)

CREATE INDEX IX_122011_TasksDueCompleted ON #Tasks(Urgent, Due, Completed)

INSERT #Tasks
SELECT [Reminder Type] = CAST('' AS varchar(50)), ReminderTypeID = NULL, R.OwnerEmployeeID, R.RegardingPersonID,
[Text] = R.Task + dbo.fnPrefixSuffixIfNotEmpty(' (', RE.[Employee Number], ')', ''),
Due = dbo.GetDateFromDaysPast1900(T.[Due Day past 1900]), R.Urgent, 
[Owner Initials] = dbo.fnGetInitials(O.[First Name], O.[Middle Name], O.[Last Name]),
[Regarding Initials] =  ISNULL(dbo.fnGetInitials(G.[First Name], G.[Middle Name], G.[Last Name]), ''), 
[Owner] = dbo.fnGetListAs(O.[First Name], O.[Middle Name], O.[Last Name], O.Suffix), 
[Regarding] = dbo.fnGetListAs(G.[First Name], G.[Middle Name], G.[Last Name], G.Suffix), 
R.TaskID, R.CreatorEmployeeID, R.[Created Day after 1900], T.ItemID, Completed =  dbo.GetDateFromDaysPast1900(T.[Completed Day past 1900]), 
[Creator Initials] = dbo.fnGetInitials(C.[First Name], C.[Middle Name], C.[Last Name]),
[Creator] = dbo.fnGetListAs(C.[First Name], C.[Middle Name], C.[Last Name], C.Suffix),
[To Lower] = CAST('' AS varchar(400)),  CC = CAST('' AS varchar(50)), Created = R.[Created Day after 1900],
[Regarding Employee Number] = ISNULL(RE.[Employee Number], ''),
RE.EmployeeNumberNumeric
FROM dbo.Task R
INNER JOIN dbo.TempX X ON X.BatchID = @batch_id AND R.OwnerEmployeeID = X.[ID] AND -- Filters out tasks that the current user is not allowed  to view
(
	((@regarding_none = 0) AND (@regarding_id IS NULL OR R.RegardingPersonID = @regarding_id)) OR
	((@regarding_none = 1) AND R.RegardingPersonID IS NULL)
)
INNER JOIN dbo.TaskOccurence T ON R.TaskID = T.TaskID AND T.TaskID >= @first_task_id
INNER JOIN dbo.Person O ON O.PersonID = R.OwnerEmployeeID AND
(T.[Due Day past 1900] >= @due_start AND T.[Due Day past 1900] <= @due_stop) AND
(
	(@complete = 0 AND T.[Completed Day past 1900] IS NULL) OR
	(@complete = 1 AND T.[Completed Day past 1900] IS NOT NULL AND T.[Completed Day past 1900] >= @completed_start AND  T.[Completed Day past 1900] <= @completed_stop) OR
	(@complete Is NULL)
) AND
(@owner_id IS NULL OR R.OwnerEmployeeID = @owner_id)
INNER JOIN dbo.Person C ON C.PersonID = R.CreatorEmployeeID -- AND (@creator_id IS NULL OR R.CreatorEmployeeID =  @creator_id)
INNER JOIN dbo.Employee E ON E.EmployeeID = X.[ID]
LEFT JOIN dbo.Person G ON G.PersonID = R.RegardingPersonID
LEFT JOIN dbo.Employee RE ON RE.EmployeeID = R.RegardingPersonID

DELETE dbo.TempX WHERE BatchID = @batch_id OR DATEDIFF(hh, Created, GETDATE()) > 1

IF EXISTS(SELECT * FROM #R WHERE ReminderTypeID=01)
BEGIN
	IF OBJECT_ID('dbo.spTaskList01Override') IS NOT NULL
		EXEC sp_executesql N'EXEC dbo.spTaskList01Override @due_start, @due_stop, @today0, @todaym4, @todaym7, @today, @yesterday', 
			N'@due_start int, @due_stop int, @today0 int, @todaym4 int, @todaym7 int, @today datetime, @yesterday datetime',
			@due_start, @due_stop, @today0, @todaym4, @todaym7, @today, @yesterday
	ELSE
		EXEC dbo.spTaskList01 @due_start, @due_stop, @today0, @todaym4, @todaym7, @today, @yesterday
END

IF EXISTS(SELECT * FROM #R WHERE ReminderTypeID=02) EXEC dbo.spTaskList02 @due_start, @due_stop, @today0, @todaym4, @todaym7, @today, @yesterday

IF EXISTS(SELECT * FROM #R WHERE ReminderTypeID=03)
BEGIN
	IF OBJECT_ID('dbo.spTaskList03Override') IS NOT NULL
		EXEC sp_executesql N'EXEC dbo.spTaskList03Override @due_start, @due_stop, @today0, @todaym4, @todaym7, @today, @yesterday', 
			N'@due_start int, @due_stop int, @today0 int, @todaym4 int, @todaym7 int, @today datetime, @yesterday datetime',
			@due_start, @due_stop, @today0, @todaym4, @todaym7, @today, @yesterday
	ELSE
		EXEC dbo.spTaskList03 @due_start, @due_stop, @today0, @todaym4, @todaym7, @today, @yesterday
END

IF EXISTS(SELECT * FROM #R WHERE ReminderTypeID=04) EXEC dbo.spTaskList04 @due_start, @due_stop, @today0, @todaym4, @todaym7, @today, @yesterday
IF EXISTS(SELECT * FROM #R WHERE ReminderTypeID=05) EXEC dbo.spTaskList05 @due_start, @due_stop, @today0, @todaym4, @todaym7, @today, @yesterday
IF EXISTS(SELECT * FROM #R WHERE ReminderTypeID=06) EXEC dbo.spTaskList06 @due_start, @due_stop, @today0, @todaym4, @todaym7, @today, @yesterday
IF EXISTS(SELECT * FROM #R WHERE ReminderTypeID=07) EXEC dbo.spTaskList07 @due_start, @due_stop, @today0, @todaym4, @todaym7, @today, @yesterday
IF EXISTS(SELECT * FROM #R WHERE ReminderTypeID=08) EXEC dbo.spTaskList08 @due_start, @due_stop, @today0, @todaym4, @todaym7, @today, @yesterday
IF EXISTS(SELECT * FROM #R WHERE ReminderTypeID=09) EXEC dbo.spTaskList09 @due_start, @due_stop, @today0, @todaym4, @todaym7, @today, @yesterday
IF EXISTS(SELECT * FROM #R WHERE ReminderTypeID=10) EXEC dbo.spTaskList10 @due_start, @due_stop, @today0, @todaym4, @todaym7, @today, @yesterday
IF EXISTS(SELECT * FROM #R WHERE ReminderTypeID=11) EXEC dbo.spTaskList11 @due_start, @due_stop, @today0, @todaym4, @todaym7, @today, @yesterday
IF EXISTS(SELECT * FROM #R WHERE ReminderTypeID=12) EXEC dbo.spTaskList12 @due_start, @due_stop, @today0, @todaym4, @todaym7, @today, @yesterday
IF EXISTS(SELECT * FROM #R WHERE ReminderTypeID=13) EXEC dbo.spTaskList13 @due_start, @due_stop, @today0, @todaym4, @todaym7, @today, @yesterday
IF EXISTS(SELECT * FROM #R WHERE ReminderTypeID=14)
BEGIN
	EXEC dbo.spTaskList14A @due_start, @due_stop, @today0, @todaym4, @todaym7, @today, @yesterday
	EXEC dbo.spTaskList14B @due_start, @due_stop, @today0, @todaym4, @todaym7, @today, @yesterday
END
IF EXISTS(SELECT * FROM #R WHERE ReminderTypeID=15)
BEGIN
	IF OBJECT_ID('dbo.spTaskList15Override') IS NOT NULL
		EXEC sp_executesql N'EXEC dbo.spTaskList15Override @due_start, @due_stop, @today0, @todaym4, @todaym7, @today, @yesterday',
			N'@due_start int, @due_stop int, @today0 int, @todaym4 int, @todaym7 int, @today datetime, @yesterday datetime',
			@due_start, @due_stop, @today0, @todaym4, @todaym7, @today, @yesterday
	ELSE
		EXEC dbo.spTaskList15 @due_start, @due_stop, @today0, @todaym4, @todaym7, @today, @yesterday
END
IF EXISTS(SELECT * FROM #R WHERE ReminderTypeID=16) EXEC dbo.spTaskList16 @due_start, @due_stop, @today0, @todaym4, @todaym7, @today, @yesterday
IF EXISTS(SELECT * FROM #R WHERE ReminderTypeID=17) EXEC dbo.spTaskList17 @due_start, @due_stop, @today0, @todaym4, @todaym7, @today, @yesterday
IF EXISTS(SELECT * FROM #R WHERE ReminderTypeID=18) EXEC dbo.spTaskList18 @due_start, @due_stop, @today0, @todaym4, @todaym7, @today, @yesterday
IF EXISTS(SELECT * FROM #R WHERE ReminderTypeID=19) EXEC dbo.spTaskList19 @due_start, @due_stop, @today0, @todaym4, @todaym7, @today, @yesterday
IF EXISTS(SELECT * FROM #R WHERE ReminderTypeID=20) EXEC dbo.spTaskList20 @due_start, @due_stop, @today0, @todaym4, @todaym7, @today, @yesterday
IF EXISTS(SELECT * FROM #R WHERE ReminderTypeID=21) EXEC dbo.spTaskList21 @due_start, @due_stop, @today0, @todaym4, @todaym7, @today, @yesterday
IF EXISTS(SELECT * FROM #R WHERE ReminderTypeID=22)
BEGIN
	EXEC dbo.spTaskList22A @due_start, @due_stop, @today0, @todaym4, @todaym7, @today, @yesterday
	EXEC dbo.spTaskList22B @due_start, @due_stop, @today0, @todaym4, @todaym7, @today, @yesterday
END
IF EXISTS(SELECT * FROM #R WHERE ReminderTypeID=23) EXEC dbo.spTaskList23 @due_start, @due_stop, @today0, @todaym4, @todaym7, @today, @yesterday
IF EXISTS(SELECT * FROM #R WHERE ReminderTypeID=24)
BEGIN
	EXEC dbo.spTaskList24A @due_start, @due_stop, @today0, @todaym4, @todaym7, @today, @yesterday
	EXEC dbo.spTaskList24B @due_start, @due_stop, @today0, @todaym4, @todaym7, @today, @yesterday
END
IF EXISTS(SELECT * FROM #R WHERE ReminderTypeID=25)
BEGIN
	IF OBJECT_ID('dbo.spTaskList25Override') IS NOT NULL
		EXEC sp_executesql N'EXEC dbo.spTaskList25Override @due_start, @due_stop, @today0, @todaym4, @todaym7, @today, @yesterday',
			N'@due_start int, @due_stop int, @today0 int, @todaym4 int, @todaym7 int, @today datetime, @yesterday datetime',
			@due_start, @due_stop, @today0, @todaym4, @todaym7, @today, @yesterday
	ELSE
		EXEC dbo.spTaskList25 @due_start, @due_stop, @today0, @todaym4, @todaym7, @today, @yesterday
END

SELECT * FROM #Tasks
ORDER BY Urgent DESC, Due ASC, Completed ASC
GO
-- Creates hook that may be modified by user 
IF OBJECT_ID('dbo.spTaskListForEmail') IS NULL EXEC sp_executesql N'
CREATE PROC dbo.spTaskListForEmail
	@owner_id int,
	@regarding_id int,
	@regarding_none bit,
	@due_start int,
	@due_stop int,
	@completed_start int,
	@completed_stop int,
	@complete bit,
	@first_task_id int
AS
EXEC dbo.spTaskList @owner_id, @regarding_id, @regarding_none, @due_start, @due_stop, @completed_start, @completed_stop, @complete, @first_task_id'
GO
GRANT EXEC ON dbo.spTaskListForEmail TO public
GO
ALTER PROC dbo.spEmployeeTimeCalculateFilter
	@batch_id int,
 	@start_date datetime out,
 	@group_by smallint,
	@work_week int,
	@work_week_year int,
	@time_type_mask int = 0x7FFFFFFF,
	@leave_type_mask int = 0x7FFFFFFF,
	@include_pending_time bit = 0,
	@authorized bit = 0 OUT
AS
SET NOCOUNT ON
DECLARE @stop_date datetime


IF @group_by = 0
BEGIN
	-- Strips off hh:mm
	SELECT @start_date = DATEADD(d, 0, DATEDIFF(d, 0, @start_date))

	SELECT @stop_date = DATEADD(d,15,@start_date)
	SELECT @stop_date = DATEADD(ms, -1 ,@stop_date)
END
ELSE IF @group_by = 1
BEGIN
	IF (DATEPART(wk, dbo.GetDateFromMDY(12, 31, @work_week_year)) < @work_week)
	-- @work_week might be 53 or 54, but the max week in @work_week_year is only 52 or 53 (less than given @work_week number)
		RETURN
	

	DECLARE @date_first int
	SELECT @date_first = DatePartDW FROM vwDateFirst

	DECLARE @first_ww datetime
	SELECT @first_ww = dbo.GetDateFromMDY(1, 1, @work_week_year) -- Jan 1

	SET DATEFIRST 7 -- Sunday is first day for dw function

	SELECT @start_date = DATEADD(d, @date_first - DATEPART(dw,@first_ww), @first_ww) -- Go to start of week
	IF @start_date > @first_ww SET @start_date = DATEADD(d,-7,@start_date)
	SELECT @first_ww = DATEADD(wk,@work_week-1,@start_date) -- Add weeks

	SELECT @start_date = @first_ww
	SELECT @stop_date = DATEADD(wk,14,@start_date)
END
ELSE IF @group_by = 2
BEGIN
	DECLARE @group_id int
	SELECT @group_id = GroupID FROM LeaveRatePeriod WHERE Payroll = 1 AND PeriodID = (SELECT CurrentPayrollPeriodID FROM dbo.Constant)



	-- Gets first payroll period start dates
	CREATE TABLE #P(StartDate datetime, StopDate datetime)
	INSERT #P(StartDate, StopDate)
	EXEC dbo.spEmployeeTimeCalculateFilterInverse @start_date, 1
	SELECT @start_date = StartDate FROM #P

	IF @group_id = 8
		SELECT @stop_date = DATEADD(m,2*14,@start_date)
	ELSE IF @group_id = 16
		SELECT @stop_date = DATEADD(m,14,@start_date)
	ELSE IF @group_id = 32
		SELECT @stop_date = DATEADD(m,14/2,@start_date)
	ELSE IF @group_id = 64
		SELECT @stop_date = DATEADD(wk,2*14,@start_date)
	ELSE IF @group_id = 128
		SELECT @stop_date = DATEADD(wk,14,@start_date)

END
ELSE IF @group_by = 3
	SELECT @stop_date = DATEADD(m,12,@start_date)
	
DECLARE @start_day int, @stop_day int
SELECT @start_day = DATEDIFF(d,0,@start_date), @stop_day = DATEDIFF(d,0,@stop_date)

DECLARE @pending_type_id int, @authorized_leave bit

SET @authorized_leave = 0
EXEC dbo.spPermissionGetOnPeopleForCurrentUser2 @batch_id, 10001

IF EXISTS(SELECT * FROM TempX WHERE (X & 1) = 0) SET @authorized_leave = 0
ELSE SET @authorized_leave = 1


-- Insert leave
SELECT L.EmployeeID,
DD = L.[Day past 1900],
Seconds = 0 - L.Seconds,
PayrollPeriod = 0
INTO #ET
FROM dbo.vwEmployeeLeaveApproved L
INNER JOIN TempX X ON  L.Seconds < 0
AND X.BatchID=@batch_id AND X.[ID]=L.EmployeeID AND (X.X & 1) = 1
AND (L.[Extended Type Mask] & @leave_type_mask) != 0
AND L.[Day past 1900] BETWEEN @start_day AND @stop_day



CREATE TABLE #EMPLOYEE_TIME_ROUNDED(
	TempItemID int NOT NULL IDENTITY(1,1) PRIMARY KEY,
	EmployeeID int NOT NULL,
	OriginalTypeID int NOT NULL, 
	CalculatedTypeID int NOT NULL,
	[In Day past 1900] int NOT NULL, 
	[OT Eligible] bit NOT NULL,
	[OT Disable] bit NOT NULL,
	[Pay Rate] money NOT NULL,
	[Fixed Pay] money NOT NULL DEFAULT(0),
	[Fixed Items] int DEFAULT(0),
	Regular bit DEFAULT(0),
	[In Seconds] int NOT NULL,
	[Out Seconds] int NOT NULL,
	TimeSchemaID int NOT NULL,
	ShiftDiffItemID int NULL,
	TempShiftDiffSeconds int NULL,
	TempShiftDiffItemID int NULL,
	OriginalTimeItemID int NULL,
	CopyTimeItemID int NULL,
	[Time Seconds] int NOT NULL DEFAULT(0),
	[Holiday Seconds] int NOT NULL DEFAULT(0),
	[OT Seconds] int NOT NULL DEFAULT(0),
	Flags int NOT NULL DEFAULT(0),
	[Actual In] datetime NULL,
	[Actual Out] datetime NULL,
	[Base Seconds] int NOT NULL DEFAULT(0),
	[X2 Seconds] int NOT NULL DEFAULT(0)
)

DECLARE @denied_type_id int
EXEC dbo.spEmployeeTimeRoundAndCalcOT @batch_id, 0, @start_day, @stop_day, NULL, NULL, @authorized OUT, @pending_type_id OUT, @denied_type_id OUT
IF @authorized_leave=0 SET @authorized=0


-- Insert time
INSERT #ET
SELECT ET.EmployeeID,
DD = ET.[In Day past 1900],
Seconds = ET.[Out Seconds] - ET.[In Seconds],
PayrollPeriod = 0
FROM #EMPLOYEE_TIME_ROUNDED ET WHERE 
(@include_pending_time = 1 AND ET.CalculatedTypeID = @pending_type_id) OR
(ET.CalculatedTypeID != @pending_type_id AND (ET.OriginalTypeID & @time_type_mask) != 0)


DELETE dbo.TempX WHERE BatchID=@batch_id OR DATEDIFF(minute, Created, GETDATE()) > 30

CREATE TABLE #ET2
(
	EmployeeID int,
	DD datetime,
	Seconds int,
	PayrollPeriod int
)


INSERT #ET2
SELECT EmployeeID, DD = DATEADD(d, 0, DD), Seconds = SUM(Seconds), PayrollPeriod = MIN(PayrollPeriod)
FROM #ET GROUP BY EmployeeID, DD



-- SUM the Seconds of the work day that has 2 or more entries depending on the group by
IF @group_by = 0
-- day
BEGIN
--	SELECT EmployeeID, [Work day],Seconds=SUM(Seconds) FROM #ET2  GROUP BY [Work day],EmployeeID

	SELECT P.PersonID, Employee = P.[List As],
		Day0 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.PersonID AND DATEDIFF(dd, @start_date, #ET2.[DD]) = 0), 0) / 3600.00,
		Day1 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.PersonID AND DATEDIFF(dd, @start_date, #ET2.[DD]) = 1), 0) / 3600.00,
		Day2 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.PersonID AND DATEDIFF(dd, @start_date, #ET2.[DD]) = 2), 0) / 3600.00,
		Day3 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.PersonID AND DATEDIFF(dd, @start_date, #ET2.[DD]) = 3), 0) / 3600.00,
		Day4 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.PersonID AND DATEDIFF(dd, @start_date, #ET2.[DD]) = 4), 0) / 3600.00,
		Day5 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.PersonID AND DATEDIFF(dd, @start_date, #ET2.[DD]) = 5), 0) / 3600.00,
		Day6 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.PersonID AND DATEDIFF(dd, @start_date, #ET2.[DD]) = 6), 0) / 3600.00,
		Day7 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.PersonID AND DATEDIFF(dd, @start_date, #ET2.[DD]) = 7), 0) / 3600.00,
		Day8 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.PersonID AND DATEDIFF(dd, @start_date, #ET2.[DD]) = 8), 0) / 3600.00,
		Day9 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.PersonID AND DATEDIFF(dd, @start_date, #ET2.[DD]) = 9), 0) / 3600.00,
		Day10 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.PersonID AND DATEDIFF(dd, @start_date, #ET2.[DD]) = 10), 0) / 3600.00,
		Day11 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.PersonID AND DATEDIFF(dd, @start_date, #ET2.[DD]) = 11), 0) / 3600.00,
		Day12 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.PersonID AND DATEDIFF(dd, @start_date, #ET2.[DD]) = 12), 0) / 3600.00,
		Day13 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.PersonID AND DATEDIFF(dd, @start_date, #ET2.[DD]) = 13), 0) / 3600.00,
		Day14 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.PersonID AND DATEDIFF(dd, @start_date, #ET2.[DD]) = 14), 0) / 3600.00,
		Day15 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.PersonID AND DATEDIFF(dd, @start_date, #ET2.[DD]) = 15), 0) / 3600.00
	FROM dbo.vwPersonListAs P WHERE P.PersonID IN
	(
		SELECT EmployeeID FROM #ET2
	)
	ORDER BY P.[List As]
END

ELSE IF @group_by = 1
-- Work week
BEGIN
	DECLARE @ww0 int
	SET @ww0 = DATEDIFF(d,0,@first_ww)


	SELECT P.PersonID, Employee=P.[List As],
		WW0 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.PersonID AND #ET2.[DD] - @ww0 BETWEEN 0 AND 6), 0) / 3600.00,
		WW1 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.PersonID AND #ET2.[DD] - @ww0 BETWEEN 7 AND 13), 0) / 3600.00,
		WW2 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.PersonID AND #ET2.[DD] - @ww0 BETWEEN 14 AND 20), 0) / 3600.00,
		WW3 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.PersonID AND #ET2.[DD] - @ww0 BETWEEN 21 AND 27), 0) / 3600.00,
		WW4 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.PersonID AND #ET2.[DD] - @ww0 BETWEEN 28 AND 34), 0) / 3600.00,
		WW5 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.PersonID AND #ET2.[DD] - @ww0 BETWEEN 35 AND 41), 0) / 3600.00,
		WW6 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.PersonID AND #ET2.[DD] - @ww0 BETWEEN 42 AND 48), 0) / 3600.00,
		WW7 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.PersonID AND #ET2.[DD] - @ww0 BETWEEN 49 AND 55), 0) / 3600.00,
		WW8 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.PersonID AND #ET2.[DD] - @ww0 BETWEEN 56 AND 62), 0) / 3600.00,
		WW9 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.PersonID AND #ET2.[DD] - @ww0 BETWEEN 63 AND 69), 0) / 3600.00,
		WW10 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.PersonID AND #ET2.[DD] - @ww0 BETWEEN 70 AND 76), 0) / 3600.00,
		WW11 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.PersonID AND #ET2.[DD] - @ww0 BETWEEN 77 AND 83), 0) / 3600.00,
		WW12 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.PersonID AND #ET2.[DD] - @ww0 BETWEEN 84 AND 90), 0) / 3600.00,
		WW13 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.PersonID AND #ET2.[DD] - @ww0 BETWEEN 91 AND 97), 0) / 3600.00,
		WW14 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.PersonID AND #ET2.[DD] - @ww0 BETWEEN 98 AND 104), 0) / 3600.00,
		WW15 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.PersonID AND #ET2.[DD] - @ww0 BETWEEN 105 AND 111), 0) / 3600.00
	FROM dbo.vwPersonListAs P WHERE P.PersonID IN
	(
		SELECT EmployeeID FROM #ET2
	)
	ORDER BY P.[List As]

END

ELSE IF @group_by = 2
-- payroll
BEGIN
	DECLARE @first_payroll_period int
	SELECT @first_payroll_period = dbo.GetPayrollPeriodNumber(@start_date)
	UPDATE #ET2 SET [PayrollPeriod]= dbo.GetPayrollPeriodNumber(#ET2.[DD])
--	SELECT DISTINCT [PayrollPeriod] FROM #ET2
	SELECT P.PersonID, Employee=P.[List As],
		Payroll0 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.PersonID AND #ET2.[PayrollPeriod] - @first_payroll_period = 0),0) / 3600.00,
		Payroll1 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.PersonID AND #ET2.[PayrollPeriod] - @first_payroll_period = 1),0) / 3600.00,
		Payroll2 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.PersonID AND #ET2.[PayrollPeriod] - @first_payroll_period = 2),0) / 3600.00,
		Payroll3 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.PersonID AND #ET2.[PayrollPeriod] - @first_payroll_period = 3),0) / 3600.00,
		Payroll4 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.PersonID AND #ET2.[PayrollPeriod] - @first_payroll_period = 4),0) / 3600.00,
		Payroll5 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.PersonID AND #ET2.[PayrollPeriod] - @first_payroll_period = 5),0) / 3600.00,
		Payroll6 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.PersonID AND #ET2.[PayrollPeriod] - @first_payroll_period = 6),0) / 3600.00,
		Payroll7 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.PersonID AND #ET2.[PayrollPeriod] - @first_payroll_period = 7),0) / 3600.00,
		Payroll8 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.PersonID AND #ET2.[PayrollPeriod] - @first_payroll_period = 8),0) / 3600.00,
		Payroll9 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.PersonID AND #ET2.[PayrollPeriod] - @first_payroll_period = 9),0) / 3600.00,
		Payroll10 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.PersonID AND #ET2.[PayrollPeriod] - @first_payroll_period = 10),0) / 3600.00,
		Payroll11 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.PersonID AND #ET2.[PayrollPeriod] - @first_payroll_period = 11),0) / 3600.00,
		Payroll12 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.PersonID AND #ET2.[PayrollPeriod] - @first_payroll_period = 12),0) / 3600.00,
		Payroll13 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.PersonID AND #ET2.[PayrollPeriod] - @first_payroll_period = 13),0) / 3600.00,
		Payroll14 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.PersonID AND #ET2.[PayrollPeriod] - @first_payroll_period = 14),0) / 3600.00,
		Payroll15 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.PersonID AND #ET2.[PayrollPeriod] - @first_payroll_period = 15),0) / 3600.00
	FROM dbo.vwPersonListAs P WHERE P.PersonID IN
	(
		SELECT EmployeeID FROM #ET2
	)
	ORDER BY P.[List As]

END

ELSE IF @group_by = 3
-- month
BEGIN
	UPDATE #ET2 SET [DD]=DATEADD(d,1-DAY([DD]),[DD])

	SELECT P.PersonID, Employee=P.[List As],
		Month0 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.PersonID AND DATEDIFF(m, @start_date, #ET2.[DD]) = 0), 0) / 3600.00,
		Month1 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.PersonID AND DATEDIFF(m, @start_date, #ET2.[DD]) = 1), 0) / 3600.00,
		Month2 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.PersonID AND DATEDIFF(m, @start_date, #ET2.[DD]) = 2), 0) / 3600.00,
		Month3 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.PersonID AND DATEDIFF(m, @start_date, #ET2.[DD]) = 3), 0) / 3600.00,
		Month4 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.PersonID AND DATEDIFF(m, @start_date, #ET2.[DD]) = 4), 0) / 3600.00,
		Month5 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.PersonID AND DATEDIFF(m, @start_date, #ET2.[DD]) = 5), 0) / 3600.00,
		Month6 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.PersonID AND DATEDIFF(m, @start_date, #ET2.[DD]) = 6), 0) / 3600.00,
		Month7 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.PersonID AND DATEDIFF(m, @start_date, #ET2.[DD]) = 7), 0) / 3600.00,
		Month8 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.PersonID AND DATEDIFF(m, @start_date, #ET2.[DD]) = 8), 0) / 3600.00,
		Month9 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.PersonID AND DATEDIFF(m, @start_date, #ET2.[DD]) = 9), 0) / 3600.00,
		Month10 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.PersonID AND DATEDIFF(m, @start_date, #ET2.[DD]) = 10), 0) / 3600.00,
		Month11 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.PersonID AND DATEDIFF(m, @start_date, #ET2.[DD]) = 11), 0) / 3600.00
	FROM dbo.vwPersonListAs P WHERE P.PersonID IN
	(
		SELECT EmployeeID FROM #ET2
	)
	ORDER BY P.[List As]
END

ELSE IF @group_by = 4
-- quarter
BEGIN
	UPDATE #ET2 SET [DD]=DATEADD(d,1-DAY([DD]),[DD])

	SELECT P.PersonID, Employee=P.[List As],
		Quarter0 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.PersonID AND DATEDIFF(m, @start_date, #ET2.[DD]) BETWEEN 0 AND 2), 0) / 3600.00,
		Quarter1 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.PersonID AND DATEDIFF(m, @start_date, #ET2.[DD]) BETWEEN 3 AND 5), 0) / 3600.00,
		Quarter2 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.PersonID AND DATEDIFF(m, @start_date, #ET2.[DD]) BETWEEN 6 AND 8), 0) / 3600.00,
		Quarter3 = ISNULL((SELECT SUM(Seconds) FROM #ET2 WHERE #ET2.EmployeeID = P.PersonID AND DATEDIFF(m, @start_date, #ET2.[DD]) BETWEEN 9 AND 11), 0) / 3600.00
	FROM dbo.vwPersonListAs P WHERE P.PersonID IN
	(
		SELECT EmployeeID FROM #ET2
	)
	ORDER BY P.[List As]
END
GO
ALTER VIEW dbo.vwBenefit AS SELECT BenefitID, Benefit, Note, [Deduction Code] FROM Benefit
GO
ALTER VIEW dbo.vwTDRP AS
SELECT TDRPID, TDRP, [Max Employee Contribution Percent], Note, [Account Number], [Deduction Code], [Deduction Code Loan Repay], [Deduction Code Catch Up] FROM TDRP
GO
IF OBJECT_id('dbo.vwDeduction') IS NOT NULL DROP VIEW dbo.vwDeduction
GO
CREATE VIEW dbo.vwDeduction AS SELECT DeductionID, Deduction, [Deduction Code] FROM Deduction
GO
IF OBJECT_id('dbo.vwEmployeeDeduction') IS NOT NULL DROP VIEW dbo.vwEmployeeDeduction
GO
CREATE VIEW dbo.vwEmployeeDeduction AS
SELECT ED.ItemID, ED.EmployeeID, ED.DeductionID, ED.Amount, ED.Comment,
D.Deduction, D.[Deduction Code],
P.[First Name], P.[Last Name], V.[List As],
E.[Employee Number],
X.SSN
FROM EmployeeDeduction ED
INNER JOIN Deduction D ON ED.DeductionID=D.DeductionID
INNER JOIN Employee E ON ED.EmployeeID=E.EmployeeID
INNER JOIN Person P ON E.EmployeeID=P.PersonID
INNER JOIN PersonX X ON P.PersonID=X.PersonID
INNER JOIN dbo.vwPersonListAs V ON P.PersonID=V.PersonID
GO
IF OBJECT_id('dbo.vwEmployeeDeductionUnion2') IS NOT NULL DROP VIEW dbo.vwEmployeeDeductionUnion2
GO
CREATE VIEW dbo.vwEmployeeDeductionUnion2 AS
SELECT ED.EmployeeID, ED.Amount
FROM EmployeeDeduction ED WHERE ED.Amount <> 0

UNION ALL

SELECT EB.EmployeeID, EB.[Employee Premium]
FROM EmployeeBenefit EB WHERE EB.[Employee Premium] <> 0 AND dbo.fnIsBenefitActive(EB.[Declined Day past 1900], EB.[Expires Day past 1900], EB.[First Enrolled Day past 1900], EB.[Last Enrolled Day past 1900]) = 1


UNION ALL

-- TDRP: Employee Fixed
SELECT ET.EmployeeID, ET.[Employee Fixed]
FROM EmployeeTDRP ET WHERE ET.[Employee Fixed] <> 0 AND dbo.fnIsBenefitActive(ET.[Declined Day past 1900], ET.[Expires Day past 1900], ET.[First Enrolled Day past 1900], ET.[Last Enrolled Day past 1900]) = 1

UNION ALL

-- TDRP: Catch Up
SELECT ET.EmployeeID,ET.[Catch Up]
FROM EmployeeTDRP ET WHERE ET.[Catch Up] <> 0 AND dbo.fnIsBenefitActive(ET.[Declined Day past 1900], ET.[Expires Day past 1900], ET.[First Enrolled Day past 1900], ET.[Last Enrolled Day past 1900]) = 1

UNION ALL

-- TDRP: Loan Repay
SELECT ET.EmployeeID, ET.[Loan Repay]
FROM EmployeeTDRP ET WHERE ET.[Loan Repay] <> 0 AND dbo.fnIsBenefitActive(ET.[Declined Day past 1900], ET.[Expires Day past 1900], ET.[First Enrolled Day past 1900], ET.[Last Enrolled Day past 1900]) = 1
GO
IF OBJECT_id('dbo.vwEmployeeDeductionUnion') IS NOT NULL DROP VIEW dbo.vwEmployeeDeductionUnion
GO
CREATE VIEW dbo.vwEmployeeDeductionUnion AS
SELECT ED.ItemID, ED.EmployeeID, DeductionID=ED.DeductionID, ED.Amount, ED.Comment,
D.Deduction, D.[Deduction Code],
P.[First Name], P.[Last Name], V.[List As],
E.[Employee Number],
X.SSN, TypeID=1, Type=CAST('Deduction' AS varchar(50))
FROM EmployeeDeduction ED
INNER JOIN Deduction D ON ED.DeductionID=D.DeductionID
INNER JOIN Employee E ON ED.EmployeeID=E.EmployeeID
INNER JOIN Person P ON E.EmployeeID=P.PersonID
INNER JOIN PersonX X ON P.PersonID=X.PersonID
INNER JOIN dbo.vwPersonListAs V ON P.PersonID=V.PersonID

UNION ALL

SELECT EB.EmployeeBenefitID, EB.EmployeeID, EB.BenefitID, EB.[Employee Premium], EB.Note,
B.Benefit, B.[Deduction Code],
P.[First Name], P.[Last Name], V.[List As],
E.[Employee Number],
X.SSN, TypeID=2, Type='Benefit'
FROM EmployeeBenefit EB
INNER JOIN Benefit B ON EB.BenefitID=B.BenefitID AND EB.[Employee Premium] <> 0
INNER JOIN Employee E ON EB.EmployeeID=E.EmployeeID
INNER JOIN Person P ON E.EmployeeID=P.PersonID
INNER JOIN PersonX X ON P.PersonID=X.PersonID
INNER JOIN dbo.vwPersonListAs V ON P.PersonID=V.PersonID

UNION ALL

-- TDRP: Employee Fixed
SELECT ET.EmployeeTDRPID, ET.EmployeeID, ET.TDRPID, ET.[Employee Fixed], ET.Note,
TDRP.TDRP, TDRP.[Deduction Code],
P.[First Name], P.[Last Name], V.[List As],
E.[Employee Number],
X.SSN, TypeID=3, Type='TDRP Fixed'
FROM EmployeeTDRP ET
INNER JOIN TDRP ON ET.TDRPID=TDRP.TDRPID AND ET.[Employee Fixed] <> 0
INNER JOIN Employee E ON ET.EmployeeID=E.EmployeeID
INNER JOIN Person P ON E.EmployeeID=P.PersonID
INNER JOIN PersonX X ON P.PersonID=X.PersonID
INNER JOIN dbo.vwPersonListAs V ON P.PersonID=V.PersonID

UNION ALL

-- TDRP: Catch Up
SELECT ET.EmployeeTDRPID, ET.EmployeeID, ET.TDRPID, ET.[Catch Up], ET.Note,
TDRP.TDRP, TDRP.[Deduction Code Catch Up],
P.[First Name], P.[Last Name], V.[List As],
E.[Employee Number],
X.SSN, TypeID=4, Type='TDRP Catch Up'
FROM EmployeeTDRP ET
INNER JOIN TDRP ON ET.TDRPID=TDRP.TDRPID AND ET.[Catch Up] <> 0
INNER JOIN Employee E ON ET.EmployeeID=E.EmployeeID
INNER JOIN Person P ON E.EmployeeID=P.PersonID
INNER JOIN PersonX X ON P.PersonID=X.PersonID
INNER JOIN dbo.vwPersonListAs V ON P.PersonID=V.PersonID

UNION ALL

-- TDRP: Loan Repay
SELECT ET.EmployeeTDRPID, ET.EmployeeID, ET.TDRPID, ET.[Catch Up], ET.Note,
TDRP.TDRP, TDRP.[Deduction Code Loan repay],
P.[First Name], P.[Last Name], V.[List As],
E.[Employee Number],
X.SSN, TypeID=5, Type='TDRP Loan Repay'
FROM EmployeeTDRP ET
INNER JOIN TDRP ON ET.TDRPID=TDRP.TDRPID AND ET.[Loan Repay] <> 0
INNER JOIN Employee E ON ET.EmployeeID=E.EmployeeID
INNER JOIN Person P ON E.EmployeeID=P.PersonID
INNER JOIN PersonX X ON P.PersonID=X.PersonID
INNER JOIN dbo.vwPersonListAs V ON P.PersonID=V.PersonID
GO
IF OBJECT_id('dbo.vwEmployeeDeductionUnionClear') IS NOT NULL DROP VIEW dbo.vwEmployeeDeductionUnionClear
GO
CREATE VIEW dbo.vwEmployeeDeductionUnionClear AS

SELECT Type=CAST('Deduction' AS varchar(50)), E.EmployeeID, D.DeductionID, E.[Employee Number], D.[Deduction Code]
FROM Deduction D CROSS JOIN Employee E 
LEFT JOIN EmployeeDeduction ED ON ED.EmployeeID=E.EmployeeID AND ED.DeductionID=D.DeductionID
WHERE ED.ItemID IS NULL OR ED.Amount = 0

UNION ALL

SELECT Type='Benefit', E.EmployeeID, B.BenefitID, E.[Employee Number], B.[Deduction Code]
FROM Benefit B CROSS JOIN Employee E
LEFT JOIN EmployeeBenefit EB ON EB.EmployeeID=E.EmployeeID AND EB.BenefitID=B.BenefitID
WHERE EB.EmployeeBenefitID IS NULL OR EB.[Employee Premium] = 0

UNION ALL

-- TDRP: Employee Fixed
SELECT Type='TDRP Fixed', E.EmployeeID, B.TDRPID, E.[Employee Number], B.[Deduction Code]
FROM TDRP B CROSS JOIN Employee E
LEFT JOIN EmployeeTDRP EB ON EB.EmployeeID=E.EmployeeID AND EB.TDRPID=B.TDRPID
WHERE EB.EmployeeTDRPID IS NULL OR EB.[Employee Fixed] = 0

UNION ALL


-- TDRP: Catch Up
SELECT Type='TDRP Catch Up', E.EmployeeID, B.TDRPID, E.[Employee Number], B.[Deduction Code Catch Up]
FROM TDRP B CROSS JOIN Employee E
LEFT JOIN EmployeeTDRP EB ON EB.EmployeeID=E.EmployeeID AND EB.TDRPID=B.TDRPID
WHERE EB.EmployeeTDRPID IS NULL OR EB.[Catch Up] = 0

UNION ALL

-- TDRP: Load Repay
SELECT Type='TDRP Loan Repay', E.EmployeeID, B.TDRPID, E.[Employee Number], B.[Deduction Code Loan Repay]
FROM TDRP B CROSS JOIN Employee E
LEFT JOIN EmployeeTDRP EB ON EB.EmployeeID=E.EmployeeID AND EB.TDRPID=B.TDRPID
WHERE EB.EmployeeTDRPID IS NULL OR EB.[Loan Repay] = 0
GO
ALTER PROC dbo.spEmployeeDeleteAll
AS
BEGIN TRAN

UPDATE ReminderType SET OwnerID=NULL
DELETE Payment
DELETE Invoice
UPDATE Equipment SET EmployeeID = NULL, [Checked Out Day past 1900] = NULL, [Due Day past 1900] = NULL
UPDATE StandardTask SET OwnerEmployeeID = NULL, Owner = 2 WHERE OwnerEmployeeID IS NOT NULL
UPDATE Employee SET ManagerID = NULL
DELETE EmployeeLeaveUsed
DELETE Employee
DELETE PersonX
DELETE Person

COMMIT TRAN
GO
IF OBJECT_id('dbo.spLeaveInsertDay') IS NOT NULL DROP PROC dbo.spLeaveInsertDay
GO
CREATE PROC dbo.spLeaveInsertDay
	@employee_id int,
	@day int,
	@seconds int,
	@leave_id int = NULL
AS
DECLARE @authorized bit

-- Requires insert permission on Employee Leave and Tardiness Detail
EXEC dbo.spPermissionInsureForCurrentUserOnPerson @employee_id, 10001, 4, @authorized out

IF @authorized=0 RETURN

-- Is leave expected between expected departure and greater of expected return or authorization expires
SELECT TOP 1  @leave_id = LeaveID FROM EmployeeLeaveUsed WHERE (@leave_id IS NULL OR LeaveID=@leave_id) AND EmployeeID=@employee_id AND @day BETWEEN
ISNULL([Expected Departure Day past 1900], -2147483648) AND 

CASE
	WHEN [Authorization Expires Day past 1900] IS NOT NULL THEN [Authorization Expires Day past 1900]
	WHEN [Expected Return Day past 1900] IS NOT NULL THEN [Expected Return Day past 1900]
	ELSE 2147483647
END
ORDER BY [Start Day past 1900] DESC

IF @@ROWCOUNT  = 0
BEGIN
	RAISERROR ('Leave is not authorized for that date.', 16, 1)
	RETURN
END

-- Is leave out of certification
DECLARE @began_date char(11), @expired_date char(11)
SELECT @began_date = CAST(DATEADD(d,0,[First Certified Day past 1900]) AS char(11)),  @expired_date = CAST(DATEADD(d,0,[Recertify Day past 1900]) AS char(11)) FROM EmployeeLeaveUsed WHERE LeaveID=@leave_id AND (@day < [First Certified Day past 1900] OR @day > [Recertify Day past 1900])
IF @@ROWCOUNT  = 1
BEGIN
	DECLARE @msg varchar(100)
	IF @began_date IS NULL SET @msg = 'Leave needs to be recertified. Certification ends ' + @expired_date + '.'
	ELSE IF @expired_date IS NULL SET @msg = 'Leave needs to be recertified. Certification began ' + @began_date + '.'
	ELSE SET @msg = 'Leave needs to be recertified. Certification began ' + @began_date + ' and ends ' + @expired_date + '.'
	RAISERROR (@msg, 16, 1)
	RETURN
END

IF EXISTS(SELECT * FROM EmployeeLeaveUsedItem WHERE LeaveID=@leave_id AND [Day past 1900]=@day)
BEGIN
	RAISERROR ('Leave is already recorded for that date.', 16, 1)
	RETURN
END

DECLARE @atype_mask int, @stype_mask int, @ptype_mask int, @stype_id int
SELECT @atype_mask=ISNULL(SUM(TypeID), 0) FROM dbo.vwLeaveType WHERE Advanced=1

SELECT @ptype_mask = T.[Leave Type Mask] 
FROM EmployeeLeaveUsed U INNER JOIN LeaveApprovalType T ON U.LeaveID=@leave_id AND U.ApprovalTypeID=T.TypeID

SELECT TOP 1 @stype_id=TypeID FROM EmployeeLeaveUsedItem WHERE LeaveID=@leave_id ORDER BY [Day past 1900] DESC
IF @@ROWCOUNT=0
BEGIN
	SELECT TOP 1 @stype_id=TypeID FROM LeaveType WHERE (TypeID & @ptype_mask) != 0 ORDER BY [Order]
	IF @@ROWCOUNT=0
	BEGIN
		SELECT TOP 1 @stype_id=TypeID FROM LeaveType ORDER BY [Order]
		IF @@ROWCOUNT=0
		BEGIN
			RAISERROR ('At least one type of simple leave must be defined in the Windows client.', 16, 1)
			RETURN
		END
	END
END

INSERT EmployeeLeaveUsedItem(LeaveID, [Day past 1900], [PPE Day past 1900], TypeID, [Advanced Type Mask], Seconds)
SELECT @leave_id, @day, @day, @stype_id, @atype_mask & @ptype_mask, @seconds

EXEC dbo.spEmployeeLeaveUsedRecalc @leave_id
GO
GRANT EXEC ON dbo.spLeaveInsertDay TO public
GO
IF OBJECT_ID('dbo.EmployeeTDRPLogUpdate') IS NULL EXEC sp_executesql N'CREATE TRIGGER dbo.EmployeeTDRPLogUpdate ON dbo.EmployeeTDRP FOR UPDATE AS SELECT A=0'
GO
alter TRIGGER [dbo].EmployeeTDRPLogUpdate ON [dbo].[EmployeeTDRP] FOR UPDATE
AS
DECLARE @audit_TDRPs bit

SET NOCOUNT ON

EXEC dbo.spAuditGetOperation 536870912, 2, @audit_TDRPs OUT
IF @audit_TDRPs=0 RETURN

INSERT AuditTrail(SID, [User], RegardingPersonID, [ID], ObjectID, TableID, [Event Mask], Event)
SELECT SUSER_SID(), SUSER_SNAME(), I.EmployeeID, I.TDRPID, 536870912, 536870912, 2,
'TDRP Benefit changed. ' +
CASE WHEN I.EmployeeID=D.EmployeeID THEN '' ELSE 'Employee changed from ' + DP.[List As] + ' to ' + IP.[List As] + '. ' END +
CASE WHEN I.TDRPID=D.TDRPID THEN '' ELSE 'TDRP changed from ' + DTDRP.TDRP + ' to ' + ITDRP.TDRP + '. ' END +
CASE WHEN I.[Employee Contribution]=D.[Employee Contribution] THEN '' ELSE 'Employee Contribution changed from ' + CAST(CAST(D.[Employee Contribution] AS numeric(23,2)) AS varchar(50)) + ' to ' + CAST(CAST(I.[Employee Contribution] AS numeric(23,2)) AS varchar(50)) + '. ' END +
CASE WHEN I.[Employer Contribution]=D.[Employer Contribution] THEN '' ELSE 'Employer Contribution changed from ' + CAST(CAST(D.[Employer Contribution] AS numeric(23,2)) AS varchar(50)) + ' to ' + CAST(CAST(I.[Employer Contribution] AS numeric(23,2)) AS varchar(50)) + '. ' END +
CASE WHEN I.[Employee Fixed]=D.[Employee Fixed] THEN '' ELSE 'Employee Fixed changed from ' + CAST(CAST(D.[Employee Fixed] AS numeric(23,2)) AS varchar(50)) + ' to ' + CAST(CAST(I.[Employee Fixed] AS numeric(23,2)) AS varchar(50)) + '. ' END +
CASE WHEN I.[Employer Fixed]=D.[Employer Fixed] THEN '' ELSE 'Employer Fixed changed from ' + CAST(CAST(D.[Employer Fixed] AS numeric(23,2)) AS varchar(50)) + ' to ' + CAST(CAST(I.[Employer Fixed] AS numeric(23,2)) AS varchar(50)) + '. ' END +

CASE WHEN ISNULL(I.[Eligible Day past 1900],0x7FFFFFFF)=ISNULL(D.[Eligible Day past 1900], 0x7FFFFFFF) THEN '' ELSE 'Eligible changed from ' + CASE WHEN D.[Eligible Day past 1900] IS NULL THEN 'Unspecified' ELSE CAST(dbo.GetDateFromDaysPast1900(D.[Eligible Day past 1900]) AS char(11)) END + ' to ' + CASE WHEN I.[Eligible Day past 1900] IS NULL THEN 'Unspecified' ELSE CAST(dbo.GetDateFromDaysPast1900(I.[Eligible Day past 1900]) AS char(11)) END  + '. ' END +
CASE WHEN ISNULL(I.[Expires Day past 1900],0x7FFFFFFF)=ISNULL(D.[Expires Day past 1900], 0x7FFFFFFF) THEN '' ELSE 'Expires changed from ' + CASE WHEN D.[Expires Day past 1900] IS NULL THEN 'Unspecified' ELSE CAST(dbo.GetDateFromDaysPast1900(D.[Expires Day past 1900]) AS char(11)) END + ' to ' + CASE WHEN I.[Expires Day past 1900] IS NULL THEN 'Unspecified' ELSE CAST(dbo.GetDateFromDaysPast1900(I.[Expires Day past 1900]) AS char(11)) END  + '. ' END +
CASE WHEN ISNULL(I.[Notified Day past 1900],0x7FFFFFFF)=ISNULL(D.[Notified Day past 1900], 0x7FFFFFFF) THEN '' ELSE 'Notified changed from ' + CASE WHEN D.[Notified Day past 1900] IS NULL THEN 'Unspecified' ELSE CAST(dbo.GetDateFromDaysPast1900(D.[Notified Day past 1900]) AS char(11)) END + ' to ' + CASE WHEN I.[Notified Day past 1900] IS NULL THEN 'Unspecified' ELSE CAST(dbo.GetDateFromDaysPast1900(I.[Notified Day past 1900]) AS char(11)) END  + '. ' END +
CASE WHEN ISNULL(I.[First Enrolled Day past 1900],0x7FFFFFFF)=ISNULL(D.[First Enrolled Day past 1900], 0x7FFFFFFF) THEN '' ELSE 'First Enrolled changed from ' + CASE WHEN D.[First Enrolled Day past 1900] IS NULL THEN 'Unspecified' ELSE CAST(dbo.GetDateFromDaysPast1900(D.[First Enrolled Day past 1900]) AS char(11)) END + ' to ' + CASE WHEN I.[First Enrolled Day past 1900] IS NULL THEN 'Unspecified' ELSE CAST(dbo.GetDateFromDaysPast1900(I.[First Enrolled Day past 1900]) AS char(11)) END  + '. ' END +
CASE WHEN ISNULL(I.[Last Enrolled Day past 1900],0x7FFFFFFF)=ISNULL(D.[Last Enrolled Day past 1900], 0x7FFFFFFF) THEN '' ELSE 'Last Enrolled changed from ' + CASE WHEN D.[Last Enrolled Day past 1900] IS NULL THEN 'Unspecified' ELSE CAST(dbo.GetDateFromDaysPast1900(D.[Last Enrolled Day past 1900]) AS char(11)) END + ' to ' + CASE WHEN I.[Last Enrolled Day past 1900] IS NULL THEN 'Unspecified' ELSE CAST(dbo.GetDateFromDaysPast1900(I.[Last Enrolled Day past 1900]) AS char(11)) END  + '. ' END +
CASE WHEN ISNULL(I.[Declined Day past 1900],0x7FFFFFFF)=ISNULL(D.[Declined Day past 1900], 0x7FFFFFFF) THEN '' ELSE 'Declined changed from ' + CASE WHEN D.[Declined Day past 1900] IS NULL THEN 'Unspecified' ELSE CAST(dbo.GetDateFromDaysPast1900(D.[Declined Day past 1900]) AS char(11)) END + ' to ' + CASE WHEN I.[Declined Day past 1900] IS NULL THEN 'Unspecified' ELSE CAST(dbo.GetDateFromDaysPast1900(I.[Declined Day past 1900]) AS char(11)) END  + '. ' END +
CASE WHEN I.Note=D.Note THEN '' ELSE 'Note changed from ''' + D.Note + ''' to ''' + I.Note + '''. ' END
FROM inserted I INNER JOIN deleted D ON I.EmployeeTDRPID=D.EmployeeTDRPID
INNER JOIN dbo.TDRP ITDRP ON I.TDRPID=ITDRP.TDRPID
INNER JOIN dbo.TDRP DTDRP ON D.TDRPID = DTDRP.TDRPID
INNER JOIN dbo.vwPersonListAs IP ON I.EmployeeID = IP.PersonID
INNER JOIN dbo.vwPersonListAs DP ON D.EmployeeID = DP.PersonID
GO
IF OBJECT_ID('dbo.EmployeeTDRPLogInsert') IS NULL EXEC sp_executesql N'CREATE TRIGGER dbo.EmployeeTDRPLogInsert ON dbo.EmployeeTDRP FOR UPDATE AS SELECT A=0'
GO
ALTER TRIGGER dbo.EmployeeTDRPLogInsert ON [dbo].[EmployeeTDRP] FOR INSERT
AS
DECLARE @audit_TDRPs bit

SET NOCOUNT ON

EXEC dbo.spAuditGetOperation 536870912, 2, @audit_TDRPs OUT
IF @audit_TDRPs=0 RETURN

INSERT AuditTrail(SID, [User], RegardingPersonID, [ID], ObjectID, TableID, [Event Mask], Event)
SELECT SUSER_SID(), SUSER_SNAME(), D.EmployeeID, D.TDRPID, 536870912, 536870912, 8,
'TDRP Benefit inserted. ' +
'Employee ' + DP.[List As] + '. '  +
'TDRP ' + DTDRP.TDRP + ' . '  +
'Employee Contribution ' + CAST(CAST(D.[Employee Contribution] AS numeric(23,2)) AS varchar(50)) + '. '  +
'Employer Contribution ' + CAST(CAST(D.[Employer Contribution] AS numeric(23,2)) AS varchar(50)) + '. ' +
'Employee Fixed ' + CAST(CAST(D.[Employee Fixed] AS numeric(23,2)) AS varchar(50)) + ' to ' + CAST(CAST(D.[Employee Fixed] AS numeric(23,2)) AS varchar(50)) + '. '  +
'Employer Fixed ' + CAST(CAST(D.[Employer Fixed] AS numeric(23,2)) AS varchar(50)) + ' to ' + CAST(CAST(D.[Employer Fixed] AS numeric(23,2)) AS varchar(50)) + '. '  +
'Eligible ' + CASE WHEN D.[Eligible Day past 1900] IS NULL THEN 'Unspecified' ELSE CAST(dbo.GetDateFromDaysPast1900(D.[Eligible Day past 1900]) AS char(11)) END + '. '   +
'Expires ' + CASE WHEN D.[Expires Day past 1900] IS NULL THEN 'Unspecified' ELSE CAST(dbo.GetDateFromDaysPast1900(D.[Expires Day past 1900]) AS char(11)) END  + '. '  +
'Notified ' + CASE WHEN D.[Notified Day past 1900] IS NULL THEN 'Unspecified' ELSE CAST(dbo.GetDateFromDaysPast1900(D.[Notified Day past 1900]) AS char(11)) END +  '. '  +
'First Enrolled ' + CASE WHEN D.[First Enrolled Day past 1900] IS NULL THEN 'Unspecified' ELSE CAST(dbo.GetDateFromDaysPast1900(D.[First Enrolled Day past 1900]) AS char(11))  END +  '. '   +
'Last Enrolled ' + CASE WHEN D.[Last Enrolled Day past 1900] IS NULL THEN 'Unspecified' ELSE CAST(dbo.GetDateFromDaysPast1900(D.[Last Enrolled Day past 1900]) AS char(11)) END + '. '  +
'Declined ' + CASE WHEN D.[Declined Day past 1900] IS NULL THEN 'Unspecified' ELSE CAST(dbo.GetDateFromDaysPast1900(D.[Declined Day past 1900]) AS char(11)) END + '. '  + 
'Note ''' + D.Note + '''. ' 
FROM inserted D 
INNER JOIN dbo.TDRP DTDRP ON D.TDRPID = DTDRP.TDRPID
INNER JOIN dbo.vwPersonListAs DP ON D.EmployeeID = DP.PersonID
GO
IF OBJECT_ID('dbo.EmployeeTDRPLogDelete') IS NULL EXEC sp_executesql N'CREATE TRIGGER dbo.EmployeeTDRPLogDelete ON dbo.EmployeeTDRP FOR UPDATE AS SELECT A=0'
GO
ALTER TRIGGER dbo.EmployeeTDRPLogDelete ON dbo.EmployeeTDRP FOR DELETE
AS
DECLARE @audit_TDRPs bit

SET NOCOUNT ON

EXEC dbo.spAuditGetOperation 536870912, 2, @audit_TDRPs OUT
IF @audit_TDRPs=0 RETURN

INSERT AuditTrail(SID, [User], RegardingPersonID, [ID], ObjectID, TableID, [Event Mask], Event)
SELECT SUSER_SID(), SUSER_SNAME(), D.EmployeeID, D.TDRPID, 536870912, 536870912, 8,
'TDRP Benefit deleted. ' +
'Employee ' + DP.[List As] + '. '  +
'TDRP ' + DTDRP.TDRP + ' . '  +
'Employee Contribution ' + CAST(CAST(D.[Employee Contribution] AS numeric(23,2)) AS varchar(50)) + '. '  +
'Employer Contribution ' + CAST(CAST(D.[Employer Contribution] AS numeric(23,2)) AS varchar(50)) + '. ' +
'Employee Fixed ' + CAST(CAST(D.[Employee Fixed] AS numeric(23,2)) AS varchar(50)) + ' to ' + CAST(CAST(D.[Employee Fixed] AS numeric(23,2)) AS varchar(50)) + '. '  +
'Employer Fixed ' + CAST(CAST(D.[Employer Fixed] AS numeric(23,2)) AS varchar(50)) + ' to ' + CAST(CAST(D.[Employer Fixed] AS numeric(23,2)) AS varchar(50)) + '. '  +
 'Eligible ' + CASE WHEN D.[Eligible Day past 1900] IS NULL THEN 'Unspecified' ELSE CAST(dbo.GetDateFromDaysPast1900(D.[Eligible Day past 1900]) AS char(11)) END + '. '   +
'Expires ' + CASE WHEN D.[Expires Day past 1900] IS NULL THEN 'Unspecified' ELSE CAST(dbo.GetDateFromDaysPast1900(D.[Expires Day past 1900]) AS char(11)) END  + '. '  +



'Notified ' + CASE WHEN D.[Notified Day past 1900] IS NULL THEN 'Unspecified' ELSE CAST(dbo.GetDateFromDaysPast1900(D.[Notified Day past 1900]) AS char(11)) END +  '. '  +

'First Enrolled ' + CASE WHEN D.[First Enrolled Day past 1900] IS NULL THEN 'Unspecified' ELSE CAST(dbo.GetDateFromDaysPast1900(D.[First Enrolled Day past 1900]) AS char(11))  END +  '. '   +
'Last Enrolled ' + CASE WHEN D.[Last Enrolled Day past 1900] IS NULL THEN 'Unspecified' ELSE CAST(dbo.GetDateFromDaysPast1900(D.[Last Enrolled Day past 1900]) AS char(11)) END + '. '  +


'Declined ' + CASE WHEN D.[Declined Day past 1900] IS NULL THEN 'Unspecified' ELSE CAST(dbo.GetDateFromDaysPast1900(D.[Declined Day past 1900]) AS char(11)) END + '. '  +

+ 'Note ''' + D.Note + '''. ' 

FROM deleted D 
INNER JOIN dbo.TDRP DTDRP ON D.TDRPID = DTDRP.TDRPID
INNER JOIN dbo.vwPersonListAs DP ON D.EmployeeID = DP.PersonID
GO
CREATE TRIGGER dbo.EmployeeLeaveEarnedLogInsert ON dbo.EmployeeLeaveEarned FOR INSERT
AS
IF EXISTS(SELECT * FROM inserted WHERE [Auto]=0)
BEGIN
	DECLARE @audit_insert bit
	EXEC dbo.spAuditGetOperation 10001, 4, @audit_insert OUT
	IF @audit_insert=0 RETURN

	INSERT AuditTrail(SID, [User], RegardingPersonID, [ID], ObjectID, TableID, [Event Mask], Event)
	SELECT SUSER_SID(), SUSER_SNAME(), ELE.EmployeeID, ELE.LeaveID, 10001, 10003, 4,
	'Inserted leave adjustment. ' +
	'Hrs=' + CAST(CAST((ELE.Seconds / 3600.00) AS numeric(9,2)) AS varchar(50)) +
	',Type=' + CAST(TT.Type AS varchar(50))  + 
	CASE WHEN ELE.[Note] = '' THEN '' ELSE ',Note=' + CAST(ELE.[Note] AS varchar(50)) END + 
	',Date=' + CAST(DATEADD(Day,0,ELE.[Day past 1900]) AS varchar(11))
	FROM inserted ELE
	INNER JOIN LeaveType TT ON ELE.TypeID=TT.TypeID AND ELE.[Auto] = 0

	EXEC dbo.spAuditLogPurge
END
GO
CREATE TRIGGER dbo.EmployeeLeaveEarnedLogDelete ON dbo.EmployeeLeaveEarned FOR DELETE
AS
DECLARE @audit_delete bit
EXEC dbo.spAuditGetOperation 10001, 8, @audit_delete OUT
IF @audit_delete=0 RETURN
INSERT AuditTrail(SID, [User], RegardingPersonID, [ID], ObjectID, TableID, [Event Mask], Event)
SELECT SUSER_SID(), SUSER_SNAME(), D.EmployeeID, D.LeaveID, 10001, 10003, 8,
'Deleted leave adjustment. ' +
'Hrs=' + CAST(CAST(D.Seconds / 3600.00 AS numeric(9,2)) AS varchar(50)) +
',Type=' + TT.Type +
CASE WHEN D.[Note] = '' THEN '' ELSE ',Note=' + CAST(D.[Note] AS varchar(50)) END + 
', Date=' + CAST(DATEADD(Day,0,D.[Day past 1900]) AS varchar(11))
FROM deleted D
INNER JOIN LeaveType TT ON D.TypeID=TT.TypeID AND D.Auto = 0

EXEC dbo.spAuditLogPurge
GO
CREATE TRIGGER dbo.EmployeeLeaveEarnedLogUpdate ON dbo.EmployeeLeaveEarned FOR UPDATE
AS
DECLARE @audit_update bit

EXEC dbo.spAuditGetOperation 10001, 2, @audit_update OUT
IF @audit_update=0 RETURN

INSERT AuditTrail(SID, [User], RegardingPersonID, [ID], ObjectID, TableID, [Event Mask], Event)
SELECT SUSER_SID(), SUSER_SNAME(), D.EmployeeID, D.LeaveID, 10001, 10003, 2,
'Updated leave adjustment. ' +
SUBSTRING(
	CASE WHEN D.TypeID = I.TypeID THEN '' ELSE ',Type changed from ' + DT.[Type] + ' to ' + [IT].[Type] END +
	CASE 
		WHEN I.Seconds = D.Seconds AND I.TypeID = D.TypeID THEN '' 
		WHEN I.Seconds = D.Seconds AND I.TypeID <> D.TypeID THEN ',Hrs=' + CAST(CAST((I.Seconds / 3600.00) AS numeric(9,2)) AS varchar(50)) 
		ELSE ',Hrs changed from ' + CAST(CAST((D.Seconds / 3600.00) AS numeric(9,2)) AS varchar(50))  + ' to ' + CAST(CAST((I.Seconds / 3600.00) AS numeric(9,2)) AS varchar(50)) 
	END + 
	CASE WHEN I.TypeID = D.TypeID THEN '' ELSE ',Type changed from ' + DT.Type + ' to ' + IT.Type END +
	CASE WHEN D.[Note] = I.[Note] THEN '' ELSE ',Note changed from ' + D.[Note] + ' to ' + I.[Note] END +
	CASE WHEN D.[Day past 1900] = I.[Day past 1900] THEN '' ELSE ',Date changed from ' + CAST(dbo.GetDateFromDaysPast1900(D.[Day past 1900]) As varchar(11)) + ' to ' + CAST(dbo.GetDateFromDaysPast1900(I.[Day past 1900]) As varchar(11)) END

,2,4000)

FROM deleted D
INNER JOIN inserted I ON D.LeaveID=I.LeaveID
INNER JOIN LeaveType IT ON I.TypeID = IT.TypeID
INNER JOIN LeaveType DT ON D.TypeID = DT.TypeID

EXEC dbo.spAuditLogPurge
GO
IF OBJECT_ID('dbo.EmployeeLeaveUsedItemLogDelete') IS NULL EXEC sp_executesql N'CREATE TRIGGER dbo.EmployeeLeaveUsedItemLogDelete ON dbo.EmployeeLeaveUsedItem FOR DELETE AS SELECT A=0'
GO
ALTER TRIGGER dbo.EmployeeLeaveUsedItemLogDelete ON dbo.EmployeeLeaveUsedItem FOR DELETE
AS
SET NOCOUNT ON
DECLARE @audit_delete bit

EXEC dbo.spAuditGetOperation 10001, 8, @audit_delete OUT
IF @audit_delete=0 RETURN

INSERT AuditTrail(SID, [User], RegardingPersonID, [ID], ObjectID, TableID, [Event Mask], Event)
SELECT SUSER_SID(), SUSER_SNAME(), U.EmployeeID, ID.LeaveID, 10001, 10003, 8,
'Deleted item in leave of absence. ' +
'Hrs=' + CAST(CAST(ID.Seconds / 3600.00 AS numeric(9,2)) AS varchar(50))+
',Type=' + TT.Type +
CASE WHEN DT1.Type IS NULL THEN '' ELSE ' ' + DT1.Type END +
CASE WHEN DT2.Type IS NULL THEN '' ELSE ' ' + DT2.Type END +
CASE WHEN DT3.Type IS NULL THEN '' ELSE ' ' + DT3.Type END +
CASE WHEN DT4.Type IS NULL THEN '' ELSE ' ' + DT4.Type END +
CASE WHEN DT5.Type IS NULL THEN '' ELSE ' ' + DT5.Type END +
CASE WHEN DT6.Type IS NULL THEN '' ELSE ' ' + DT6.Type END +
CASE WHEN DT7.Type IS NULL THEN '' ELSE ' ' + DT7.Type END +
CASE WHEN DT8.Type IS NULL THEN '' ELSE ' ' + DT8.Type END +
CASE WHEN DT9.Type IS NULL THEN '' ELSE ' ' + DT9.Type END +
CASE WHEN DT10.Type IS NULL THEN '' ELSE ' ' + DT10.Type END +
CASE WHEN DT11.Type IS NULL THEN '' ELSE ' ' + DT11.Type END +
CASE WHEN DT12.Type IS NULL THEN '' ELSE ' ' + DT12.Type END +
CASE WHEN DT13.Type IS NULL THEN '' ELSE ' ' + DT13.Type END +
CASE WHEN DT14.Type IS NULL THEN '' ELSE ' ' + DT14.Type END +
CASE WHEN DT15.Type IS NULL THEN '' ELSE ' ' + DT15.Type END +
CASE WHEN DT16.Type IS NULL THEN '' ELSE ' ' + DT16.Type END +
CASE WHEN DT17.Type IS NULL THEN '' ELSE ' ' + DT17.Type END +
CASE WHEN DT18.Type IS NULL THEN '' ELSE ' ' + DT18.Type END +
CASE WHEN DT19.Type IS NULL THEN '' ELSE ' ' + DT19.Type END +
CASE WHEN DT20.Type IS NULL THEN '' ELSE ' ' + DT20.Type END +
CASE WHEN DT21.Type IS NULL THEN '' ELSE ' ' + DT21.Type END +
CASE WHEN DT22.Type IS NULL THEN '' ELSE ' ' + DT22.Type END +
CASE WHEN DT23.Type IS NULL THEN '' ELSE ' ' + DT23.Type END +
CASE WHEN DT24.Type IS NULL THEN '' ELSE ' ' + DT24.Type END +
CASE WHEN DT25.Type IS NULL THEN '' ELSE ' ' + DT25.Type END +
CASE WHEN DT26.Type IS NULL THEN '' ELSE ' ' + DT26.Type END +
CASE WHEN DT27.Type IS NULL THEN '' ELSE ' ' + DT27.Type END +
CASE WHEN DT28.Type IS NULL THEN '' ELSE ' ' + DT28.Type END +
CASE WHEN DT29.Type IS NULL THEN '' ELSE ' ' + DT29.Type END +
CASE WHEN DT30.Type IS NULL THEN '' ELSE ' ' + DT30.Type END +
CASE WHEN DT31.Type IS NULL THEN '' ELSE ' ' + DT31.Type END +

CASE WHEN ID.[Day past 1900] = 0 THEN '' ELSE ', Date=' + CAST(dbo.GetDateFromDaysPast1900(ID.[Day past 1900]) AS varchar(11)) END
FROM deleted ID
INNER JOIN LeaveType TT ON ID.TypeID=TT.TypeID
INNER JOIN EmployeeLeaveUsed U ON U.LeaveID = ID.LeaveID

LEFT JOIN LeaveType DT1 ON ID.[Advanced Type Mask] & 1 = 1 AND DT1.TypeID=1
LEFT JOIN LeaveType DT2 ON ID.[Advanced Type Mask] & 2 = 2 AND DT2.TypeID=2
LEFT JOIN LeaveType DT3 ON ID.[Advanced Type Mask] & 4 = 4 AND DT3.TypeID=4
LEFT JOIN LeaveType DT4 ON ID.[Advanced Type Mask] & 8 = 8 AND DT4.TypeID=8
LEFT JOIN LeaveType DT5 ON ID.[Advanced Type Mask] & 0x10 = 0x10 AND DT5.TypeID=0x10
LEFT JOIN LeaveType DT6 ON ID.[Advanced Type Mask] & 0x20 = 0x20 AND DT6.TypeID=0x20
LEFT JOIN LeaveType DT7 ON ID.[Advanced Type Mask] & 0x40 = 0x40 AND DT7.TypeID=0x40
LEFT JOIN LeaveType DT8 ON ID.[Advanced Type Mask] & 0x80 = 0x80 AND DT8.TypeID=0x80
LEFT JOIN LeaveType DT9 ON ID.[Advanced Type Mask] & 0x100 = 0x100 AND DT9.TypeID=0x100
LEFT JOIN LeaveType DT10 ON ID.[Advanced Type Mask] & 0x200 = 0x200 AND DT10.TypeID=0x200
LEFT JOIN LeaveType DT11 ON ID.[Advanced Type Mask] & 0x400 = 0x400 AND DT11.TypeID=0x400
LEFT JOIN LeaveType DT12 ON ID.[Advanced Type Mask] & 0x800 = 0x800 AND DT12.TypeID=0x800
LEFT JOIN LeaveType DT13 ON ID.[Advanced Type Mask] & 0x1000 = 0x1000 AND DT13.TypeID=0x1000
LEFT JOIN LeaveType DT14 ON ID.[Advanced Type Mask] & 0x2000 = 0x2000 AND DT14.TypeID=0x2000
LEFT JOIN LeaveType DT15 ON ID.[Advanced Type Mask] & 0x4000 = 0x4000 AND DT15.TypeID=0x4000
LEFT JOIN LeaveType DT16 ON ID.[Advanced Type Mask] & 0x8000 = 0x8000 AND DT16.TypeID=0x8000
LEFT JOIN LeaveType DT17 ON ID.[Advanced Type Mask] & 0x10000 = 0x10000 AND DT17.TypeID=0x10000
LEFT JOIN LeaveType DT18 ON ID.[Advanced Type Mask] & 0x20000 = 0x20000 AND DT18.TypeID=0x20000
LEFT JOIN LeaveType DT19 ON ID.[Advanced Type Mask] & 0x40000 = 0x40000 AND DT19.TypeID=0x40000
LEFT JOIN LeaveType DT20 ON ID.[Advanced Type Mask] & 0x80000 = 0x80000 AND DT20.TypeID=0x80000
LEFT JOIN LeaveType DT21 ON ID.[Advanced Type Mask] & 0x100000 = 0x100000 AND DT21.TypeID=0x100000
LEFT JOIN LeaveType DT22 ON ID.[Advanced Type Mask] & 0x200000 = 0x200000 AND DT22.TypeID=0x200000
LEFT JOIN LeaveType DT23 ON ID.[Advanced Type Mask] & 0x400000 = 0x400000 AND DT23.TypeID=0x400000
LEFT JOIN LeaveType DT24 ON ID.[Advanced Type Mask] & 0x800000 = 0x800000 AND DT24.TypeID=0x800000
LEFT JOIN LeaveType DT25 ON ID.[Advanced Type Mask] & 0x1000000 = 0x1000000 AND DT25.TypeID=0x1000000
LEFT JOIN LeaveType DT26 ON ID.[Advanced Type Mask] & 0x2000000 = 0x2000000 AND DT26.TypeID=0x2000000
LEFT JOIN LeaveType DT27 ON ID.[Advanced Type Mask] & 0x4000000 = 0x4000000 AND DT27.TypeID=0x4000000
LEFT JOIN LeaveType DT28 ON ID.[Advanced Type Mask] & 0x8000000 = 0x8000000 AND DT28.TypeID=0x8000000
LEFT JOIN LeaveType DT29 ON ID.[Advanced Type Mask] & 0x10000000 = 0x10000000 AND DT29.TypeID=0x10000000
LEFT JOIN LeaveType DT30 ON ID.[Advanced Type Mask] & 0x20000000 = 0x20000000 AND DT30.TypeID=0x20000000
LEFT JOIN LeaveType DT31 ON ID.[Advanced Type Mask] & 0x40000000 = 0x40000000 AND DT31.TypeID=0x40000000

EXEC dbo.spAuditLogPurge
GO
IF OBJECT_ID('dbo.EmployeeLeaveUsedItemLogInsert') IS NULL EXEC sp_executesql N'CREATE TRIGGER dbo.EmployeeLeaveUsedItemLogInsert ON dbo.EmployeeLeaveUsedItem FOR INSERT AS SELECT A=0'
GO
ALTER TRIGGER dbo.EmployeeLeaveUsedItemLogInsert ON dbo.EmployeeLeaveUsedItem FOR INSERT
AS
SET NOCOUNT ON
DECLARE @audit_insert bit
EXEC dbo.spAuditGetOperation 10001, 4, @audit_insert OUT
IF @audit_insert=0 RETURN

INSERT AuditTrail(SID, [User], RegardingPersonID, [ID], ObjectID, TableID, [Event Mask], Event)
SELECT SUSER_SID(), SUSER_SNAME(), U.EmployeeID, I.LeaveID, 10001, 10002, 4,
'Inserted item into leave of absence. ' +
'Hrs=' + CAST(CAST((I.Seconds / 3600.00) AS numeric(9,2)) AS varchar(50))+   
',Type=' + CAST(TT.[Type] AS varchar(50)) +
CASE WHEN IT1.Type IS NULL THEN '' ELSE ' ' + IT1.Type END +
	CASE WHEN IT2.Type IS NULL THEN '' ELSE ' ' + IT2.Type END +
	CASE WHEN IT3.Type IS NULL THEN '' ELSE ' ' + IT3.Type END +
	CASE WHEN IT4.Type IS NULL THEN '' ELSE ' ' + IT4.Type END +
	CASE WHEN IT5.Type IS NULL THEN '' ELSE ' ' + IT5.Type END +
	CASE WHEN IT6.Type IS NULL THEN '' ELSE ' ' + IT6.Type END +
	CASE WHEN IT7.Type IS NULL THEN '' ELSE ' ' + IT7.Type END +
	CASE WHEN IT8.Type IS NULL THEN '' ELSE ' ' + IT8.Type END +
	CASE WHEN IT9.Type IS NULL THEN '' ELSE ' ' + IT9.Type END +
	CASE WHEN IT10.Type IS NULL THEN '' ELSE ' ' + IT10.Type END +
	CASE WHEN IT11.Type IS NULL THEN '' ELSE ' ' + IT11.Type END +
	CASE WHEN IT12.Type IS NULL THEN '' ELSE ' ' + IT12.Type END +
	CASE WHEN IT13.Type IS NULL THEN '' ELSE ' ' + IT13.Type END +
	CASE WHEN IT14.Type IS NULL THEN '' ELSE ' ' + IT14.Type END +
	CASE WHEN IT15.Type IS NULL THEN '' ELSE ' ' + IT15.Type END +
	CASE WHEN IT16.Type IS NULL THEN '' ELSE ' ' + IT16.Type END +
	CASE WHEN IT17.Type IS NULL THEN '' ELSE ' ' + IT17.Type END +
	CASE WHEN IT18.Type IS NULL THEN '' ELSE ' ' + IT18.Type END +
	CASE WHEN IT19.Type IS NULL THEN '' ELSE ' ' + IT19.Type END +
	CASE WHEN IT20.Type IS NULL THEN '' ELSE ' ' + IT20.Type END +
	CASE WHEN IT21.Type IS NULL THEN '' ELSE ' ' + IT21.Type END +
	CASE WHEN IT22.Type IS NULL THEN '' ELSE ' ' + IT22.Type END +
	CASE WHEN IT23.Type IS NULL THEN '' ELSE ' ' + IT23.Type END +
	CASE WHEN IT24.Type IS NULL THEN '' ELSE ' ' + IT24.Type END +
	CASE WHEN IT25.Type IS NULL THEN '' ELSE ' ' + IT25.Type END +
	CASE WHEN IT26.Type IS NULL THEN '' ELSE ' ' + IT26.Type END +
	CASE WHEN IT27.Type IS NULL THEN '' ELSE ' ' + IT27.Type END +
	CASE WHEN IT28.Type IS NULL THEN '' ELSE ' ' + IT28.Type END +
	CASE WHEN IT29.Type IS NULL THEN '' ELSE ' ' + IT29.Type END +
	CASE WHEN IT30.Type IS NULL THEN '' ELSE ' ' + IT30.Type END +
	CASE WHEN IT31.Type IS NULL THEN '' ELSE ' ' + IT31.Type END +
CASE WHEN I.[Day past 1900] = 0 THEN '' ELSE ',Date=' + CAST(dbo.GetDateFromDaysPast1900(I.[Day past 1900]) AS varchar(11)) END  
FROM inserted I
INNER JOIN LeaveType TT ON I.TypeID=TT.TypeID 
INNER JOIN EmployeeLeaveUsed U ON I.LeaveID=U.LeaveID

LEFT JOIN LeaveType IT1 ON I.[Advanced Type Mask] & 1 = 1 AND IT1.TypeID=1
LEFT JOIN LeaveType IT2 ON I.[Advanced Type Mask] & 2 = 2 AND IT2.TypeID=2
LEFT JOIN LeaveType IT3 ON I.[Advanced Type Mask] & 4 = 4 AND IT3.TypeID=4
LEFT JOIN LeaveType IT4 ON I.[Advanced Type Mask] & 8 = 8 AND IT4.TypeID=8
LEFT JOIN LeaveType IT5 ON I.[Advanced Type Mask] & 0x10 = 0x10 AND IT5.TypeID=0x10
LEFT JOIN LeaveType IT6 ON I.[Advanced Type Mask] & 0x20 = 0x20 AND IT6.TypeID=0x20
LEFT JOIN LeaveType IT7 ON I.[Advanced Type Mask] & 0x40 = 0x40 AND IT7.TypeID=0x40
LEFT JOIN LeaveType IT8 ON I.[Advanced Type Mask] & 0x80 = 0x80 AND IT8.TypeID=0x80
LEFT JOIN LeaveType IT9 ON I.[Advanced Type Mask] & 0x100 = 0x100 AND IT9.TypeID=0x100
LEFT JOIN LeaveType IT10 ON I.[Advanced Type Mask] & 0x200 = 0x200 AND IT10.TypeID=0x200
LEFT JOIN LeaveType IT11 ON I.[Advanced Type Mask] & 0x400 = 0x400 AND IT11.TypeID=0x400
LEFT JOIN LeaveType IT12 ON I.[Advanced Type Mask] & 0x800 = 0x800 AND IT12.TypeID=0x800
LEFT JOIN LeaveType IT13 ON I.[Advanced Type Mask] & 0x1000 = 0x1000 AND IT13.TypeID=0x1000
LEFT JOIN LeaveType IT14 ON I.[Advanced Type Mask] & 0x2000 = 0x2000 AND IT14.TypeID=0x2000
LEFT JOIN LeaveType IT15 ON I.[Advanced Type Mask] & 0x4000 = 0x4000 AND IT15.TypeID=0x4000
LEFT JOIN LeaveType IT16 ON I.[Advanced Type Mask] & 0x8000 = 0x8000 AND IT16.TypeID=0x8000
LEFT JOIN LeaveType IT17 ON I.[Advanced Type Mask] & 0x10000 = 0x10000 AND IT17.TypeID=0x10000
LEFT JOIN LeaveType IT18 ON I.[Advanced Type Mask] & 0x20000 = 0x20000 AND IT18.TypeID=0x20000
LEFT JOIN LeaveType IT19 ON I.[Advanced Type Mask] & 0x40000 = 0x40000 AND IT19.TypeID=0x40000
LEFT JOIN LeaveType IT20 ON I.[Advanced Type Mask] & 0x80000 = 0x80000 AND IT20.TypeID=0x80000
LEFT JOIN LeaveType IT21 ON I.[Advanced Type Mask] & 0x100000 = 0x100000 AND IT21.TypeID=0x100000
LEFT JOIN LeaveType IT22 ON I.[Advanced Type Mask] & 0x200000 = 0x200000 AND IT22.TypeID=0x200000
LEFT JOIN LeaveType IT23 ON I.[Advanced Type Mask] & 0x400000 = 0x400000 AND IT23.TypeID=0x400000
LEFT JOIN LeaveType IT24 ON I.[Advanced Type Mask] & 0x800000 = 0x800000 AND IT24.TypeID=0x800000
LEFT JOIN LeaveType IT25 ON I.[Advanced Type Mask] & 0x1000000 = 0x1000000 AND IT25.TypeID=0x1000000
LEFT JOIN LeaveType IT26 ON I.[Advanced Type Mask] & 0x2000000 = 0x2000000 AND IT26.TypeID=0x2000000
LEFT JOIN LeaveType IT27 ON I.[Advanced Type Mask] & 0x4000000 = 0x4000000 AND IT27.TypeID=0x4000000
LEFT JOIN LeaveType IT28 ON I.[Advanced Type Mask] & 0x8000000 = 0x8000000 AND IT28.TypeID=0x8000000
LEFT JOIN LeaveType IT29 ON I.[Advanced Type Mask] & 0x10000000 = 0x10000000 AND IT29.TypeID=0x10000000
LEFT JOIN LeaveType IT30 ON I.[Advanced Type Mask] & 0x20000000 = 0x20000000 AND IT30.TypeID=0x20000000
LEFT JOIN LeaveType IT31 ON I.[Advanced Type Mask] & 0x40000000 = 0x40000000 AND IT31.TypeID=0x40000000

EXEC dbo.spAuditLogPurge
GO
IF OBJECT_ID('dbo.EmployeeLeaveUsedItemLogUpdate') IS NULL EXEC sp_executesql N'CREATE TRIGGER dbo.EmployeeLeaveUsedItemLogUpdate ON dbo.EmployeeLeaveUsedItem FOR UPDATE AS SELECT A=0'
GO
ALTER TRIGGER dbo.EmployeeLeaveUsedItemLogUpdate ON dbo.[EmployeeLeaveUsedItem] FOR UPDATE
AS
SET NOCOUNT ON
DECLARE @audit_update bit

EXEC dbo.spAuditGetOperation 10001, 2, @audit_update OUT
IF @audit_update=0 RETURN

INSERT AuditTrail(SID, [User], RegardingPersonID, [ID], ObjectID, TableID, [Event Mask], Event)
SELECT SUSER_SID(), SUSER_SNAME(), U.EmployeeID, D.ItemID, 10001, 10002, 2,
'Updated Employee Leave Used Item. ' +
SUBSTRING(
	CASE WHEN D.TypeID = I.TypeID AND D.[Advanced Type Mask]=I.[Advanced Type Mask] THEN '' 
	ELSE ',Type changed from ' + DT.[Type] + 
	CASE WHEN DT1.Type IS NULL THEN '' ELSE ' ' + DT1.Type END +
	CASE WHEN DT2.Type IS NULL THEN '' ELSE ' ' + DT2.Type END +
	CASE WHEN DT3.Type IS NULL THEN '' ELSE ' ' + DT3.Type END +
	CASE WHEN DT4.Type IS NULL THEN '' ELSE ' ' + DT4.Type END +
	CASE WHEN DT5.Type IS NULL THEN '' ELSE ' ' + DT5.Type END +
	CASE WHEN DT6.Type IS NULL THEN '' ELSE ' ' + DT6.Type END +
	CASE WHEN DT7.Type IS NULL THEN '' ELSE ' ' + DT7.Type END +
	CASE WHEN DT8.Type IS NULL THEN '' ELSE ' ' + DT8.Type END +
	CASE WHEN DT9.Type IS NULL THEN '' ELSE ' ' + DT9.Type END +
	CASE WHEN DT10.Type IS NULL THEN '' ELSE ' ' + DT10.Type END +
	CASE WHEN DT11.Type IS NULL THEN '' ELSE ' ' + DT11.Type END +
	CASE WHEN DT12.Type IS NULL THEN '' ELSE ' ' + DT12.Type END +
	CASE WHEN DT13.Type IS NULL THEN '' ELSE ' ' + DT13.Type END +
	CASE WHEN DT14.Type IS NULL THEN '' ELSE ' ' + DT14.Type END +
	CASE WHEN DT15.Type IS NULL THEN '' ELSE ' ' + DT15.Type END +
	CASE WHEN DT16.Type IS NULL THEN '' ELSE ' ' + DT16.Type END +
	CASE WHEN DT17.Type IS NULL THEN '' ELSE ' ' + DT17.Type END +
	CASE WHEN DT18.Type IS NULL THEN '' ELSE ' ' + DT18.Type END +
	CASE WHEN DT19.Type IS NULL THEN '' ELSE ' ' + DT19.Type END +
	CASE WHEN DT20.Type IS NULL THEN '' ELSE ' ' + DT20.Type END +
	CASE WHEN DT21.Type IS NULL THEN '' ELSE ' ' + DT21.Type END +
	CASE WHEN DT22.Type IS NULL THEN '' ELSE ' ' + DT22.Type END +
	CASE WHEN DT23.Type IS NULL THEN '' ELSE ' ' + DT23.Type END +
	CASE WHEN DT24.Type IS NULL THEN '' ELSE ' ' + DT24.Type END +
	CASE WHEN DT25.Type IS NULL THEN '' ELSE ' ' + DT25.Type END +
	CASE WHEN DT26.Type IS NULL THEN '' ELSE ' ' + DT26.Type END +
	CASE WHEN DT27.Type IS NULL THEN '' ELSE ' ' + DT27.Type END +
	CASE WHEN DT28.Type IS NULL THEN '' ELSE ' ' + DT28.Type END +
	CASE WHEN DT29.Type IS NULL THEN '' ELSE ' ' + DT29.Type END +
	CASE WHEN DT30.Type IS NULL THEN '' ELSE ' ' + DT30.Type END +
	CASE WHEN DT31.Type IS NULL THEN '' ELSE ' ' + DT31.Type END +

	' to ' + [IT].[Type] +
	CASE WHEN IT1.Type IS NULL THEN '' ELSE ' ' + IT1.Type END +
	CASE WHEN IT2.Type IS NULL THEN '' ELSE ' ' + IT2.Type END +
	CASE WHEN IT3.Type IS NULL THEN '' ELSE ' ' + IT3.Type END +
	CASE WHEN IT4.Type IS NULL THEN '' ELSE ' ' + IT4.Type END +
	CASE WHEN IT5.Type IS NULL THEN '' ELSE ' ' + IT5.Type END +
	CASE WHEN IT6.Type IS NULL THEN '' ELSE ' ' + IT6.Type END +
	CASE WHEN IT7.Type IS NULL THEN '' ELSE ' ' + IT7.Type END +
	CASE WHEN IT8.Type IS NULL THEN '' ELSE ' ' + IT8.Type END +
	CASE WHEN IT9.Type IS NULL THEN '' ELSE ' ' + IT9.Type END +
	CASE WHEN IT10.Type IS NULL THEN '' ELSE ' ' + IT10.Type END +
	CASE WHEN IT11.Type IS NULL THEN '' ELSE ' ' + IT11.Type END +
	CASE WHEN IT12.Type IS NULL THEN '' ELSE ' ' + IT12.Type END +
	CASE WHEN IT13.Type IS NULL THEN '' ELSE ' ' + IT13.Type END +
	CASE WHEN IT14.Type IS NULL THEN '' ELSE ' ' + IT14.Type END +
	CASE WHEN IT15.Type IS NULL THEN '' ELSE ' ' + IT15.Type END +
	CASE WHEN IT16.Type IS NULL THEN '' ELSE ' ' + IT16.Type END +
	CASE WHEN IT17.Type IS NULL THEN '' ELSE ' ' + IT17.Type END +
	CASE WHEN IT18.Type IS NULL THEN '' ELSE ' ' + IT18.Type END +
	CASE WHEN IT19.Type IS NULL THEN '' ELSE ' ' + IT19.Type END +
	CASE WHEN IT20.Type IS NULL THEN '' ELSE ' ' + IT20.Type END +
	CASE WHEN IT21.Type IS NULL THEN '' ELSE ' ' + IT21.Type END +
	CASE WHEN IT22.Type IS NULL THEN '' ELSE ' ' + IT22.Type END +
	CASE WHEN IT23.Type IS NULL THEN '' ELSE ' ' + IT23.Type END +
	CASE WHEN IT24.Type IS NULL THEN '' ELSE ' ' + IT24.Type END +
	CASE WHEN IT25.Type IS NULL THEN '' ELSE ' ' + IT25.Type END +
	CASE WHEN IT26.Type IS NULL THEN '' ELSE ' ' + IT26.Type END +
	CASE WHEN IT27.Type IS NULL THEN '' ELSE ' ' + IT27.Type END +
	CASE WHEN IT28.Type IS NULL THEN '' ELSE ' ' + IT28.Type END +
	CASE WHEN IT29.Type IS NULL THEN '' ELSE ' ' + IT29.Type END +
	CASE WHEN IT30.Type IS NULL THEN '' ELSE ' ' + IT30.Type END +
	CASE WHEN IT31.Type IS NULL THEN '' ELSE ' ' + IT31.Type END
	END +
	
	CASE 
		WHEN I.Seconds = D.Seconds AND D.TypeID = I.TypeID THEN '' 
		WHEN I.Seconds = D.Seconds AND D.TypeID <> I.TypeID THEN ',Hrs=' + CAST(CAST((I.Seconds / 3600.00) AS numeric(9,2)) AS varchar(50)) 
		ELSE ',Hrs changed from ' + CAST(CAST((D.Seconds / 3600.00) AS numeric(9,2)) AS varchar(11))  + ' to ' + CAST(CAST((I.Seconds / 3600.00) AS numeric(9,2)) AS varchar(50)) 
	END + 
	CASE WHEN D.[Day past 1900] = I.[Day past 1900] THEN '' ELSE ',Date changed from ' + CAST(dbo.GetDateFromDaysPast1900(D.[Day past 1900]) As varchar(11)) + ' to ' + CAST(dbo.GetDateFromDaysPast1900(I.[Day past 1900]) As varchar(11)) END

,2,4000)

FROM deleted D
INNER JOIN inserted I ON D.LeaveID=I.LeaveID
INNER JOIN LeaveType IT ON I.TypeID = IT.TypeID
INNER JOIN LeaveType DT ON D.TypeID = DT.TypeID
INNER JOIN EmployeeLeaveUSed U ON I.LeaveID = U.LeaveID

LEFT JOIN LeaveType DT1 ON D.[Advanced Type Mask] & 1 = 1 AND DT1.TypeID=1
LEFT JOIN LeaveType DT2 ON D.[Advanced Type Mask] & 2 = 2 AND DT2.TypeID=2
LEFT JOIN LeaveType DT3 ON D.[Advanced Type Mask] & 4 = 4 AND DT3.TypeID=4
LEFT JOIN LeaveType DT4 ON D.[Advanced Type Mask] & 8 = 8 AND DT4.TypeID=8
LEFT JOIN LeaveType DT5 ON D.[Advanced Type Mask] & 0x10 = 0x10 AND DT5.TypeID=0x10
LEFT JOIN LeaveType DT6 ON D.[Advanced Type Mask] & 0x20 = 0x20 AND DT6.TypeID=0x20
LEFT JOIN LeaveType DT7 ON D.[Advanced Type Mask] & 0x40 = 0x40 AND DT7.TypeID=0x40
LEFT JOIN LeaveType DT8 ON D.[Advanced Type Mask] & 0x80 = 0x80 AND DT8.TypeID=0x80
LEFT JOIN LeaveType DT9 ON D.[Advanced Type Mask] & 0x100 = 0x100 AND DT9.TypeID=0x100
LEFT JOIN LeaveType DT10 ON D.[Advanced Type Mask] & 0x200 = 0x200 AND DT10.TypeID=0x200
LEFT JOIN LeaveType DT11 ON D.[Advanced Type Mask] & 0x400 = 0x400 AND DT11.TypeID=0x400
LEFT JOIN LeaveType DT12 ON D.[Advanced Type Mask] & 0x800 = 0x800 AND DT12.TypeID=0x800
LEFT JOIN LeaveType DT13 ON D.[Advanced Type Mask] & 0x1000 = 0x1000 AND DT13.TypeID=0x1000
LEFT JOIN LeaveType DT14 ON D.[Advanced Type Mask] & 0x2000 = 0x2000 AND DT14.TypeID=0x2000
LEFT JOIN LeaveType DT15 ON D.[Advanced Type Mask] & 0x4000 = 0x4000 AND DT15.TypeID=0x4000
LEFT JOIN LeaveType DT16 ON D.[Advanced Type Mask] & 0x8000 = 0x8000 AND DT16.TypeID=0x8000
LEFT JOIN LeaveType DT17 ON D.[Advanced Type Mask] & 0x10000 = 0x10000 AND DT17.TypeID=0x10000
LEFT JOIN LeaveType DT18 ON D.[Advanced Type Mask] & 0x20000 = 0x20000 AND DT18.TypeID=0x20000
LEFT JOIN LeaveType DT19 ON D.[Advanced Type Mask] & 0x40000 = 0x40000 AND DT19.TypeID=0x40000
LEFT JOIN LeaveType DT20 ON D.[Advanced Type Mask] & 0x80000 = 0x80000 AND DT20.TypeID=0x80000
LEFT JOIN LeaveType DT21 ON D.[Advanced Type Mask] & 0x100000 = 0x100000 AND DT21.TypeID=0x100000
LEFT JOIN LeaveType DT22 ON D.[Advanced Type Mask] & 0x200000 = 0x200000 AND DT22.TypeID=0x200000
LEFT JOIN LeaveType DT23 ON D.[Advanced Type Mask] & 0x400000 = 0x400000 AND DT23.TypeID=0x400000
LEFT JOIN LeaveType DT24 ON D.[Advanced Type Mask] & 0x800000 = 0x800000 AND DT24.TypeID=0x800000
LEFT JOIN LeaveType DT25 ON D.[Advanced Type Mask] & 0x1000000 = 0x1000000 AND DT25.TypeID=0x1000000
LEFT JOIN LeaveType DT26 ON D.[Advanced Type Mask] & 0x2000000 = 0x2000000 AND DT26.TypeID=0x2000000
LEFT JOIN LeaveType DT27 ON D.[Advanced Type Mask] & 0x4000000 = 0x4000000 AND DT27.TypeID=0x4000000
LEFT JOIN LeaveType DT28 ON D.[Advanced Type Mask] & 0x8000000 = 0x8000000 AND DT28.TypeID=0x8000000
LEFT JOIN LeaveType DT29 ON D.[Advanced Type Mask] & 0x10000000 = 0x10000000 AND DT29.TypeID=0x10000000
LEFT JOIN LeaveType DT30 ON D.[Advanced Type Mask] & 0x20000000 = 0x20000000 AND DT30.TypeID=0x20000000
LEFT JOIN LeaveType DT31 ON D.[Advanced Type Mask] & 0x40000000 = 0x40000000 AND DT31.TypeID=0x40000000

LEFT JOIN LeaveType IT1 ON I.[Advanced Type Mask] & 1 = 1 AND IT1.TypeID=1
LEFT JOIN LeaveType IT2 ON I.[Advanced Type Mask] & 2 = 2 AND IT2.TypeID=2
LEFT JOIN LeaveType IT3 ON I.[Advanced Type Mask] & 4 = 4 AND IT3.TypeID=4
LEFT JOIN LeaveType IT4 ON I.[Advanced Type Mask] & 8 = 8 AND IT4.TypeID=8
LEFT JOIN LeaveType IT5 ON I.[Advanced Type Mask] & 0x10 = 0x10 AND IT5.TypeID=0x10
LEFT JOIN LeaveType IT6 ON I.[Advanced Type Mask] & 0x20 = 0x20 AND IT6.TypeID=0x20
LEFT JOIN LeaveType IT7 ON I.[Advanced Type Mask] & 0x40 = 0x40 AND IT7.TypeID=0x40
LEFT JOIN LeaveType IT8 ON I.[Advanced Type Mask] & 0x80 = 0x80 AND IT8.TypeID=0x80
LEFT JOIN LeaveType IT9 ON I.[Advanced Type Mask] & 0x100 = 0x100 AND IT9.TypeID=0x100
LEFT JOIN LeaveType IT10 ON I.[Advanced Type Mask] & 0x200 = 0x200 AND IT10.TypeID=0x200
LEFT JOIN LeaveType IT11 ON I.[Advanced Type Mask] & 0x400 = 0x400 AND IT11.TypeID=0x400
LEFT JOIN LeaveType IT12 ON I.[Advanced Type Mask] & 0x800 = 0x800 AND IT12.TypeID=0x800
LEFT JOIN LeaveType IT13 ON I.[Advanced Type Mask] & 0x1000 = 0x1000 AND IT13.TypeID=0x1000
LEFT JOIN LeaveType IT14 ON I.[Advanced Type Mask] & 0x2000 = 0x2000 AND IT14.TypeID=0x2000
LEFT JOIN LeaveType IT15 ON I.[Advanced Type Mask] & 0x4000 = 0x4000 AND IT15.TypeID=0x4000
LEFT JOIN LeaveType IT16 ON I.[Advanced Type Mask] & 0x8000 = 0x8000 AND IT16.TypeID=0x8000
LEFT JOIN LeaveType IT17 ON I.[Advanced Type Mask] & 0x10000 = 0x10000 AND IT17.TypeID=0x10000
LEFT JOIN LeaveType IT18 ON I.[Advanced Type Mask] & 0x20000 = 0x20000 AND IT18.TypeID=0x20000
LEFT JOIN LeaveType IT19 ON I.[Advanced Type Mask] & 0x40000 = 0x40000 AND IT19.TypeID=0x40000
LEFT JOIN LeaveType IT20 ON I.[Advanced Type Mask] & 0x80000 = 0x80000 AND IT20.TypeID=0x80000
LEFT JOIN LeaveType IT21 ON I.[Advanced Type Mask] & 0x100000 = 0x100000 AND IT21.TypeID=0x100000
LEFT JOIN LeaveType IT22 ON I.[Advanced Type Mask] & 0x200000 = 0x200000 AND IT22.TypeID=0x200000
LEFT JOIN LeaveType IT23 ON I.[Advanced Type Mask] & 0x400000 = 0x400000 AND IT23.TypeID=0x400000
LEFT JOIN LeaveType IT24 ON I.[Advanced Type Mask] & 0x800000 = 0x800000 AND IT24.TypeID=0x800000
LEFT JOIN LeaveType IT25 ON I.[Advanced Type Mask] & 0x1000000 = 0x1000000 AND IT25.TypeID=0x1000000
LEFT JOIN LeaveType IT26 ON I.[Advanced Type Mask] & 0x2000000 = 0x2000000 AND IT26.TypeID=0x2000000
LEFT JOIN LeaveType IT27 ON I.[Advanced Type Mask] & 0x4000000 = 0x4000000 AND IT27.TypeID=0x4000000
LEFT JOIN LeaveType IT28 ON I.[Advanced Type Mask] & 0x8000000 = 0x8000000 AND IT28.TypeID=0x8000000
LEFT JOIN LeaveType IT29 ON I.[Advanced Type Mask] & 0x10000000 = 0x10000000 AND IT29.TypeID=0x10000000
LEFT JOIN LeaveType IT30 ON I.[Advanced Type Mask] & 0x20000000 = 0x20000000 AND IT30.TypeID=0x20000000
LEFT JOIN LeaveType IT31 ON I.[Advanced Type Mask] & 0x40000000 = 0x40000000 AND IT31.TypeID=0x40000000

EXEC dbo.spAuditLogPurge
GO
IF OBJECT_ID('dbo.EmployeeLeaveUsedLogInsert') IS NULL EXEC sp_executesql N'CREATE TRIGGER dbo.EmployeeLeaveUsedLogInsert ON dbo.EmployeeLeaveUsed FOR INSERT AS SELECT A=0'
GO
ALTER TRIGGER dbo.EmployeeLeaveUsedLogInsert ON dbo.EmployeeLeaveUsed FOR INSERT
AS
SET NOCOUNT ON
DECLARE @audit_insert bit
EXEC dbo.spAuditGetOperation 10001, 4, @audit_insert OUT
IF @audit_insert=0 RETURN

INSERT AuditTrail(SID, [User], RegardingPersonID, [ID], ObjectID, TableID, [Event Mask], Event)
SELECT SUSER_SID(), SUSER_SNAME(), U.EmployeeID, U.LeaveID, 10001, 10002, 4,
'Created leave of absence. ' +
'Status=' + dbo.fnGetStatusText(U.Status, A.[First Name], A.[Middle Name], A.[Last Name], U.[Authorized Day past 1900], LAT.[Type], D.Reason) +
',Requested=' + CAST(DATEADD(d,0,[Requested Day past 1900]) AS varchar(11)) 
FROM inserted U
LEFT JOIN dbo.Person A ON U.AuthorizingEmployeeID = A.PersonID
LEFT JOIN dbo.DenialReason D ON U.DenialReasonID = D.DenialReasonID
LEFT JOIN dbo.LeaveApprovalType LAT ON U.ApprovalTypeID = LAT.TypeID

EXEC dbo.spAuditLogPurge
GO
IF OBJECT_ID('dbo.EmployeeLeaveUsedLogUpdate') IS NULL EXEC sp_executesql N'CREATE TRIGGER dbo.EmployeeLeaveUsedLogUpdate ON dbo.EmployeeLeaveUsed FOR UPDATE AS SELECT A=0'
GO
ALTER TRIGGER dbo.EmployeeLeaveUsedLogUpdate ON dbo.EmployeeLeaveUsed FOR UPDATE
AS
SET NOCOUNT ON
IF NOT (UPDATE(Seconds) OR UPDATE(EmployeeID) OR UPDATE([Status]) OR UPDATE(ApprovalTypeID) OR UPDATE(DenialReasonID)) RETURN

DECLARE @audit_update bit
EXEC dbo.spAuditGetOperation 10001, 2, @audit_update OUT
IF @audit_update=0 RETURN

CREATE TABLE #EmployeeLeaveUsedStatusChanges(LeaveID int PRIMARY KEY, IStatus varchar(400) COLLATE SQL_Latin1_General_CP1_CI_AS, UStatus varchar(400) COLLATE SQL_Latin1_General_CP1_CI_AS, [Event] varchar(400) COLLATE SQL_Latin1_General_CP1_CI_AS, Changed bit)

INSERT #EmployeeLeaveUsedStatusChanges
SELECT U.LeaveID,
IStatus = ISNULL(dbo.fnGetStatusText(I.Status, IA.[First Name], IA.[Middle Name], IA.[Last Name], I.[Authorized Day past 1900], ILAT.[Type], ID.Reason), 'NULL'),
UStatus = ISNULL(dbo.fnGetStatusText(U.Status, UA.[First Name], UA.[Middle Name], UA.[Last Name], U.[Authorized Day past 1900], ULAT.[Type], UD.Reason), 'NULL'),
[Event] = '',
Changed = CASE WHEN
	I.EmployeeID <> U.EmployeeID OR I.Seconds <> U.Seconds THEN 1
	ELSE 0
END

FROM inserted I
INNER JOIN deleted U ON I.LeaveID=U.LeaveID

LEFT JOIN dbo.Person UA ON U.AuthorizingEmployeeID = UA.PersonID
LEFT JOIN dbo.DenialReason UD ON U.DenialReasonID = UD.DenialReasonID
LEFT JOIN dbo.LeaveApprovalType ULAT ON U.ApprovalTypeID = ULAT.TypeID

LEFT JOIN dbo.Person IA ON I.AuthorizingEmployeeID = IA.PersonID
LEFT JOIN dbo.DenialReason ID ON I.DenialReasonID = ID.DenialReasonID
LEFT JOIN dbo.LeaveApprovalType ILAT ON I.ApprovalTypeID = ILAT.TypeID

UPDATE #EmployeeLeaveUsedStatusChanges SET [Event] = CASE
	WHEN UStatus = IStatus THEN ''
	ELSE ' New Status=' + IStatus + ',Old Status=' + UStatus + '.'
END, Changed = CASE
	WHEN UStatus = IStatus THEN Changed
	ELSE 1
END


INSERT AuditTrail(SID, [User], RegardingPersonID, [ID], ObjectID, TableID, [Event Mask], Event)
SELECT SUSER_SID(), SUSER_SNAME(), U.EmployeeID, U.LeaveID, 10001, 10002, 2,
'Changed leave of absence.' + 
CASE WHEN I.EmployeeID != U.EmployeeID THEN 
	' Employee changed from ' + dbo.fnGetListAs(UP.[First Name], UP.[Middle Name], UP.[Last Name], UP.Suffix) + ' to ' +
	dbo.fnGetListAs(IP.[First Name], IP.[Middle Name], IP.[Last Name], IP.Suffix) + '. '
ELSE '' END +
CASE 
	WHEN I.Seconds = U.Seconds THEN ''
	WHEN U.Seconds = 0 THEN ' Total hrs set to ' + CAST(CAST(I.Seconds / 3600.00 AS numeric(21,2)) AS varchar(50)) + '.'
	ELSE ' Total hrs changed from ' + CAST(CAST(U.Seconds / 3600.00 AS numeric(21,2)) AS varchar(50)) + ' to ' + CAST(CAST(I.Seconds / 3600.00 AS numeric(21,2)) AS varchar(50)) + '.'
END +
C.[Event]
FROM inserted I
INNER JOIN deleted U ON I.LeaveID=U.LeaveID
INNER JOIN #EmployeeLeaveUsedStatusChanges C ON C.LeaveID=I.LeaveID AND C.Changed=1
INNER JOIN dbo.Person UP ON U.EmployeeID = UP.PersonID
INNER JOIN dbo.Person IP ON I.EmployeeID = IP.PersonID

EXEC dbo.spAuditLogPurge
GO
IF OBJECT_ID('dbo.EmployeeLeaveUsedLogDelete') IS NULL EXEC sp_executesql N'CREATE TRIGGER dbo.EmployeeLeaveUsedLogDelete ON dbo.EmployeeLeaveUsed FOR INSERT AS SELECT A=0'
GO
ALTER TRIGGER dbo.EmployeeLeaveUsedLogDelete ON dbo.EmployeeLeaveUsed FOR DELETE
AS
SET NOCOUNT ON
DECLARE @audit_deleted bit
EXEC dbo.spAuditGetOperation 10001, 8, @audit_deleted OUT
IF @audit_deleted=0 RETURN

INSERT AuditTrail(SID, [User], RegardingPersonID, [ID], ObjectID, TableID, [Event Mask], Event)
SELECT SUSER_SID(), SUSER_SNAME(), U.EmployeeID, U.LeaveID, 10001, 10002, 8,
'Deleted leave of absence. ' +
'Status=' + dbo.fnGetStatusText(U.Status, A.[First Name], A.[Middle Name], A.[Last Name], U.[Authorized Day past 1900], LAT.[Type], D.Reason) +
',Requested=' + CAST(DATEADD(d,0,[Requested Day past 1900]) AS varchar(11)) +
',Total Hrs=' + CAST(CAST(U.Seconds / 3600.00 AS numeric(21,2)) AS varchar(50)) + '.'
FROM deleted U
LEFT JOIN dbo.Person A ON U.AuthorizingEmployeeID = A.PersonID
LEFT JOIN dbo.DenialReason D ON U.DenialReasonID = D.DenialReasonID
LEFT JOIN dbo.LeaveApprovalType LAT ON U.ApprovalTypeID = LAT.TypeID

EXEC dbo.spAuditLogPurge
GO
CREATE TRIGGER dbo.PersonLogInsert ON dbo.Person FOR INSERT
AS
DECLARE @person bit

EXEC dbo.spAuditGetOperation 0, 4, @person OUT
IF @person=0 RETURN

INSERT AuditTrail(SID, [User], RegardingPersonID, [ID], ObjectID, TableID, [Event Mask], Event)
SELECT SUSER_SID(), SUSER_SNAME(), I.PersonID, I.PersonID, 1, 1, 4,
'Person inserted. ' + I.[First Name] + ' ' + I.[Last Name]
FROM inserted I

EXEC dbo.spAuditLogPurge
GO
CREATE TRIGGER dbo.PersonLogDelete ON dbo.Person FOR INSERT
AS
DECLARE @person bit

EXEC dbo.spAuditGetOperation 0, 8, @person OUT
IF @person=0 RETURN

INSERT AuditTrail(SID, [User], RegardingPersonID, [ID], ObjectID, TableID, [Event Mask], Event)
SELECT SUSER_SID(), SUSER_SNAME(), I.PersonID, I.PersonID, 1, 1, 4,
'Person deleted. ' + I.[First Name] + ' ' + I.[Last Name]
FROM inserted I

EXEC dbo.spAuditLogPurge
GO
CREATE TRIGGER dbo.PersonLogUpdate ON dbo.Person FOR UPDATE
AS
DECLARE @work bit, @home bit

EXEC dbo.spAuditGetOperation 1, 2, @home OUT
EXEC dbo.spAuditGetOperation 2, 2, @work OUT

IF @home=0 AND @work=0 RETURN

CREATE TABLE #PersonLogUpdateTemp(SID varbinary(85), [User] sysname COLLATE SQL_Latin1_General_CP1_CI_AS, RegardingPersonID int, [ID] int, ObjectID int, TableID int, [Event Mask] int, Event varchar(4000) COLLATE SQL_Latin1_General_CP1_CI_AS)

INSERT #PersonLogUpdateTemp
SELECT SUSER_SID(), SUSER_SNAME(), I.PersonID, I.PersonID, 2, 1, 2,
CASE WHEN I.[Title]=D.[Title] THEN '' ELSE 'Title changed from ' + D.[Title] + ' to ' + I.[Title] END + '.' +
CASE WHEN I.[First Name]=D.[First Name] THEN '' ELSE 'FirstName changed from ' + D.[First Name] + ' to ' + I.[First Name] END + '.' +
CASE WHEN I.[Middle Name]=D.[Middle Name] THEN '' ELSE 'MiddleName changed from ' + D.[Middle Name] + ' to ' + I.[Middle Name] END + '.' +
CASE WHEN I.[Last Name]=D.[Last Name] THEN '' ELSE 'LastName changed from ' + D.[Last Name] + ' to ' + I.[Last Name] END + '.' +
CASE WHEN I.[Suffix]=D.[Suffix] THEN '' ELSE 'Suffix changed from ' + D.[Suffix] + ' to ' + I.[Suffix] END + '.' +
CASE WHEN I.[Work Phone]=D.[Work Phone] THEN '' ELSE 'WorkPhone changed from ' + D.[Work Phone] + ' to ' + I.[Work Phone] END + '.' +
CASE WHEN I.[Work Address]=D.[Work Address] THEN '' ELSE 'WorkAddress changed from ' + D.[Work Address] + ' to ' + I.[Work Address] END + '.' +
CASE WHEN I.[Work Address (cont.)]=D.[Work Address (cont.)] THEN '' ELSE 'WorkAddress2 changed from ' + D.[Work Address (cont.)] + ' to ' + I.[Work Address (cont.)] END + '.' +
CASE WHEN I.[Work City]=D.[Work City] THEN '' ELSE 'WorkCity changed from ' + D.[Work City] + ' to ' + I.[Work City] END + '.' +
CASE WHEN I.[Work State]=D.[Work State] THEN '' ELSE 'WorkState changed from ' + D.[Work State] + ' to ' + I.[Work State] END + '.' +
CASE WHEN I.[Work ZIP]=D.[Work ZIP] THEN '' ELSE 'WorkZIP changed from ' + D.[Work ZIP] + ' to ' + I.[Work ZIP] END + '.' +
CASE WHEN I.[Work Country]=D.[Work Country] THEN '' ELSE 'WorkCountry from ' + D.[Work Country] + ' to ' + I.[Work Country] END
FROM inserted I INNER JOIN deleted D ON @work=1 AND I.PersonID=D.PersonID

INSERT #PersonLogUpdateTemp
SELECT SUSER_SID(), SUSER_SNAME(), I.PersonID, I.PersonID, 1, 1, 2,
CASE WHEN I.[Home Phone]=D.[Home Phone] THEN '' ELSE 'HomePhone changed from ' + D.[Home Phone] + ' to ' + I.[Home Phone] END + '.' +
CASE WHEN I.[Home Address]=D.[Home Address] THEN '' ELSE 'HomeAddress changed from ' + D.[Home Address] + ' to ' + I.[Home Address] END + '.' +
CASE WHEN I.[Home Address (cont.)]=D.[Home Address (cont.)] THEN '' ELSE 'HomeAddress2 changed from ' + D.[Home Address (cont.)] + ' to ' + I.[Home Address (cont.)] END + '.' +
CASE WHEN I.[Home City]=D.[Home City] THEN '' ELSE 'HomeCity changed from ' + D.[Home City] + ' to ' + I.[Home City] END + '.' +
CASE WHEN I.[Home State]=D.[Home State] THEN '' ELSE 'HomeState changed from ' + D.[Home State] + ' to ' + I.[Home State] END + '.' +
CASE WHEN I.[Home ZIP]=D.[Home ZIP] THEN '' ELSE 'HomeZIP changed from ' + D.[Home ZIP] + ' to ' + I.[Home ZIP] END + '.' +
CASE WHEN I.[Home Country]=D.[Home Country] THEN '' ELSE 'HomeCountry from ' + D.[Home Country] + ' to ' + I.[Home Country] END + '.'
FROM inserted I INNER JOIN deleted D ON @home=1 AND I.PersonID=D.PersonID

INSERT AuditTrail(SID, [User], RegardingPersonID, [ID], ObjectID, TableID, [Event Mask], Event)
SELECT SID, [User], RegardingPersonID, [ID], ObjectID, TableID, [Event Mask], 
CASE WHEN ObjectID=2 THEN 'Person name/work contact changed. ' ELSE 'Person home contact changed.' END + Event
FROM #PersonLogUpdateTemp WHERE Event <> ''

EXEC dbo.spAuditLogPurge
GO
CREATE TRIGGER dbo.PersonXLogUpdate ON dbo.PersonX FOR UPDATE
AS
DECLARE @personal bit

EXEC dbo.spAuditGetOperation 4, 2, @personal OUT
IF @personal=0 RETURN

INSERT AuditTrail(SID, [User], RegardingPersonID, [ID], ObjectID, TableID, [Event Mask], Event)
SELECT SUSER_SID(), SUSER_SNAME(), I.PersonID, I.PersonID, 4, 4, 2,
'Personal information changed. ' +
CASE WHEN I.SSN=D.SSN THEN '' ELSE 'SSN changed from ' + D.SSN + ' to ' + I.SSN + '. ' END +
CASE WHEN I.RaceID=D.RaceID THEN '' ELSE 'Race changed from ' + DR.Race + ' to ' + IR.Race + '. ' END +
CASE 
	WHEN D.[DOB Day past 1900] IS NULL AND I.[DOB Day past 1900] IS NULL THEN ''
	WHEN D.[DOB Day past 1900] IS NULL AND I.[DOB Day past 1900] IS NOT NULL THEN 'DOB set to ' + CAST(dbo.GetDateFromDaysPast1900(I.[DOB Day past 1900]) As varchar(11)) + '. '
	WHEN D.[DOB Day past 1900] IS NOT NULL AND I.[DOB Day past 1900] IS NULL THEN 'DOB changed from ' + CAST(dbo.GetDateFromDaysPast1900(D.[DOB Day past 1900]) As varchar(11)) + ' to unspecified. '
	WHEN D.[DOB Day past 1900]=I.[DOB Day past 1900] THEN ''
	ELSE 'DOB changed from ' + CAST(dbo.GetDateFromDaysPast1900(D.[DOB Day past 1900]) As varchar(11)) + ' to ' + CAST(dbo.GetDateFromDaysPast1900(I.[DOB Day past 1900]) As varchar(11)) + '. '
END
FROM inserted I INNER JOIN deleted D ON I.PersonID=D.PersonID
INNER JOIN Race IR ON I.RaceID=IR.RaceID
INNER JOIN Race DR ON D.RaceID=DR.RaceID

EXEC dbo.spAuditLogPurge
GO
CREATE TRIGGER dbo.EmployeeTimeLogInsert ON EmployeeTime FOR INSERT
AS
DECLARE @audit_insert bit

EXEC dbo.spAuditGetOperation 262144, 4, @audit_insert OUT
IF @audit_insert=0 RETURN

INSERT AuditTrail(SID, [User], RegardingPersonID, [ID], ObjectID, TableID, [Event Mask], Event)
SELECT SUSER_SID(), SUSER_SNAME(), I.EmployeeID, I.ItemID, 262144, 262144, 4,
'Inserted time. ' +
'In=' + CAST(I.[In] AS varchar(50))  + 
',Hrs=' + CAST(CAST((I.Seconds / 3600.00) AS numeric(9,2)) AS varchar(50)) + ' (Out=' +  CAST(DATEADD(s,I.seconds,I.[In]) AS varchar(50)) + ')' +
',Type=' + TT.Type +
',Status=' + S.Status +
CASE WHEN I.[Employee Comment] = '' THEN '' ELSE ',Employee Comment=' + I.[Employee Comment] END + 
CASE WHEN I.[Manager Comment] = '' THEN '' ELSE ',Manager Comment=' + I.[Manager Comment] END + 
CASE WHEN I.[Pay Rate] = 0 THEN '' ELSE ',Pay Rate=' + CAST(I.[Pay Rate] AS varchar(50)) END + 
CASE WHEN I.[Fixed Pay] = 0 THEN '' ELSE ',Fixed Pay=' + CAST(I.[Fixed Pay] AS varchar(50)) END + 
CASE WHEN I.[Billing Rate] = 0 THEN '' ELSE ',Billing Rate=' + CAST(I.[Billing Rate] AS varchar(50)) END + 
CASE WHEN I.[Fixed Billing] = 0 THEN '' ELSE ',Fixed Billing=' + CAST(I.[Fixed Billing] AS varchar(50)) END + 
CASE WHEN I.[Odometer Start] = 0 THEN '' ELSE ',Odometer Start=' + CAST(I.[Odometer Start] AS varchar(50)) END + 
CASE WHEN I.[Odometer Stop] = 0 THEN '' ELSE ',Odometer Stop=' + CAST(I.[Odometer Stop] AS varchar(50)) END + 
CASE WHEN I.ProjectID IS NULL THEN '' ELSE ',ProjectID=' + P.Project END +
CASE WHEN I.SourceIn = '' THEN '' ELSE ',SourceIn=' + I.SourceIn END +
CASE WHEN I.SourceOut = '' THEN '' ELSE ',SourceOut=' + I.SourceOut END +
CASE WHEN I.[GMT+Hours] IS NULL THEN '' ELSE ',GMT+Hours=' + CAST(I.[GMT+Hours] AS varchar(50)) END
FROM inserted I
LEFT JOIN Project P ON I.ProjectID=P.ProjectID
INNER JOIN TimeType TT ON I.TypeID=TT.TypeID
INNER JOIN EmployeeTimeStatus S ON I.StatusID=S.StatusID

EXEC dbo.spAuditLogPurge
GO
CREATE TRIGGER dbo.EmployeeTimeLogDelete ON EmployeeTime FOR DELETE
AS
DECLARE @audit_delete bit

EXEC dbo.spAuditGetOperation 262144, 8, @audit_delete OUT
IF @audit_delete=0 RETURN

INSERT AuditTrail(SID, [User], RegardingPersonID, [ID], ObjectID, TableID, [Event Mask], Event)
SELECT SUSER_SID(), SUSER_SNAME(), D.EmployeeID, D.ItemID, 262144, 252144, 8,
'Deleted time. ' +
'In=' + CAST(D.[In] AS varchar(50))  + 
',Hrs=' + CAST(CAST(D.Seconds / 3600.00 AS numeric(9,2)) AS varchar(50)) + ' (Out=' +  CAST(DATEADD(s,D.seconds,D.[In]) AS varchar(50)) + ')' +
',Type=' + TT.Type +
',Status=' + S.Status +
CASE WHEN D.[Employee Comment] = '' THEN '' ELSE ',Employee Comment=' + D.[Employee Comment] END + 
CASE WHEN D.[Manager Comment] = '' THEN '' ELSE ',Manager Comment=' + D.[Manager Comment] END + 
CASE WHEN D.[Pay Rate] = 0 THEN '' ELSE ',Pay Rate=' + CAST(D.[Pay Rate] AS varchar(50)) END + 
CASE WHEN D.[Fixed Pay] = 0 THEN '' ELSE ',Fixed Pay=' + CAST(D.[Fixed Pay] AS varchar(50)) END + 
CASE WHEN D.[Billing Rate] = 0 THEN '' ELSE ',Billing Rate=' + CAST(D.[Billing Rate] AS varchar(50)) END + 
CASE WHEN D.[Fixed Billing] = 0 THEN '' ELSE ',Fixed Billing=' + CAST(D.[Fixed Billing] AS varchar(50)) END + 
CASE WHEN D.[Odometer Start] = 0 THEN '' ELSE ',Odometer Start=' + CAST(D.[Odometer Start] AS varchar(50)) END + 
CASE WHEN D.[Odometer Stop] = 0 THEN '' ELSE ',Odometer Stop=' + CAST(D.[Odometer Stop] AS varchar(50)) END + 
CASE WHEN D.ProjectID IS NULL THEN '' ELSE ',ProjectID=' + P.Project END +
CASE WHEN D.SourceIn = '' THEN '' ELSE ',SourceIn=' + D.SourceIn END +
CASE WHEN D.SourceOut = '' THEN '' ELSE ',SourceOut=' + D.SourceOut END +
CASE WHEN D.[GMT+Hours] IS NULL THEN '' ELSE ',GMT+Hours=' + CAST(D.[GMT+Hours] AS varchar(50)) END
FROM deleted D
LEFT JOIN Project P ON D.ProjectID=P.ProjectID
INNER JOIN TimeType TT ON D.TypeID=TT.TypeID
INNER JOIN EmployeeTimeStatus S ON D.StatusID=S.StatusID

EXEC dbo.spAuditLogPurge
GO
CREATE TRIGGER dbo.EmployeeTimeLogUpdate ON EmployeeTime FOR UPDATE
AS
DECLARE @audit_update bit

EXEC dbo.spAuditGetOperation 262144, 2, @audit_update OUT
IF @audit_update=0 RETURN

INSERT AuditTrail(SID, [User], RegardingPersonID, [ID], ObjectID, TableID, [Event Mask], Event)
SELECT SUSER_SID(), SUSER_SNAME(), D.EmployeeID, D.ItemID, 262144, 262144, 2,
'Updated time. ' +
SUBSTRING(
CASE WHEN D.StatusID = I.StatusID THEN '' ELSE ',Status changed from ' + DS.Status + ' to ' + [IS].Status END +
CASE 
	WHEN D.[In] = I.[In] AND D.StatusID = I.StatusID THEN ''
	WHEN D.[In] = I.[In] AND D.StatusID <> I.StatusID THEN ',In=' + CAST(I.[In] AS varchar(50))
	ELSE ',In changed from ' + CAST(D.[In] AS varchar(50)) + ' to ' + CAST(I.[In] AS varchar(50)) 
END +
CASE 
	WHEN I.Seconds = D.Seconds AND I.StatusID = D.StatusID THEN
		CASE WHEN D.[In] = I.[In] AND D.StatusID = I.StatusID THEN '' ELSE ' (Out=' +  CAST(DATEADD(s,D.seconds,D.[In]) AS varchar(50)) + ')' END
	WHEN I.Seconds = D.Seconds AND I.Seconds <> D.StatusID THEN ',Hrs=' + CAST(CAST((I.Seconds / 3600.00) AS numeric(9,2)) AS varchar(50)) + ' (Out=' +  CAST(DATEADD(s,I.seconds,I.[In]) AS varchar(50)) + ')'
	ELSE ',Hrs changed from ' + CAST(CAST((D.Seconds / 3600.00) AS numeric(9,2)) AS varchar(50))  + ' to ' + CAST(CAST((I.Seconds / 3600.00) AS numeric(9,2)) AS varchar(50)) + ' (Out=' +  CAST(DATEADD(s,I.seconds,I.[In]) AS varchar(50)) + ')'
END +
CASE WHEN I.TypeID = D.TypeID THEN '' ELSE ',Type changed from ' + DT.Type + ' to ' + IT.Type END +
CASE WHEN D.[Employee Comment] = I.[Employee Comment] THEN '' ELSE ',Employee Comment changed from ' + D.[Employee Comment] + ' to ' + I.[Employee Comment] END +
CASE WHEN D.[Manager Comment] = I.[Manager Comment] THEN '' ELSE ',Manager Comment changed from ' + D.[Manager Comment] + ' to ' + I.[Manager Comment] END +
CASE 
	WHEN I.ProjectID IS NULL AND D.ProjectID IS NULL THEN '' 
	WHEN I.ProjectID IS NOT NULL AND D.ProjectID IS NULL THEN ',Project changed from null to ' + IP.Project
	WHEN I.ProjectID IS NULL AND D.ProjectID IS NOT NULL THEN ',Project changed to null from ' + DP.Project
	WHEN I.ProjectID = D.ProjectID AND D.StatusID = I.StatusID THEN ''
	WHEN I.ProjectID = D.ProjectID AND D.StatusID <> I.StatusID THEN ',Project=' + IP.Project
	ELSE ',Project changed from ' + DP.Project + 'to ' + IP.Project
END +
CASE WHEN D.[Fixed Pay] = I.[Fixed Pay] THEN '' ELSE ',Fixed Pay changed from ' + CAST(D.[Fixed Pay] AS varchar(50)) + ' to ' + CAST(I.[Fixed Pay] AS varchar(50)) END +
CASE WHEN D.[Billing Rate] = I.[Billing Rate] THEN '' ELSE ',Fixed Pay changed from ' + CAST(D.[Billing Rate] AS varchar(50)) + ' to ' + CAST(I.[Billing Rate] AS varchar(50)) END +
CASE WHEN D.[Fixed Billing] = I.[Fixed Billing] THEN '' ELSE ',Fixed Pay changed from ' + CAST(D.[Fixed Billing] AS varchar(50)) + ' to ' + CAST(I.[Fixed Billing] AS varchar(50)) END +
CASE WHEN D.[Pay Rate] = I.[Pay Rate] THEN '' ELSE ',Pay Rate changed from ' + CAST(D.[Pay Rate] AS varchar(50)) + ' to ' + CAST(I.[Pay Rate] AS varchar(50)) END +
CASE WHEN D.[Odometer Start] = I.[Odometer Start] THEN '' ELSE ',Odometer Start changed from ' + CAST(D.[Odometer Start] AS varchar(50)) + ' to ' + CAST(I.[Odometer Start] AS varchar(50)) END +
CASE WHEN D.[Odometer Stop] =I.[Odometer Stop] THEN '' ELSE ',Odometer Stop changed from ' + CAST(D.[Odometer Stop] AS varchar(50)) + ' to ' + CAST(I.[Odometer Stop] AS varchar(50)) END +
CASE WHEN D.SourceIn = I.SourceIn THEN '' WHEN D.SourceIn='' THEN ',SourceIn=' + I.SourceIn ELSE ',SourceIn changed from ' + D.SourceIn + ' to ' + I.SourceIn END +
CASE WHEN D.SourceOut = I.SourceOut THEN '' WHEN D.SourceOut='' THEN ',SourceOut=' + I.SourceOut ELSE ',SourceOut changed from ' + D.SourceOut + ' to ' + I.SourceOut END +
CASE 
	WHEN D.[GMT+Hours] IS NULL AND I.[GMT+Hours] IS NOT NULL THEN ',GMT+Hours=' + CAST(I.[GMT+Hours] AS varchar(50))
	WHEN D.[GMT+Hours] IS NOT NULL AND I.[GMT+Hours] IS NULL THEN ',GMT+Hours changed to null from ' + CAST(D.[GMT+Hours] AS varchar(50))
	WHEN D.[GMT+Hours] IS NULL AND I.[GMT+Hours] IS NULL THEN ''
	WHEN D.[GMT+Hours] = I.[GMT+Hours] THEN ''
	ELSE ',GMT+Hours changed from ' + CAST(D.[GMT+Hours] AS varchar(50)) + ' to ' + CAST(I.[GMT+Hours] AS varchar(50))
END
,2,4000) +
CASE
	WHEN D.[Last Submitted Day past 1900] IS NULL AND I.[Last Submitted Day past 1900] IS NULL THEN ''
	WHEN D.[Last Submitted Day past 1900] = I.[Last Submitted Day past 1900] THEN ''
	WHEN D.[Last Submitted Day past 1900] IS NULL THEN ',Submitted changed to ' + CAST(DATEADD(d,0,I.[Last Submitted Day past 1900]) AS char(11))
	ELSE ',Submitted changed from ' + ISNULL(CAST(DATEADD(d,0,D.[Last Submitted Day past 1900]) AS char(11)), 'NULL') + ' to ' + CAST(DATEADD(d,0,I.[Last Submitted Day past 1900]) AS char(11))
END +
CASE
	WHEN D.[Last Submitted by] = I.[Last Submitted by] THEN ''
	WHEN D.[Last Submitted by] = '' THEN ',SubmittedBy changed to ' + I.[Last Submitted by]
	ELSE ',SubmittedBy changed from ''' + D.[Last Submitted by] + ''' to ''' + I.[Last Submitted by] + ''''
END
FROM deleted D
INNER JOIN inserted I ON D.ItemID=I.ItemID
INNER JOIN EmployeeTimeStatus [IS] ON I.StatusID=[IS].StatusID
INNER JOIN EmployeeTimeStatus DS ON D.StatusID=DS.StatusID
INNER JOIN TimeType IT ON I.TypeID=IT.TypeID
INNER JOIN TimeType DT ON D.TypeID=DT.TypeID
LEFT JOIN Project IP ON I.ProjectID=IP.ProjectID
LEFT JOIN Project DP ON D.ProjectID=DP.ProjectID

EXEC dbo.spAuditLogPurge
GO
GRANT EXEC ON dbo.spLeaveInsertDay TO public
GO
IF OBJECT_id('dbo.spBitFindNextOpenID') IS NOT NULL DROP PROC dbo.spBitFindNextOpenID
IF OBJECT_id('dbo.spBitMoveDown') IS NOT NULL DROP PROC dbo.spBitMoveDown
IF OBJECT_id('dbo.spBitMoveUp') IS NOT NULL DROP PROC dbo.spBitMoveUp
IF OBJECT_id('dbo.spBitStraighten') IS NOT NULL DROP PROC dbo.spBitStraighten
GO
-- Copy to TempX, X is order
CREATE PROC dbo.spBitFindNextOpenID
	@batch_id int,
	@error_code int,
	@id int OUT,
	@order int OUT
AS
DECLARE @continue bit
DECLARE @error bit

SELECT @id = 1, @continue = 0, @error = 0
SELECT @continue = 1 FROM TempX WHERE BatchID=@batch_id AND [ID]=@id
WHILE @continue = 1
BEGIN
	SELECT @id = @id * 2, @continue = 0
	IF @id = 0x40000000 SELECT @error = 1 FROM TempX WHERE BatchID=@batch_id AND [ID]=@id
	ELSE SELECT @continue = 1 FROM TempX WHERE BatchID=@batch_id AND [ID]=@id
END

IF @error = 1
BEGIN
	SET @id=NULL
	EXEC dbo.spErrorRaise @error_code
END
ELSE SELECT @order = ISNULL(MAX(X) + 1, 0) FROM TempX WHERE BatchID=@batch_id
GO
-- Ensures that Order is unique
CREATE PROC dbo.[spBitStraighten] @batch_id int
AS SET NOCOUNT ON
DECLARE @id int
SELECT TOP 1 @id = MIN(ID) FROM TempX WHERE BatchID=@batch_id GROUP BY X HAVING COUNT(*) > 1
WHILE @@ROWCOUNT > 0
BEGIN
	UPDATE TempX SET X = X + 1 WHERE BatchID=@batch_id AND ID = @id
	SELECT TOP 1 @id = MIN([ID]) FROM TempX WHERE BatchID=@batch_id GROUP BY X HAVING COUNT(*) > 1
END
GO
-- Moves an item down a list
CREATE PROC dbo.[spBitMoveDown]
	@batch_id int,
	@id int
AS SET NOCOUNT ON
DECLARE @next_id int, @order int, @next_order int

SELECT @order = X FROM TempX WHERE BatchID=@batch_id AND [ID]=@id
SELECT TOP 1 @next_id = [ID] FROM TempX WHERE BatchID=@batch_id AND X > @order ORDER BY X
SELECT @next_order = X FROM TempX WHERE BatchID=@batch_id AND ID = @next_id

IF @next_order IS NOT NULL
BEGIN
	UPDATE TempX SET X = @next_order WHERE BatchID=@batch_id AND ID=@id
	UPDATE TempX SET X = @order WHERE BatchID=@batch_id AND ID=@next_id
END

EXEC dbo.spBitStraighten @batch_id
GO
-- Moves an item up a list
CREATE PROC dbo.spBitMoveUp @batch_id int, @id int
AS SET NOCOUNT ON
DECLARE @previous_id int, @order int, @previous_order int

SELECT @order = X FROM TempX WHERE BatchID=@batch_id AND [ID]=@id
SELECT TOP 1 @previous_id = [ID] FROM TempX WHERE BatchID=@batch_id AND X < @order ORDER BY X DESC
SELECT @previous_order = X FROM TempX WHERE BatchID=@batch_id AND [ID]=@previous_id

IF @previous_order IS NOT NULL
BEGIN
	UPDATE TempX SET X = @previous_order WHERE BatchID = @batch_id AND [ID]=@id
	UPDATE TempX SET X = @order WHERE BatchID = @batch_id AND [ID]=@previous_id
END
EXEC dbo.spBitStraighten @batch_id
GO
IF OBJECT_id('dbo.spTerminalInsert') IS NOT NULL DROP PROC dbo.spTerminalInsert
IF OBJECT_id('dbo.spTerminalUpdate') IS NOT NULL DROP PROC dbo.spTerminalUpdate
IF OBJECT_id('dbo.spTerminalList') IS NOT NULL DROP PROC dbo.spTerminalList
IF OBJECT_id('dbo.spTerminalSelect') IS NOT NULL DROP PROC dbo.spTerminalSelect
IF OBJECT_id('dbo.spTerminalDelete') IS NOT NULL DROP PROC dbo.spTerminalDelete
IF OBJECT_id('dbo.spTerminalConstantGet') IS NOT NULL DROP PROC dbo.spTerminalConstantGet
IF OBJECT_id('dbo.spTerminalConstantSet') IS NOT NULL DROP PROC dbo.spTerminalConstantSet
IF OBJECT_id('dbo.spTerminalConstantSet2') IS NOT NULL DROP PROC dbo.spTerminalConstantSet2
IF OBJECT_id('dbo.spTerminalUpdateLastResult') IS NOT NULL DROP PROC dbo.spTerminalUpdateLastResult
IF OBJECT_id('dbo.spTerminalConstantUpdateLastResult') IS NOT NULL DROP PROC dbo.spTerminalConstantUpdateLastResult
IF OBJECT_id('dbo.spTerminalPunch') IS NOT NULL DROP PROC dbo.spTerminalPunch
GO
CREATE PROC dbo.spTerminalPunch @terminal_id int, @stamp datetime, @in_out_mode int = 0, @work_code int = 0, @employee_number varchar(50) = NULL,
@badge int = NULL -- depricated 
AS
IF @employee_number IS NULL SET @employee_number = CAST(@badge AS varchar(50))
INSERT dbo.EmployeeTimeZKQ(Badge,Terminal,[Time],[In Out Mode],[Work Code])
SELECT @employee_number,@terminal_id,@stamp,@in_out_mode,@work_code
GO
CREATE PROC dbo.spTerminalInsert @terminal_id int, @ip binary(4), @port int, @password int, @flags int = 0, @source varchar(50) = '', @ddns varchar(50) = ''
AS
DECLARE @batch_id int, @unique_bit int
SET @batch_id=RAND() * 2147483647
INSERT TempX(BatchID,[ID],X) SELECT @batch_id,TerminalID,TerminalID FROM Terminal
EXEC dbo.spBitFindNextOpenID @batch_id, 50057, @unique_bit OUT, 0
IF @unique_bit IS NOT NULL
INSERT Terminal(TerminalID,IP,Port,[Password],Flags,UniqueBit,Source,DDNS) VALUES(@terminal_id,@ip,@port,@password,@flags,@unique_bit,@source,@ddns)

DELETE dbo.TempX WHERE BatchID=@batch_id OR DATEDIFF(minute,Created,GETDATE()) > 30
GO
CREATE PROC dbo.spTerminalUpdate @terminal_id int, @ip binary(4), @port int, @password int, @flags int = NULL, @source varchar(50) = NULL, @ddns varchar(50) = NULL
AS UPDATE Terminal SET IP=@ip,Port=@port,[Password]=@password,
Flags = CASE WHEN @flags IS NULL THEN Flags ELSE @flags END,
Source = CASE WHEN @source IS NULL THEN Source ELSE @source END,
DDNS = CASE WHEN @ddns IS NULL THEN DDNS ELSE @ddns END
WHERE TerminalID=@terminal_id
GO
CREATE PROC dbo.spTerminalDelete @terminal_id int AS DELETE Terminal WHERE TerminalID=@terminal_id
GO
CREATE PROC dbo.spTerminalList AS SET NOCOUNT ON SELECT * FROM dbo.vwTerminal ORDER BY TerminalID
GO
GRANT EXEC ON dbo.spTerminalList TO public
GO
CREATE PROC dbo.spTerminalSelect @terminal_id int AS SET NOCOUNT ON SELECT * FROM dbo.vwTerminal WHERE TerminalID=@terminal_id
GO
CREATE PROC dbo.spTerminalUpdateLastResult @terminal_id int, @result varchar(1000) AS 
UPDATE Terminal SET [Last Result]=@result, [Last Updated] = GETDATE() WHERE TerminalID=@terminal_id
GO
CREATE PROC dbo.spTerminalConstantUpdateLastResult @result varchar(1000) AS 
UPDATE Constant SET [Terminal Service Last Result]=@result, [Terminal Service Last Updated] = GETDATE()
GO
CREATE PROC dbo.spTerminalConstantGet AS SET NOCOUNT ON SELECT
[Terminal Service Last Result],
[Terminal Service Last Updated],
[Terminal Service Enable],
[Terminal Service Verbosity],
[Terminal Synch All Fingerprints Start],
[Terminal Synch All Fingerprints Seconds],
[Terminal Synch New Fingerprints Start],
[Terminal Synch New Fingerprints Seconds],
[Terminal Poll Punches Start],
[Terminal Poll Punches Seconds],
[Terminal Synch Time Start],
[Terminal Synch Time Seconds],
[Terminal Default Sync Flags],
[Terminal Default Enrollment Mask],
[Terminal Allow Db PID Card Update]
FROM dbo.Constant
GO
CREATE PROC dbo.spTerminalConstantSet
	@enable bit, @verbosity int, @all_fp_start datetime, @all_fp_seconds int,
	@new_fp_start datetime, @new_fp_seconds int,
	@punches_start datetime, @punches_seconds int,
	@time_start datetime, @time_seconds int,
	@default_sync_flags int = NULL, -- added v118
	@default_enrolled_terminals_mask int = NULL, -- added v118
	@allow_db_pid_card_update bit = NULL
AS
UPDATE CONSTANT
SET [Terminal Service Enable] = @enable,
[Terminal Service Verbosity] = @verbosity,
[Terminal Synch All Fingerprints Start] = @all_fp_start,
[Terminal Synch All Fingerprints Seconds] = @all_fp_seconds,
[Terminal Synch New Fingerprints Start] = @new_fp_start,
[Terminal Synch New Fingerprints Seconds] = @new_fp_seconds,
[Terminal Poll Punches Start] = @punches_start,
[Terminal Poll Punches Seconds] = @punches_seconds,
[Terminal Synch Time Start] = @time_start,
[Terminal Synch Time Seconds] = @time_seconds,
[Terminal Default Sync Flags] = CASE WHEN @default_sync_flags IS NULL THEN [Terminal Default Sync Flags] ELSE @default_sync_flags END,
[Terminal Default Enrollment Mask] = CASE WHEN @default_enrolled_terminals_mask IS NULL THEN [Terminal Default Enrollment Mask] ELSE @default_enrolled_terminals_mask END,
[Terminal Allow Db PID Card Update]= CASE WHEN @allow_db_pid_card_update IS NULL THEN [Terminal Allow Db PID Card Update] ELSE @allow_db_pid_card_update END
GO
IF OBJECT_id('dbo.spEmployeeTimeGetProjectsWorked') IS NOT NULL DROP PROC dbo.spEmployeeTimeGetProjectsWorked
GO
CREATE PROC dbo.spEmployeeTimeGetProjectsWorked @employee_id int,@begin_day int, @end_day int
AS 
SELECT DISTINCT ET.ProjectID FROM EmployeeTime ET
INNER JOIN Project P ON ET.EmployeeID=@employee_id AND ET.ProjectID IS NOT NULL AND DATEDIFF(d,0,ET.[In]) BETWEEN @begin_day AND @end_day
AND ET.ProjectID=P.ProjectID AND P.Active=1
GO
GRANT EXEC ON dbo.spEmployeeTimeGetProjectsWorked TO public
GO
CREATE PROC dbo.spTerminalConstantSet2
	@all_fp_start datetime, @new_fp_start datetime, @punches_start datetime, @time_start datetime
AS
IF @all_fp_start IS NOT NULL UPDATE CONSTANT SET [Terminal Synch All Fingerprints Start] = @all_fp_start
IF @new_fp_start IS NOT NULL UPDATE CONSTANT SET [Terminal Synch New Fingerprints Start] = @new_fp_start
IF @punches_start IS NOT NULL UPDATE CONSTANT SET [Terminal Poll Punches Start] = @punches_start
IF @time_start IS NOT NULL UPDATE CONSTANT SET [Terminal Synch Time Start] = @time_start
GO
GRANT EXEC ON spTerminalConstantGet TO public
GO
IF OBJECT_id('dbo.[vwEmployeeLeaveUsedItem2]') IS NOT NULL DROP VIEW dbo.[vwEmployeeLeaveUsedItem2]
GO
CREATE VIEW dbo.[vwEmployeeLeaveUsedItem2] AS
SELECT I.ItemID, I.LeaveID, I.TypeID, I.[Day past 1900], I.Seconds, I.[Advanced Type Mask], [Date] = dbo.GetDateFromDaysPast1900([Day past 1900]),
[Extended Type Mask] = TypeID | I.[Advanced Type Mask], U.EmployeeID, U.ReasonID, U.Status,
PPE = dbo.GetDateFromDaysPast1900(I.[PPE Day past 1900])
FROM EmployeeLeaveUsedItem I
INNER JOIN EmployeeLeaveUsed U ON U.LeaveID=I.LeaveID

UNION ALL

SELECT E.LeaveID, NULL, E.TypeID, E.[Day past 1900], -E.Seconds, ISNULL(T.TypeID,0), DATEADD(d, 0, E.[Day past 1900]), 
E.TypeID, E.EmployeeID, NULL, 2,
PPE = dbo.GetDateFromDaysPast1900(E.[PPE Day past 1900])
FROM EmployeeLeaveEarned E 
LEFT JOIN LeaveType T ON E.TypeID=T.TypeID AND T.Advanced=0
WHERE E.Seconds<0 AND E.Auto=0
GO
IF OBJECT_id('dbo.spEmployeeLeaveUsedItemList2') IS NOT NULL DROP PROC dbo.spEmployeeLeaveUsedItemList2
GO
CREATE PROC dbo.spEmployeeLeaveUsedItemList2
	@employee_id int, @start_day int, @stop_day int, @status_mask int
AS
SET NOCOUNT ON
DECLARE @authorized bit
EXEC dbo.spPermissionInsureForCurrentUserOnPerson @employee_id, 10001, 1, @authorized out
IF @authorized = 1 
SELECT * FROM dbo.vwEmployeeLeaveUsedItem2 WHERE EmployeeID=@employee_id AND ([Status] & @status_mask)>0 AND [Day past 1900] BETWEEN @start_day AND @stop_day ORDER BY [Day past 1900]
GO
GRANT EXEC ON dbo.spEmployeeLeaveUsedItemList2 TO public
GO
IF NOT EXISTS(SELECT * FROM Error WHERE ErrorID=50052)
INSERT Error(ErrorID,Error)
VALUES (50052, 'This event cannot be added because the system can only track 31 events.')
GO
ALTER PROC dbo.spLeaveTypeUpdate
	@type_id int,
	@paid bit,
	@bank bit = 0,
	@ot_eligible bit = 1,
	@type varchar(50),
	@abbreviation varchar(4) = NULL,
	@holiday_concurrent bit = NULL,
	@suspend_accrual bit = NULL,

	@ot_comp bit = 0, --legacy
	
	@carryover_target_leave_type_id int = NULL,
	@carryover_limit_seconds int = NULL,
	@carryover_offset_days int = NULL,
	@carryover_multiplier decimal(9,8) = NULL,
	@cbuz_type_mask int = NULL,
	
	@comp_eligible bit = NULL,
	@occurrence bit = NULL
AS
UPDATE LeaveType SET [Type] = @type, Abbreviation = ISNULL(@abbreviation,Abbreviation), Bank = @bank, Paid = @paid, [OT Eligible] = @ot_eligible, [Holiday Concurrent] = ISNULL(@holiday_concurrent,[Holiday Concurrent]), [Suspend Accrual]=ISNULL(@suspend_accrual,[Suspend Accrual]),
CarryoverTargetLeaveTypeID = CASE WHEN @carryover_limit_seconds IS NULL THEN CarryoverTargetLeaveTypeID ELSE @carryover_target_leave_type_id END,
[Carryover Limit Seconds] = CASE WHEN @carryover_limit_seconds IS NULL THEN [Carryover Limit Seconds] ELSE @carryover_limit_seconds END,
[Carryover Offset Days] = CASE WHEN @carryover_offset_days IS NULL THEN [Carryover Offset Days] ELSE @carryover_offset_days END,
[Carryover Multiplier] = CASE WHEN @carryover_multiplier IS NULL THEN [Carryover Multiplier] ELSE @carryover_multiplier END,
[CBUZ Type Mask] = CASE WHEN @cbuz_type_mask IS NULL THEN [CBUZ Type Mask] ELSE @cbuz_type_mask END,
[Comp Eligible] = CASE WHEN @comp_eligible IS NULL THEN [Comp Eligible] ELSE @comp_eligible END,
[Occurrence] = CASE WHEN @occurrence IS NULL THEN [Occurrence] ELSE @occurrence END

WHERE TypeID = @type_id
GO
ALTER PROC dbo.spLeaveTypeInsert
	@type varchar(50),
	@paid bit,
	@advanced bit,
	@abbreviation varchar(4) = '',
	@ot_eligible bit = 1,
	@bank bit = 1,
	@initial_period_id int,
	@initial_seconds int,
	@type_id int OUT,
	@holiday_concurrent bit = 0,
	@suspend_accrual bit = 0,
	@ot_comp bit = 0, -- legacy
	
	@carryover_target_leave_type_id int = NULL,
	@carryover_limit_seconds int = 0x7FFFFFFF,
	@carryover_offset_days int = 0,
	@carryover_multiplier decimal(9,8) = 1,
	
	@cbuz_type_mask int = 0,
	
	@comp_eligible bit = 1,
	
	@occurrence bit = 0
AS
DECLARE @batch_id int, @order int
SET @batch_id=RAND() * 2147483647
INSERT TempX(BatchID,[ID],X) SELECT @batch_id,TypeID,[Order] FROM LeaveType
EXEC dbo.spBitFindNextOpenID @batch_id, 50006, @type_id OUT, @order OUT
IF @type_id IS NOT NULL 
INSERT LeaveType(TypeID, [Type], Abbreviation, Bank, Paid, Advanced, [OT Eligible], [Order], InitialPeriodID, [Initial Seconds], [Holiday Concurrent], [Suspend Accrual],
CarryoverTargetLeaveTypeID, [Carryover Limit Seconds], [Carryover Offset Days], [Carryover Multiplier], [CBUZ Type Mask], [Comp Eligible], Occurrence)
VALUES(@type_id, @type, @abbreviation, @bank, @paid, @advanced, @ot_eligible, @order, @initial_period_id, @initial_seconds, @holiday_concurrent, @suspend_accrual,
@carryover_target_leave_type_id, @carryover_limit_seconds, @carryover_offset_days, @carryover_multiplier, @cbuz_type_mask, @comp_eligible, @occurrence)
DELETE dbo.TempX WHERE BatchID=@batch_id OR DATEDIFF(minute,Created,GETDATE()) > 30
GO
ALTER PROC dbo.spLeaveTypeMoveDown
	@type_id int
AS
DECLARE @next_type_id int, @order int, @next_order int, @batch_id int
SET @batch_id=RAND() * 2147483647
INSERT TempX(BatchID,[ID],X) SELECT @batch_id,TypeID,[Order] FROM LeaveType
EXEC dbo.spBitMoveDown @batch_id, @type_id
UPDATE T SET [Order]=X.X FROM LeaveType T
INNER JOIN TempX X ON X.BatchID=@batch_id AND X.[ID]=T.TypeID AND X.X<>T.[Order]
DELETE dbo.TempX WHERE BatchID=@batch_id OR DATEDIFF(minute,Created,GETDATE()) > 30
GO
ALTER PROC dbo.spLeaveTypeMoveUp
	@type_id int
AS
DECLARE @next_type_id int, @order int, @next_order int, @batch_id int
SET @batch_id=RAND() * 2147483647
INSERT TempX(BatchID,[ID],X) SELECT @batch_id,TypeID,[Order] FROM LeaveType
EXEC dbo.spBitMoveUp @batch_id, @type_id
UPDATE T SET [Order]=X.X FROM LeaveType T
INNER JOIN TempX X ON X.BatchID=@batch_id AND X.[ID]=T.TypeID AND X.X<>T.[Order]
DELETE dbo.TempX WHERE BatchID=@batch_id OR DATEDIFF(minute,Created,GETDATE()) > 30
GO
IF OBJECT_id('dbo.spLeaveTypeStraighten') IS NOT NULL DROP PROC dbo.spLeaveTypeStraighten
GO
IF OBJECT_id('dbo.spEmployeeCompensationEventStartSelect') IS NOT NULL DROP PROC dbo.spEmployeeCompensationEventStartSelect
IF OBJECT_id('dbo.spEmployeeCompensationEventStartDelete') IS NOT NULL DROP PROC dbo.spEmployeeCompensationEventStartDelete
IF OBJECT_id('dbo.spEmployeeCompensationEventStartUpdate') IS NOT NULL DROP PROC dbo.spEmployeeCompensationEventStartUpdate
IF OBJECT_id('dbo.spEmployeeCompensationEventStartInsert') IS NOT NULL DROP PROC dbo.spEmployeeCompensationEventStartInsert
IF OBJECT_id('dbo.spEmployeeCompensationEventStartMoveUp') IS NOT NULL DROP PROC dbo.spEmployeeCompensationEventStartMoveUp
IF OBJECT_id('dbo.spEmployeeCompensationEventStartMoveDown') IS NOT NULL DROP PROC dbo.spEmployeeCompensationEventStartMoveDown
GO
IF OBJECT_id('dbo.spCompensationSummary2') IS NOT NULL DROP PROC dbo.spCompensationSummary2
GO
CREATE PROC dbo.spCompensationSummary2
	@effective_day int,
	@batch_id int,
	@period_id int
AS
SET NOCOUNT ON

EXEC dbo.spPermissionGetOnPeopleForCurrentUser2 @batch_id, 1024
DELETE TempX WHERE BatchID = @batch_id AND (X & 1) = 0

DECLARE @rate numeric(9, 1)
SELECT @rate = 7488000.0 / Seconds FROM Period WHERE PeriodID = @period_id

SELECT EmployeeID = E.PersonID, Employee = E.[List As], [Other Compensation] = ISNULL(C.[Other Compensation], ''), Period = ISNULL(P.Period, ''),
Note = ISNULL(C.Note, ''),
[Employer Premiums] = ISNULL(C.[Annualized Employer Premiums] /  @rate, 0),
[Adjustment Min] =ISNULL( [Annualized Adjustment Min] / @rate, 0),
[Adjustment Max] = ISNULL([Annualized Adjustment Max] / @rate, 0),
Pay = ISNULL(CASE WHEN @period_id = 512 THEN [Hourly Pay] ELSE [Annualized Pay] / @rate END, 0)
FROM TempX T
INNER JOIN dbo.vwPersonListAs E ON T.BatchID = @batch_id AND T.[ID] = E.PersonID
LEFT JOIN vwEmployeeCompensation C ON C.EmployeeID = E.PersonID AND @effective_day >= C.[Start Day past 1900] AND (C.[Stop Day past 1900] IS NULL OR @effective_day <= C.[Stop Day past 1900])
LEFT JOIN Period P ON P.PeriodID = C.PeriodID ORDER BY Employee

DELETE TempX WHERE BatchID = @batch_id OR DATEDIFF(hh, Created, GETDATE()) > 1
GO
GRANT EXEC ON dbo.spCompensationSummary2 TO public
GO
CREATE PROC dbo.spEmployeeCompensationEventStartDelete @event_id int AS
DELETE EmployeeCompensationEventStart WHERE EventID=@event_id
GO
CREATE PROC dbo.spEmployeeCompensationEventStartInsert
	@event varchar(50),
	@flags int,
	@event_id int OUT
AS
DECLARE @batch_id int, @order int
SET @batch_id=RAND() * 2147483647
INSERT TempX(BatchID,[ID],X) SELECT @batch_id,EventID,[Order] FROM EmployeeCompensationEventStart
EXEC dbo.spBitFindNextOpenID @batch_id, 50052, @event_id OUT, @order OUT
IF @event_id IS NOT NULL INSERT EmployeeCompensationEventStart(EventID, Event, Flags, [Order]) VALUES(@event_id, @event, @flags, @order)
GO
CREATE PROC dbo.spEmployeeCompensationEventStartUpdate
	@event varchar(50),
	@flags int,
	@event_id int OUT
AS
UPDATE dbo.EmployeeCompensationEventStart SET Event=@event,Flags=@flags WHERE EventID=@event_id
GO
CREATE PROC dbo.spEmployeeCompensationEventStartMoveUp @event_id int
AS SET NOCOUNT ON
DECLARE @batch_id int
SET @batch_id=RAND() * 2147483647
INSERT TempX(BatchID,[ID],X) SELECT @batch_id,EventID,[Order] FROM EmployeeCompensationEventStart
EXEC dbo.spBitMoveUp @batch_id, @event_id
UPDATE C SET [Order]=X.X FROM EmployeeCompensationEventStart C
INNER JOIN TempX X ON X.BatchID=@batch_id AND X.[ID]=C.EventID AND X.X<>C.[Order]
GO
CREATE PROC dbo.spEmployeeCompensationEventStartMoveDown @event_id int
AS SET NOCOUNT ON
DECLARE @batch_id int
SET @batch_id=RAND() * 2147483647
INSERT TempX(BatchID,[ID],X) SELECT @batch_id,EventID,[Order] FROM EmployeeCompensationEventStart
EXEC dbo.spBitMoveDown @batch_id, @event_id
UPDATE C SET [Order]=X.X FROM EmployeeCompensationEventStart C
INNER JOIN TempX X ON X.BatchID=@batch_id AND X.[ID]=C.EventID AND X.X<>C.[Order]
GO
IF OBJECT_id('dbo.spEmployeeCompensationEventStopDelete') IS NOT NULL DROP PROC dbo.spEmployeeCompensationEventStopDelete
IF OBJECT_id('dbo.spEmployeeCompensationEventStopUpdate') IS NOT NULL DROP PROC dbo.spEmployeeCompensationEventStopUpdate
IF OBJECT_id('dbo.spEmployeeCompensationEventStopInsert') IS NOT NULL DROP PROC dbo.spEmployeeCompensationEventStopInsert
IF OBJECT_id('dbo.spEmployeeCompensationEventStopMoveUp') IS NOT NULL DROP PROC dbo.spEmployeeCompensationEventStopMoveUp
IF OBJECT_id('dbo.spEmployeeCompensationEventStopMoveDown') IS NOT NULL DROP PROC dbo.spEmployeeCompensationEventStopMoveDown
GO
CREATE PROC dbo.spEmployeeCompensationEventStopDelete @event_id int AS
DELETE EmployeeCompensationEventStop WHERE EventID=@event_id
GO
CREATE PROC dbo.spEmployeeCompensationEventStopInsert
	@event varchar(50),
	@flags int,
	@event_id int OUT
AS
DECLARE @batch_id int, @order int
SET @batch_id=RAND() * 2147483647
INSERT TempX(BatchID,[ID],X) SELECT @batch_id,EventID,[Order] FROM EmployeeCompensationEventStop
EXEC dbo.spBitFindNextOpenID @batch_id, 50052, @event_id OUT, @order OUT
IF @event_id IS NOT NULL INSERT EmployeeCompensationEventStop(EventID, Event, Flags, [Order]) VALUES(@event_id, @event, @flags, @order)
GO
CREATE PROC dbo.spEmployeeCompensationEventStopUpdate
	@event varchar(50),
	@flags int,
	@event_id int OUT
AS
UPDATE dbo.EmployeeCompensationEventStop SET Event=@event,Flags=@flags WHERE EventID=@event_id
GO
CREATE PROC dbo.spEmployeeCompensationEventStopMoveUp @event_id int
AS SET NOCOUNT ON
DECLARE @batch_id int
SET @batch_id=RAND() * 2147483647
INSERT TempX(BatchID,[ID],X) SELECT @batch_id,EventID,[Order] FROM EmployeeCompensationEventStop
EXEC dbo.spBitMoveUp @batch_id, @event_id
UPDATE C SET [Order]=X.X FROM EmployeeCompensationEventStop C
INNER JOIN TempX X ON X.BatchID=@batch_id AND X.[ID]=C.EventID AND X.X<>C.[Order]
GO
CREATE PROC dbo.spEmployeeCompensationEventStopMoveDown @event_id int
AS SET NOCOUNT ON
DECLARE @batch_id int
SET @batch_id=RAND() * 2147483647
INSERT TempX(BatchID,[ID],X) SELECT @batch_id,EventID,[Order] FROM EmployeeCompensationEventStop
EXEC dbo.spBitMoveDown @batch_id, @event_id
UPDATE C SET [Order]=X.X FROM EmployeeCompensationEventStop C
INNER JOIN TempX X ON X.BatchID=@batch_id AND X.[ID]=C.EventID AND X.X<>C.[Order]
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spEmployeeInsertPrepare'
GO
ALTER PROC dbo.spEmployeeInsertPrepare
	@last_employee_id int,
	@male bit out,
	@org_user_field1 int out,
	@location_id int out, @shift_id int out, @division_id int out, @department_id int out,
	@salaried bit out, @ot_pay_multiplier numeric(9,4) out, @holiday_pay_multiplier numeric(9,4) out, @weekend_pay_multiplier numeric(9,4) out, @ot_basis int out
AS
IF OBJECT_ID('dbo.spCustom_EmployeeInsertPrepare') IS NOT NULL
BEGIN
	EXEC sp_executesql N'EXEC dbo.spCustom_EmployeeInsertPrepare @last_employee_id,@male out,@org_user_field1 out,@location_id out,@shift_id out,@division_id out,@department_id out,@salaried out,@ot_pay_multiplier out,@holiday_pay_multiplier out,@weekend_pay_multiplier out,@ot_basis out',N'@last_employee_id int,@male bit out,@org_user_field1 int out,@location_id int out,@shift_id int out,@division_id int out,@department_id int out,@salaried bit out,@ot_pay_multiplier bit out,@holiday_pay_multiplier numeric(9,4) out,@weekend_pay_multiplier numeric(9,4) out,@ot_basis int out', @last_employee_id,@male=@male out,@org_user_field1=@org_user_field1 out,@location_id=@location_id out,@shift_id=@shift_id out,@division_id=@division_id out,@department_id=@department_id out,@salaried=@salaried out,@ot_pay_multiplier=@ot_pay_multiplier out,@holiday_pay_multiplier=@holiday_pay_multiplier out,@weekend_pay_multiplier=@weekend_pay_multiplier out,@ot_basis=@ot_basis out
	RETURN
END

SELECT TOP 1 @male = [Male] FROM Person P
INNER JOIN Employee E ON P.PersonID = E.EmployeeID
GROUP BY Male ORDER BY COUNT(*) DESC

SELECT @org_user_field1 = OrgUserField1, @location_id = LocationID, @shift_id = ShiftID, @division_id = DivisionID, @department_id = DepartmentID, @salaried = Salaried, @ot_pay_multiplier = [OT Pay Multiplier], @holiday_pay_multiplier = [Holiday Pay Multiplier], @weekend_pay_multiplier = [Weekend Pay Multiplier], @ot_basis = [OT Basis]
FROM Employee WHERE EmployeeID = @last_employee_id

IF @@ROWCOUNT = 0
BEGIN
	SET @org_user_field1 = NULL
	SELECT TOP 1 @shift_id = ShiftID FROM Shift
	SELECT TOP 1 @division_id = DivisionID FROM Division
	SELECT TOP 1 @department_id = DepartmentID FROM Department
	SELECT TOP 1 @location_id = LocationID FROM Location
	SELECT @salaried = 0, @ot_pay_multiplier = 1.5, @holiday_pay_multiplier = 1, @weekend_pay_multiplier = 1, @ot_basis = 0
END
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spEmployeeInsert'
GO
ALTER PROC dbo.spEmployeeInsert
	@title varchar(50),
	@first_name varchar(50),
	@middle_name varchar(50),
	@last_name varchar(50),
	@suffix varchar(50),
	@credentials varchar(50),
	@person_id int OUT
AS
-- Inserts a person, personx, and employee. Intelligently guesses many default values based on either last entry or most frequently entered information.
DECLARE @result int

DECLARE @last_employee_id int
DECLARE @plan_id int
DECLARE @race_id int
DECLARE @i9status_id int
DECLARE @marital_status_id int
DECLARE @time_schema_id int

DECLARE @default_time_type_id int
DECLARE @terminal_sync_flags int
DECLARE @enrolled_terminals_mask int

SET NOCOUNT ON



SELECT TOP 1 @last_employee_id = EmployeeID FROM Employee E WHERE [SID] = SUSER_SID()

IF @@ROWCOUNT=0
SELECT TOP 1 @last_employee_id = EmployeeID FROM Employee E
INNER JOIN Person P ON P.PersonID = E.EmployeeID
ORDER BY Created DESC

EXEC dbo.spPersonXInsertPrepare @race_id out, @i9status_id out, @marital_status_id out


DECLARE @salaried bit, @ot_pay_multiplier numeric(9,4), @holiday_pay_multiplier numeric(9,4), @weekend_pay_multiplier numeric(9,4), @ot_basis int, @male bit
DECLARE @shift_id int, @division_id int, @department_id int, @location_id int, @org_user_field1 int

SELECT @result = 0, @male = 1

-- Employee
EXEC dbo.spEmployeeInsertPrepare @last_employee_id, @male out, @org_user_field1 out, @location_id out, @shift_id out, @division_id out, @department_id out, @salaried out, @ot_pay_multiplier out, @holiday_pay_multiplier out, @weekend_pay_multiplier out, @ot_basis out

SELECT @time_schema_id = DefaultTimeSchemaID,
@terminal_sync_flags = [Terminal Default Sync Flags],
@enrolled_terminals_mask = [Terminal Default Enrollment Mask]
FROM dbo.Constant

SELECT TOP 1 @default_time_type_id = TypeID FROM TimeType ORDER BY [Order]



BEGIN TRAN

INSERT Person(
Title, [First Name], [Middle Name], [Last Name], Suffix, Credentials,
Male,[Work Phone], [Toll Free Phone],
[Work Fax], [Work Address], [Work Address (cont.)], [Work City], [Work State], [Work ZIP], [Work Country], [Home Country]
) VALUES (
@title, @first_name, @middle_name, @last_name, @suffix, @credentials,
@male, '', '',
'','','','','','','',''
)

SELECT @result = @@ERROR, @person_id = SCOPE_IDENTITY()

IF @result = 0 EXEC @result = dbo.spPersonXInsert @person_id, @race_id, @i9status_id, @marital_status_id
IF @result = 0 EXEC @result = dbo.spEmployeeClassify @person_id, @shift_id, @division_id, @department_id, @location_id, @time_schema_id, @salaried, @ot_pay_multiplier, @holiday_pay_multiplier, @weekend_pay_multiplier, @ot_basis, @default_time_type_id, @terminal_sync_flags, @enrolled_terminals_mask, @org_user_field1
	

IF @result = 0
	COMMIT TRAN
ELSE IF @@TRANCOUNT > 0
	ROLLBACK TRAN

GO
ALTER PROC dbo.spPersonInsert
	@title varchar(50),
	@first_name varchar(50),
	@middle_name varchar(50),
	@last_name varchar(50),
	@suffix varchar(50),
	@credentials varchar(50),
	@person_id int OUT
AS
DECLARE @result int

DECLARE @male bit
DECLARE @last_employee_id int
DECLARE @manager_id int
DECLARE @shift_id int
DECLARE @division_id int
DECLARE @department_id int
DECLARE @location_id int
DECLARE @plan_id int

SET NOCOUNT ON

SELECT @result = 0, @male = 1

SELECT @last_employee_id = EmployeeID FROM Employee WHERE [SID]=SUSER_SID()
IF @@ROWCOUNT = 0
SELECT TOP 1 @last_employee_id = EmployeeID FROM Employee E
INNER JOIN Person P ON P.PersonID = E.EmployeeID
ORDER BY Created DESC

SELECT TOP 1 @male = [Male] FROM Person P
INNER JOIN Employee E ON P.PersonID = E.EmployeeID
GROUP BY Male ORDER BY COUNT(*) DESC


-- Employee
SELECT @shift_id = ShiftID, @division_id = DivisionID, @department_id = DepartmentID, @manager_id = ManagerID, @location_id = LocationID
FROM Employee WHERE EmployeeID = @last_employee_id

IF @@ROWCOUNT = 0
BEGIN
	SELECT TOP 1 @shift_id = ShiftID FROM Shift
	SELECT TOP 1 @division_id = DivisionID FROM Division
	SELECT TOP 1 @department_id = DepartmentID FROM Department
	SELECT TOP 1 @location_id = LocationID FROM Location
END



BEGIN TRAN

INSERT Person(
Title, [First Name], [Middle Name], [Last Name], Suffix, Credentials,
Male,[Work Phone], [Toll Free Phone],
[Work Fax], [Work Address], [Work Address (cont.)], [Work City], [Work State], [Work ZIP], [Work Country],
[Role Mask]
) VALUES (
@title, @first_name, @middle_name, @last_name, @suffix, @credentials,
@male, '', '',
'','','','','','','',
1
)

SELECT @result = @@ERROR, @person_id = SCOPE_IDENTITY()

IF @result = 0
BEGIN
	DECLARE @race_id int
	DECLARE @i9status_id int
	DECLARE @marital_status_id int


	EXEC dbo.spPersonXInsertPrepare @race_id out, @i9status_id out, @marital_status_id out
	EXEC @result = spPersonXInsert @person_id, @race_id, @i9status_id, @marital_status_id
	SELECT @result = @@ERROR
END

IF @result = 0
BEGIN
	INSERT Employee(EmployeeID, ManagerID, ShiftID, DivisionID, DepartmentID, LocationID)
	VALUES(@person_id, @manager_id, @shift_id, @division_id, @department_id, @location_id)
	SELECT @result = @@ERROR
END

IF @result = 0
	COMMIT TRAN
ELSE
	ROLLBACK TRAN
GO
ALTER PROC dbo.spLeaveSummaryShift
	@start_day int,
	@stop_day int,
	@batch_id int,
	@authorized bit OUT,
	@days bit = 0,
	@flags int = NULL
AS
SET NOCOUNT ON

IF (@flags IS NOT NULL) SET @days = @flags & 1

EXEC dbo.spPermissionGetOnPeopleForCurrentUser2 @batch_id, 10003
DELETE TempX WHERE BatchID = @batch_id AND X & 1 = 0
SELECT @authorized = CASE WHEN @@ROWCOUNT = 0 THEN 1 ELSE 0 END

SELECT I.Seconds, E.ShiftID, I.[Extended Type Mask],
[Seconds per Unit] = CAST(CASE WHEN @days=1 THEN S.[Effective Seconds per Day] ELSE 3600.0000 END AS numeric(9,4))
INTO #L
FROM dbo.vwEmployeeLeaveUsedItemApproved I
INNER JOIN dbo.TempX X ON X.BatchID = @batch_id AND X.[ID] = I.EmployeeID AND I.[Day past 1900] BETWEEN @start_day AND @stop_day
INNER JOIN dbo.Employee E ON I.EmployeeID = E.EmployeeID
INNER JOIN dbo.vwEmployeeEffectiveSecondsPerDay S ON I.EmployeeID=S.EmployeeID

DELETE dbo.TempX WHERE BatchID = @batch_id OR DATEDIFF(hh, Created, GETDATE()) > 1

SELECT DISTINCT ShiftID INTO #UD FROM #L
SELECT DISTINCT T.TypeID INTO #UT FROM LeaveType T
INNER JOIN #L ON (#L.[Extended Type Mask] & T.TypeID) != 0

CREATE TABLE #H(ShiftID int, TypeID int NULL, [Type] varchar(50) COLLATE SQL_Latin1_General_CP1_CI_AS, [Order] int, Hrs numeric(9,4))

INSERT #H
SELECT #UD.ShiftID, #UT.TypeID, T.[Type], T.[Order], 
Hrs = ISNULL((
	SELECT SUM(#L.Seconds / #L.[Seconds per Unit]) FROM #L WHERE #L.ShiftID = #UD.ShiftID AND (#L.[Extended Type Mask] & #UT.TypeID) != 0
), 0)
FROM #UT
INNER JOIN LeaveType T ON #UT.TypeID = T.TypeID
CROSS JOIN #UD

IF (SELECT COUNT(*) FROM LeaveType T INNER JOIN #UT ON T.TypeID = #UT.TypeID AND T.Paid = 0 AND T.Advanced = 0) > 1
BEGIN
	INSERT #H
	SELECT #UD.ShiftID, NULL, 'Total Unpaid', 0x7FFFFFFE, ISNULL((
		SELECT SUM(#H.Hrs) FROM #H INNER JOIN LeaveType T ON #H.TypeID = T.TypeID AND #H.ShiftID = #UD.ShiftID AND T.Paid = 0 AND T.Advanced = 0
	), 0)
	FROM #UD
END

IF (SELECT COUNT(*) FROM LeaveType T INNER JOIN #UT ON T.TypeID = #UT.TypeID AND T.Paid = 1 AND T.Advanced = 0) > 1
BEGIN
	INSERT #H
	SELECT #UD.ShiftID, NULL, 'Total Paid', 0x7FFFFFFF, ISNULL((
		SELECT SUM(#H.Hrs) FROM #H INNER JOIN LeaveType T ON #H.TypeID = T.TypeID AND #H.ShiftID = #UD.ShiftID AND T.Paid = 1 AND T.Advanced = 0
	), 0)
	FROM #UD
END

SELECT #H.ShiftID, D.Shift, #H.[Type], #H.Hrs
FROM #H
INNER JOIN Shift D ON #H.ShiftID = D.ShiftID
ORDER BY D.[Shift], #H.ShiftID, #H.[Order]
GO
ALTER PROC dbo.spLeaveSummaryManager
	@start_day int,
	@stop_day int,
	@batch_id int,
	@authorized bit OUT,
	@days bit = 0,
	@flags int = NULL
AS
SET NOCOUNT ON

IF (@flags IS NOT NULL) SET @days = @flags & 1

EXEC dbo.spPermissionGetOnPeopleForCurrentUser2 @batch_id, 10003
DELETE TempX WHERE BatchID = @batch_id AND X & 1 = 0
SELECT @authorized = CASE WHEN @@ROWCOUNT = 0 THEN 1 ELSE 0 END

SELECT I.Seconds, E.ManagerID, I.[Extended Type Mask],
[Seconds per Unit] = CAST(CASE WHEN @days=1 THEN S.[Effective Seconds per Day] ELSE 3600.0000 END AS numeric(9,4))
INTO #L
FROM vwEmployeeLeaveUsedItemApproved I
INNER JOIN TempX X ON X.BatchID = @batch_id AND X.[ID] = I.EmployeeID AND I.[Day past 1900] BETWEEN @start_day AND @stop_day
INNER JOIN Employee E ON E.EmployeeID = I.EmployeeID
INNER JOIN vwEmployeeEffectiveSecondsPerDay S ON I.EmployeeID=S.EmployeeID

DELETE TempX WHERE BatchID = @batch_id OR DATEDIFF(hh, Created, GETDATE()) > 1

UPDATE #L SET ManagerID = ISNULL((SELECT MIN(EmployeeID) FROM Employee), 0) - 1 WHERE ManagerID IS NULL

SELECT DISTINCT ManagerID INTO #UD FROM #L
SELECT DISTINCT T.TypeID INTO #UT FROM LeaveType T
INNER JOIN #L ON (#L.[Extended Type Mask] & T.TypeID) != 0

CREATE TABLE #H(ManagerID int, TypeID int NULL, [Type] varchar(50) COLLATE SQL_Latin1_General_CP1_CI_AS, [Order] int, Hrs numeric(9,4))

INSERT #H
SELECT #UD.ManagerID, #UT.TypeID, T.[Type], T.[Order],
Hrs = ISNULL((
	SELECT SUM(#L.Seconds / #L.[Seconds per Unit]) FROM #L WHERE #L.ManagerID = #UD.ManagerID AND (#L.[Extended Type Mask] & #UT.TypeID) != 0
), 0)
FROM #UT
INNER JOIN LeaveType T ON #UT.TypeID = T.TypeID
CROSS JOIN #UD

IF (SELECT COUNT(*) FROM LeaveType T INNER JOIN #UT ON T.TypeID = #UT.TypeID AND T.Paid = 0 AND T.Advanced = 0) > 1
BEGIN
	INSERT #H
	SELECT #UD.ManagerID, NULL, 'Total Unpaid', 0x7FFFFFFE, ISNULL((
		SELECT SUM(#H.Hrs) FROM #H INNER JOIN LeaveType T ON #H.TypeID = T.TypeID AND #H.ManagerID = #UD.ManagerID AND T.Paid = 0 AND T.Advanced = 0
	), 0)
	FROM #UD
END

IF (SELECT COUNT(*) FROM LeaveType T INNER JOIN #UT ON T.TypeID = #UT.TypeID AND T.Paid = 1 AND T.Advanced = 0) > 1
BEGIN
	INSERT #H
	SELECT #UD.ManagerID, NULL, 'Total Paid', 0x7FFFFFFF, ISNULL((
		SELECT SUM(#H.Hrs) FROM #H INNER JOIN LeaveType T ON #H.TypeID = T.TypeID AND #H.ManagerID = #UD.ManagerID AND T.Paid = 1 AND T.Advanced = 0
	), 0)
	FROM #UD
END

SELECT #H.ManagerID, Manager = ISNULL(D.[List As], '<Unspecified>'), #H.[Type], #H.Hrs
FROM #H
LEFT JOIN dbo.vwPersonListAs D ON #H.ManagerID = D.PersonID
ORDER BY D.[List As], #H.ManagerID, #H.[Order]
GO
ALTER PROC dbo.spLeaveSummaryWeekday
	@start_day int,
	@stop_day int,
	@batch_id int,
	@authorized bit OUT,
	@days bit = 0,
	@flags int = NULL
AS
SET NOCOUNT ON

IF (@flags IS NOT NULL) SET @days = @flags & 1

EXEC dbo.spPermissionGetOnPeopleForCurrentUser2 @batch_id, 10003
DELETE TempX WHERE BatchID = @batch_id AND X & 1 = 0
SELECT @authorized = CASE WHEN @@ROWCOUNT = 0 THEN 1 ELSE 0 END

SELECT I.Seconds, D = DATEPART(dw,I.[Day past 1900]), I.[Extended Type Mask],
[Seconds per Unit] = CAST(CASE WHEN @days=1 THEN S.[Effective Seconds per Day] ELSE 3600.0000 END AS numeric(9,4))
INTO #L
FROM vwEmployeeLeaveUsedItemApproved I
INNER JOIN TempX X ON X.BatchID = @batch_id AND X.[ID] = I.EmployeeID AND I.[Day past 1900] BETWEEN @start_day AND @stop_day
INNER JOIN vwEmployeeEffectiveSecondsPerDay S ON I.EmployeeID=S.EmployeeID

DELETE TempX WHERE BatchID = @batch_id OR DATEDIFF(hh, Created, GETDATE()) > 1

SELECT D = 1, [WeekDay] = 'Sunday'
INTO #D
UNION SELECT 2, 'Monday'
UNION SELECT 3, 'Tuesday'
UNION SELECT 4, 'Wednesday'
UNION SELECT 5, 'Thursday'
UNION SELECT 6, 'Friday'
UNION SELECT 7, 'Saturday'


SELECT DISTINCT T.TypeID INTO #UT FROM LeaveType T
INNER JOIN #L ON (#L.[Extended Type Mask] & T.TypeID) != 0

CREATE TABLE #H(D int, TypeID int NULL, [Type] varchar(50) COLLATE SQL_Latin1_General_CP1_CI_AS, [Order] int, Hrs numeric(9,4))

INSERT #H
SELECT #D.D, #UT.TypeID, T.[Type], T.[Order],
Hrs = ISNULL((
	SELECT SUM(#L.Seconds / #L.[Seconds per Unit]) FROM #L WHERE #L.D = #D.D AND (#L.[Extended Type Mask] & #UT.TypeID) != 0
), 0)
FROM #UT
INNER JOIN LeaveType T ON #UT.TypeID = T.TypeID
CROSS JOIN #D

IF (SELECT COUNT(*) FROM LeaveType T INNER JOIN #UT ON T.TypeID = #UT.TypeID AND T.Paid = 0 AND T.Advanced = 0) > 1
BEGIN
	INSERT #H
	SELECT #D.D, NULL, 'Total Unpaid', 0x7FFFFFFE, ISNULL((
		SELECT SUM(#H.Hrs) FROM #H INNER JOIN LeaveType T ON #H.TypeID = T.TypeID AND #H.D = #D.D AND T.Paid = 0 AND T.Advanced = 0
	), 0)
	FROM #D
END

IF (SELECT COUNT(*) FROM LeaveType T INNER JOIN #UT ON T.TypeID = #UT.TypeID AND T.Paid = 1 AND T.Advanced = 0) > 1
BEGIN
	INSERT #H
	SELECT #D.D, NULL, 'Total Paid', 0x7FFFFFFF, ISNULL((
		SELECT SUM(#H.Hrs) FROM #H INNER JOIN LeaveType T ON #H.TypeID = T.TypeID AND #H.D = #D.D AND T.Paid = 1 AND T.Advanced = 0
	), 0)
	FROM #D
END

SELECT WeekDayID = #H.D, #D.[WeekDay], #H.[Type], #H.Hrs
FROM #H
INNER JOIN #D ON #H.D = #D.D
ORDER BY #H.D, #H.[Order]
GO
ALTER PROC dbo.spLeaveSummaryReason
	@start_day int,
	@stop_day int,
	@batch_id int,
	@authorized bit OUT,
	@days bit = 0,
	@flags int = NULL
AS
SET NOCOUNT ON

IF (@flags IS NOT NULL) SET @days = @flags & 1

EXEC dbo.spPermissionGetOnPeopleForCurrentUser2 @batch_id, 10003
DELETE TempX WHERE BatchID = @batch_id AND X & 1 = 0
SELECT @authorized = CASE WHEN @@ROWCOUNT = 0 THEN 1 ELSE 0 END

SELECT I.Seconds, I.ReasonID, I.[Extended Type Mask],
[Seconds per Unit] = CAST(CASE WHEN @days=1 THEN S.[Effective Seconds per Day] ELSE 3600.0000 END AS numeric(9,4))
INTO #L
FROM vwEmployeeLeaveUsedItemApproved I
INNER JOIN TempX X ON X.BatchID = @batch_id AND X.[ID] = I.EmployeeID AND I.[Day past 1900] BETWEEN @start_day AND @stop_day
INNER JOIN vwEmployeeEffectiveSecondsPerDay S ON I.EmployeeID=S.EmployeeID

DELETE TempX WHERE BatchID = @batch_id OR DATEDIFF(hh, Created, GETDATE()) > 1

UPDATE #L SET ReasonID = ISNULL((SELECT MIN(ReasonID) FROM Reason), 0) - 1 WHERE ReasonID IS NULL

SELECT DISTINCT ReasonID INTO #UD FROM #L
SELECT DISTINCT T.TypeID INTO #UT FROM LeaveType T
INNER JOIN #L ON (#L.[Extended Type Mask] & T.TypeID) != 0

CREATE TABLE #H(ReasonID int, TypeID int NULL, [Type] varchar(50) COLLATE SQL_Latin1_General_CP1_CI_AS, [Order] int, Hrs numeric(9,4))

INSERT #H
SELECT #UD.ReasonID, #UT.TypeID, T.[Type], T.[Order], 
Hrs = ISNULL((
	SELECT SUM(#L.Seconds / #L.[Seconds per Unit]) FROM #L WHERE #L.ReasonID = #UD.ReasonID AND (#L.[Extended Type Mask] & #UT.TypeID) != 0
), 0)
FROM #UT
INNER JOIN LeaveType T ON #UT.TypeID = T.TypeID
CROSS JOIN #UD

IF (SELECT COUNT(*) FROM LeaveType T INNER JOIN #UT ON T.TypeID = #UT.TypeID AND T.Paid = 0 AND T.Advanced = 0) > 1
BEGIN
	INSERT #H
	SELECT #UD.ReasonID, NULL, 'Total Unpaid', 0x7FFFFFFE, ISNULL((
		SELECT SUM(#H.Hrs) FROM #H INNER JOIN LeaveType T ON #H.TypeID = T.TypeID AND #H.ReasonID = #UD.ReasonID AND T.Paid = 0 AND T.Advanced = 0
	), 0)
	FROM #UD
END

IF (SELECT COUNT(*) FROM LeaveType T INNER JOIN #UT ON T.TypeID = #UT.TypeID AND T.Paid = 1 AND T.Advanced = 0) > 1
BEGIN
	INSERT #H
	SELECT #UD.ReasonID, NULL, 'Total Paid', 0x7FFFFFFF, ISNULL((
		SELECT SUM(#H.Hrs) FROM #H INNER JOIN LeaveType T ON #H.TypeID = T.TypeID AND #H.ReasonID = #UD.ReasonID AND T.Paid = 1 AND T.Advanced = 0
	), 0)
	FROM #UD
END

SELECT #H.ReasonID, Reason = ISNULL(D.Reason, '<Unspecified>'), #H.[Type], #H.Hrs
FROM #H
LEFT JOIN Reason D ON #H.ReasonID = D.ReasonID
ORDER BY D.[Reason], #H.ReasonID, #H.[Order]
GO
ALTER PROC dbo.spLeaveSummaryEmployee
	@start_day int,
	@stop_day int,
	@batch_id int,
	@authorized bit OUT,
	@days bit = 0,
	@flags int = NULL 
AS
SET NOCOUNT ON

IF (@flags IS NOT NULL) SET @days = @flags & 1

EXEC dbo.spPermissionGetOnPeopleForCurrentUser2 @batch_id, 10003
DELETE TempX WHERE BatchID = @batch_id AND X & 1 = 0
SELECT @authorized = CASE WHEN @@ROWCOUNT = 0 THEN 1 ELSE 0 END

SELECT I.Seconds, I.EmployeeID, I.[Extended Type Mask],
[Seconds per Unit] = CAST(CASE WHEN @days=1 THEN S.[Effective Seconds per Day] ELSE 3600.0000 END AS numeric(9,4))
INTO #L
FROM dbo.vwEmployeeLeaveUsedItemApproved I
INNER JOIN TempX X ON X.BatchID = @batch_id AND X.[ID] = I.EmployeeID AND I.[Day past 1900] BETWEEN @start_day AND @stop_day
INNER JOIN vwEmployeeEffectiveSecondsPerDay S ON I.EmployeeID=S.EmployeeID

CREATE TABLE #Unused(
	EmployeeID int, 
	Employee varchar(400) COLLATE SQL_Latin1_General_CP1_CI_AS, 
	[Employee Number] varchar(50) COLLATE SQL_Latin1_General_CP1_CI_AS, 
	[Type] varchar(50) COLLATE SQL_Latin1_General_CP1_CI_AS,
	Accumulated numeric(9,4), Available numeric(9,4), [Order] int, TypeID int)

IF (@flags & 2) = 2
INSERT #Unused
EXEC dbo.spLeaveSummarizeUnused @stop_day, @batch_id, @days

DELETE TempX WHERE BatchID = @batch_id OR DATEDIFF(hh, Created, GETDATE()) > 1

SELECT DISTINCT EmployeeID INTO #UE FROM #L
SELECT DISTINCT T.TypeID INTO #UT FROM LeaveType T
INNER JOIN #L ON (#L.[Extended Type Mask] & T.TypeID) != 0

CREATE TABLE #H(EmployeeID int, TypeID int NULL, [Type] varchar(50) COLLATE SQL_Latin1_General_CP1_CI_AS, [Order] int, Hrs numeric(9,4))

INSERT #H
SELECT #UE.EmployeeID, #UT.TypeID, T.[Type], T.[Order], 
Hrs = ISNULL((
	SELECT SUM(#L.Seconds / #L.[Seconds per Unit]) FROM #L WHERE #L.EmployeeID = #UE.EmployeeID AND (#L.[Extended Type Mask] & #UT.TypeID) != 0
), 0)
FROM #UT
INNER JOIN LeaveType T ON #UT.TypeID = T.TypeID
CROSS JOIN #UE

IF (SELECT COUNT(*) FROM LeaveType T INNER JOIN #UT ON T.TypeID = #UT.TypeID AND T.Paid = 0 AND T.Advanced = 0) > 1
BEGIN
	INSERT #H
	SELECT #UE.EmployeeID, NULL, 'Total Unpaid', 0x7FFFFFFE,
	ISNULL((
		SELECT SUM(#H.Hrs) FROM #H INNER JOIN LeaveType T ON #H.TypeID = T.TypeID AND #H.EmployeeID = #UE.EmployeeID AND T.Paid = 0 AND T.Advanced = 0
	), 0)
	FROM #UE
END

IF (SELECT COUNT(*) FROM LeaveType T INNER JOIN #UT ON T.TypeID = #UT.TypeID AND T.Paid = 1 AND T.Advanced = 0) > 1
BEGIN
	INSERT #H
	SELECT #UE.EmployeeID, NULL, 'Total Paid', 0x7FFFFFFF, 
	ISNULL((
		SELECT SUM(#H.Hrs) FROM #H INNER JOIN LeaveType T ON #H.TypeID = T.TypeID AND #H.EmployeeID = #UE.EmployeeID AND T.Paid = 1 AND T.Advanced = 0
	), 0)
	FROM #UE
END

SELECT #H.EmployeeID, Employee = P.[List As], E.[Employee Number],[Type] = CASE WHEN (@flags & 2) = 2 THEN 'Used ' ELSE '' END + #H.[Type], #H.Hrs, #H.[Order], Accumulated = 0
FROM #H
INNER JOIN dbo.vwPersonListAs P ON #H.EmployeeID = P.PersonID
INNER JOIN dbo.Employee E ON P.PersonID = E.EmployeeID
UNION
SELECT #Unused.EmployeeID, Employee, E.[Employee Number], 'Remaining ' + [Type], Accumulated, [Order], Accumulated = 1
FROM #Unused
INNER JOIN #UE ON #UE.EmployeeID=#Unused.EmployeeID
INNER JOIN dbo.Employee E ON #UE.EmployeeID = E.EmployeeID
INNER JOIN #UT ON #UT.TypeID=#Unused.TypeID
ORDER BY P.[List As], #H.EmployeeID, #H.[Order], Accumulated
GO
ALTER PROC dbo.spLeaveSummaryLocation
	@start_day int,
	@stop_day int,
	@batch_id int,
	@authorized bit OUT,
	@days bit = 0,
	@flags int = NULL
AS
SET NOCOUNT ON

IF (@flags IS NOT NULL) SET @days = @flags & 1

EXEC dbo.spPermissionGetOnPeopleForCurrentUser2 @batch_id, 10003
DELETE TempX WHERE BatchID = @batch_id AND X & 1 = 0
SELECT @authorized = CASE WHEN @@ROWCOUNT = 0 THEN 1 ELSE 0 END

SELECT I.Seconds, E.LocationID, I.[Extended Type Mask],
[Seconds per Unit] = CAST(CASE WHEN @days=1 THEN S.[Effective Seconds per Day] ELSE 3600.0000 END AS numeric(9,4))
INTO #L
FROM vwEmployeeLeaveUsedItemApproved I
INNER JOIN TempX X ON X.BatchID = @batch_id AND X.[ID] = I.EmployeeID AND I.[Day past 1900] BETWEEN @start_day AND @stop_day
INNER JOIN Employee E ON I.EmployeeID = E.EmployeeID
INNER JOIN vwEmployeeEffectiveSecondsPerDay S ON I.EmployeeID=S.EmployeeID



DELETE TempX WHERE BatchID = @batch_id OR DATEDIFF(hh, Created, GETDATE()) > 1

SELECT DISTINCT LocationID INTO #UD FROM #L
SELECT DISTINCT T.TypeID INTO #UT FROM LeaveType T
INNER JOIN #L ON (#L.[Extended Type Mask] & T.TypeID) != 0

CREATE TABLE #H(LocationID int, TypeID int NULL, [Type] varchar(50) COLLATE SQL_Latin1_General_CP1_CI_AS, [Order] int, Hrs numeric(9,4))

INSERT #H
SELECT #UD.LocationID, #UT.TypeID, T.[Type], T.[Order], 
Hrs = ISNULL((
	SELECT SUM(#L.Seconds / #L.[Seconds per Unit]) FROM #L WHERE #L.LocationID = #UD.LocationID AND (#L.[Extended Type Mask] & #UT.TypeID) != 0
), 0)
FROM #UT
INNER JOIN LeaveType T ON #UT.TypeID = T.TypeID
CROSS JOIN #UD

IF (SELECT COUNT(*) FROM LeaveType T INNER JOIN #UT ON T.TypeID = #UT.TypeID AND T.Paid = 0 AND T.Advanced = 0) > 1
BEGIN
	INSERT #H
	SELECT #UD.LocationID, NULL, 'Total Unpaid', 0x7FFFFFFE, ISNULL((
		SELECT SUM(#H.Hrs) FROM #H INNER JOIN LeaveType T ON #H.TypeID = T.TypeID AND #H.LocationID = #UD.LocationID AND T.Paid = 0 AND T.Advanced = 0
	), 0)
	FROM #UD
END

IF (SELECT COUNT(*) FROM LeaveType T INNER JOIN #UT ON T.TypeID = #UT.TypeID AND T.Paid = 1 AND T.Advanced = 0) > 1
BEGIN
	INSERT #H
	SELECT #UD.LocationID, NULL, 'Total Paid', 0x7FFFFFFF, ISNULL((
		SELECT SUM(#H.Hrs) FROM #H INNER JOIN LeaveType T ON #H.TypeID = T.TypeID AND #H.LocationID = #UD.LocationID AND T.Paid = 1 AND T.Advanced = 0
	), 0)
	FROM #UD
END

SELECT #H.LocationID, Location = D.[List As], #H.[Type], #H.Hrs
FROM #H
INNER JOIN Location D ON #H.LocationID = D.LocationID
ORDER BY D.[List As], #H.LocationID, #H.[Order]
GO
ALTER PROC dbo.spLeaveSummaryDepartment
	@start_day int,
	@stop_day int,
	@batch_id int,
	@authorized bit OUT,
	@days bit = 0,
	@flags int = NULL 
AS
SET NOCOUNT ON

IF (@flags IS NOT NULL) SET @days = @flags & 1

EXEC dbo.spPermissionGetOnPeopleForCurrentUser2 @batch_id, 10003
DELETE TempX WHERE BatchID = @batch_id AND X & 1 = 0
SELECT @authorized = CASE WHEN @@ROWCOUNT = 0 THEN 1 ELSE 0 END

SELECT I.Seconds, E.DepartmentID, I.[Extended Type Mask],
[Seconds per Unit] = CAST(CASE WHEN @days=1 THEN S.[Effective Seconds per Day] ELSE 3600.0000 END AS numeric(9,4))
INTO #L
FROM vwEmployeeLeaveUsedItemApproved I
INNER JOIN TempX X ON X.BatchID = @batch_id AND X.[ID] = I.EmployeeID AND I.[Day past 1900] BETWEEN @start_day AND @stop_day
INNER JOIN Employee E ON I.EmployeeID = E.EmployeeID
INNER JOIN vwEmployeeEffectiveSecondsPerDay S ON I.EmployeeID=S.EmployeeID

DELETE TempX WHERE BatchID = @batch_id OR DATEDIFF(hh, Created, GETDATE()) > 1

SELECT DISTINCT DepartmentID INTO #UD FROM #L
SELECT DISTINCT T.TypeID INTO #UT FROM LeaveType T
INNER JOIN #L ON (#L.[Extended Type Mask] & T.TypeID) != 0

CREATE TABLE #H(DepartmentID int, TypeID int NULL, [Type] varchar(50) COLLATE SQL_Latin1_General_CP1_CI_AS, [Order] int, Hrs numeric(9,4))

INSERT #H
SELECT #UD.DepartmentID, #UT.TypeID, T.[Type], T.[Order], 
Hrs = ISNULL((
	SELECT SUM(#L.Seconds / #L.[Seconds per Unit]) FROM #L WHERE #L.DepartmentID = #UD.DepartmentID AND (#L.[Extended Type Mask] & #UT.TypeID) != 0
), 0)
FROM #UT
INNER JOIN LeaveType T ON #UT.TypeID = T.TypeID
CROSS JOIN #UD

IF (SELECT COUNT(*) FROM LeaveType T INNER JOIN #UT ON T.TypeID = #UT.TypeID AND T.Paid = 0 AND T.Advanced = 0) > 1
BEGIN
	INSERT #H
	SELECT #UD.DepartmentID, NULL, 'Total Unpaid', 0x7FFFFFFE, ISNULL((
		SELECT SUM(#H.Hrs) FROM #H INNER JOIN LeaveType T ON #H.TypeID = T.TypeID AND #H.DepartmentID = #UD.DepartmentID AND T.Paid = 0 AND T.Advanced = 0
	), 0)
	FROM #UD
END

IF (SELECT COUNT(*) FROM LeaveType T INNER JOIN #UT ON T.TypeID = #UT.TypeID AND T.Paid = 1 AND T.Advanced = 0) > 1
BEGIN
	INSERT #H
	SELECT #UD.DepartmentID, NULL, 'Total Paid', 0x7FFFFFFF, ISNULL((
		SELECT SUM(#H.Hrs) FROM #H INNER JOIN LeaveType T ON #H.TypeID = T.TypeID AND #H.DepartmentID = #UD.DepartmentID AND T.Paid = 1 AND T.Advanced = 0
	), 0)
	FROM #UD
END

SELECT #H.DepartmentID, D.Department, #H.[Type], #H.Hrs
FROM #H
INNER JOIN Department D ON #H.DepartmentID = D.DepartmentID
ORDER BY D.[Department], #H.DepartmentID, #H.[Order]
GO
ALTER PROC dbo.spLeaveSummaryDivision
	@start_day int,
	@stop_day int,
	@batch_id int,
	@authorized bit OUT,
	@days bit = 0,
	@flags int = NULL 
AS
SET NOCOUNT ON

IF (@flags IS NOT NULL) SET @days = @flags & 1

EXEC dbo.spPermissionGetOnPeopleForCurrentUser2 @batch_id, 10003
DELETE TempX WHERE BatchID = @batch_id AND X & 1 = 0
SELECT @authorized = CASE WHEN @@ROWCOUNT = 0 THEN 1 ELSE 0 END

SELECT I.Seconds, E.DivisionID, I.[Extended Type Mask],
[Seconds per Unit] = CAST(CASE WHEN @days=1 THEN S.[Effective Seconds per Day] ELSE 3600.0000 END AS numeric(9,4))
INTO #L
FROM vwEmployeeLeaveUsedItemApproved I
INNER JOIN TempX X ON X.BatchID = @batch_id AND X.[ID] = I.EmployeeID AND I.[Day past 1900] BETWEEN @start_day AND @stop_day
INNER JOIN Employee E ON I.EmployeeID = E.EmployeeID
INNER JOIN vwEmployeeEffectiveSecondsPerDay S ON I.EmployeeID=S.EmployeeID

DELETE TempX WHERE BatchID = @batch_id OR DATEDIFF(hh, Created, GETDATE()) > 1

SELECT DISTINCT DivisionID INTO #UD FROM #L
SELECT DISTINCT T.TypeID INTO #UT FROM LeaveType T
INNER JOIN #L ON (#L.[Extended Type Mask] & T.TypeID) != 0

CREATE TABLE #H(DivisionID int, TypeID int NULL, [Type ]varchar(50) COLLATE SQL_Latin1_General_CP1_CI_AS, [Order] int, Hrs numeric(9,4))

INSERT #H
SELECT #UD.DivisionID, #UT.TypeID, T.[Type], T.[Order], 
Hrs = ISNULL((
	SELECT SUM(#L.Seconds / #L.[Seconds per Unit]) FROM #L WHERE #L.DivisionID = #UD.DivisionID AND (#L.[Extended Type Mask] & #UT.TypeID) != 0
), 0)
FROM #UT
INNER JOIN LeaveType T ON #UT.TypeID = T.TypeID
CROSS JOIN #UD

IF (SELECT COUNT(*) FROM LeaveType T INNER JOIN #UT ON T.TypeID = #UT.TypeID AND T.Paid = 0 AND T.Advanced = 0) > 1
BEGIN
	INSERT #H
	SELECT #UD.DivisionID, NULL, 'Total Unpaid', 0x7FFFFFFE, ISNULL((
		SELECT SUM(#H.Hrs) FROM #H INNER JOIN LeaveType T ON #H.TypeID = T.TypeID AND #H.DivisionID = #UD.DivisionID AND T.Paid = 0 AND T.Advanced = 0
	), 0)
	FROM #UD
END

IF (SELECT COUNT(*) FROM LeaveType T INNER JOIN #UT ON T.TypeID = #UT.TypeID AND T.Paid = 1 AND T.Advanced = 0) > 1
BEGIN
	INSERT #H
	SELECT #UD.DivisionID, NULL, 'Total Paid', 0x7FFFFFFF, ISNULL((
		SELECT SUM(#H.Hrs) FROM #H INNER JOIN LeaveType T ON #H.TypeID = T.TypeID AND #H.DivisionID = #UD.DivisionID AND T.Paid = 1 AND T.Advanced = 0
	), 0)
	FROM #UD
END

SELECT #H.DivisionID, D.Division, #H.[Type], #H.Hrs
FROM #H
INNER JOIN Division D ON #H.DivisionID = D.DivisionID
ORDER BY D.[Division], #H.DivisionID, #H.[Order]
GO
IF OBJECT_id('dbo.spEmployeeTimeGroupByProject2') IS NOT NULL DROP PROC dbo.spEmployeeTimeGroupByProject2
IF OBJECT_id('dbo.spEmployeeTimeLock') IS NOT NULL DROP PROC dbo.spEmployeeTimeLock
GO
IF OBJECT_id('dbo.spEmployeeTimeGroupByProject') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spEmployeeTimeGroupByProject AS SELECT A=0'
GO
ALTER PROC dbo.spEmployeeTimeGroupByProject
	@batch_id int,
	@in_start int,
	@in_stop int,
	@authorized bit OUT
AS
SET NOCOUNT ON

EXEC dbo.spPermissionGetOnPeopleForCurrentUser2 @batch_id, 262144
DELETE X FROM dbo.TempX X WHERE X.BatchID=@batch_id AND (X.X & 1)=0
SELECT @authorized=CASE WHEN @@ROWCOUNT=0 THEN 1 ELSE 0 END

SELECT RowText=ISNULL(P.Project,'<Unspecified>'), RowID=ET.ProjectID, Hours=SUM(ET.Seconds/3600.00), Pay=SUM(ET.Seconds/3600.0000*ET.[Pay Rate]+ET.[Fixed Pay]), Billing=SUM(ET.Seconds/3600.0000*ET.[Billing Rate]+ET.[Fixed Billing]) , ET.ProjectID
FROM dbo.EmployeeTime ET
INNER JOIN dbo.TempX X ON ET.StatusID <> 2 AND X.BatchID=@batch_id AND X.[ID]=ET.EmployeeID AND DATEDIFF(d,0,ET.[In]) BETWEEN @in_start AND @in_stop
LEFT JOIN dbo.Project P ON ET.ProjectID=P.ProjectID
GROUP BY ET.ProjectID,P.Project
ORDER BY P.Project

DELETE dbo.TempX WHERE BatchID=@batch_id OR DATEDIFF(minute, Created, GETDATE()) > 30
GO
IF OBJECT_id('dbo.spEmployeeTimeGroupByProject3') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEmployeeTimeGroupByProject3 AS SELECT A=0'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spEmployeeTimeGroupByProject3 TO public'
END
GO
ALTER PROC dbo.spEmployeeTimeGroupByProject3
	@batch_id int,
	@in_start int,
	@in_stop int,
	@authorized bit OUT
AS
SET NOCOUNT ON

EXEC dbo.spPermissionGetOnPeopleForCurrentUser2 @batch_id, 262144
DELETE X FROM dbo.TempX X WHERE X.BatchID=@batch_id AND (X.X & 1)=0
SELECT @authorized=CASE WHEN @@ROWCOUNT=0 THEN 1 ELSE 0 END

-- Start --
CREATE TABLE #EMPLOYEE_TIME_ROUNDED(
TempItemID int NOT NULL IDENTITY(1,1) PRIMARY KEY,
EmployeeID int NOT NULL,
OriginalTypeID int NOT NULL, 
CalculatedTypeID int NOT NULL,
[In Day past 1900] int NOT NULL, 
[OT Eligible] bit NOT NULL,
[OT Disable] bit NOT NULL,
[Pay Rate] money NOT NULL,
[Fixed Pay] money NOT NULL DEFAULT(0),
[Fixed Items] int DEFAULT(0),
Regular bit DEFAULT(0),
[In Seconds] int NOT NULL,
[Out Seconds] int NOT NULL,
TimeSchemaID int NOT NULL,
ShiftDiffItemID int NULL,
TempShiftDiffSeconds int NULL,
TempShiftDiffItemID int NULL,
OriginalTimeItemID int NULL,
CopyTimeItemID int NULL,
[Time Seconds] int NOT NULL DEFAULT(0),
[Holiday Seconds] int NOT NULL DEFAULT(0),
[OT Seconds] int NOT NULL DEFAULT(0),
Flags int NOT NULL DEFAULT(0),
[Actual In] datetime NULL,
[Actual Out] datetime NULL,
[Base Seconds] int NOT NULL DEFAULT(0),
[X2 Seconds] int NOT NULL DEFAULT(0)
)

DECLARE @pending_type_id int, @denied_type_id int
EXEC dbo.spEmployeeTimeRoundAndCalcOT @batch_id, 0, @in_start, @in_stop, NULL, NULL, 0, @pending_type_id OUT, @denied_type_id OUT


SELECT 
RowText=ISNULL(P.Project,'<Unspecified>'), 
RowID = 0,
Employee=dbo.fnGetListAs(PERS.[First Name], PERS.[Middle Name], PERS.[Last Name], PERS.Suffix),
--[Date] = CAST(CAST(ET.[In] AS char(11)) AS datetime),
[Hours]=SUM(
	CASE WHEN ETR.[Out Seconds] < ETR.[In Seconds] THEN 0
	ELSE ETR.[Out Seconds] - ETR.[In Seconds] END
) /3600.0000, 
Pay=ISNULL(
SUM(
	CASE WHEN ETR.[Out Seconds] < ETR.[In Seconds] THEN 0
	ELSE ETR.[Out Seconds] - ETR.[In Seconds] END
	/3600.0000*ET.[Pay Rate]+ET.[Fixed Pay]
),0), 
Billing=ISNULL(
SUM(
	CASE WHEN ETR.[Out Seconds] < ETR.[In Seconds] THEN 0
	ELSE ETR.[Out Seconds] - ETR.[In Seconds] END
	/3600.0000*ET.[Billing Rate]+ET.[Fixed Billing]
),0),
P.ProjectID
FROM #EMPLOYEE_TIME_ROUNDED ETR
INNER JOIN dbo.EmployeeTime ET ON ETR.CopyTimeItemID = ET.ItemID AND ETR.[In Day past 1900] BETWEEN @in_start AND @in_stop
INNER JOIN dbo.Person PERS ON ET.EmployeeID = PERS.PersonID
INNER JOIN dbo.TempX X ON ET.StatusID <> 2 AND X.BatchID=@batch_id AND X.[ID]=ET.EmployeeID
LEFT JOIN dbo.Project P ON ET.ProjectID=P.ProjectID
GROUP BY P.ProjectID, P.Project, PERS.[Last Name], PERS.[First Name], PERS.[Middle Name], PERS.[Suffix]
ORDER BY P.Project, PERS.[Last Name], PERS.[First Name], PERS.[Middle Name]--, ET.[In]

DELETE dbo.TempX WHERE BatchID=@batch_id OR DATEDIFF(minute, Created, GETDATE()) > 30
GO
CREATE PROC dbo.spEmployeeTimeLock @employee_id int, @day int
AS
DECLARE @authorized bit
EXEC dbo.spPermissionInsureForCurrentUserOnPerson @employee_id, 262144, 2, @authorized out
IF @authorized=1 UPDATE Employee SET [Pending Timecard Lock] = @day WHERE @day > [Pending Timecard Lock] AND EmployeeID=@employee_id
GO
CREATE PROC dbo.spEmployeeTimeGroupByProject2 @employee_id int, @start int, @stop int
AS
DECLARE @authorized bit
EXEC dbo.spPermissionInsureForCurrentUserOnPerson @employee_id, 262144, 1, @authorized out

IF @authorized=1
SELECT Project, 
[Approved Seconds]= SUM(CASE WHEN (StatusID & 1) = 1 THEN Seconds ELSE 0 END),
[Pending Seconds] = SUM(CASE WHEN StatusID=8 THEN Seconds ELSE 0 END)
FROM vwEmployeeTime 
WHERE EmployeeID=@employee_id AND [In Day past 1900] BETWEEN @start AND @stop
GROUP BY [Project]
GO
GRANT EXEC ON dbo.spEmployeeTimeGroupByProject TO public
GRANT EXEC ON dbo.spEmployeeTimeGroupByProject2 TO public
GRANT EXEC ON dbo.spEmployeeTimeLock TO public
GO
IF NOT EXISTS(SELECT * FROM Error WHERE ErrorID = 50054)
INSERT Error(ErrorID, Error) VALUES(50054, 'Your changes were rejected because you previously submitted time for this period.')
IF OBJECT_id('dbo.spEmployeeTimeLockEnforce') IS NOT NULL DROP PROC dbo.spEmployeeTimeLockEnforce
GO
CREATE PROC dbo.spEmployeeTimeLockEnforce @employee_id int, @status_id int, @in smalldatetime, @operation int, @authorized bit OUT
AS
SET NOCOUNT ON
DECLARE @authorized_pending bit, @authorized_approved bit, @attribute int, @lock_day int

SELECT @authorized = 0

SELECT @lock_day=[Pending Timecard Lock] FROM Employee WHERE EmployeeID=@employee_id
EXEC dbo.spPermissionGetOnPersonForCurrentUser2 @employee_id, 262144, @operation, @authorized_pending out
EXEC dbo.spPermissionGetOnPersonForCurrentUser2 @employee_id, 262145, @operation, @authorized_approved out

IF @status_id = 8 AND @authorized_pending = 0 EXEC dbo.spErrorRaiseNoPermission 262144, @operation
ELSE IF @status_id <> 8 AND @authorized_approved = 0 EXEC dbo.spErrorRaiseNoPermission 262145, @operation
ELSE IF @authorized_pending=1 AND @authorized_approved=0 AND DATEDIFF(d,0,@in) <= @lock_day EXEC dbo.spErrorRaise 50054
ELSE SELECT @authorized = 1
GO
GRANT EXEC ON dbo.spEmployeeTimeLockEnforce TO public
GO
IF OBJECT_id('dbo.spEmployeeTimeInsert2') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEmployeeTimeInsert2 AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spEmployeeTimeInsert2 TO public'
END
GO
ALTER PROC dbo.spEmployeeTimeInsert2
	@employee_id int,
	@in smalldatetime,
	@seconds int,
	@project_id int,
	@task_id int,
	@status_id int,
	@employee_comment varchar(50),
	@manager_comment varchar(50),
	@pay_rate smallmoney,
	@fixed_pay smallmoney = 0,
	@billing_rate smallmoney = 0,
	@fixed_billing smallmoney = 0,
	@type_id int,
	@odometer_start int = 0,
	@odometer_stop int = 0,
	@item_id int OUT,
	@source_in varchar(50) = '',
	@source_out varchar(50) = '',
	@ppe int = NULL,
	@gmt_hours int = NULL
AS
-- Defines @ppe if it is undefined
IF @ppe IS NULL 
BEGIN
	DECLARE @ppe_date datetime, @now datetime, @shift_2nd bit
	SELECT @now = DATEADD(second, [Payroll PPE Offset Seconds], GETDATE()) FROM dbo.Constant
	SELECT @shift_2nd = Flags & 2048 FROM dbo.Shift S INNER JOIN dbo.Employee E ON E.EmployeeID = @employee_id AND E.ShiftID = S.ShiftID
	
	IF @shift_2nd = 1 SET @ppe = DATEDIFF(d,0,DATEADD(hour,-9,@in))
	ELSE
	BEGIN
		IF @in > @now SET @ppe_date = @in
		ELSE SET @ppe_date = @now
		CREATE TABLE #T_20110506(StartDate datetime, StopDate datetime)
		INSERT #T_20110506
		EXEC dbo.spEmployeeTimeCalculateFilterInverse @ppe_date, 1
		SELECT TOP 1 @ppe = DATEDIFF(d,0,StopDate) FROM #T_20110506
	END
END

-- Enforces locks
DECLARE @authorized bit
EXEC dbo.spEmployeeTimeLockEnforce @employee_id, @status_id, @in, 4, @authorized out
IF @authorized = 0 RETURN

INSERT EmployeeTime(EmployeeID, [In], Seconds, ProjectID, TaskID, [Employee Comment], StatusID, [Pay Rate], [Billing Rate], [Manager Comment], TypeID, [Odometer Start], [Odometer Stop], [Fixed Pay], [Fixed Billing], SourceIn, SourceOut, [PPE Day past 1900], [GMT+Hours])
VALUES(@employee_id, @in, @seconds, @project_id, @task_id, @employee_comment, @status_id, @pay_rate, @billing_rate, @manager_comment, @type_id, @odometer_start, @odometer_stop, @fixed_pay, @fixed_billing, @source_in, @source_out, @ppe, @gmt_hours)

SET @item_id = SCOPE_IDENTITY()
GO
GRANT EXEC ON dbo.spEmployeeTimeInsert2 TO public
GO
IF OBJECT_id('dbo.spEmployeeTimeUpdate2') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEmployeeTimeUpdate2 AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spEmployeeTimeUpdate2 TO public'
END
GO
ALTER PROC dbo.spEmployeeTimeUpdate2
	@employee_id int,
	@in smalldatetime,
	@seconds int,
	@project_id int,
	@task_id int,
	@status_id int,
	@employee_comment varchar(50),
	@manager_comment varchar(50),
	@pay_rate smallmoney,
	@billing_rate smallmoney,
	@type_id int,
	@odometer_start int,
	@odometer_stop int,
	@item_id int,
	@fixed_pay smallmoney = 0,
	@fixed_billing smallmoney = 0,
	@source_in varchar(50) = '',
	@source_out varchar(50) = '',
	@ppe int = NULL,
	@gmt_hours int = 2147483647
AS
DECLARE @authorized bit, @old_in smalldatetime, @old_status_id int, @greatest_in smalldatetime, @least_status_id int

SELECT @old_in = [In], @old_status_id = StatusID, @employee_id = EmployeeID FROM EmployeeTime WHERE ItemID = @item_id

IF @old_status_id = 8 AND @status_id = 8 SET @least_status_id = 8 ELSE SET @least_status_id = 1
IF @old_in > @in SET @greatest_in = @old_in ELSE SET @greatest_in = @in

EXEC dbo.spEmployeeTimeLockEnforce @employee_id, @least_status_id, @greatest_in, 2, @authorized out
IF @authorized = 0 RETURN

IF @ppe IS NULL 
BEGIN
	DECLARE @shift_2nd bit
	SELECT @shift_2nd = Flags & 2048 FROM dbo.Shift S INNER JOIN dbo.Employee E ON E.EmployeeID = @employee_id AND E.ShiftID = S.ShiftID
	IF @shift_2nd = 1 SET @ppe = DATEDIFF(d,0,DATEADD(hour,-9,@in))
END

UPDATE EmployeeTime SET
[Last Updated Day past 1900] = DATEDIFF(d, 0, GETDATE()),
[Last Updated User] = SUSER_SNAME(),
EmployeeID = @employee_id,
StatusID = @status_id,
[In] = @in,
Seconds = @seconds,
ProjectID = @project_id,
TaskID = @task_id,
[Employee Comment] = @employee_comment,
[Pay Rate] = @pay_rate,
[Billing Rate] = @billing_rate,
[Manager Comment] = @manager_comment,
[TypeID] = @type_id,
[Odometer Start] = @odometer_start,
[Odometer Stop] = @odometer_stop,
[Fixed Pay] = @fixed_pay,
[Fixed Billing] = @fixed_billing,
SourceIn = @source_in,
SourceOut = @source_out,
[PPE Day past 1900] = CASE WHEN @ppe IS NULL THEN [PPE Day past 1900] ELSE @ppe END,
[GMT+Hours] = CASE WHEN @gmt_hours = 2147483647 THEN [GMT+Hours] ELSE @gmt_hours END
WHERE ItemID = @item_id
GO
ALTER PROC dbo.spEmployeeTimeDelete
	@item_id int
AS
DECLARE @old_employee_id int, @authorized bit, @attribute int, @old_status_id int, @old_in smalldatetime

SET NOCOUNT ON

SELECT @old_status_id = StatusID, @old_employee_id = EmployeeID, @old_in = [In] FROM EmployeeTime WHERE ItemID = @item_id
EXEC dbo.spEmployeeTimeLockEnforce @old_employee_id, @old_status_id, @old_in, 8, @authorized out

IF @authorized = 1 DELETE EmployeeTime WHERE ItemID = @item_id
GO
IF OBJECT_id('dbo.spEmployeeTimeGetColumnMask') IS NOT NULL DROP PROC dbo.spEmployeeTimeGetColumnMask
GO
CREATE PROC dbo.spEmployeeTimeGetColumnMask
	@employee_id int,
	@column_mask int OUT
AS
SELECT @column_mask = S.[Column Mask] FROM TimeSchema S
INNER JOIN Employee E ON E.EmployeeID = @employee_id AND E.TimeSchemaID = S.TimeSchemaID
GO
GRANT EXEC ON dbo.spEmployeeTimeGetColumnMask TO public
GO
IF OBJECT_id('dbo.spEmployeeListTerminated2') IS NOT NULL DROP PROC dbo.spEmployeeListTerminated2
GO
CREATE PROC dbo.spEmployeeListTerminated2 @batch_id int
AS
EXEC dbo.spPermissionGetOnPeopleForCurrentUser2 @batch_id, 0x1000000
SELECT E.EmployeeID, E.[Employee Number] 
FROM Employee E
INNER JOIN TempX X ON X.BatchID=@batch_id AND X.[ID]=E.EmployeeID AND E.[Terminated Day past 1900] IS NOT NULL
GO
GRANT EXEC ON dbo.spEmployeeListTerminated2 TO public
GO
IF OBJECT_ID('dbo.spEmployeeListTerminated') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEmployeeListTerminated AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spEmployeeListTerminated TO public'
END
GO
ALTER PROC dbo.spEmployeeListTerminated
	@batch_id int,
	@start_day int,
	@stop_day int
AS
SET NOCOUNT ON

CREATE TABLE #EmployeesTerminated010507
(
	EmployeeID int PRIMARY KEY,
	[Note] varchar(4000) COLLATE SQL_Latin1_General_CP1_CI_AS DEFAULT '',
	[Day of Hire] int
)

EXEC dbo.spPermissionGetOnPeopleForCurrentUser2 @batch_id, 0x1000000

INSERT #EmployeesTerminated010507(EmployeeID, Note, [Day of Hire])
SELECT E.EmployeeID, 
CASE WHEN E.[Track Cobra] = 1 THEN 'COBRA. ' ELSE '' END,
ISNULL(
	(SELECT TOP 1 [Start Day past 1900] FROM EmployeeCompensation EC WHERE EC.EmployeeID=E.EmployeeID ORDER BY EC.[Start Day past 1900]), 
	E.[Seniority Begins Day past 1900]
)
FROM Employee E
INNER JOIN TempX X ON X.BatchID = @batch_id AND (X.X & 1) = 1 AND X.[ID] = E.EmployeeID AND E.[Terminated Day past 1900] IS NOT NULL AND E.[Terminated Day past 1900] BETWEEN @start_day AND @stop_day

DELETE TempX WHERE BatchID = @batch_id OR DATEDIFF(hour, Created, GETDATE()) > 1

UPDATE #EmployeesTerminated010507 SET Note = Note + 'Not inactivated. '
FROM #EmployeesTerminated010507
INNER JOIN Employee E ON #EmployeesTerminated010507.EmployeeID = E.EmployeeID AND E.[Active Employee] = 1

UPDATE #EmployeesTerminated010507 SET Note = Note + 'Compensation not discontinued. '
WHERE EXISTS
(
	SELECT * FROM EmployeeCompensation EC
	WHERE EC.EmployeeID = #EmployeesTerminated010507.EmployeeID AND EC.[Stop Day past 1900] IS NULL
)

UPDATE #EmployeesTerminated010507 SET Note = SUBSTRING(Note + CASE E.Rehire WHEN 1 THEN 'Would rehire. ' ELSE 'Would not rehire. ' END + SUBSTRING(E.[Reason for Termination], 1, 80), 1, 4000)
FROM #EmployeesTerminated010507
INNER JOIN Employee E ON #EmployeesTerminated010507.EmployeeID = E.EmployeeID


SELECT E.EmployeeID, Employee = V.[List As],
Terminated = dbo.GetDateFromDaysPast1900(E.[Terminated Day past 1900]),
[Last Position] = ISNULL((EC.[Job Title]), ''),
ET.Note,
TR.ReasonID, Reason = ISNULL(TR.Reason,''), 
E.Rehire, 
DOH = dbo.GetDateFromDaysPast1900(ET.[Day of Hire]),
[Days Employed] = E.[Terminated Day past 1900] - ET.[Day of Hire] + 1,
E.[Employee Number]
FROM #EmployeesTerminated010507 ET
INNER JOIN dbo.Employee E ON E.EmployeeID=ET.EmployeeID
INNER JOIN dbo.vwPersonListAs V ON E.EmployeeID = V.PersonID
LEFT JOIN dbo.TerminationReason TR ON E.TerminationReasonID=TR.ReasonID
LEFT JOIN dbo.vwEmployeeCompensation EC ON E.LastCompensationID=EC.CompensationID
ORDER BY E.Rehire, TR.Reason, E.[Terminated Day past 1900]
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spEmployeeTimeList3'
GO
ALTER PROC dbo.spEmployeeTimeList3
	@employee_id int = NULL,
	@start_day int,
	@stop_day int,
	@flags int = 0, -- 1: Return no rows if timecard is blank, 2: Return one row for every day between start_day and stop_day and return actual punches
	@authorized bit = 0 OUT,
	@batch_id int = NULL,
	@employees_returned int = 0 OUT
AS
DECLARE @return_true_punches bit
DECLARE @start_day_effective int
DECLARE @stop_day_effective int

SET NOCOUNT ON

DECLARE @split_time_into_days bit
SELECT @split_time_into_days = [Timecard Max 24 Hours per Day] FROM dbo.Constant 
SET @return_true_punches = @flags & 2
IF @return_true_punches=1 AND @start_day > -2147483648 AND @split_time_into_days = 1 SET @start_day_effective = @start_day - 1
ELSE SET @start_day_effective = @start_day

IF @batch_id IS NULL EXEC dbo.spAdminGetNextRandom @batch_id out
IF @employee_id IS NOT NULL AND NOT EXISTS (SELECT * FROM dbo.TempX WHERE BatchID=@batch_id AND [ID]=@employee_id)
INSERT dbo.TempX(BatchID,[ID]) SELECT @batch_id,@employee_id

CREATE TABLE #EMPLOYEE_TIME_ROUNDED(
	TempItemID int NOT NULL IDENTITY(1,1) PRIMARY KEY,
	EmployeeID int NOT NULL,
	OriginalTypeID int NOT NULL, 
	CalculatedTypeID int NOT NULL,
	[In Day past 1900] int NOT NULL, 
	[OT Eligible] bit NOT NULL,
	[OT Disable] bit NOT NULL,
	[Pay Rate] money NOT NULL,
	[Fixed Pay] money NOT NULL DEFAULT(0),
	[Fixed Items] int DEFAULT(0),
	Regular bit DEFAULT(0),
	[In Seconds] int NOT NULL,
	[Out Seconds] int NOT NULL,
	TimeSchemaID int NOT NULL,
	ShiftDiffItemID int NULL,
	TempShiftDiffSeconds int NULL,
	TempShiftDiffItemID int NULL,
	OriginalTimeItemID int NULL,
	CopyTimeItemID int NULL,
	[Time Seconds] int NOT NULL DEFAULT(0),
	[Holiday Seconds] int NOT NULL DEFAULT(0),
	[OT Seconds] int NOT NULL DEFAULT(0),
	Flags int NOT NULL DEFAULT(0),
	[Actual In] datetime NULL,
	[Actual Out] datetime NULL,
	[Base Seconds] int NOT NULL DEFAULT(0),
	[X2 Seconds] int NOT NULL DEFAULT(0),
	[In Seconds Bounded] int NOT NULL DEFAULT(0),
	[Out Seconds Bounded] int NOT NULL DEFAULT(0)
)

DECLARE @pending_type_id int, @denied_type_id int, @start_day_excluding_empty_periods int, @stop_day_excluding_empty_periods int
SELECT @start_day_excluding_empty_periods = @start_day_effective, @stop_day_excluding_empty_periods = @stop_day, @stop_day_effective = @stop_day


EXEC dbo.spEmployeeTimeRoundAndCalcOT @batch_id, 0, @start_day_excluding_empty_periods OUT, @stop_day_excluding_empty_periods OUT, NULL, NULL, @authorized OUT, @pending_type_id OUT, @denied_type_id OUT
IF @return_true_punches = 0 SELECT @start_day_effective = @start_day_excluding_empty_periods, @stop_day_effective = @stop_day_excluding_empty_periods




IF @return_true_punches = 0 
BEGIN
	DELETE #EMPLOYEE_TIME_ROUNDED WHERE CalculatedTypeID IN (@denied_type_id)
END
ELSE
BEGIN	
	UPDATE ETR SET 
		[Actual In] = CASE WHEN ETR.OriginalTimeItemID IS NULL THEN NULL ELSE ET.[In] END, 
		[Actual Out] = CASE WHEN ETR.OriginalTimeItemID IS NULL OR ET.Seconds=0 THEN NULL ELSE DATEADD(second, ET.Seconds, ET.[In]) END,
		CopyTimeItemID = ETR.OriginalTimeItemID
	FROM #EMPLOYEE_TIME_ROUNDED ETR
	LEFT JOIN dbo.EmployeeTime ET ON ETR.OriginalTimeItemID = ET.ItemID

	
	


	UPDATE #EMPLOYEE_TIME_ROUNDED
	SET [Base Seconds]=0, [Time Seconds]=0, [Holiday Seconds]=0, [OT Seconds]=0, [X2 Seconds]=0 WHERE [In Day past 1900] < @start_day

	DELETE #EMPLOYEE_TIME_ROUNDED WHERE 
		([In Day past 1900] < @start_day AND [Actual Out] IS NULL) OR
		[Actual Out] < DATEADD(d,0,@start_day)
END



IF @split_time_into_days = 1
BEGIN
	UPDATE #EMPLOYEE_TIME_ROUNDED SET
	[In Seconds Bounded] = CASE
		WHEN OriginalTimeItemID IS NULL THEN [In Seconds]
		WHEN [Actual In] IS NULL THEN 0
		WHEN [Actual In] < DATEADD(d,0,@start_day) THEN 86400
		ELSE [In Seconds]
	END,
	[Out Seconds Bounded] = CASE
		WHEN OriginalTimeItemID IS NULL THEN [Out Seconds] 
		WHEN [Actual In] IS NULL THEN 0
		WHEN [Out Seconds] <= 86400 THEN [Out Seconds]
		WHEN DATEDIFF(d,0,[Actual Out]) > @stop_day THEN 86400
		-- [Actual In] IS NOT NULL AND ([Actual Out] IS NULL OR DATEDIFF(d,0,[Actual Out]) <= @stop_day)
		ELSE [Out Seconds]
	END
	FROM #EMPLOYEE_TIME_ROUNDED WHERE [In Day past 1900] >= @start_day
END
ELSE
BEGIN
	UPDATE #EMPLOYEE_TIME_ROUNDED SET [In Seconds Bounded] = [In Seconds]
	UPDATE #EMPLOYEE_TIME_ROUNDED SET [Out Seconds Bounded] = [Out Seconds]
END




-- Provides way to override first day of week as defined by the current language
DECLARE @date_first int
SELECT @date_first = DatePartDW FROM vwDateFirst
--DECLARE @start_date datetime, @stop_date datetime
--SELECT @start_date = dbo.GetDateFromDaysPast1900(@start_day_effective), @stop_date = dbo.GetDateFromDaysPast1900(@stop_day)


CREATE TABLE #ET(
	EmployeeID int,
	[Day past 1900] int, 
	IN1 datetime NULL, OUT1 datetime NULL, SECONDS1 int DEFAULT 0, OriginalTimeItemID1 int NULL, Changed1 bit DEFAULT 0, Pending1 bit DEFAULT 1, ProjectID1 int,
	IN2 datetime NULL, OUT2 datetime NULL, SECONDS2 int DEFAULT 0, OriginalTimeItemID2 int NULL, Changed2 bit DEFAULT 0, Pending2 bit DEFAULT 1, ProjectID2 int,
	IN3 datetime NULL, OUT3 datetime NULL, SECONDS3 int DEFAULT 0, OriginalTimeItemID3 int NULL, Changed3 bit DEFAULT 0, Pending3 bit DEFAULT 1, ProjectID3 int,
	IN4 datetime NULL, OUT4 datetime NULL, SECONDS4 int DEFAULT 0, OriginalTimeItemID4 int NULL, Changed4 bit DEFAULT 0, Pending4 bit DEFAULT 1, ProjectID4 int,
	IN5 datetime NULL, OUT5 datetime NULL, SECONDS5 int DEFAULT 0, OriginalTimeItemID5 int NULL, Changed5 bit DEFAULT 0, Pending5 bit DEFAULT 1, ProjectID5 int,
	[Pending Unpaid Timecard Seconds] int DEFAULT 0,
	[Pending Paid Timecard Seconds] int DEFAULT 0,
	[Pending Paid Leave Seconds] int DEFAULT 0,
	[Pending Unpaid Leave Seconds] int DEFAULT 0,
	[Holiday Seconds] int DEFAULT 0, 
	[OT Seconds] int DEFAULT 0,
	[X2 Seconds] int DEFAULT 0,
	[Unpaid Timecard Seconds] int DEFAULT 0, 
	[Paid Timecard Seconds] int DEFAULT 0,
	[Paid Leave Seconds] int DEFAULT 0, 
	[Unpaid Leave Seconds] int DEFAULT 0, 
	[Payroll Start] datetime, 
	[Payroll Stop] datetime, 
	LeastItemID int, 
	LeastSeconds int,
	StatusID1 int NULL, StatusID2 int NULL, StatusID3 int NULL, StatusID4 int NULL, StatusID5 int NULL)




CREATE INDEX #ET_IN1 ON #ET(EmployeeID,LeastItemID)
CREATE INDEX #ET_IN2 ON #ET(EmployeeID,[Day past 1900])

-- Days to include
INSERT #ET(EmployeeID,[Day past 1900], [OT Seconds], [X2 Seconds])
SELECT EmployeeID,[In Day past 1900], SUM([OT Seconds]), SUM([X2 Seconds]) FROM #EMPLOYEE_TIME_ROUNDED GROUP BY EmployeeID,[In Day past 1900]

-- Calculates total timecard seconds and pending timecard seconds
UPDATE #ET SET [Unpaid Timecard Seconds] = ISNULL((
	SELECT SUM([Out Seconds] - [In Seconds]) FROM #EMPLOYEE_TIME_ROUNDED T
	WHERE CalculatedTypeID <> @pending_type_id AND T.EmployeeID = #ET.EmployeeID AND #ET.[Day past 1900] = T.[In Day past 1900] AND (T.Flags & 64) = 64
), 0),
[Pending Unpaid Timecard Seconds] = ISNULL((
	SELECT SUM([Out Seconds Bounded] - [In Seconds Bounded]) FROM #EMPLOYEE_TIME_ROUNDED T
	WHERE CalculatedTypeID = @pending_type_id AND T.EmployeeID = #ET.EmployeeID AND #ET.[Day past 1900] = T.[In Day past 1900] AND (T.Flags & 64) = 64
), 0),
[Holiday Seconds] = ISNULL((
	SELECT SUM([Holiday Seconds]) FROM #EMPLOYEE_TIME_ROUNDED ETR WHERE ETR.EmployeeID = #ET.EmployeeID AND #ET.[Day past 1900] = ETR.[In Day past 1900]
),0),
[Paid Timecard Seconds] = ISNULL((
	SELECT SUM([Out Seconds Bounded] - [In Seconds Bounded]) FROM #EMPLOYEE_TIME_ROUNDED T
	WHERE CalculatedTypeID <> @pending_type_id AND T.EmployeeID = #ET.EmployeeID AND #ET.[Day past 1900] = T.[In Day past 1900] AND (T.Flags & 64) = 0
), 0),
[Pending Paid Timecard Seconds] = ISNULL((
	SELECT SUM([Out Seconds Bounded] - [In Seconds Bounded]) FROM #EMPLOYEE_TIME_ROUNDED T
	WHERE CalculatedTypeID = @pending_type_id AND T.EmployeeID = #ET.EmployeeID AND #ET.[Day past 1900] = T.[In Day past 1900] AND (T.Flags & 64) = 0
), 0)

-- IN1 OUT1
UPDATE #ET SET LeastItemID = (
	SELECT TOP 1 R.TempItemID FROM #EMPLOYEE_TIME_ROUNDED R WHERE R.EmployeeID=#ET.EmployeeID AND R.[In Day past 1900]=#ET.[Day past 1900] AND (R.Flags & 2) = 2 ORDER BY R.[In Seconds], R.[Out Seconds], R.TempItemID
)

UPDATE #ET SET 
IN1 = R.[Actual In],
OUT1 = CASE 
	WHEN R.[Actual In] = R.[Actual Out] THEN NULL
	ELSE R.[Actual Out]
END,
OriginalTimeItemID1 = R.OriginalTimeItemID,
Changed1 = CASE WHEN R.CopyTimeItemID IS NULL THEN 0 WHEN R.OriginalTimeItemID IS NULL THEN 0 ELSE 1 END,
Pending1 = CASE WHEN EmployeeTime.StatusID = 8 THEN 1 ELSE 0 END,
StatusID1 = EmployeeTime.StatusID,
SECONDS1 = R.[Base Seconds],
ProjectID1 = EmployeeTime.ProjectID
FROM #ET
INNER JOIN #EMPLOYEE_TIME_ROUNDED R ON R.TempItemID=#ET.LeastItemID
INNER JOIN EmployeeTime ON R.CopyTimeItemID=EmployeeTime.ItemID


DELETE R FROM #EMPLOYEE_TIME_ROUNDED R
INNER JOIN #ET ON #ET.LeastItemID=R.TempItemID


-- IN2 OUT2
UPDATE #ET SET LeastItemID = (
	SELECT TOP 1 R.TempItemID FROM #EMPLOYEE_TIME_ROUNDED R WHERE R.EmployeeID=#ET.EmployeeID AND R.[In Day past 1900]=#ET.[Day past 1900] AND (R.Flags & 2) = 2 ORDER BY R.[In Seconds], R.[Out Seconds], R.TempItemID
)

UPDATE #ET SET 
IN2 = R.[Actual In],
OUT2 = CASE 
	WHEN R.[Actual In] = R.[Actual Out] THEN NULL
	ELSE R.[Actual Out]
END,
OriginalTimeItemID2 = R.OriginalTimeItemID,
Changed2 = CASE WHEN R.CopyTimeItemID IS NULL THEN 0 WHEN R.OriginalTimeItemID IS NULL THEN 0 ELSE 1 END,
Pending2 = CASE WHEN EmployeeTime.StatusID = 8 THEN 1 ELSE 0 END,
StatusID2 = EmployeeTime.StatusID,
SECONDS2 = R.[Base Seconds],
ProjectID2 = EmployeeTime.ProjectID
FROM #ET
INNER JOIN #EMPLOYEE_TIME_ROUNDED R ON R.TempItemID=#ET.LeastItemID
INNER JOIN EmployeeTime ON R.CopyTimeItemID=EmployeeTime.ItemID


DELETE R FROM #EMPLOYEE_TIME_ROUNDED R
INNER JOIN #ET ON #ET.LeastItemID=R.TempItemID

-- IN3 OUT3
UPDATE #ET SET LeastItemID = (
	SELECT TOP 1 R.TempItemID FROM #EMPLOYEE_TIME_ROUNDED R WHERE R.EmployeeID=#ET.EmployeeID AND R.[In Day past 1900]=#ET.[Day past 1900] AND (R.Flags & 2) = 2 ORDER BY R.[In Seconds], R.[Out Seconds], R.TempItemID
)

UPDATE #ET SET 
IN3 = R.[Actual In],
OUT3 = CASE 
	WHEN R.[Actual In] = R.[Actual Out] THEN NULL
	ELSE R.[Actual Out]
END,
OriginalTimeItemID3 = R.OriginalTimeItemID,
Changed3 = CASE WHEN R.CopyTimeItemID IS NULL THEN 0 WHEN R.OriginalTimeItemID IS NULL THEN 0 ELSE 1 END,
Pending3 = CASE WHEN EmployeeTime.StatusID = 8 THEN 1 ELSE 0 END,
StatusID3 = EmployeeTime.StatusID,
SECONDS3 = R.[Base Seconds],
ProjectID3 = EmployeeTime.ProjectID
FROM #ET
INNER JOIN #EMPLOYEE_TIME_ROUNDED R ON R.TempItemID=#ET.LeastItemID
INNER JOIN EmployeeTime ON R.CopyTimeItemID=EmployeeTime.ItemID


DELETE R FROM #EMPLOYEE_TIME_ROUNDED R
INNER JOIN #ET ON #ET.LeastItemID=R.TempItemID


-- IN4 OUT4
UPDATE #ET SET LeastItemID = (
	SELECT TOP 1 R.TempItemID FROM #EMPLOYEE_TIME_ROUNDED R WHERE R.EmployeeID=#ET.EmployeeID AND R.[In Day past 1900]=#ET.[Day past 1900] AND (R.Flags & 2) = 2 ORDER BY R.[In Seconds], R.[Out Seconds], R.TempItemID
)

UPDATE #ET SET 
IN4 = R.[Actual In],
OUT4 = CASE 
	WHEN R.[Actual In] = R.[Actual Out] THEN NULL
	ELSE R.[Actual Out]
END,
OriginalTimeItemID4 = R.OriginalTimeItemID,
Changed4 = CASE WHEN R.CopyTimeItemID IS NULL THEN 0 WHEN R.OriginalTimeItemID IS NULL THEN 0 ELSE 1 END,
Pending4 = CASE WHEN EmployeeTime.StatusID = 8 THEN 1 ELSE 0 END,
StatusID4 = EmployeeTime.StatusID,
SECONDS4 = R.[Base Seconds],
ProjectID4 = EmployeeTime.ProjectID
FROM #ET
INNER JOIN #EMPLOYEE_TIME_ROUNDED R ON R.TempItemID=#ET.LeastItemID
INNER JOIN EmployeeTime ON R.CopyTimeItemID=EmployeeTime.ItemID


DELETE R FROM #EMPLOYEE_TIME_ROUNDED R
INNER JOIN #ET ON #ET.LeastItemID=R.TempItemID


-- IN5 OUT5
UPDATE #ET SET LeastItemID = (
	SELECT TOP 1 R.TempItemID FROM #EMPLOYEE_TIME_ROUNDED R WHERE R.EmployeeID=#ET.EmployeeID AND R.[In Day past 1900]=#ET.[Day past 1900] AND (R.Flags & 2) = 2 ORDER BY R.[In Seconds], R.[Out Seconds], R.TempItemID
)


UPDATE #ET SET 
IN5 = R.[Actual In],
OUT5 = CASE 
	WHEN R.[Actual In] = R.[Actual Out] THEN NULL
	ELSE R.[Actual Out]
END,
OriginalTimeItemID5 = R.OriginalTimeItemID,
Changed5 = CASE WHEN R.CopyTimeItemID IS NULL THEN 0 WHEN R.OriginalTimeItemID IS NULL THEN 0 ELSE 1 END,
Pending5 = CASE WHEN EmployeeTime.StatusID = 8 THEN 1 ELSE 0 END,
StatusID5 = EmployeeTime.StatusID,
SECONDS5 = R.[Base Seconds],
ProjectID5 = EmployeeTime.ProjectID
FROM #ET
INNER JOIN #EMPLOYEE_TIME_ROUNDED R ON R.TempItemID=#ET.LeastItemID
INNER JOIN EmployeeTime ON R.CopyTimeItemID=EmployeeTime.ItemID


DELETE R FROM #EMPLOYEE_TIME_ROUNDED R
INNER JOIN #ET ON #ET.LeastItemID=R.TempItemID



-- Insert blanks for empty weekdays
DECLARE @dt datetime, @dti int

SELECT @dti = @start_day, @dt = DATEADD(d, 0, @dti)

WHILE @dti <= @stop_day_effective
BEGIN
	--IF NOT EXISTS(SELECT * FROM #ET WHERE [Day past 1900] = @dti) INSERT #ET([Day past 1900]) VALUES(@dti)

	INSERT #ET(EmployeeID, [Day past 1900])
	SELECT X.[ID], @dti
	FROM dbo.TempX X
	LEFT JOIN #ET ON X.BatchID=@batch_id AND X.[ID]=#ET.EmployeeID AND #ET.[Day past 1900]=@dti
	WHERE X.BatchID=@batch_id AND #ET.EmployeeID IS NULL
	
	SELECT @dt = DATEADD(d, 1, @dt)	, @dti = @dti + 1
END

DECLARE @type_bank_mask int
SELECT TOP 1 @type_bank_mask = [Timecard Leave Type Mask] FROM dbo.Constant

-- Leave
UPDATE #ET SET [Paid Leave Seconds] =
ISNULL((
	SELECT SUM(-L.Seconds) FROM dbo.vwEmployeeLeaveApproved L WHERE L.EmployeeID=#ET.EmployeeID AND L.[Limit Adjustment]=0 AND L.Seconds < 0 AND L.Paid=1 AND L.[Day past 1900] = #ET.[Day past 1900]
), 0), [Unpaid Leave Seconds] =
ISNULL((
	SELECT SUM(-L.Seconds) FROM dbo.vwEmployeeLeaveApproved L WHERE L.EmployeeID=#ET.EmployeeID AND L.[Limit Adjustment]=0 AND L.Seconds < 0 AND L.Paid=0 AND L.[Day past 1900] = #ET.[Day past 1900]
), 0), [Pending Paid Leave Seconds] =
ISNULL((
	SELECT SUM(U.Seconds) FROM dbo.vwEmployeeLeaveUsedItem U WHERE U.EmployeeID=#ET.EmployeeID AND (U.TypeID & @type_bank_mask) != 0 AND U.[Status] = 1 AND U.[Day past 1900] = #ET.[Day past 1900] AND U.Paid=1
), 0), [Pending Unpaid Leave Seconds] =
ISNULL((
	SELECT SUM(U.Seconds) FROM dbo.vwEmployeeLeaveUsedItem U WHERE U.EmployeeID=#ET.EmployeeID AND (U.TypeID & @type_bank_mask) != 0 AND U.[Status] = 1 AND U.[Day past 1900] = #ET.[Day past 1900] AND U.Paid=0
), 0)

-- Calculate payroll start dates
CREATE TABLE #T(StartDate datetime, StopDate datetime)


WHILE EXISTS(SELECT * FROM #ET WHERE [Payroll Start] IS NULL)
BEGIN
	SELECT TOP 1 @dt = DATEADD(d, [Day past 1900], 0) FROM #ET WHERE [Payroll Start] IS NULL

	DELETE #T
	INSERT #T
	EXEC dbo.spEmployeeTimeCalculateFilterInverse @dt, 5

	UPDATE #ET SET [Payroll Start] = T.StartDate, [Payroll Stop] = T.StopDate
	FROM #ET
	INNER JOIN #T T ON #ET.[Payroll Start] IS NULL AND DATEADD(d, [Day past 1900], 0) BETWEEN T.StartDate AND T.StopDate
END

/*
IF @start_day_effective < @start_day
BEGIN
	UPDATE #ET SET Seconds1=0, Seconds2=0, Seconds3=0, Seconds4=0, Seconds5=0, [Paid Leave Seconds]=0, [Unpaid Leave Seconds]=0, [Paid Timecard Seconds]=0, [Unpaid Timecard Seconds]=0,
	[Holiday Seconds] = 0, [Pending Paid Timecard Seconds] = 0, [Pending Unpaid Timecard Seconds] = 0, [Pending Paid Leave Seconds] = 0, [Pending Unpaid Leave Seconds] = 0
	WHERE [Day past 1900] = @start_day_effective AND (
		(IN1 IS NOT NULL AND OUT1 IS NOT NULL AND DATEDIFF(d,0,IN1) != DATEDIFF(d,0,OUT1)) OR
		(IN2 IS NOT NULL AND OUT2 IS NOT NULL AND DATEDIFF(d,0,IN2) != DATEDIFF(d,0,OUT2)) OR
		(IN3 IS NOT NULL AND OUT3 IS NOT NULL AND DATEDIFF(d,0,IN3) != DATEDIFF(d,0,OUT3)) OR
		(IN4 IS NOT NULL AND OUT4 IS NOT NULL AND DATEDIFF(d,0,IN4) != DATEDIFF(d,0,OUT4)) OR
		(IN5 IS NOT NULL AND OUT5 IS NOT NULL AND DATEDIFF(d,0,IN5) != DATEDIFF(d,0,OUT5))
	)
	--ELSE DELETE #ET WHERE [Day past 1900] = @start_day
END
*/

IF (@flags & 1) = 1
BEGIN
	DELETE #ET WHERE EmployeeID NOT IN (
		SELECT EmployeeID FROM #ET WHERE IN1 IS NOT NULL OR IN2 IS NOT NULL OR IN3 IS NOT NULL OR IN4 IS NOT NULL OR IN5 IS NOT NULL OR 
		[Paid Leave Seconds] <> 0 OR [Unpaid Leave Seconds] <> 0 OR [Unpaid Timecard Seconds] <> 0 OR [Paid Timecard Seconds] <> 0 OR [Holiday Seconds] <> 0 OR
		[OT Seconds] <> 0 OR [Pending Unpaid Timecard Seconds] <> 0 OR [Pending Paid Leave Seconds] <> 0 OR [Pending Unpaid Leave Seconds] <> 0
	)
END



SET @employees_returned = ISNULL((
	SELECT COUNT(DISTINCT EmployeeID) FROM #ET
), 0)


SELECT EID = #ET.[EmployeeID], [Date] = DATEADD(d, 0, #ET.[Day past 1900]), #ET.[Payroll Start], #ET.[Payroll Stop],
[Week Start] = dbo.GetWeekStart(@date_first, #ET.[Day past 1900]),
#ET.IN1, #ET.OUT1, HOURS1 = #ET.SECONDS1 / 3600.0, #ET.OriginalTimeItemID1, #ET.Changed1, #ET.Pending1, #ET.ProjectID1, StatusID1 = CASE WHEN #ET.StatusID1 IS NOT NULL THEN #ET.StatusID1 WHEN TS.[Column Mask] & 2= 2 THEN 8 ELSE 1 END, 
#ET.IN2, #ET.OUT2, HOURS2 = #ET.SECONDS2 / 3600.0, #ET.OriginalTimeItemID2, #ET.Changed2, #ET.Pending2, #ET.ProjectID2, StatusID2 = CASE WHEN #ET.StatusID2 IS NOT NULL THEN #ET.StatusID2 WHEN TS.[Column Mask] & 2= 2 THEN 8 ELSE 1 END,
#ET.IN3, #ET.OUT3, HOURS3 = #ET.SECONDS3 / 3600.0, #ET.OriginalTimeItemID3, #ET.Changed3, #ET.Pending3, #ET.#ET.ProjectID3, StatusID3 = CASE WHEN #ET.StatusID3 IS NOT NULL THEN #ET.StatusID3 WHEN TS.[Column Mask] & 2= 2 THEN 8 ELSE 1 END,
#ET.IN4, #ET.OUT4, HOURS4 = #ET.SECONDS4 / 3600.0, #ET.OriginalTimeItemID4, #ET.Changed4, #ET.Pending4, ProjectID4, StatusID4 = CASE WHEN #ET.StatusID4 IS NOT NULL THEN #ET.StatusID4 WHEN TS.[Column Mask] & 2= 2 THEN 8 ELSE 1 END,
#ET.IN5, #ET.OUT5, HOURS5 = #ET.SECONDS5 / 3600.0, #ET.OriginalTimeItemID5, #ET.Changed5, #ET.Pending5, #ET.ProjectID5, StatusID5 = CASE WHEN #ET.StatusID5 IS NOT NULL THEN #ET.StatusID5 WHEN TS.[Column Mask] & 2= 2 THEN 8 ELSE 1 END,
[Paid Leave Hours] = #ET.[Paid Leave Seconds] / 3600.0,
[Unpaid Leave Hours] = #ET.[Unpaid Leave Seconds] / 3600.0,
[Timecard Hours] = (#ET.[Paid Timecard Seconds] + #ET.[Unpaid Timecard Seconds]) / 3600.0,
[Holiday Hours] = #ET.[Holiday Seconds] / 3600.0,
[Total Hours] = (#ET.[Pending Paid Timecard Seconds] + #ET.[Pending Unpaid Timecard Seconds] + #ET.[Paid Timecard Seconds] + #ET.[Unpaid Timecard Seconds] + #ET.[Paid Leave Seconds] + #ET.[Unpaid Leave Seconds]) / 3600.0,
[Total Paid Hours] = (#ET.[Pending Paid Timecard Seconds] + #ET.[Pending Paid Leave Seconds] + #ET.[Paid Timecard Seconds] + #ET.[Paid Leave Seconds]) / 3600.0,
[OT Hours] = #ET.[OT Seconds] / 3600.00,
[X2 Hours] = #ET.[X2 Seconds] / 3600.00,
[NonOT Hours] = (#ET.[Paid Timecard Seconds] - #ET.[Holiday Seconds] - #ET.[OT Seconds] - #ET.[X2 Seconds]) / 3600.00,
[Pending Timecard Hours] = (#ET.[Pending Unpaid Timecard Seconds] + #ET.[Pending Paid Timecard Seconds]) / 3600.00,
[Pending Paid Leave Hours] = #ET.[Pending Paid Leave Seconds] / 3600.00,
[Pending Unpaid Leave Hours] = #ET.[Pending Unpaid Leave Seconds] / 3600.00,
[Pending Paid Timecard Hours] = #ET.[Pending Paid Timecard Seconds] / 3600.00,
[Unpaid Timecard Hours] = #ET.[Unpaid Timecard Seconds] / 3600.00,
[List As] = dbo.fnGetListAs(P.[First Name], P.[Middle Name], P.[Last Name], P.Suffix),
[Full Name] = dbo.fnGetFullName(P.[First Name], P.[Middle Name], P.[Last Name], P.Suffix)
FROM #ET 
INNER JOIN dbo.Employee E ON #ET.EmployeeID=E.EmployeeID
INNER JOIN dbo.TimeSchema TS ON E.TimeSchemaID = TS.TimeSchemaID
INNER JOIN dbo.Person P ON P.PersonID=#ET.EmployeeID
ORDER BY P.[Last Name],P.[First Name],P.[Title],P.[Middle Name],[Day past 1900]

DELETE TempXYZ WHERE BatchID=@batch_id OR DATEDIFF(hour,Created,GETDATE()) > 1
GO
IF OBJECT_ID('dbo.spEmployeeTimeList5ReportColumns') IS NOT NULL DROP PROC dbo.spEmployeeTimeList5ReportColumns
GO
CREATE PROC dbo.spEmployeeTimeList5ReportColumns
AS
SET NOCOUNT ON

CREATE TABLE #REPORT_COLUMNS(colid int PRIMARY KEY, [Name] sysname COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL, Caption sysname COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL, [Example] varchar(50) COLLATE SQL_Latin1_General_CP1_CI_AS NULL, [Group] varchar(50) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL, Flags int NOT NULL)

INSERT #REPORT_COLUMNS
SELECT 
CColumns.colid,
[Name] = CColumns.[name], 
Caption = dbo.GetCaptionForColumnName(CColumns.[name]),
Example = dbo.GetExampleForColumnName(CColumns.[name], NULL),
[Group] = dbo.GetGroupFromColumnName(CColumns.[name], 'Other'),
Flags = 0
FROM syscolumns CColumns
WHERE [ID]=OBJECT_ID('vwEmployeeSecure') AND dbo.IsColumnVisibleOnReport(CColumns.[name]) = 1 AND CColumns.[name] != 'Person List As'

EXEC dbo.spReportFillColumnExamples 'vwEmployeeSecure', 'EmployeeID'

INSERT #REPORT_COLUMNS(colid,[Name],Caption,Example,[Group],Flags) VALUES(-1, 'vIn', 'In', '12:30PM', 'Time Analysis', 0)
INSERT #REPORT_COLUMNS(colid,[Name],Caption,Example,[Group],Flags) VALUES(-2, 'vOut', 'Out', '4:30PM', 'Time Analysis', 0)
INSERT #REPORT_COLUMNS(colid,[Name],Caption,Example,[Group],Flags) VALUES(-3, 'vIn2', 'In (Hrs past midnight)', '12.5', 'Time Analysis', 0)
INSERT #REPORT_COLUMNS(colid,[Name],Caption,Example,[Group],Flags) VALUES(-4, 'vOut2', 'Out (Hrs past midnight)', '15.5', 'Time Analysis', 0)
INSERT #REPORT_COLUMNS(colid,[Name],Caption,Example,[Group],Flags) VALUES(-5, 'vHours', 'Hours', '3.00', 'Time Analysis', 0)
INSERT #REPORT_COLUMNS(colid,[Name],Caption,Example,[Group],Flags) VALUES(-6, 'vBreak', 'Break', '1.25', 'Time Analysis', 0)
INSERT #REPORT_COLUMNS(colid,[Name],Caption,Example,[Group],Flags) VALUES(-7, 'Row', 'Employee', 'Doe, John / Total', 'Time Analysis', 0)

SELECT * FROM #REPORT_COLUMNS ORDER BY CASE WHEN [Group] = 'Name' THEN '_' ELSE '' END + [Group], Caption
GO
GRANT EXEC ON dbo.spEmployeeTimeList5ReportColumns TO public
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spEmployeeTimeList5', 1
GO
ALTER PROC dbo.spEmployeeTimeList5
	@batch_id int,
	@start_day int,
	@stop_day int,
	@flags int, -- 1: exclude pending
	@time_type_mask int,
	@authorized bit OUT
AS
SET NOCOUNT ON

DECLARE @exclude_pending bit
SET @exclude_pending = CASE WHEN (@flags & 1) = 1 THEN 1 ELSE 0 END

CREATE TABLE #EMPLOYEE_TIME_ROUNDED(
	TempItemID int NOT NULL IDENTITY(1,1) PRIMARY KEY,
	EmployeeID int NOT NULL,
	OriginalTypeID int NOT NULL, 
	CalculatedTypeID int NOT NULL,
	[In Day past 1900] int NOT NULL, 
	[OT Eligible] bit NOT NULL,
	[OT Disable] bit NOT NULL,
	[Pay Rate] money NOT NULL,
	[Fixed Pay] money NOT NULL DEFAULT(0),
	[Fixed Items] int DEFAULT(0),
	Regular bit DEFAULT(0),
	[In Seconds] int NOT NULL,
	[Out Seconds] int NOT NULL,
	TimeSchemaID int NOT NULL,
	ShiftDiffItemID int NULL,
	TempShiftDiffSeconds int NULL,
	TempShiftDiffItemID int NULL,
	OriginalTimeItemID int NULL,
	CopyTimeItemID int NULL,
	[Time Seconds] int NOT NULL DEFAULT(0),
	[Holiday Seconds] int NOT NULL DEFAULT(0),
	[OT Seconds] int NOT NULL DEFAULT(0),
	Flags int NOT NULL DEFAULT(0),
	[Actual In] datetime NULL,
	[Actual Out] datetime NULL,
	[Base Seconds] int NOT NULL DEFAULT(0),
	[X2 Seconds] int NOT NULL DEFAULT(0)
)

DECLARE @pending_type_id int, @denied_type_id int
EXEC dbo.spEmployeeTimeRoundAndCalcOT @batch_id, 0, @start_day OUT, @stop_day OUT, NULL, NULL, @authorized OUT, @pending_type_id OUT, @denied_type_id OUT

DELETE #EMPLOYEE_TIME_ROUNDED WHERE CalculatedTypeID = @denied_type_id
IF @exclude_pending = 1 DELETE #EMPLOYEE_TIME_ROUNDED WHERE CalculatedTypeID = @pending_type_id
DELETE #EMPLOYEE_TIME_ROUNDED WHERE CalculatedTypeID <> @pending_type_id AND (CalculatedTypeID & @time_type_mask) = 0
DELETE #EMPLOYEE_TIME_ROUNDED WHERE [In Day past 1900] NOT BETWEEN @start_day AND @stop_day

CREATE TABLE #L(
	ItemID int IDENTITY(1,1) PRIMARY KEY,
	TypeID int NOT NULL,
	EmployeeID int NULL,
	Row varchar(400) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
	D int NULL,
	[First Actual In] int NULL,
	[Last Actual Out] int NULL, 
	Seconds int NULL,
	[Break Seconds] int NULL,
	ColOrder int NOT NULL
)


CREATE TABLE #D(D int NOT NULL)

DECLARE @d int
SET @d = @start_day
WHILE @d <= @stop_day
BEGIN
	INSERT #D(D) SELECT @d
	SET @d = @d + 1
END


INSERT #L(TypeID, EmployeeID, Row, D, ColOrder)
SELECT 0, X.[ID], '', #D.D, 0
FROM dbo.TempX X
CROSS JOIN #D WHERE X.BatchID=@batch_id



CREATE INDEX LspEmployeeTimeList5EmployeeID ON #L(EmployeeID)
CREATE INDEX LspEmployeeTimeList5TypeID ON #L(TypeID)
CREATE INDEX LspEmployeeTimeList5D ON #L(D)
CREATE INDEX LspEmployeeTimeList5EmployeeIDD ON #L(EmployeeID, D)


UPDATE #L SET
Row = P.[List As],
[First Actual In] = (
	SELECT MIN(DATEDIFF(second,R.[In Day past 1900],R.[Actual In])) FROM #EMPLOYEE_TIME_ROUNDED R WHERE R.EmployeeID=#L.EmployeeID AND R.[In Day past 1900]=#L.D
),
[Last Actual Out] = (
	SELECT MAX(DATEDIFF(second,R.[In Day past 1900],R.[Actual Out])) FROM #EMPLOYEE_TIME_ROUNDED R WHERE R.EmployeeID=#L.EmployeeID AND R.[In Day past 1900]=#L.D
),
Seconds = (
	SELECT SUM(R.[Base Seconds]) FROM #EMPLOYEE_TIME_ROUNDED R WHERE R.EmployeeID=#L.EmployeeID AND R.[In Day past 1900]=#L.D
)
FROM #L
INNER JOIN dbo.vwPersonListAs P ON #L.EmployeeID = P.PersonID

UPDATE #L SET [Break Seconds] = [Last Actual Out] - [First Actual In] - Seconds


-- Total Column
IF @start_day != @stop_day
INSERT #L(TypeID, EmployeeID, Row, D, [First Actual In], [Last Actual Out], Seconds, [Break Seconds], ColOrder)
SELECT
TypeID = 1,
EmployeeID = #L.EmployeeID,
Row = P.[List As],
D  = NULL,
[First Actual In] = NULL,
[Last Actual Out] = NULL,
Seconds = SUM(#L.Seconds),
[Break Seconds] = SUM(#L.[Break Seconds]),
ColOrder = 2
FROM #L
INNER JOIN dbo.vwPersonListAs P ON #L.EmployeeID = P.PersonID AND #L.TypeID=0
GROUP BY #L.EmployeeID, P.[List As]

-- Avg Column
IF @start_day != @stop_day
INSERT #L(TypeID, EmployeeID, Row, D, [First Actual In], [Last Actual Out], Seconds, [Break Seconds], ColOrder)
SELECT
TypeID = 2,
EmployeeID = #L.EmployeeID,
Row = P.[List As],
D = NULL,
[First Actual In] = AVG(#L.[First Actual In]),
[Last Actual Out] = AVG(#L.[Last Actual Out]),
Seconds = AVG(#L.Seconds),
[Break Seconds] = AVG(#L.[Break Seconds]),
ColOrder = 1
FROM #L
INNER JOIN dbo.vwPersonListAs P ON #L.EmployeeID = P.PersonID AND #L.TypeID=0
GROUP BY #L.EmployeeID, P.[List As]

-- Total row
INSERT #L(TypeID, EmployeeID, Row, D, [First Actual In], [Last Actual Out], Seconds, [Break Seconds], ColOrder)
SELECT
TypeID = 3,
EmployeeID = NULL,
Row = 'Total',
D,
[First Actual In] = NULL,
[Last Actual Out] = NULL,
Seconds = SUM(Seconds),
[Break Seconds] = SUM([Break Seconds]),
ColOrder = ColOrder + 4
FROM #L WHERE TypeID <= 2 GROUP BY D, ColOrder



-- Average row
INSERT #L(TypeID, EmployeeID, Row, D, [First Actual In], [Last Actual Out], Seconds, [Break Seconds], ColOrder)
SELECT 4,
NULL,
Row = 'Average',
D,
AVG([First Actual In]),
AVG([Last Actual Out]),
AVG(Seconds),
AVG([Break Seconds]),
ColOrder = ColOrder + 3
FROM #L WHERE TypeID <= 2 GROUP BY D, ColOrder

SELECT
EmployeeIDIsNull = CAST(CASE WHEN EmployeeID IS NULL THEN 1 ELSE 0 END AS bit),
TypeID,
EmployeeID,
Row,
D = DATEADD(day,0,D),
[First Actual In],
[Last Actual Out],
Seconds,
[Break Seconds],
RowID = CASE
	WHEN TypeID <=2 THEN 'E' + CAST(EmployeeID AS varchar(50))
	ELSE 'T' + CAST(TypeID AS varchar(50))
END
FROM #L 
ORDER BY
CASE
	WHEN EmployeeID IS NOT NULL THEN -1
	ELSE 1000 - TypeID
END,
Row, EmployeeID, ColOrder, D

SELECT S.* FROM dbo.vwEmployeeSecure S
INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID] = S.EID

DELETE dbo.TempX WHERE BatchID=@batch_id OR DATEDIFF(hour,Created,GETDATE()) > 1
GO
IF OBJECT_id('dbo.spPermissionListOnPersonForCurrentUser') IS NOT NULL DROP PROC dbo.spPermissionListOnPersonForCurrentUser
GO
CREATE PROC dbo.spPermissionListOnPersonForCurrentUser
	@person_id int,
	@attribute_id int,
	@deny int = 0 out,
	@permission int = 0 out
AS
-- Returns the permission on a given attribute 
-- on a given person (employee\applicant...) for the current user
DECLARE @employee_id int
DECLARE @department_id int
DECLARE @division_id int
DECLARE @location_id int
DECLARE @position_id int
DECLARE @manager_id int
DECLARE @org_user_field_1 int

CREATE TABLE #P (
	[Group] varchar(50) COLLATE SQL_Latin1_General_CP1_CI_AS, Scope varchar(50) COLLATE SQL_Latin1_General_CP1_CI_AS, [Permission Mask] int, [Deny Mask] int
)

SELECT @org_user_field_1 = OrgUserField1, @manager_id = ManagerID, @employee_id = EmployeeID, @division_id = DivisionID, @department_id = DepartmentID, @location_id = LocationID FROM Employee WHERE SID = SUSER_SID()

DECLARE @name sysname, @sid varbinary(85), @p int, @d int, @uid int


IF IS_MEMBER('db_owner') = 1
BEGIN
	SELECT @p=0x7FFFFFFF, @d=0
	INSERT #P SELECT [Group] = 'db_owner', Scope='', [Permission Mask]=@p, [Deny Mask]=@d
	SELECT @permission=@permission | @p, @deny=@deny | @d
END

DECLARE g_cursor CURSOR LOCAL FORWARD_ONLY STATIC FOR SELECT [name], SID, UID FROM sysusers

DECLARE @match_sid bit
SET @match_sid = 0

OPEN g_cursor
FETCH g_cursor INTO @name, @sid, @uid
WHILE @@FETCH_STATUS=0
BEGIN
	IF IS_MEMBER(@name)=1 OR @sid = SUSER_SID()
	BEGIN
		DECLARE @match bit
		SET @match=0

		IF @sid = SUSER_SID() SET @match_sid = 1

		-- All people
		SELECT @p=P.[Permission Mask], @d=P.[Deny Mask]
		FROM PermissionScopeAttribute P WHERE P.ScopeID=1 AND P.AttributeID=@attribute_id AND P.UID=@uid
		IF @@ROWCOUNT > 0
		BEGIN
			INSERT #P SELECT [Group] = @name, Scope='All People',  [Permission Mask]=@p, [Deny Mask]=@d
			SELECT @permission=@permission | @p, @deny=@deny | @d
			SET @match=1
		END

		-- Applicant
		SELECT @p=P.[Permission Mask], @d=P.[Deny Mask]
		FROM PermissionScopeAttribute P
		INNER JOIN Applicant ON Applicant.ApplicantID = @person_id AND P.ScopeID = 128 AND P.AttributeID = @attribute_id AND P.UID=@uid
		AND P.UID=@uid
		IF @@ROWCOUNT > 0
		BEGIN
			INSERT #P SELECT [Group] = @name, Scope='Applicant',  [Permission Mask]=@p, [Deny Mask]=@d
			SELECT @permission=@permission | @p, @deny=@deny | @d
			SET @match=1
		END

		-- Select employee-level permissions
		SELECT @p=P.[Permission Mask], @d=P.[Deny Mask]
		FROM PermissionScopeAttribute P 
		INNER JOIN Employee E ON P.AttributeID = @attribute_id AND E.EmployeeID = @person_id AND P.UID=@uid AND
		P.ScopeID = 2						
		IF @@ROWCOUNT > 0
		BEGIN
			INSERT #P SELECT [Group] = @name, Scope='All Employees',  [Permission Mask]=@p, [Deny Mask]=@d
			SELECT @permission=@permission | @p, @deny=@deny | @d
			SET @match=1
		END				


		-- Select self
		SELECT @p=P.[Permission Mask], @d=P.[Deny Mask]
		FROM PermissionScopeAttribute P 
		INNER JOIN Employee E ON P.AttributeID = @attribute_id AND E.EmployeeID = @person_id AND P.UID=@uid AND
		P.ScopeID = 4 AND E.SID = @sid			
		IF @@ROWCOUNT > 0
		BEGIN
			INSERT #P SELECT [Group] = @name, Scope='Self',  [Permission Mask]=@p, [Deny Mask]=@d
			SELECT @permission=@permission | @p, @deny=@deny | @d
			SET @match=1
		END

		-- Select division
		SELECT @p=P.[Permission Mask], @d=P.[Deny Mask]
		FROM PermissionScopeAttribute P 
		INNER JOIN Employee E ON P.AttributeID = @attribute_id AND E.EmployeeID = @person_id AND P.UID=@uid AND
		P.ScopeID = 16 AND E.DivisionID = @division_id
		IF @@ROWCOUNT > 0
		BEGIN
			INSERT #P SELECT [Group] = @name, Scope='Division',  [Permission Mask]=@p, [Deny Mask]=@d
			SELECT @permission=@permission | @p, @deny=@deny | @d
			SET @match=1
		END
		
		-- Select OrgUserfield1
		SELECT @p=P.[Permission Mask], @d=P.[Deny Mask]
		FROM PermissionScopeAttribute P 
		INNER JOIN Employee E ON P.AttributeID = @attribute_id AND E.EmployeeID = @person_id AND P.UID=@uid AND
		P.ScopeID = 4096 AND (
			(@org_user_field_1 IS NOT NULL AND E.OrgUserField1 = @org_user_field_1) OR EXISTS(
				SELECT * FROM dbo.EmployeeUserFieldItem WHERE EmployeeID=@employee_id AND ItemID=E.OrgUserField1
			)
		)
		IF @@ROWCOUNT > 0
		BEGIN
			INSERT #P SELECT [Group] = @name, Scope='OrgUserField1',  [Permission Mask]=@p, [Deny Mask]=@d
			SELECT @permission=@permission | @p, @deny=@deny | @d
			SET @match=1
		END
		
		-- Select inactive employees
		SELECT @p=P.[Permission Mask], @d=P.[Deny Mask]
		FROM PermissionScopeAttribute P 
		INNER JOIN Employee E ON P.AttributeID = @attribute_id AND E.EmployeeID = @person_id AND P.UID=@uid AND
		P.ScopeID = 8192 AND E.[Active Employee] = 0
		IF @@ROWCOUNT > 0
		BEGIN
			INSERT #P SELECT [Group] = @name, Scope='Inactive Employees',  [Permission Mask]=@p, [Deny Mask]=@d
			SELECT @permission=@permission | @p, @deny=@deny | @d
			SET @match=1
		END

		-- Select leave keeper
		SELECT TOP 1 @p=P.[Permission Mask], @d=P.[Deny Mask]
		FROM PermissionScopeAttribute P 
		INNER JOIN Employee E ON P.AttributeID = @attribute_id AND E.EmployeeID = @person_id AND P.UID=@uid AND P.ScopeID = 16384
		INNER JOIN dbo.Department D ON D.DepartmentID = E.DepartmentID
		INNER JOIN dbo.Division V ON V.DivisionID = E.DivisionID
		WHERE @employee_id IN (D.LeaveKeeperID, V.LeaveKeeperID) 

		IF @@ROWCOUNT > 0
		BEGIN
			INSERT #P SELECT [Group] = @name, Scope='Leave Keeper',  [Permission Mask]=@p, [Deny Mask]=@d
			SELECT @permission=@permission | @p, @deny=@deny | @d
			SET @match=1
		END

		-- Select location
		SELECT @p=P.[Permission Mask], @d=P.[Deny Mask]
		FROM PermissionScopeAttribute P 
		INNER JOIN Employee E ON P.AttributeID = @attribute_id AND E.EmployeeID = @person_id AND P.UID=@uid AND
		P.ScopeID = 64 AND E.LocationID = @location_id
		IF @@ROWCOUNT > 0
		BEGIN
			INSERT #P SELECT [Group] = @name, Scope='Location',  [Permission Mask]=@p, [Deny Mask]=@d
			SELECT @permission=@permission | @p, @deny=@deny | @d
			SET @match=1
		END

		-- Select department
		SELECT @p=P.[Permission Mask], @d=P.[Deny Mask]
		FROM PermissionScopeAttribute P 
		INNER JOIN Employee E ON P.AttributeID = @attribute_id AND E.EmployeeID = @person_id AND P.UID=@uid AND
		P.ScopeID = 32 AND E.DepartmentID = @department_id
		IF @@ROWCOUNT > 0
		BEGIN
			INSERT #P SELECT [Group] = @name, Scope='Department',  [Permission Mask]=@p, [Deny Mask]=@d
			SELECT @permission=@permission | @p, @deny=@deny | @d
			SET @match=1
		END

		-- Subordinates
		SELECT @p=P.[Permission Mask], @d=P.[Deny Mask]
		FROM PermissionScopeAttribute P 
		INNER JOIN Employee E ON P.AttributeID = @attribute_id AND E.EmployeeID = @person_id AND P.UID=@uid AND
		(P.ScopeID = 8 AND EXISTS(				-- Subordinates
				SELECT TOP 1 S.ItemID FROM EmployeeSuperior S WHERE S.EmployeeID = E.EmployeeID AND S.SuperiorID = @employee_id
			))
		IF @@ROWCOUNT > 0
		BEGIN
			INSERT #P SELECT [Group] = @name, Scope='Subordinates',  [Permission Mask]=@p, [Deny Mask]=@d
			SELECT @permission=@permission | @p, @deny=@deny | @d
			SET @match=1
		END
		
		-- Manager's Subordinates
		SELECT @p=P.[Permission Mask], @d=P.[Deny Mask]
		FROM PermissionScopeAttribute P 
		INNER JOIN Employee E ON P.AttributeID = @attribute_id AND E.EmployeeID = @person_id AND P.UID=@uid AND
		(P.ScopeID = 2048 AND EXISTS(				-- Subordinates
				SELECT TOP 1 S.ItemID FROM EmployeeSuperior S WHERE S.EmployeeID = E.EmployeeID AND S.SuperiorID = @manager_id
			))
		IF @@ROWCOUNT > 0
		BEGIN
			INSERT #P SELECT [Group] = @name, Scope='Managers Subordinates',  [Permission Mask]=@p, [Deny Mask]=@d
			SELECT @permission=@permission | @p, @deny=@deny | @d
			SET @match=1
		END


		IF @match=0 INSERT #P  SELECT [Group]=@name, Scope='', [Permission Mask]=0, [Deny Mask]=0
	END
	FETCH g_cursor INTO @name, @sid, @uid
END
CLOSE g_cursor
DEALLOCATE g_cursor

IF @deny=0 OR IS_MEMBER('db_owner') = 1 INSERT #P SELECT [Group]='Effective', [Scope]='Effective', [Permission Mask]=@permission, [Deny Mask]=@deny
ELSE
BEGIN
	INSERT #P SELECT [Group]='Cumulative', [Scope]='', [Permission Mask]=@permission, [Deny Mask]=@deny
	INSERT #P SELECT [Group]='Effective', [Scope]='', [Permission Mask]=@permission & (0x7FFFFFFF ^ @deny), [Deny Mask]=0
END

IF @match_sid = 0
INSERT #P SELECT [Group]=SUSER_SNAME(), [Scope]='', [Permission Mask]=0, [Deny Mask]=0

SELECT * FROM #P ORDER BY 
CASE [Group] 
	WHEN SUSER_SNAME() THEN 0 
	WHEN 'Effective' THEN 9
	WHEN 'Cumulative' THEN 8
	ELSE 1 
END
GO
GRANT EXEC ON dbo.spPermissionListOnPersonForCurrentUser TO public
GO
ALTER PROC dbo.spLeaveSummarizeAccrual
	@day int,
	@batch_id int,
	@authorized bit OUT
AS
SET NOCOUNT ON

EXEC dbo.spPermissionGetOnPeopleForCurrentUser2 @batch_id, 128
DELETE TempX WHERE BatchID = @batch_id AND (X & 1) = 0
SELECT @authorized = CASE WHEN @@ROWCOUNT = 0 THEN 1 ELSE 0 END

SELECT
EP.EmployeeID,
EP.TypeID,
Hrs = EP.[Effective Seconds] * (2080.00 / EP.[Seconds in Period]),
EP.[Plan]
INTO #L
FROM dbo.TempX X 
INNER JOIN dbo.vwEmployeeLeavePlanLeaveRate EP ON X.BatchID = @batch_id AND X.[ID] = EP.EmployeeID AND
DATEDIFF(mm, EP.[Seniority Begins Day past 1900], DATEADD(d,@day,0)) BETWEEN EP.[Start Month] AND EP.[Stop Month] AND
@day BETWEEN EP.[Start Day past 1900] AND ISNULL(EP.[Stop Day past 1900], 0x7FFFFFFF)

SELECT DISTINCT #L.EmployeeID, #L.[Plan] INTO #UE FROM #L

INSERT #UE SELECT X.[ID],'' FROM dbo.TempX X WHERE X.BatchID=@batch_id AND X.[ID] NOT IN (
	SELECT EmployeeID FROM #L
)

SELECT DISTINCT TypeID INTO #UT FROM #L

SELECT #UE.EmployeeID, 
Employee = P.[List As], 
T.[Type], 
Hrs = ISNULL((
	SELECT Hrs FROM #L WHERE #L.EmployeeID = #UE.EmployeeID AND #L.TypeID = #UT.TypeID
), 0), 
#UE.[Plan],
T.[Order],
T.TypeID
FROM #UE INNER JOIN dbo.vwPersonListAs P ON #UE.EmployeeID = P.PersonID
CROSS JOIN #UT INNER JOIN dbo.LeaveType T ON #UT.TypeID = T.TypeID
ORDER BY P.[List As], #UE.EmployeeID, T.[Order], T.TypeID
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spEmployeeCompensationGroupRaise2', 0
GO
ALTER PROC dbo.spEmployeeCompensationGroupRaise2
	@batch_id int,
	@percent numeric(9,4),
	@amount money,
	@new_event_id int,
	@effective int,
	@precision int,
	@round_function int
WITH EXEC AS 'dbo'
AS
IF OBJECT_ID('dbo.fnCustom_GroupPayRaiseRound') IS NOT NULL
BEGIN
	-- EXECUTE AS USER = 'dbo'
		
	EXEC sp_executesql
	N'INSERT EmployeeCompensation(EmployeeID, PeriodID, EmploymentStatusID, [Start Day past 1900], [Stop Day past 1900], Note, PositionID, [Base Pay], [Other Compensation], Budgeted, PayStepID, StartEventID, StopEventID)
	SELECT EmployeeID, PeriodID, EmploymentStatusID, @effective, NULL, '''', PositionID, dbo.fnCustom_GroupPayRaiseRound([Base Pay], @percent, @amount, @precision, @round_function), [Other Compensation], Budgeted, PayStepID, @new_event_id, NULL
	FROM EmployeeCompensation EC
	INNER JOIN TempX X ON X.BatchID=@batch_id AND X.Y=EC.CompensationID',
	N'@batch_id int, @effective int, @percent numeric(9,4), @amount money, @precision int, @round_function int, @new_event_id int',
	@batch_id, @effective, @percent, @amount, @precision, @round_function, @new_event_id
		
	-- REVERT
END
ELSE
BEGIN
	INSERT EmployeeCompensation(EmployeeID, PeriodID, EmploymentStatusID, [Start Day past 1900], [Stop Day past 1900], Note, PositionID, [Base Pay], [Other Compensation], Budgeted, PayStepID, StartEventID, StopEventID)
	SELECT EmployeeID, PeriodID, EmploymentStatusID, @effective, NULL, '', PositionID, ROUND([Base Pay] * (1 + @percent / 100) + @amount, @precision, @round_function), [Other Compensation], Budgeted, PayStepID, @new_event_id, NULL
	FROM EmployeeCompensation EC
	INNER JOIN TempX X ON X.BatchID=@batch_id AND X.Y=EC.CompensationID
END
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spEmployeeCompensationGroupRaise'
GO
ALTER PROC dbo.spEmployeeCompensationGroupRaise
	@batch_id int,
	@percent numeric(9,4),
	@amount money,
	@new_event_id int,
	@old_event_id int,
	@effective int,
	@precision int = 2,
	@truncate bit = 0
--WITH EXEC AS 'dbo'
AS
DECLARE @hidden bit

EXEC dbo.spPermissionInsureForCurrentUserOnPeople @batch_id, 1024, 1, @hidden out
IF @hidden=1
BEGIN
	EXEC dbo.spErrorRaise x
	RETURN
END

IF NOT EXISTS(SELECT * FROM dbo.EmployeeCompensationEventStop WHERE EventID=@old_event_id)
SET @old_event_id = NULL

UPDATE X SET Y=
(
	SELECT TOP 1 EC.CompensationID FROM EmployeeCompensation EC
	WHERE EC.EmployeeID = X.[ID] AND EC.[Stop Day past 1900] IS NULL ORDER BY EC.[Start Day past 1900] DESC
) 
FROM TempX X WHERE BatchID=@batch_id

DECLARE @bad_employees varchar(1000), @person varchar(400)
SET @bad_employees = ''

DECLARE b_cursor CURSOR LOCAL FORWARD_ONLY STATIC FOR SELECT V.[Full Name] FROM TempX X
INNER JOIN dbo.vwPersonCalculated V ON X.BatchID=@batch_id AND X.[ID]=V.PersonID AND X.Y IS NULL ORDER BY V.[Last Name], V.[First Name]

OPEN b_cursor

FETCH b_cursor INTO @person
WHILE @@FETCH_STATUS=0
BEGIN
	SET @bad_employees = SUBSTRING(@bad_employees + CASE WHEN @bad_employees='' THEN '' ELSE ',' END + @person, 1, 950)
	FETCH b_cursor INTO @person
END

CLOSE b_cursor
DEALLOCATE b_cursor

IF @bad_employees <> ''
BEGIN
	SET @bad_employees = 'These employee(s) have closed compensation entries (stop date has been specified): ' + @bad_employees
	RAISERROR(@bad_employees,16,1)
	RETURN
END

DECLARE b_cursor CURSOR LOCAL FORWARD_ONLY STATIC FOR SELECT V.[Full Name] FROM TempX X
INNER JOIN EmployeeCompensation EC ON X.BatchId=@batch_id AND X.Y=EC.CompensationID AND EC.[Start Day past 1900] >= @effective
INNER JOIN dbo.vwPersonCalculated V ON X.BatchID=@batch_id AND X.[ID]=V.PersonID ORDER BY V.[Last Name], V.[First Name]

OPEN b_cursor

FETCH b_cursor INTO @person
WHILE @@FETCH_STATUS=0
BEGIN
	SET @bad_employees = SUBSTRING(@bad_employees + CASE WHEN @bad_employees='' THEN '' ELSE ',' END + @person, 1, 950)
	FETCH b_cursor INTO @person
END

IF @bad_employees <> ''
BEGIN
	SET @bad_employees = 'These employee(s) have a compensation entry on\after ' + CAST(dbo.GetDateFromDaysPast1900(@effective) AS varchar(11)) + ': ' + @bad_employees
	RAISERROR(@bad_employees,16,1)
	RETURN
END

CLOSE b_cursor
DEALLOCATE b_cursor


DECLARE @error int
SET @error=0

BEGIN TRAN

UPDATE EC SET [Stop Day past 1900] = @effective - 1, StopEventID = @old_event_id
FROM EmployeeCompensation EC
INNER JOIN TempX X ON X.BatchID=@batch_id AND X.Y=EC.CompensationID
SET @error = @@ERROR

IF @error=0
BEGIN
	DECLARE @round_function int

	SELECT @round_function = @truncate
	EXEC dbo.spEmployeeCompensationGroupRaise2 @batch_id, @percent, @amount, @new_event_id, @effective, @precision, @round_function
	SET @error = @@ERROR
END

IF @error=0 COMMIT TRAN
ELSE IF @@TRANCOUNT > 0 ROLLBACK TRAN

DELETE TempX WHERE BatchID=@batch_id OR DATEDIFF(hour,Created,GETDATE())>1
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spEmployeeCompensationInsert'
GO
ALTER PROC dbo.spEmployeeCompensationInsert
	@employee_id int,
	@period_id int,
	@budgeted bit,
	@employment_status_id int,
	@start_day_past_1900 int,
	@stop_day_past_1900 int,
	@note varchar(4000),
	@base_pay money,
	@other_compensation varchar(4000),
	@position_id int,
	@step_id int = NULL,
	@compensation_id int OUT,
	@pay_step int = NULL,
	@start_event_id int = NULL,
	@stop_event_id int = NULL,
	@employee_seconds_per_week int = NULL
AS
DECLARE @authorized bit

SET NOCOUNT ON

IF @step_id IS NULL
BEGIN
	SET @authorized = 0
	EXEC dbo.spErrorRaise 50046
END
ELSE EXEC dbo.spPermissionInsureForCurrentUserOnPerson @employee_id, 1024, 4, @authorized out

IF @authorized = 1
BEGIN
	IF @start_event_id IS NULL SELECT TOP 1 @start_event_id = EventID FROM EmployeeCompensationEventStart ORDER BY Flags&1 DESC, [Order]

	BEGIN TRAN

	-- If the last compensation entry for the employee was left open then sets its stop date to one day before the start date for the new entry
	UPDATE EmployeeCompensation SET [Stop Day past 1900] = @start_day_past_1900 - 1 WHERE [Stop Day past 1900] IS NULL AND EmployeeID = @employee_id AND @start_day_past_1900 > [Start Day past 1900]

	-- If @stop is null and there is a next compensation entry for the employee then change @stop to next start - 1
	IF @stop_day_past_1900 IS NULL 
	SELECT @stop_day_past_1900 = [Start Day past 1900] - 1 FROM EmployeeCompensation WHERE EmployeeID = @employee_id AND [Start Day past 1900] > @start_day_past_1900 ORDER BY [Start Day past 1900] 
	

	INSERT EmployeeCompensation(EmployeeID, PeriodID, [Start Day past 1900], [Stop Day past 1900],Note, [Base Pay], [Other Compensation], PositionID, PayStepID, Budgeted, EmploymentStatusID, StartEventID, StopEventID, [Employee Seconds per Week])
	VALUES (@employee_id, @period_id, @start_day_past_1900, @stop_day_past_1900,@note, @base_pay, @other_compensation, @position_id, @step_id, @budgeted, @employment_status_id, @start_event_id, @stop_event_id, @employee_seconds_per_week)
	SELECT @compensation_id = SCOPE_IDENTITY()

	COMMIT TRAN
END
GO
CREATE PROC dbo.spEmployeeCompensationEventStartSelect @event_id int AS SET NOCOUNT ON
SELECT * FROM vwEmployeeCompensationEventStart WHERE EventID = @event_id
GO
GRANT EXEC ON dbo.spEmployeeCompensationEventStartSelect TO public
GO
IF OBJECT_id('dbo.spEmployeeCompensationEventStartList') IS NOT NULL DROP PROC dbo.spEmployeeCompensationEventStartList
GO
CREATE PROC dbo.spEmployeeCompensationEventStartList
	@and_flags int = 0,
	@or_flags int = 0,
	@top int = 0x7FFFFFFF,
	@default_id int = 0 out
AS
SET ROWCOUNT @top

SELECT * FROM vwEmployeeCompensationEventStart WHERE
(@and_flags & Flags) = @and_flags AND
(@or_flags=0 OR (@or_flags & Flags) != 0)
ORDER BY [Order]

IF @@ROWCOUNT = 0 SELECT TOP 1 @default_id = EventID FROM EmployeeCompensationEventStart ORDER BY [Order]
GO
GRANT EXEC ON dbo.spEmployeeCompensationEventStartList TO public
GO
IF OBJECT_id('dbo.spPersonListAsListItems3') IS NOT NULL DROP PROC dbo.spPersonListAsListItems3
GO
CREATE PROC dbo.spPersonListAsListItems3
	@batch_id int
AS
EXEC dbo.spPermissionGetOnPeopleForCurrentUser @batch_id
SELECT P.PersonID, P.[List As], P.[Full Name],
[Employee Number] = ISNULL(E.[Employee Number], ''),
SSN = ISNULL(X.SSN, ''),
[DOB Day past 1900] = ISNULL(X.[DOB Day past 1900], 0),
DOB = CASE 
	WHEN X.[DOB Day past 1900] IS NULL THEN CONVERT(datetime, '19000101', 112)
	WHEN X.[DOB Day past 1900] <= -53690 THEN CONVERT(datetime, '17530101', 112)
	WHEN X.[DOB Day past 1900] >= 2958463 THEN CONVERT(datetime, '99991231', 112)
	ELSE dbo.GetDateFromDaysPast1900(X.[DOB Day past 1900])
END,
P.[Role Mask],
P.[Active Role Mask],
Roles = '', -- Backward compatibility for clients prior to v30
[Home Fax] = CASE WHEN (PermissionHome.[Permission Mask]&1) =1 THEN P.[Home Fax] ELSE '' END,
[Home E-mail] = CASE WHEN (PermissionHome.[Permission Mask]&1) =1 THEN P.[Home E-mail] ELSE '' END,
[Home Address] = CASE WHEN (PermissionHome.[Permission Mask]&1) =1 THEN P.[Home Address] ELSE '' END,
[Home Address (cont.)] = CASE WHEN (PermissionHome.[Permission Mask]&1) =1 THEN P.[Home Address (cont.)] ELSE '' END,
[Home City] = CASE WHEN (PermissionHome.[Permission Mask]&1) =1 THEN P.[Home City] ELSE '' END,
[Home State] = CASE WHEN (PermissionHome.[Permission Mask]&1) =1 THEN P.[Home State] ELSE '' END,
[Home Zip] = CASE WHEN (PermissionHome.[Permission Mask]&1) =1 THEN P.[Home Zip] ELSE '' END,
[Home Country] = CASE WHEN (PermissionHome.[Permission Mask]&1) =1 THEN P.[Home Country] ELSE '' END
FROM dbo.vwPerson P
INNER JOIN dbo.TempPersonPermission PermissionPersonal ON PermissionPersonal.BatchID = @batch_id AND PermissionPersonal.PersonID = P.PersonID AND PermissionPersonal.AttributeID=4
INNER JOIN dbo.TempPersonPermission PermissionHome ON PermissionHome.BatchID = @batch_id AND PermissionHome.PersonID = P.PersonID AND PermissionHome.AttributeID=1
LEFT JOIN dbo.PersonX X ON X.PersonID = PermissionPersonal.PersonID AND (PermissionPersonal.[Permission Mask] & 1) = 1
LEFT JOIN dbo.Employee E ON P.PersonID = E.EmployeeID
ORDER BY P.[List As]

DELETE dbo.TempPersonPermission WHERE BatchID = @batch_id OR DATEDIFF(hh, Created, GETDATE()) > 1
GO
IF OBJECT_id('dbo.spPersonListAsListItems2') IS NOT NULL DROP PROC dbo.spPersonListAsListItems2
GO
CREATE PROC dbo.spPersonListAsListItems2
	@batch_id int
AS
INSERT dbo.TempPersonPermission(BatchID, PersonID, AttributeID)
SELECT @batch_id, [ID], 4 FROM TempX WHERE BatchID=@batch_id
UNION
SELECT @batch_id, [ID], 1 FROM TempX WHERE BatchID=@batch_id

EXEC dbo.spPersonListAsListItems3 @batch_id
DELETE TempX WHERE BatchID = @batch_id OR DATEDIFF(hh, Created, GETDATE()) > 1
GO
GRANT EXEC ON dbo.spPersonListAsListItems2 TO public
GO
ALTER PROC dbo.spPersonListAsListItems
	@person_id int = NULL,
	@role_or_mask int = 0x7FFFFFFF,
	@role_and_mask int = 0,
	@role_not_mask int = 0,
	@active_role_or_mask int = 0,
	@active_role_and_mask int = 0,
	@active_role_not_mask int = 0,

	-- Pre V30 compatible
	@active bit = NULL,
	@role_mask int = NULL
AS
DECLARE @batch_id int

SET NOCOUNT ON

SELECT @batch_id = RAND() * 2147483647

--EXEC dbo.spPersonListAsListItems @person_id = NULL, @role_or_mask = 1, @role_and_mask = 0, @role_not_mask = 0, @active_role_or_mask = 0, @active_role_and_mask = 0, @active_role_not_mask = 0
IF @person_id IS NULL AND @role_or_mask=1 AND @role_and_mask=0 AND @role_not_mask=0 AND @active_role_or_mask=0 AND @active_role_and_mask=0 AND @active_role_not_mask=0
BEGIN
	INSERT dbo.TempPersonPermission(BatchID, PersonID, AttributeID)
	SELECT @batch_id, EmployeeID, 1 FROM Employee UNION
	SELECT @batch_id, EmployeeID, 4 FROM Employee
END
ELSE IF @person_id IS NULL AND @role_or_mask=1 AND @role_and_mask=0 AND @role_not_mask=0 AND @active_role_or_mask=1 AND @active_role_and_mask=0 AND @active_role_not_mask=0
BEGIN
	INSERT dbo.TempPersonPermission(BatchID, PersonID, AttributeID)
	SELECT @batch_id, EmployeeID, 1 FROM Employee WHERE [Active Employee]=1 UNION
	SELECT @batch_id, EmployeeID, 4 FROM Employee WHERE [Active Employee]=1
END
ELSE
BEGIN
	IF @active IS NOT NULL OR @role_mask IS NOT NULL
	BEGIN
		SELECT @role_or_mask = @role_mask
		IF @active = 1 SET @active_role_or_mask = @role_mask
	END

	INSERT dbo.TempPersonPermission(BatchID, PersonID, AttributeID)
	SELECT @batch_id, PersonID, 1 FROM Person WHERE
	(
		(@role_or_mask = 0 OR (@role_or_mask & [Role Mask]) > 0) AND
		(@role_and_mask = 0 OR (@role_and_mask & [Role Mask]) = @role_and_mask) AND
		((@role_not_mask & [Role Mask]) = 0) AND
		(@active_role_or_mask = 0 OR (@active_role_or_mask & [Active Role Mask]) > 0) AND
		(@active_role_and_mask = 0 OR (@active_role_and_mask & [Active Role Mask]) = @active_role_and_mask) AND
		((@active_role_not_mask & [Active Role Mask]) = 0)
		
	) OR PersonID = @person_id

	INSERT dbo.TempPersonPermission(BatchID, PersonID, AttributeID)
	SELECT @batch_id, PersonID, 4 FROM TempPersonPermission WHERE BatchID=@batch_id -- AND AttributeID=1
END

EXEC dbo.spPersonListAsListItems3 @batch_id
GO
ALTER PROC dbo.spPersonFind
	@first_name varchar(50),
	@last_name varchar(50),
	@ssn varchar(50),
	@employee_number varchar(50),
	@dob int,
	@role_mask int = 1,
	@home_address varchar(50) = '',
	@home_address2 varchar(50) = '',
	@home_city varchar(50) = '',
	@home_state varchar(50) = '',
	@home_zip varchar(50) = '',
	@home_country varchar(50) = '',
	@flags int = 0, -- 1: return batch_id instead of list of employees
	@batch_id int = NULL OUT
AS
DECLARE @result int

SET NOCOUNT ON

SELECT @first_name = RTRIM(LTRIM(@first_name))
SELECT @last_name = RTRIM(LTRIM(@last_name))
SELECT @employee_number = RTRIM(LTRIM(@employee_number))
SELECT @home_address = RTRIM(LTRIM(@home_address))
SELECT @home_address2 = RTRIM(LTRIM(@home_address2))
SELECT @home_city = RTRIM(LTRIM(@home_city))
SELECT @home_state = RTRIM(LTRIM(@home_state))
SELECT @home_zip = RTRIM(LTRIM(@home_zip))
SELECT @home_country = RTRIM(LTRIM(@home_country))

SELECT @first_name = @first_name + '%' WHERE LEN(@first_name) BETWEEN 1 AND 49
SELECT @last_name = @last_name + '%' WHERE LEN(@last_name) BETWEEN 1 AND 49
SELECT @employee_number = '%' + @employee_number WHERE LEN(@employee_number) BETWEEN 1 AND 49

SELECT @home_address = '%' + @home_address + '%' WHERE LEN(@home_address) BETWEEN 1 AND 48
SELECT @home_address2 = '%' + @home_address2 + '%' WHERE LEN(@home_address2) BETWEEN 1 AND 48
SELECT @home_city = '%' + @home_city + '%' WHERE LEN(@home_city) BETWEEN 1 AND 48
SELECT @home_state = '%' + @home_state + '%' WHERE LEN(@home_state) BETWEEN 1 AND 48
SELECT @home_zip = '%' + @home_zip + '%' WHERE LEN(@home_zip) BETWEEN 1 AND 48
SELECT @home_country = '%' + @home_country + '%' WHERE LEN(@home_country) BETWEEN 1 AND 48

EXEC @result = dbo.spSSNClean @ssn OUTPUT

IF @result != 0 EXEC dbo.spErrorRaise @result
ELSE
BEGIN
	SET @batch_id = RAND() * 2147483647
	
	INSERT dbo.TempX(BatchID, [ID])
	SELECT TOP 200 @batch_id, P.PersonID
	FROM dbo.Person P
	LEFT JOIN dbo.Employee E ON P.PersonID = E.EmployeeID
	LEFT JOIN dbo.PersonX X ON P.PersonID = X.PersonID
	WHERE 
	(@first_name = '' OR [First Name] LIKE @first_name) AND
	(@employee_number = '' OR [Employee Number] LIKE @employee_number) AND
	(@last_name = '' OR [Last Name] LIKE @last_name) AND
	(@ssn = '' OR [SSN] LIKE @ssn) AND
	(@dob IS NULL OR X.[DOB Day past 1900] = @dob) AND
	(@role_mask = 0x7FFFFFFF OR (@role_mask & P.[Role Mask]) != 0) AND
	(@home_address = '' OR P.[Home Address] LIKE @home_address) AND
	(@home_address = '' OR P.[Home Address (cont.)] LIKE @home_address OR P.[Home Address (cont.)] LIKE @home_address2) AND
	(@home_state = '' OR P.[Home State] LIKE @home_state) AND
	(@home_city = '' OR P.[Home City] LIKE @home_city) AND
	(@home_zip = '' OR P.[Home ZIP] LIKE @home_zip) AND
	(@home_country = '' OR P.[Home Country] LIKE @home_country)
	ORDER BY P.[Last Name], P.[First Name], P.[Middle Name]
		
		
	IF ((@flags & 1) = 0) EXEC dbo.spPersonListAsListItems2 @batch_id
END
GO
IF OBJECT_id('dbo.spEmployeeRateList') IS NOT NULL DROP PROC dbo.spEmployeeRateList
GO
CREATE PROC dbo.spEmployeeRateList
	@day int,
	@employee_id int
AS
SET NOCOUNT ON

DECLARE @batch_id int

SET @batch_id = RAND() * 2147483647

IF @employee_id IS NULL
INSERT TempX(BatchID, [ID])
SELECT @batch_id, EmployeeID FROM Employee WHERE [Active Employee] = 1
ELSE
INSERT TempX(BatchID, [ID])
SELECT @batch_id, @employee_id

EXEC dbo.spPermissionGetOnPeopleForCurrentUser2 @batch_id, 262144

DELETE TempX WHERE BatchID = @batch_id AND (X & 1) = 0

SELECT E.EmployeeID, E.[Billing Rate],
[Pay Rate] = ISNULL((
	SELECT TOP 1 C.[Hourly Pay] FROM vwEmployeeCompensation C WHERE C.EmployeeID = E.EmployeeID AND dbo.DoesRayContain(C.[Start Day past 1900], C.[Stop Day past 1900], @day) = 1
), 0),
E.DefaultTimeTypeID,
[Fixed Pay] = 0.0, [Fixed Billing] = 0.0

FROM Employee E
INNER JOIN TempX X ON X.BatchID = @batch_id AND X.[ID] = E.EmployeeID

DELETE TempX WHERE BatchID = @batch_id OR DATEDIFF(hh, Created, GETDATE()) > 1
GO
GRANT EXEC ON dbo.spEmployeeRateList TO public
GO
IF OBJECT_id('dbo.spPersonSelect2') IS NOT NULL DROP PROC dbo.spPersonSelect2
GO
CREATE PROC dbo.spPersonSelect2
	@person_id int
AS
DECLARE @batch_id int

SET NOCOUNT ON

SELECT @batch_id = RAND() * 2147483647

INSERT TempX(BatchID, [ID])
VALUES(@batch_id, @person_id)

EXEC dbo.spPersonListAsListItems2 @batch_id
GO
GRANT EXEC ON dbo.spPersonSelect2 TO public
GO
IF OBJECT_id('dbo.spTaskReassign') IS NOT NULL DROP PROC dbo.spTaskReassign
GO
CREATE PROC dbo.spTaskReassign
	@old_owner_id int,
	@new_owner_id int,
	@tasks_affected int = 0 out
AS
DECLARE @authorized bit, @error int

-- Requires delete permission on old owner's task
EXEC @error = spPermissionInsureForCurrentUserOnPerson @old_owner_id, 10005, 8, @authorized out
IF @authorized=0 RETURN @error

-- Requires insert permission on new owner's task
EXEC @error = spPermissionInsureForCurrentUserOnPerson @new_owner_id, 10005, 4, @authorized out
IF @authorized=0 RETURN @error

UPDATE Task SET OwnerEmployeeID=@new_owner_id WHERE OwnerEmployeeID=@old_owner_id
SELECT @error = @@ERROR, @tasks_affected = @@ROWCOUNT

RETURN @error
GO
GRANT EXEC ON dbo.spTaskReassign TO public
GO
ALTER PROC dbo.[spEmployeeTerminate]
	@employee_id int,
	@effective int,
	@compensation bit,
	@leave bit,
	@inactive bit,
	@reason varchar(4000),
	@rehire bit,
	@reassign bit = 0,
	@new_manager_id int = NULL,
	@reassign_tasks bit = 0,
	@new_task_owner_id int = 0,
	@reason_id int = NULL
AS
DECLARE @compensation_id int
DECLARE @terminated bit
DECLARE @authorized bit
DECLARE @error int

SET @error = 0

EXEC dbo.spPermissionInsureForCurrentUserOnPerson @employee_id, 0x1000000, 2, @authorized out

IF @authorized = 1
BEGIN
	BEGIN TRAN
	
	IF @error = 0 
	BEGIN
		UPDATE Employee SET [Terminated Day past 1900] = @effective, [Reason for Termination] = @reason, Rehire = @rehire, TerminationReasonID = @reason_id WHERE EmployeeID = @employee_id
		SET @error = @@ERROR
	END
	SELECT @compensation_id = LastCompensationID FROM Employee WHERE EmployeeID = @employee_id

	-- Reassigns manager. Does not check individual employee permissions
	IF @error = 0 AND @reassign = 1
	BEGIN
		UPDATE Employee SET ManagerID=@new_manager_id WHERE ManagerID=@employee_id
		SET @error = @@ERROR
	END
	
	-- Reassigns tasks
	IF @error = 0 AND @reassign_tasks = 1 EXEC @error = spTaskReassign @employee_id, @new_task_owner_id
	
	-- Close employee compensation
	IF @error = 0 AND @compensation = 1 AND NOT (@compensation_id IS NULL)
	BEGIN
		-- EXEC dbo.spPermissionInsureForCurrentUserOnPerson @employee_id, 1024, 2, @authorized out
		UPDATE EmployeeCompensation SET [Stop Day past 1900] = @effective WHERE CompensationID = @compensation_id AND [Stop Day past 1900] IS NULL
		SET @error = @@ERROR
	END
	
	-- Inactivates
	IF @error = 0 AND @inactive = 1
	BEGIN
		-- EXEC dbo.spPermissionInsureForCurrentUserOnPerson @employee_id, 8, 2, @authorized out
		UPDATE Employee SET [Active Employee] = 0 WHERE EmployeeID = @employee_id
		SET @error = @@ERROR
	END
	
	-- Closes leave plan
	IF @error = 0 aND @leave = 1 AND @authorized = 1
	BEGIN
		-- EXEC dbo.spPermissionInsureForCurrentUserOnPerson @employee_id, 128, 2, @authorized out
		
		DECLARE @recalc bit
	
		SET @recalc = 0
		DELETE EmployeeLeavePlan WHERE EmployeeID = @employee_id AND [Start Day past 1900] > @effective
		IF @@ROWCOUNT > 0 SET @recalc = 1
	
		DECLARE @plan_item_id int
		SELECT TOP 1 @plan_item_id = ItemID FROM EmployeeLeavePlan WHERE EmployeeID = @employee_id AND ([Stop Day past 1900] IS NULL OR [Stop Day past 1900] > @effective) ORDER BY [Start Day past 1900] DESC 
	
		IF @plan_item_id IS NOT NULL
		BEGIN
			UPDATE EmployeeLeavePlan SET [Stop Day past 1900] = @effective WHERE ItemID = @plan_item_id
			SET @error = @@ERROR
			IF @error = 0 SET @recalc = 1
		END

		-- DELETE EmployeeLeaveUsedItem WHERE EmployeeID = @employee_id AND [Day past 1900] > @effective
		-- DELETE EmployeeLeaveEarned WHERE EmployeeID = @employee_id AND [Day past 1900] > @effective

		IF @recalc = 1
		BEGIN
			EXEC dbo.spEmployeeLeaveCalcForEmployee @employee_id, @effective
			SET @error = @@ERROR
		END
	END
	
	IF @error = 0 COMMIT TRAN
	ELSE IF @@TRANCOUNT > 0 ROLLBACK
END
GO
IF OBJECT_id('dbo.spEmployeeTimeBulkInsertPrepare') IS NOT NULL DROP PROC dbo.spEmployeeTimeBulkInsertPrepare
GO
CREATE PROC dbo.spEmployeeTimeBulkInsertPrepare
	@batch_id int,
	@exclude_day int 
AS
SELECT [ID]
FROM TempX WHERE BatchID = @batch_id AND NOT EXISTS
(SELECT * FROM vwEmployeeLeaveUsedItem WHERE [Day past 1900] = @exclude_day) AND NOT EXISTS
(SELECT * FROM vwEmployeeTime WHERE [In Day past 1900] = @exclude_day)

DELETE TempX WHERE BatchID = @batch_id OR DATEDIFF(hh, Created, GETDATE()) > 1
GO
GRANT EXEC ON dbo.spEmployeeTimeBulkInsertPrepare TO public
GO
IF OBJECT_id('dbo.spEmployeeTimeSelectLast') IS NOT NULL DROP PROC dbo.spEmployeeTimeSelectLast
GO
IF OBJECT_id('dbo.spEmployeeCompensationSelect2') IS NOT NULL DROP PROC dbo.spEmployeeCompensationSelect2
GO
CREATE PROC dbo.spEmployeeCompensationSelect2
	@compensation_id int
AS
DECLARE @employee_id int
DECLARE @authorized bit

SET NOCOUNT ON

SELECT @employee_id = EmployeeID FROM EmployeeCompensation WHERE CompensationID = @compensation_id

EXEC dbo.spPermissionInsureForCurrentUserOnPerson @employee_id, 1024, 1, @authorized out
IF @authorized = 1 SELECT * FROM dbo.vwEmployeeCompensation WHERE CompensationID = @compensation_id
GO
IF OBJECT_id('dbo.spPayTableDelete') IS NOT NULL DROP PROC dbo.spPayTableDelete
GO
CREATE PROC dbo.spPayTableDelete
	@table_id int
AS
DECLARE @result int
BEGIN TRAN
DELETE PayGrade WHERE PayTableID = @table_id
SET @result = @@ERROR

IF @result = 0
BEGIN
	DELETE PayStep WHERE PayTableID = @table_id
	SET @result = @@ERROR
END

IF @result = 0
BEGIN
	DELETE PayTable WHERE PayTableID = @table_id
	SET @result = @@ERROR
END

IF @result = 0 COMMIT TRAN
ELSE IF @@TRANCOUNT > 0  ROLLBACK TRAN
GO
GRANT EXEC ON dbo.spEmployeeCompensationSelect2 TO public
GO
CREATE PROC dbo.spEmployeeTimeSelectLast
	@employee_id int
AS
DECLARE @authorized bit

SET NOCOUNT ON

EXEC dbo.spPermissionInsureForCurrentUserOnPerson @employee_id, 262144, 1, @authorized out

IF @authorized = 1 
SELECT TOP 1 E.*, [Employee] = V.[List As] FROM vwEmployeeTime E
INNER JOIN dbo.vwPersonListAs V ON E.EmployeeID = V.PersonID AND E.EmployeeID = @employee_id AND DATEDIFF(d,0,E.[In]) <= DATEDIFF(d,0,GETDATE())
ORDER BY E.[In] DESC
GO
GRANT EXEC ON dbo.spEmployeeTimeSelectLast TO public
GO
ALTER PROC dbo.spEmployeeTimeList
	@employee_id int,
	@start_day int,
	@stop_day int
AS
DECLARE @batch_id int

SET NOCOUNT ON

SELECT @batch_id = RAND() * 2147483647
INSERT TempX(BatchID, [ID])
SELECT @batch_id, EmployeeID FROM Employee WHERE EmployeeID = @employee_id OR @employee_id IS NULL
EXEC dbo.spPermissionGetOnPeopleForCurrentUser2 @batch_id, 262144

SELECT *
FROM dbo.vwEmployeeTime ET 
INNER JOIN TempX X ON X.BatchID = @batch_id AND ET.EmployeeID = X.[ID] AND [In Day past 1900] BETWEEN @start_day AND @stop_day
ORDER BY ET.[In], ET.Employee

DELETE TempX WHERE BatchID = @batch_id OR DATEDIFF(hour, Created, GETDATE()) > 1
GO
ALTER PROC dbo.spNoteList
	@invoice_id int,
	@payment_id int,
	@person_id int,
	@class_id int,
	@payer_id int,
	@day_min int,
	@day_max int
AS
DECLARE @batch_id int

SET NOCOUNT ON

SELECT N.NoteID, PersonID=RegardingPersonID INTO #N
FROM vwNote N WHERE
(N.[Day] BETWEEN @day_min AND @day_max) AND
(@person_id IS NULL OR N.RegardingPersonID = @person_id)/* AND
(@invoice_id IS NULL OR N.InvoiceID = @invoice_id OR 
	EXISTS (SELECT * FROM PaymentDetail D WHERE D.PaymentID = N.PaymentID AND D.InvoiceID = @invoice_id)
) AND
(@payment_id IS NULL OR N.PaymentID = @payment_id OR 
	EXISTS (SELECT * FROM PaymentDetail D WHERE D.PaymentID = @payment_id AND D.InvoiceID = N.InvoiceID)
) AND
(@class_id IS NULL OR N.ClassID = @class_id) AND
(@payer_id IS NULL OR N.PayerID = @payer_id) */

CREATE INDEX N_spNoteList_NoteID ON #N(NoteID)
CREATE INDEX N_spNoteList_PersonID ON #N(PersonID)

SELECT DISTINCT PersonID INTO #P FROM #N WHERE PersonID IS NOT NULL
INSERT #P VALUES(NULL)

SELECT AttributeID=47 INTO #NotePermissionAttribute
INSERT #NotePermissionAttribute VALUES(48)
INSERT #NotePermissionAttribute VALUES(131072)

SET @batch_id = RAND() * 2147483647
INSERT dbo.TempPersonPermission(BatchID, PersonID, AttributeID, [Permission Mask])
SELECT @batch_id, #P.PersonID, #NotePermissionAttribute.AttributeID, 0
FROM #P CROSS JOIN #NotePermissionAttribute

EXEC dbo.spPermissionGetOnPeopleForCurrentUser @batch_id

SELECT N.*, P.[Permission Mask]
FROM dbo.vwNote N 
INNER JOIN #N ON N.NoteID = #N.NoteID
INNER JOIN TempPersonPermission P ON P.BatchID=@batch_id AND (
	(P.PersonID IS NULL AND N.PersonID IS NULL) OR (P.PersonID = N.PersonID)
) AND P.AttributeID=
CASE 
	WHEN SUSER_SID()<>N.[Created By] THEN 131072
	WHEN [Created Day past 1900]+3<DATEDIFF(d,0,GETDATE()) THEN 47
	ELSE 48
END AND (P.[Permission Mask] & 1) = 1
ORDER BY N.[Day past 1900]

DELETE TempPersonPermission WHERE BatchID=@batch_id OR DATEDIFF(hh,[Created],GETDATE()) > 1
GO
IF OBJECT_id('dbo.spInvoiceInsertBatch') IS NOT NULL DROP PROC dbo.spInvoiceInsertBatch
IF OBJECT_id('dbo.spStatement') IS NOT NULL DROP PROC dbo.spStatement
IF OBJECT_id('dbo.spInvoiceInsert') IS NOT NULL DROP PROC dbo.spInvoiceInsert
IF OBJECT_id('dbo.spInvoiceUpdate') IS NOT NULL DROP PROC dbo.spInvoiceUpdate
IF OBJECT_id('dbo.spInvoiceCalc') IS NOT NULL DROP PROC dbo.spInvoiceCalc
IF OBJECT_id('dbo.spInvoiceInvoice') IS NOT NULL DROP PROC dbo.spInvoiceCalc
IF OBJECT_id('dbo.spPaymentTypeList') IS NOT NULL DROP PROC dbo.spPaymentTypeList
IF OBJECT_id('dbo.spInvoiceTypeList') IS NOT NULL DROP PROC dbo.spInvoiceTypeList
IF OBJECT_id('dbo.spInvoiceList2') IS NOT NULL DROP PROC dbo.spInvoiceList2
IF OBJECT_id('dbo.spInvoiceList') IS NOT NULL DROP PROC dbo.spInvoiceList
IF OBJECT_id('dbo.spInvoiceList3') IS NOT NULL DROP PROC dbo.spInvoiceList3
IF OBJECT_id('dbo.spInvoiceSelect') IS NOT NULL DROP PROC dbo.spInvoiceSelect
IF OBJECT_id('dbo.spPaymentSelect') IS NOT NULL DROP PROC dbo.spPaymentSelect
IF OBJECT_id('dbo.spInvoiceDelete') IS NOT NULL DROP PROC dbo.spInvoiceDelete
GO
CREATE PROC dbo.spPaymentTypeList AS SELECT * FROM PaymentType
GO
CREATE PROC dbo.spInvoiceDelete @invoice_id int AS
BEGIN TRAN
DELETE InvoiceDetail WHERE InvoiceID=@invoice_id
DELETE Invoice WHERE InvoiceID=@invoice_id
COMMIT TRAN
GO
CREATE PROC dbo.spPaymentSelect
	@payment_id int
AS SELECT * FROM vwPayment WHERE PaymentID=@payment_id
GO
CREATE PROC dbo.spInvoiceInsert
	@employee_id int,
	@template_id int,
	@due int,
	@invoice_id int out
AS
INSERT Invoice(EmployeeID, TemplateID, [Due Day past 1900], Payment, Total)
VALUES(@employee_id, @template_id, @due, 0, 0)
SET @invoice_id = SCOPE_IDENTITY()
GO
CREATE PROC dbo.spInvoiceSelect
	@invoice_id int
AS
SET NOCOUNT ON
SELECT I.*, H.*,
[Status] = dbo.fnGetInvoiceStatus(I.Total, I.Payment, I.Credit, I.[Due Day past 1900], GETDATE())
FROM vwInvoice I 
LEFT JOIN vwPersonHome H ON I.EmployeeID=H.PersonID
WHERE I.InvoiceID = @invoice_id
GO
CREATE PROC dbo.spInvoiceList
	@employee_id int,
	@paid bit,
	@due_start int,
	@due_stop int,
	@created_start int,
	@created_stop int,
	@batch_id int = NULL,
	@credit bit = NULL
AS
SET NOCOUNT ON
SELECT I.*, H.*,
[Status] = dbo.fnGetInvoiceStatus(I.Total, I.Payment, I.Credit, I.[Due Day past 1900], GETDATE())
FROM vwInvoice I
LEFT JOIN vwPersonHome H ON I.EmployeeID = H.PersonID
LEFT JOIN TempX X ON X.BatchID=@batch_id AND X.[ID]=I.EmployeeID
WHERE
(@employee_id IS NULL OR (@employee_id = EmployeeID)) AND
(@credit IS NULL OR (@credit=0 AND Credit = 0) OR (@credit=1 AND Credit > 0)) AND
(@paid IS NULL OR (@paid=0 AND Balance>0) OR (@paid=1 AND Balance=0)) AND
[Due Day past 1900] BETWEEN @due_start AND @due_stop AND
[Created Day past 1900] BETWEEN @created_start AND @created_stop AND
(@batch_id IS NULL) OR (X.[ID] IS NOT NULL)
ORDER BY Due DESC
GO
CREATE PROC dbo.spInvoiceList2 @batch_id int AS
SET NOCOUNT ON
SELECT I.*, H.*,
[Status] = dbo.fnGetInvoiceStatus(I.Total, I.Payment, I.Credit, I.[Due Day past 1900], GETDATE())
FROM vwInvoice I INNER JOIN TempX X ON X.BatchID=@batch_id AND X.[ID]=I.InvoiceID 
LEFT JOIN vwPersonHome H ON I.EmployeeID=H.PersonID

DELETE dbo.TempX WHERE BatchID=@batch_id OR DATEDIFF(minute, Created, GETDATE()) > 30
GO
CREATE PROC dbo.spInvoiceList3
	@employee_id int,
	@paid bit,
	@due_start int,
	@due_stop int,
	@created_start int,
	@created_stop int,
	@batch_id int = NULL,
	@credit bit = NULL
AS
SET NOCOUNT ON
EXEC dbo.spCustomFieldClean

SELECT I.* FROM dbo.vwInvoiceFlat I
LEFT JOIN TempX X ON X.BatchID=@batch_id AND X.[ID]=I.EmployeeID
WHERE
(@employee_id IS NULL OR (@employee_id = EmployeeID)) AND
(@credit IS NULL OR (@credit=0 AND Credit = 0) OR (@credit=1 AND Credit > 0)) AND
(@paid IS NULL OR (@paid=0 AND Balance>0) OR (@paid=1 AND Balance=0)) AND
[Due Day past 1900] BETWEEN @due_start AND @due_stop AND
[Created Day past 1900] BETWEEN @created_start AND @created_stop AND
((@batch_id IS NULL) OR (X.[ID] IS NOT NULL))

DELETE dbo.TempX WHERE BatchID=@batch_id OR DATEDIFF(minute, Created, GETDATE()) > 30
GO
CREATE PROC dbo.spInvoiceUpdate
	@employee_id int,
	@template_id int,
	@due int,
	@invoice_id int
AS
UPDATE Invoice SET
EmployeeID=@employee_id,
TemplateID = @template_id,
[Due Day past 1900] = @due,
[Last Updated By] = SUSER_SNAME(),
[Last Updated Day past 1900] = DATEDIFF(d, 0, GETDATE())
WHERE InvoiceID = @invoice_id
GO
IF OBJECT_id('dbo.spInvoiceDetailList') IS NOT NULL DROP PROC dbo.spInvoiceDetailList
IF OBJECT_id('dbo.spInvoiceDetailInsert') IS NOT NULL DROP PROC dbo.spInvoiceDetailInsert
IF OBJECT_id('dbo.spInvoiceDetailUpdate') IS NOT NULL DROP PROC dbo.spInvoiceDetailUpdate
IF OBJECT_id('dbo.spInvoiceDetailDelete') IS NOT NULL DROP PROC dbo.spInvoiceDetailDelete
GO
CREATE PROC dbo.spInvoiceDetailList @batch_id int AS SET NOCOUNT ON
SELECT I.*, H.*,
[Status] = dbo.fnGetInvoiceStatus(I.Total, I.Payment, I.Credit, I.[Due Day past 1900], GETDATE()),
Aging = dbo.fnGetInvoiceAging(I.Balance, I.[Due Day past 1900], GETDATE()),
AmountDue0 = ISNULL((SELECT SUM(I2.Balance) FROM Invoice I2 WHERE I.EmployeeID=I2.EmployeeID AND DATEDIFF(d,0,GETDATE())=I2.[Due Day past 1900]),0),
AmountDue30 = ISNULL((SELECT SUM(I2.Balance) FROM Invoice I2 WHERE I.EmployeeID=I2.EmployeeID AND DATEDIFF(d,0,GETDATE()) BETWEEN I2.[Due Day past 1900] + 1 AND I2.[Due Day past 1900] + 30),0),
AmountDue60 = ISNULL((SELECT SUM(I2.Balance) FROM Invoice I2 WHERE I.EmployeeID=I2.EmployeeID AND DATEDIFF(d,0,GETDATE()) BETWEEN I2.[Due Day past 1900] + 31 AND I2.[Due Day past 1900] + 60),0),
AmountDue90 = ISNULL((SELECT SUM(I2.Balance) FROM Invoice I2 WHERE I.EmployeeID=I2.EmployeeID AND DATEDIFF(d,0,GETDATE()) BETWEEN I2.[Due Day past 1900] + 61 AND I2.[Due Day past 1900] + 90),0),
AmountDue91 = ISNULL((SELECT SUM(I2.Balance) FROM Invoice I2 WHERE I.EmployeeID=I2.EmployeeID AND DATEDIFF(d,0,GETDATE()) > I2.[Due Day past 1900] + 90),0),
AmountDueAll = ISNULL((SELECT SUM(I2.Balance) FROM Invoice I2 WHERE I.EmployeeID=I2.EmployeeID AND DATEDIFF(d,0,GETDATE()) >= I2.[Due Day past 1900]),0),
[Date] = DATEADD(d,D.[Day past 1900],0),
D.DetailID, D.[Day past 1900], D.[Text], D.[Unit Rate], D.Units, D.Fixed, D.[Split Amount], D.[Order]
FROM TempX X
INNER JOIN vwInvoice I ON X.BatchID = @batch_id AND X.[ID] = I.InvoiceID
INNER JOIN vwPersonHome H ON I.EmployeeID = H.PersonID
INNER JOIN InvoiceDetail D ON I.InvoiceID = D.InvoiceID
ORDER BY I.InvoiceID, D.[Order]

DELETE dbo.TempX WHERE BatchID=@batch_id OR DATEDIFF(minute, Created, GETDATE()) > 30
GO
CREATE PROC dbo.spInvoiceDetailInsert
	@invoice_id int,
	@day int,
	@text varchar(50),
	@fixed money,
	@units numeric(9,4),
	@unit_rate money,
	@order int,
	@detail_id int out
AS
SET NOCOUNT ON

INSERT InvoiceDetail(InvoiceID, [Text], [Day past 1900], Units, [Unit Rate], Fixed, [Order], [Split Amount])
SELECT @invoice_id, @text, @day, @units, @unit_rate, @fixed, @order, @units*@unit_rate+@fixed

SET @detail_id = SCOPE_IDENTITY()
GO
CREATE PROC dbo.spInvoiceDetailUpdate
	@day int,
	@text varchar(50),
	@fixed money,
	@units numeric(9,4),
	@unit_rate money,
	@order int,
	@detail_id int
AS
SET NOCOUNT ON

UPDATE InvoiceDetail
SET [Day past 1900] = @day,
[Text] = @text,
Fixed = @fixed,
Units = @units,
[Unit Rate] = @unit_rate,
[Order] = @order,
[Split Amount] = @units*@unit_rate+@fixed
WHERE DetailID = @detail_id
GO
CREATE PROC dbo.spInvoiceDetailDelete
	@detail_id int
AS
DELETE InvoiceDetail WHERE DetailID=@detail_id
GO
-- Pass 2 nulls to recalc all invoices
-- Pass an @invoice_id and @batch_id=null to recalc one invoice
-- Pass @invoice_id=null and @batch_id to recalc a batch of invoices
CREATE PROC dbo.spInvoiceCalc
	@invoice_id int = NULL,
	@batch_id int = NULL
AS
IF @batch_id IS NULL
BEGIN
	SET @batch_id = RAND() * -2147483648
	IF @invoice_id IS NULL INSERT TempX(BatchID,[ID]) SELECT @batch_id, InvoiceID FROM Invoice
END
IF @invoice_id IS NOT NULL INSERT TempX(BatchID,[ID]) SELECT @batch_id, @invoice_id

UPDATE I SET [Payment Transactions]='',
Total = ISNULL((
	SELECT SUM(D.[Split Amount]) FROM InvoiceDetail D WHERE D.InvoiceID = I.InvoiceID
), 0), 
Payment = ISNULL((
	SELECT SUM(P.[Applied]) FROM PaymentDetail P WHERE P.InvoiceID = I.InvoiceID
), 0),
[Credit] = ISNULL((
	SELECT SUM(W.Amount) FROM InvoiceCredit W WHERE W.InvoiceID = I.InvoiceID
), 0)
FROM Invoice I INNER JOIN TempX X ON X.BatchID=@batch_id AND X.[ID]=I.InvoiceID


UPDATE I SET Balance=Total-Payment-Credit FROM Invoice I INNER JOIN TempX X ON X.BatchID=@batch_id AND X.[ID]=I.InvoiceID

UPDATE TempX SET X=NULL WHERE BatchID=@batch_id -- Last Payment ID
DECLARE @updates int

SET @updates = 1
WHILE @updates > 0
BEGIN
	UPDATE X SET X=(SELECT TOP 1 D.PaymentID FROM PaymentDetail D WHERE D.InvoiceID=X.[ID] AND (X.X IS NULL OR D.PaymentID > X.X) ORDER BY D.PaymentID)
	FROM TempX X WHERE X.BatchID=@batch_id

	DELETE TempX WHERE BatchID=@batch_id AND X IS NULL

	UPDATE I SET [Payment Transactions] = SUBSTRING(
		[Payment Transactions] + CASE WHEN [Payment Transactions]='' THEN '' ELSE ',' END +
		CONVERT(char(11), dbo.GetDateFromDaysPast1900(P.[Received Day past 1900]),109) + ' $' + CAST(CAST(P.Total AS numeric(9,2)) AS varchar(50)) + 
		CASE WHEN P.Split=1 THEN ' (Split)' ELSE '' END,
		1, 450
	)
	FROM dbo.Invoice I INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID]=I.InvoiceID
	INNER JOIN dbo.Payment P ON P.PaymentID=X.X AND P.Total > 0

	SELECT @updates = @@ROWCOUNT
END

DELETE dbo.TempX WHERE BatchID=@batch_id OR DATEDIFF(minute, Created, GETDATE()) > 30
GO
GRANT EXEC ON dbo.spInvoiceCalc TO public
GO
IF OBJECT_id('dbo.spPaymentInsert') IS NOT NULL DROP PROC dbo.spPaymentInsert
IF OBJECT_id('dbo.spPaymentUpdate') IS NOT NULL DROP PROC dbo.spPaymentUpdate
IF OBJECT_id('dbo.spPaymentDelete') IS NOT NULL DROP PROC dbo.spPaymentDelete
IF OBJECT_id('dbo.spPaymentList') IS NOT NULL DROP PROC dbo.spPaymentList
IF OBJECT_id('dbo.spPaymentList2') IS NOT NULL DROP PROC dbo.spPaymentList2
IF OBJECT_id('dbo.spPaymentList3') IS NOT NULL DROP PROC dbo.spPaymentList3
IF OBJECT_id('dbo.spPaymentFilter') IS NOT NULL DROP PROC dbo.spPaymentFilter
IF OBJECT_id('dbo.spPaymentDetailInsert') IS NOT NULL DROP PROC dbo.spPaymentDetailInsert
IF OBJECT_id('dbo.spPaymentDetailUpdate') IS NOT NULL DROP PROC dbo.spPaymentDetailUpdate
IF OBJECT_id('dbo.spPaymentDetailDelete') IS NOT NULL DROP PROC dbo.spPaymentDetailDelete
IF OBJECT_id('dbo.spPaymentDetailList') IS NOT NULL DROP PROC dbo.spPaymentDetailList
IF OBJECT_id('dbo.spPaymentCalc') IS NOT NULL DROP PROC dbo.spPaymentCalc
IF OBJECT_id('dbo.spInvoiceTemplateSelect') IS NOT NULL DROP PROC dbo.spInvoiceTemplateSelect
IF OBJECT_id('dbo.spInvoiceTemplateList') IS NOT NULL DROP PROC dbo.spInvoiceTemplateList
GO
CREATE PROC dbo.spPaymentDetailInsert
	@payment_id int,
	@invoice_id int,
	@comment varchar(50),
	@applied money,
	@detail_id int out
AS
INSERT PaymentDetail(PaymentID, InvoiceID, Comment, Applied)
SELECT @payment_id, @invoice_id, @comment, @applied

SELECT @detail_id=SCOPE_IDENTITY()
GO
CREATE PROC dbo.spPaymentDetailDelete @detail_id int AS
DECLARE @old_invoice_id int
SELECT @old_invoice_id=InvoiceID FROM PaymentDetail WHERE DetailID=@detail_id
DELETE PaymentDetail WHERE DetailID=@detail_id
EXEC dbo.spInvoiceCalc @old_invoice_id
GO
-- All invocies must be reclaculated somewhere else
CREATE PROC dbo.spPaymentDetailUpdate
	@invoice_id int,
	@comment varchar(50),
	@applied money,
	@detail_id int
AS
UPDATE PaymentDetail SET InvoiceID=@invoice_id, Comment=@comment, Applied=@applied WHERE DetailID=@detail_id
GO
CREATE PROC dbo.spPaymentDetailList @payment_id int AS
SET NOCOUNT ON SELECT * FROM vwPaymentDetail WHERE PaymentID=@payment_id
GO
CREATE PROC dbo.spPaymentCalc
	@payment_id int
AS
DECLARE i_cursor CURSOR LOCAL FORWARD_ONLY STATIC FOR SELECT InvoiceID FROM PaymentDetail WHERE PaymentID=@payment_id
OPEN i_cursor

DECLARE @invoice_id int, @invoices varchar(400)
SET @invoices = ''
FETCH NEXT FROM i_cursor INTO @invoice_id
WHILE @@FETCH_STATUS=0
BEGIN
	SET @invoices = SUBSTRING(@invoices + CASE @invoices WHEN '' THEN '' ELSE ',' END + CAST(@invoice_id AS varchar(400)), 1, 400)
	FETCH NEXT FROM i_cursor INTO @invoice_id
END

CLOSE i_cursor
DEALLOCATE i_cursor

DECLARE @batch_id int 
SELECT @batch_id = RAND() * 2147483647
INSERT TempX(BatchID,[ID]) SELECT @batch_id, InvoiceID FROM PaymentDetail WHERE PaymentID=@payment_id
EXEC dbo.spInvoiceCalc @batch_id = @batch_id
DELETE TempX WHERE BatchID=@batch_id OR DATEDIFF(minute, Created, GETDATE()) > 30

UPDATE Payment SET Split= CASE 
	WHEN ISNULL((
		SELECT COUNT(DISTINCT InvoiceID) FROM PaymentDetail WHERE PaymentID=@payment_id
	), 0) > 1 THEN 1
ELSE 0 END,
Applied = ISNULL((
	SELECT SUM(D.[Applied]) FROM PaymentDetail D WHERE D.PaymentID = @payment_id
), 0) ,
Refund = ISNULL((
	SELECT SUM(R.Amount) FROM PaymentRefund R WHERE R.PaymentID = @payment_id
), 0) ,
Invoices = @invoices
WHERE PaymentID=@payment_id

UPDATE Payment SET Unapplied = Total - Applied - Refund WHERE PaymentID=@payment_id
GO
CREATE PROC dbo.spPaymentDelete @payment_id int
AS
DECLARE @batch_id int 
SELECT @batch_id = RAND() * 2147483647
INSERT TempX(BatchID,[ID]) SELECT @batch_id, InvoiceID FROM PaymentDetail WHERE PaymentID=@payment_id


BEGIN TRAN
DELETE PaymentDetail WHERE PaymentID=@payment_id
DELETE PaymentRefund WHERE PaymentID=@payment_id
DELETE Payment WHERE PaymentID=@payment_id
EXEC dbo.spInvoiceCalc @batch_id = @batch_id
COMMIT TRAN

DELETE TempX WHERE BatchID=@batch_id OR DATEDIFF(minute, Created, GETDATE()) > 30
GO
GRANT EXEC ON dbo.spPaymentCalc TO public
GO
CREATE PROC dbo.spPaymentInsert 
	@type_id int,
	@employee_id int,
	@transaction_number varchar(50),
	@total money,
	@received_day int,
	@payment_id int out
AS
INSERT Payment(TypeID,EmployeeID,[Transaction Number],Total,[Received Day past 1900])
SELECT @type_id,@employee_id,@transaction_number,@total,@received_day
SELECT @payment_id=SCOPE_IDENTITY()
GO
CREATE PROC dbo.spPaymentUpdate
	@type_id int,
	@employee_id int,
	@transaction_number varchar(50),
	@total money,
	@received_day int,
	@payment_id int
AS
UPDATE Payment SET TypeID=@type_id,EmployeeID=@employee_id,[Transaction Number]=@transaction_number,Total=@total,[Received Day past 1900]=@received_day
WHERE PaymentID=@payment_id
GO
CREATE PROC dbo.spPaymentFilter
	@employee_id int,
	@invoice_id int,
	@unapplied bit,
	@applied bit,
	@refunded bit,
	@unrefunded bit,
	@split bit,
	@created_start int,
	@created_stop int,
	@received_start int,
	@received_stop int,
	@type_id int,
	@batch_id int
AS
SET NOCOUNT ON
INSERT TempX(BatchID, [ID])
SELECT @batch_id, PaymentID FROM vwPayment P WHERE
(@type_id IS NULL OR P.TypeID = @type_id) AND
(@employee_id IS NULL OR P.EmployeeID = @employee_id) AND
(@unapplied IS NULL OR (@unapplied=0 AND P.Unapplied=0) OR (@unapplied=1 AND P.Unapplied!=0)) AND
(@applied IS NULL OR (@applied=0 AND P.Applied=0) OR (@applied=1 AND P.Applied!=0)) AND
(@refunded IS NULL OR (@refunded=0 AND P.Refund=0) OR (@refunded=1 AND P.Refund!=0)) AND
(@unrefunded IS NULL OR (@unrefunded=0 AND P.Unrefunded=0) OR (@unrefunded=1 AND P.Unrefunded!=0)) AND
(@split IS NULL OR (@split=0 AND P.Split=0) OR (@split=1 AND P.Split=1)) AND
(@invoice_id IS NULL OR EXISTS(SELECT * FROM PaymentDetail D WHERE P.PaymentID=D.PaymentID AND D.InvoiceID=@invoice_id)) AND
[Created Day past 1900] BETWEEN @created_start AND @created_stop AND
[Received Day past 1900] BETWEEN @received_start AND @received_stop
GO
GRANT EXEC ON dbo.spPaymentFilter TO public
GO
CREATE PROC dbo.spPaymentList2 @batch_id int
AS
SET NOCOUNT ON
SELECT *, [Payment Permission Mask] = dbo.fnPermissionGetOnPersonForCurrentUser(P.EmployeeID, 536870914) FROM vwPayment P INNER JOIN TempX X ON X.BatchID=@batch_id AND X.[ID]=P.PaymentID AND (dbo.fnPermissionGetOnPersonForCurrentUser(P.EmployeeID, 536870914) & 1) = 1
DELETE dbo.TempX WHERE BatchID=@batch_id OR DATEDIFF(minute, Created, GETDATE()) > 30
GO
GRANT EXEC ON dbo.spPaymentList2 TO public
GO
CREATE PROC dbo.spPaymentList3 @batch_id int
AS
SET NOCOUNT ON
EXEC dbo.spCustomFieldClean
SELECT * FROM vwPaymentFlat P INNER JOIN TempX X ON X.BatchID=@batch_id AND X.[ID]=P.PaymentID
DELETE dbo.TempX WHERE BatchID=@batch_id OR DATEDIFF(minute, Created, GETDATE()) > 30
GO
GRANT EXEC ON dbo.spPaymentList3 TO public
GO
-- Legacy
CREATE PROC dbo.spPaymentList
	@employee_id int,
	@invoice_id int,
	@unapplied bit,
	@applied bit,
	@refunded bit,
	@unrefunded bit,
	@split bit,
	@created_start int,
	@created_stop int,
	@received_start int,
	@received_stop int,
	@type_id int = NULL
AS
DECLARE @batch_id int
SELECT @batch_id = RAND() * 2147483647
EXEC dbo.spPaymentFilter @employee_id, @invoice_id, @unapplied, @applied, @refunded, @unrefunded, @split, @created_start, @created_stop, @received_start, @received_stop, @type_id, @batch_id
EXEC dbo.spPaymentList2 @batch_id
GO
GRANT EXEC ON dbo.spPaymentList TO public
GO
CREATE PROC dbo.spInvoiceInsertBatch
	@batch_id int,
	@due_day int,
	@prefix varchar(50) = ''
AS
DECLARE @hidden bit
EXEC dbo.spPermissionInsureForCurrentUserOnPeople @batch_id, 536870913, 4, @hidden out
IF @hidden=1
BEGIN
	DELETE TempX WHERE BatchID=@batch_id OR DATEDIFF(hour,Created,GETDATE())>1
	EXEC dbo.spErrorRaiseNoPermission 536870913, 4
	RETURN
END

IF @prefix <> '' SET @prefix = @prefix + ' '
DECLARE @invoice_batch_id int, @template_id int

SELECT TOP 1 @template_id = TemplateID FROM InvoiceTemplate

BEGIN TRAN

IF EXISTS(SELECT * FROM Invoice WHERE BatchID = @batch_id) SELECT @invoice_batch_id = MAX(BatchID)+1 FROM Invoice
ELSE SELECT @invoice_batch_id = @batch_id

INSERT Invoice(TemplateID, BatchID, EmployeeID, [Due Day past 1900])
SELECT @template_id, @invoice_batch_id, X.[ID], @due_day 
FROM TempX X WHERE X.BatchID = @batch_id

-- Create invoice detail
INSERT InvoiceDetail(InvoiceID, [Day past 1900], [Text], Units, [Unit Rate], Fixed, [Split Amount], [Order])
SELECT InvoiceID, @due_day, @prefix + B.Benefit + ' ' + EB.Coverage, 0, 0, [Employee Premium], [Employee Premium], 0
FROM EmployeeBenefit EB
INNER JOIN Invoice I ON I.BatchID=@invoice_batch_id AND I.EmployeeID=EB.EmployeeID
INNER JOIN TempX X ON X.BatchID=@batch_id AND X.[ID]=I.EmployeeID
INNER JOIN Benefit B ON EB.BenefitID=B.BenefitID 

-- Deletes empty invoices
DELETE Invoice WHERE BatchID=@invoice_batch_id AND NOT EXISTS (
	SELECT * FROM InvoiceDetail WHERE InvoiceDetail.InvoiceID=Invoice.InvoiceID
)

-- Recalc new invoices
DELETE TempX WHERE BatchID=@batch_id OR DATEDIFF(hour,Created,GETDATE())>1
INSERT TempX(BatchID, [ID]) SELECT @batch_id, InvoiceID FROM Invoice WHERE BatchID=@invoice_batch_id
EXEC dbo.spInvoiceCalc @invoice_id=NULL, @batch_id=@batch_id

COMMIT TRAN

DELETE TempX WHERE BatchID=@batch_id OR DATEDIFF(hour,Created,GETDATE())>1
GO
IF OBJECT_ID('dbo.spLeaveListAuthorized') IS NOT NULL DROP PROC dbo.spLeaveListAuthorized
GO
CREATE PROC dbo.spLeaveListAuthorized
	@employee_id int,
	@day int
AS
SET NOCOUNT ON

SELECT U.* FROM dbo.vwEmployeeLeaveUsed U WHERE U.[LOA Status]=2 AND U.LOAEmployeeID=@employee_id AND @day BETWEEN
ISNULL(U.[LOA Expected Departure Day past 1900], -2147483648) AND 

CASE
	WHEN U.[LOA Authorization Expires Day past 1900] IS NOT NULL THEN U.[LOA Authorization Expires Day past 1900]
	WHEN U.[LOA Expected Return Day past 1900] IS NOT NULL THEN U.[LOA Expected Return Day past 1900]
	ELSE 2147483647
END
ORDER BY U.[LOA Start Day past 1900] DESC
GO
GRANT EXEC ON dbo.spLeaveListAuthorized TO public
GO
CREATE PROC dbo.spStatement
	@due_as_of int,
	@batch_id int,
	@balance bit,
	@flags int = 0,
	@template_id int = NULL -- obsolete
AS
DECLARE @ignore_small_statements bit, @ignore_single_past_due_30 bit

SELECT @ignore_small_statements = CASE WHEN (@flags & 1) = 1 THEN 1 ELSE 0 END
SELECT @ignore_single_past_due_30 = CASE WHEN (@flags & 2) = 2 THEN 1 ELSE 0 END

SELECT EmployeeID=X.ID, 
AmountDueAll = ISNULL((SELECT SUM(I2.Balance) FROM Invoice I2 WHERE X.[ID]=I2.EmployeeID AND @due_as_of >= I2.[Due Day past 1900]),0),
AmountDue30 = ISNULL((SELECT SUM(I2.Balance) FROM Invoice I2 WHERE X.[ID]=I2.EmployeeID AND @due_as_of BETWEEN I2.[Due Day past 1900] + 1 AND I2.[Due Day past 1900] + 30),0)

INTO #TotalBalance
FROM TempX X WHERE BatchID = @batch_id

CREATE INDEX IX_CurrentBalance_EmployeeID ON #TotalBalance(EmployeeID)

SELECT
AmountDue0 = ISNULL((SELECT SUM(I2.Balance) FROM Invoice I2 WHERE X.[ID]=I2.EmployeeID AND @due_as_of <= I2.[Due Day past 1900]),0),
CB.AmountDue30,
AmountDue60 = ISNULL((SELECT SUM(I2.Balance) FROM Invoice I2 WHERE X.[ID]=I2.EmployeeID AND @due_as_of BETWEEN I2.[Due Day past 1900] + 31 AND I2.[Due Day past 1900] + 60),0),
AmountDue90 = ISNULL((SELECT SUM(I2.Balance) FROM Invoice I2 WHERE X.[ID]=I2.EmployeeID AND @due_as_of BETWEEN I2.[Due Day past 1900] + 61 AND I2.[Due Day past 1900] + 90),0),
AmountDue91 = ISNULL((SELECT SUM(I2.Balance) FROM Invoice I2 WHERE X.[ID]=I2.EmployeeID AND @due_as_of > I2.[Due Day past 1900] + 90),0),
CB.AmountDueAll,
Employee = dbo.fnGetListAs(P.[First Name], P.[Middle Name], P.[Last Name], P.Suffix),
P.[Home Phone], P.[Home Address], P.[Home Address (cont.)], P.[Home City], P.[Home State], P.[Home ZIP], P.[Home Country],
[Extended Home Address] = dbo.fnGetExtendedHomeAddress(P.[Home Address], P.[Home Address (cont.)], P.[Home City], P.[Home State], P.[Home Zip]),
I.*
FROM TempX X
INNER JOIN vwInvoice I ON X.BatchID=@batch_id AND I.EmployeeID = X.[ID] AND I.[Due Day past 1900] <= @due_as_of AND (
	(@balance = 1 AND Balance > 0) OR (@balance = 0 AND Balance = 0) OR (@balance IS NULL)
)
INNER JOIN Person P ON X.[ID] = P.PersonID
INNER JOIN #TotalBalance CB ON X.[ID] = CB.EmployeeID 
AND (@ignore_small_statements = 0 OR CB.AmountDueAll > 1.0)
AND (@ignore_single_past_due_30 = 0 OR CB.AmountDueAll > CB.AmountDue30)
ORDER BY P.[First Name],P.[Last Name], I.InvoiceID

DELETE dbo.TempX WHERE BatchID=@batch_id OR DATEDIFF(minute, Created, GETDATE()) > 30
GO
CREATE PROC dbo.spInvoiceTemplateSelect @template_id int AS
SELECT * FROM vwInvoiceTemplate WHERE TemplateID = @template_id
GO
CREATE PROC dbo.spInvoiceTemplateList AS SELECT * FROM vwInvoiceTemplate
GO
GRANT EXEC ON dbo.spInvoiceInsertBatch TO public
GRANT EXEC ON dbo.spPaymentTypeList TO public	
GRANT EXEC ON dbo.spInvoiceList2 TO public
GRANT EXEC ON dbo.spStatement TO public
GRANT EXEC ON dbo.spInvoiceTemplateSelect TO public
GRANT EXEC ON dbo.spInvoiceTemplateList TO public
GO
IF OBJECT_id('dbo.spPaymentRefundDelete') IS NOT NULL DROP PROC dbo.spPaymentRefundDelete
IF OBJECT_id('dbo.spPaymentRefundInsert') IS NOT NULL DROP PROC dbo.spPaymentRefundInsert
IF OBJECT_id('dbo.spPaymentRefundUpdate') IS NOT NULL DROP PROC dbo.spPaymentRefundUpdate
IF OBJECT_id('dbo.spPaymentRefundList') IS NOT NULL DROP PROC dbo.spPaymentRefundList
GO
CREATE PROC dbo.spPaymentRefundDelete @refund_id int AS
DECLARE @old_payment_id int
SELECT @old_payment_id=PaymentID FROM PaymentRefund WHERE RefundID=@refund_id
DELETE PaymentRefund WHERE RefundID=@refund_id
EXEC dbo.spPaymentCalc @old_payment_id
GO
CREATE PROC dbo.spPaymentRefundInsert
	@payment_id int,
	@day int,
	@comment varchar(50),
	@amount money,
	@refund_id int out
AS
INSERT PaymentRefund(PaymentID, [Day past 1900], Comment, Amount)
SELECT @payment_id, @day, @comment, @amount

SELECT @refund_id=SCOPE_IDENTITY()
GO
CREATE PROC dbo.spPaymentRefundList @payment_id int AS
SET NOCOUNT ON SELECT * FROM vwPaymentRefund WHERE PaymentID=@payment_id
GO
CREATE PROC dbo.spPaymentRefundUpdate
	@day int,
	@comment varchar(50),
	@amount money,
	@refund_id int
AS
UPDATE PaymentRefund SET [Day past 1900]=@day, Comment=@comment, Amount=@amount WHERE RefundID=@refund_id
GO
GRANT EXEC ON dbo.spPaymentRefundDelete TO public
GRANT EXEC ON dbo.spPaymentRefundInsert TO public
GRANT EXEC ON dbo.spPaymentRefundList TO public
GRANT EXEC ON dbo.spPaymentRefundUpdate TO public
GO
-- INVOICE CREATION SECTION End
GO
IF OBJECT_id('dbo.spPayGradeGetPayGradeFromPayGradeID') IS NOT NULL DROP PROC dbo.spPayGradeGetPayGradeFromPayGradeID
GO
CREATE PROC dbo.spPayGradeGetPayGradeFromPayGradeID
	@pay_grade_id int,
	@pay_grade varchar(50) out
AS
SELECT @pay_grade = [Pay Grade] FROM PayGrade WHERE PayGradeID = @pay_grade_id
GO
GRANT EXEC ON dbo.spPayGradeGetPayGradeFromPayGradeID TO public
GO
IF OBJECT_ID('dbo.spLeaveCreateRandomData') IS NOT NULL DROP PROC dbo.spLeaveCreateRandomData
GO
CREATE PROC dbo.spLeaveCreateRandomData
AS
DECLARE @employee_id int
DECLARE @hired_day int
DECLARE @m18 int
DECLARE @day int
DECLARE @length int
DECLARE @leave_id int
DECLARE @seconds int
DECLARE @batch_id int
DECLARE @type_id int
DECLARE @types int
DECLARE @approval_type_id int

SET NOCOUNT ON

DELETE EmployeeLeaveUsed
DELETE EmployeeLeaveEarned
DELETE EmployeeLeavePlan

IF NOT EXISTS(SELECT * FROM LeaveApprovalType) INSERT LeaveApprovalType(Type) VALUES('Prearranged')

UPDATE Constant SET [Leave Note] = ''

SELECT @m18 = DATEDIFF(d, 0, GETDATE()) - 500, @batch_id = RAND() * 2147483647, @types = 0
SELECT TOP 1 @approval_type_id = TypeID FROM LeaveApprovalType


CREATE TABLE #T(Ordinal int, TypeID int)


DECLARE t_cursor CURSOR LOCAL FORWARD_ONLY STATIC FOR SELECT TypeID FROM LeaveType WHERE Advanced = 0
OPEN t_cursor
FETCH NEXT FROM t_cursor INTO @type_id

WHILE @@FETCH_STATUS = 0
BEGIN
	INSERT #T VALUES(@types, @type_id)
	SELECT @types = @types + 1
	FETCH NEXT FROM t_cursor INTO @type_id
END
CLOSE t_cursor
DEALLOCATE t_cursor


DECLARE t_cursor CURSOR LOCAL FORWARD_ONLY STATIC FOR SELECT TypeID FROM LeaveType WHERE Advanced = 1


UPDATE Employee SET [Ongoing Condition] = 0, [Recertify Condition Day past 1900] = NULL

DECLARE e_cursor CURSOR LOCAL FORWARD_ONLY STATIC FOR SELECT Employee.EmployeeID, Employee.[Seniority Begins Day past 1900], S.[Effective Seconds per Day]  FROM Employee
INNER JOIN vwEmployeeEffectiveSecondsPerDay S ON Employee.EmployeeID = S.EmployeeID

OPEN e_cursor
FETCH NEXT FROM e_cursor INTO @employee_id, @hired_day, @seconds

DECLARE @interval int, @fte numeric(9,4)
SELECT @interval = 150 FROM Employee

WHILE @@FETCH_STATUS = 0
BEGIN
	SELECT @day = CASE WHEN @m18 < @hired_day THEN @hired_day ELSE @m18 END

	SELECT TOP 1 @fte = FTE FROM vwEmployeeCompensation WHERE EmployeeID = @employee_id ORDER BY [Start Day past 1900] DESC
	IF @@ROWCOUNT = 0 SELECT @fte = 1

	IF RAND() < 0.1 UPDATE Employee SET [Ongoing Condition] = 1, [Recertify Condition Day past 1900] = DATEDIFF(d, 0, GETDATE())  + 15 + RAND() * 30 WHERE EmployeeID = @employee_id

	INSERT EmployeeLeavePlan(EmployeeID, PlanID, [Start Day past 1900])
	SELECT TOP 1 @employee_id, PlanID, @day FROM LeavePlan WHERE FTE = @fte ORDER BY PlanID

	WHILE @day < @m18 + 650
	BEGIN
		DECLARE @requested int, @status int, @this_approval_type_id int, @advanced_type_mask int, @atype_id int

		SELECT @day = @day + RAND() * @interval
		SELECT @length = RAND() * 6 + 1
		SELECT @advanced_type_mask = 0
		
		-- Constructs random advanced type mask
		OPEN t_cursor
		FETCH NEXT FROM t_cursor INTO @atype_id
	
		WHILE @@FETCH_STATUS = 0
		BEGIN
			IF RAND() < 0.1 SELECT @advanced_type_mask = @advanced_type_mask | @atype_id
			FETCH NEXT FROM t_cursor INTO @atype_id
		END
		CLOSE t_cursor

		SELECT @requested = @day - RAND() * 7 + 7, @type_id = RAND() * 0.99999 * @types, @status = RAND() * 100
		SELECT @type_id = TypeID FROM #T WHERE Ordinal = @type_id
		SELECT @status = CASE WHEN @status < 10 THEN 1 WHEN @status < 20 THEN 4 ELSE 2 END
		SELECT @this_approval_type_id = CASE WHEN @status = 2 THEN @approval_type_id ELSE NULL END

		EXEC dbo.spEmployeeLeaveUsedInsert
			@employee_id = @employee_id,
			@reason_id = NULL,
			@covering_employee_id = NULL,
			@requested = @requested,
			@status = @status,
			@note = '',
			@denial_reason_id = NULL,
			@advanced_type_mask = @advanced_type_mask,
			@authorized_day_past_1900 = NULL,
			@authorizing_employee_id = NULL,
			@approval_type_id = @this_approval_type_id,
			@leave_id = @leave_id OUT

		WHILE @length > 0
		BEGIN
			IF DATEPART(dw, DATEADD(d, 0, @day)) BETWEEN 2 AND 6
			INSERT EmployeeLeaveUsedItem(LeaveID, TypeID, [Day past 1900], Seconds, [Advanced Type Mask])
			VALUES(@leave_id, @type_id, @day, @seconds, @advanced_type_mask)
		
			SELECT @day = @day + 1, @length = @length - 1
		END
	END
	FETCH NEXT FROM e_cursor INTO @employee_id, @hired_day, @seconds
END
CLOSE e_cursor
DEALLOCATE e_cursor

DEALLOCATE t_cursor

DELETE EmployeeLeaveUsed WHERE LeaveID NOT IN (
	SELECT LeaveID FROM EmployeeLeaveUsedItem
)

EXEC dbo.spEmployeeLeaveCalcAll
GO
IF OBJECT_ID('dbo.spAdminCreateSampleData') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spAdminCreateSampleData AS'
	--EXEC sp_executesql N'GRANT EXEC ON dbo.spAdminCreateSampleData TO public'
END
GO
ALTER PROC dbo.spAdminCreateSampleData
AS
EXEC dbo.spEmployeeDeleteAll

DELETE Project
DELETE ProjectClass
DELETE [Union]

DBCC CHECKIDENT ('Person', RESEED, 1000)
DBCC CHECKIDENT ('PersonXLicense', RESEED, 0)
DBCC CHECKIDENT ('PersonXCertification', RESEED, 0)
DBCC CHECKIDENT ('EmployeeReview', RESEED, 0)
DBCC CHECKIDENT ('PersonXEducation', RESEED, 0)
DBCC CHECKIDENT ('PersonXEducationContinuing', RESEED, 0)
DBCC CHECKIDENT ('PersonXEmployer', RESEED, 0)
DBCC CHECKIDENT ('PersonXExperience', RESEED, 0)
DBCC CHECKIDENT ('PersonXLicense', RESEED, 0)
DBCC CHECKIDENT ('PersonXSkill', RESEED, 0)
DBCC CHECKIDENT ('PersonXTest', RESEED, 0)
DBCC CHECKIDENT ('EmployeeCourse', RESEED, 0)
DBCC CHECKIDENT ('PersonXUnion', RESEED, 0)
DBCC CHECKIDENT ('EmployeeLeaveEarned', RESEED, 0)
DBCC CHECKIDENT ('EmployeeLeaveUsed', RESEED, 0)
DBCC CHECKIDENT ('EmployeeLeaveUsedItem', RESEED, 0)
DBCC CHECKIDENT ('EmployeeLeaveUnused', RESEED, 0)
DBCC CHECKIDENT ('EmployeeSuccessor', RESEED, 0)
DBCC CHECKIDENT ('EmployeeTDRP', RESEED, 0)
DBCC CHECKIDENT ('EmployeeTime', RESEED, 0)
DBCC CHECKIDENT ('EmployeeBenefit', RESEED, 0)
DBCC CHECKIDENT ('Project', RESEED, 0)
DBCC CHECKIDENT ('ProjectClass', RESEED, 0)
DBCC CHECKIDENT ('Union', RESEED, 0)

INSERT ProjectClass(Class) VALUES ('Billable')
INSERT ProjectClass(Class) VALUES ('Nonbillable')
INSERT [Union]([Union]) VALUES ('UAW')
INSERT [Union]([Union]) VALUES ('CFGT')

INSERT Project(Project, classid, active, locationid,note)
SELECT 'Internal',2,1,(select top 1 locationid from location),'' UNION
SELECT 'ICP',1,1,(select top 1 locationid from location),'' UNION
SELECT 'AC Monitoring',1,1,(select top 1 locationid from location),'' UNION
SELECT 'Development', 1,1,(select top 1 locationid from location),''

UPDATE Constant SET [Enable Timecard Trigger] = 0

DECLARE @firsts int, @lasts int, @id int, @department_id int
DECLARE @location_id int, @division_id int, @shift_id int, @ti int, @tj int, @tk int, @tl int, @tx int, @ty int, @tz int, @terminated int
DECLARE @first varchar(50), @last varchar(50), @temp varchar(50), @t1 varchar(10), @t2 varchar(10), @t3 varchar(10), @t4 varchar(10)
DECLARE @address varchar(50), @address2 varchar(50), @address3 varchar(50), @address4 varchar(50), @text varchar(4000)
DECLARE @dt datetime, @dt2 datetime

--SET @d = DATEDIFF(d, 0, GETDATE()) - 1000
SELECT @firsts = MAX([ID]) FROM RandomFirstName
SELECT @lasts = MAX([ID]) FROM RandomLastName


SELECT @department_id = MIN(DepartmentID) FROM Department
SELECT @location_id = MIN(LocationID) FROM Location
SELECT @division_id = MIN(DivisionID) FROM Division
SELECT @shift_id = MIN(ShiftID) FROM Shift


CREATE TABLE ##Provider([ID] int IDENTITY(1,1), Provider varchar(50) COLLATE SQL_Latin1_General_CP1_CI_AS)
INSERT ##Provider(Provider) VALUES('Anthem')
INSERT ##Provider(Provider) VALUES('Blue Cross')
INSERT ##Provider(Provider) VALUES('UHC')
INSERT ##Provider(Provider) VALUES('Met')

CREATE TABLE ##Coverage([ID] int IDENTITY(1,1), Coverage varchar(50) COLLATE SQL_Latin1_General_CP1_CI_AS)
INSERT ##Coverage(Coverage) VALUES('Employee')
INSERT ##Coverage(Coverage) VALUES('Employee & Spouse')
INSERT ##Coverage(Coverage) VALUES('Family, 1 Child')
INSERT ##Coverage(Coverage) VALUES('Family, 2+ Children')

CREATE TABLE ##Plan([ID] int IDENTITY(1,1), [Plan] varchar(50) COLLATE SQL_Latin1_General_CP1_CI_AS)
INSERT ##Plan([Plan]) VALUES('HMO')
INSERT ##Plan([Plan]) VALUES('PPO Select')
INSERT ##Plan([Plan]) VALUES('PPO Standard')

CREATE TABLE ##Degree([ID] int IDENTITY(1,1), [Degree] varchar(50) COLLATE SQL_Latin1_General_CP1_CI_AS)
INSERT ##Degree([Degree]) VALUES('BCSD')
INSERT ##Degree([Degree]) VALUES('PhD')
INSERT ##Degree([Degree]) VALUES('BDSF')
INSERT ##Degree([Degree]) VALUES('Associates')

CREATE TABLE ##University([ID] int IDENTITY(1,1), University varchar(50) COLLATE SQL_Latin1_General_CP1_CI_AS)
INSERT ##University(University) VALUES('NYU')
INSERT ##University(University) VALUES('UCLA')
INSERT ##University(University) VALUES('Purdue')
INSERT ##University(University) VALUES('Berkeley')
INSERT ##University(University) VALUES('Pepperdine')

CREATE TABLE ##Course([ID] int IDENTITY(1,1), Course varchar(50) COLLATE SQL_Latin1_General_CP1_CI_AS)
INSERT ##Course(Course) VALUES('Robert''s Rules')
INSERT ##Course(Course) VALUES('Executive Management')
INSERT ##Course(Course) VALUES('CCRF Compliance')
INSERT ##Course(Course) VALUES('7 Habits')
INSERT ##Course(Course) VALUES('Time Management')
INSERT ##Course(Course) VALUES('Cold Fusion for Dummies')
INSERT ##Course(Course) VALUES('Grand Unified Theory')

WHILE (SELECT COUNT(*) FROM Employee) < 100
BEGIN
	SELECT @id = @firsts * RAND()
	IF @id < @firsts SET @id = @id + 1
	SELECT @first = [First Name] FROM RandomFirstName WHERE ID = @id

	SELECT @id = @lasts * RAND()
	IF @id < @lasts SET @id = @id + 1
	SELECT @last = [Last Name] FROM RandomLastName WHERE ID = @id

	SELECT @id = @lasts * RAND()
	IF @id < @lasts SET @id = @id + 1
	SELECT @address = [Last Name] FROM RandomLastName WHERE ID = @id

	SELECT @id = @lasts * RAND()
	IF @id < @lasts SET @id = @id + 1
	SELECT @address2 = [Last Name] FROM RandomLastName WHERE ID = @id

	SELECT @id = @lasts * RAND()
	IF @id < @lasts SET @id = @id + 1
	SELECT @address3 = [Last Name] FROM RandomLastName WHERE ID = @id
	
	SELECT @id = @lasts * RAND()
	IF @id < @lasts SET @id = @id + 1
	SELECT @address4 = [Last Name] FROM RandomLastName WHERE ID = @id

	IF NOT EXISTS(SELECT * FROM Person WHERE [First Name] = @first AND [Last Name] = @last)
	EXEC dbo.spEmployeeInsert '', @first, '', @last, '', '', @id out

	SELECT @temp = ''
	WHILE @temp = '' OR EXISTS(SELECT * FROM Employee WHERE [Employee Number] = @temp)
	SELECT @temp = 'E' + CAST(CAST((RAND() * 9000) AS int) + 1000 AS varchar(50))

	UPDATE Employee SET [Employee Number] = @temp WHERE EmployeeID = @id
	
	UPDATE Employee SET [DepartmentID] = @department_id WHERE EmployeeID = @id
	UPDATE Employee SET ShiftID = @shift_id WHERE EmployeeID = @id
	UPDATE Employee SET DivisionID = @division_id WHERE EmployeeID = @id
	UPDATE Employee Set LocationID = @location_id WHERE LocationID = @id

	SELECT TOP 1 @department_id = DepartmentID FROM Department WHERE DepartmentID > @department_id ORDER BY DepartmentID
	IF @@ROWCOUNT = 0 SELECT @department_id = MIN(DepartmentID) FROM Department

	SELECT TOP 1 @shift_id = ShiftID FROM Shift WHERE ShiftID > @shift_id ORDER BY ShiftID
	IF @@ROWCOUNT = 0 SELECT @shift_id = MIN(ShiftID) FROM Shift

	SELECT TOP 1 @division_id = DivisionID FROM Division WHERE DivisionID > @division_id ORDER BY DivisionID
	IF @@ROWCOUNT = 0 SELECT @division_id = MIN(DivisionID) FROM Division

	EXEC dbo.spAdminGetRandomID 'Location', 'LocationID', @ti out
	UPDATE Employee SET LocationID = @ti WHERE EmployeeID = @id

	DECLARE @doh int
	SELECT @doh = DATEDIFF(d,0,GETDATE()) - 150 - RAND() * 1000

	UPDATE Employee SET [Seniority Begins Day past 1900] = @doh WHERE EmployeeID = @id
	UPDATE PersonX SET [DOB Day past 1900] = DATEDIFF(d,0,GETDATE()) - 25 * 365 + RAND() * 35 * 365 WHERE PersonID = @id
	UPDATE PersonX SET SSN = CAST(CAST(RAND() * 899 + 100 AS int) AS char(3)) + '-' + CAST(CAST(RAND() * 89 AS int) + 10 AS char(2)) + '-' + CAST(CAST(RAND() * 8999 + 1000 AS int) AS char(4)) WHERE PersonID = @id
	IF RAND() > 0.5 UPDATE Person SET Male = 0 WHERE PersonID = @id

	SET @terminated = NULL
	IF (SELECT COUNT(*) FROM Employee) > 2 AND RAND() < 0.3 AND @doh < DATEDIFF(d,0,GETDATE()) - 501
	BEGIN
		SET @terminated = @doh + RAND() * 500
		UPDATE Employee SET [Active Employee] = 0, [Terminated Day past 1900] = @terminated WHERE EmployeeID = @id
	END

	EXEC dbo.spAdminRandomString 5, @t1 out
	UPDATE Person SET [Work Address] = @address + ' Drive', [Home E-mail] = LOWER(@first) + '@zmail.com', [Work E-mail] = LOWER(@first) + '@yaho.com', [Work City] = @address2 + 'ton', [Work State] = 'CI', [Work Zip] = @t1 WHERE PersonID = @id

	EXEC dbo.spAdminRandomString 5, @t1 out
	UPDATE Person SET [Home Address] = @address3 + ' Court', [Home City] = @address4 + 'ton', [Home State] = 'CI', [Home Zip] = @t1 WHERE PersonID = @id

	EXEC dbo.spAdminRandomString 3, @t1 out
	EXEC dbo.spAdminRandomString 3, @t2 out
	EXEC dbo.spAdminRandomString 4, @t3 out
	EXEC dbo.spAdminRandomString 3, @t4 out
	UPDATE Person SET [Work Phone] = '(' + @t1 +') ' + @t2 + '-' + @t3, [Extension] = @t4 WHERE PersonID = @id

	EXEC dbo.spAdminRandomString 3, @t1 out
	EXEC dbo.spAdminRandomString 3, @t2 out
	EXEC dbo.spAdminRandomString 4, @t3 out
	UPDATE Person SET [Home Phone] = '(' + @t1 +') ' + @t2 + '-' + @t3 WHERE PersonID = @id

	EXEC dbo.spAdminRandomString 3, @t1 out
	EXEC dbo.spAdminRandomString 3, @t2 out
	EXEC dbo.spAdminRandomString 4, @t3 out
	UPDATE Person SET [Home Office Phone] = '(' + @t1 +') ' + @t2 + '-' + @t3 WHERE PersonID = @id

	DECLARE @i int

	SET @i = 0
	WHILE @i < RAND() * 5
	BEGIN
		EXEC dbo.spAdminGetRandomText @text out

		SELECT @ti = @doh + RAND() * (DATEDIFF(d,0,GETDATE()) - @doh)

		INSERT Note(PersonID, [Day past 1900], Subject, [Note])
		SELECT @id, @ti, 'Warning', @text

		SET @i = @i + 1
	END	

	-- Reviews
	SET @i = 0
	WHILE @i < RAND() * 4
	BEGIN
		EXEC dbo.spAdminGetRandomText @text out
		SELECT @text = SUBSTRING(@text, 1, 200)
		SELECT @text = REPLACE(@text, CHAR(10), '')
		SELECT @text = REPLACE(@text, CHAR(13), '')

		SELECT @ti = @doh + RAND() * (DATEDIFF(d,0,GETDATE()) - @doh)


		EXEC dbo.spAdminGetRandomID 'EmployeeReviewType', 'TypeID', @tj out
		EXEC dbo.spAdminGetRandomID 'EmployeeReviewRating', 'RatingID', @tk out

		EXEC dbo.spAdminGetRandomID 'Employee', 'EmployeeID', @tl out

		INSERT EmployeeReview(EmployeeID, [Day past 1900], RatingID, TypeID, [Changed Salary], ReviewedByEmployeeID, Comment)
		SELECT @id, @ti, @tk, @tj, 0, @tl, @text


		SET @i = @i + 1
	END

	SELECT @ti = ISNULL(MAX([Day past 1900]), @doh) FROM EmployeeReview WHERE EmployeeID = @id
	SELECT @tk = @doh + RAND() * (DATEDIFF(d,0,GETDATE()) - @ti)

	UPDATE Employee SET [Next Performance Review Day past 1900] = @tk WHERE EmployeeID = @id

	
	-- Timecards
	SET @i = DATEDIFF(d, 0, GETDATE()) - 300
	IF @i < @doh SET @i = @doh
	SELECT @ti = [Terminated Day past 1900] FROM Employee WHERE EmployeeID = @id
	IF @ti IS NULL SET @ti = DATEDIFF(d, 0, GETDATE()) +360

	WHILE @i < @ti
	BEGIN
		SET @dt = DATEADD(d, 0, @i)

		IF DATEPART(dw, @dt) BETWEEN 2 AND 6
		BEGIN
			SET @dt = DATEADD(hh, 8, @dt)
			SET @dt = DATEADD(s, RAND() * 3600,  @dt)
			SET @dt2 = DATEADD(s, RAND() * 3600 * 3, @dt)

			EXEC dbo.spEmployeeTimeInsert @id, @dt, @dt2, @tz out
			EXEC dbo.spAdminGetRandomID 'Project', 'ProjectID', @tx out
			UPDATE EmployeeTime SET ProjectID = @tx WHERE ItemID = @tz

			SET @dt = DATEADD(n, 30, @dt2)
			SET @dt = DATEADD(s, RAND() * 1800, @dt)
			SET @dt2 = DATEADD(s, RAND() * 3600 * 3, @dt)

			EXEC dbo.spEmployeeTimeInsert @id, @dt, @dt2, 0

		END

		SET @i = @i + 1
	END


	-- Benefits
	DECLARE @benefit_id int
	DECLARE benefit_cursor CURSOR LOCAL FORWARD_ONLY STATIC FOR SELECT BenefitID FROM Benefit

	OPEN benefit_cursor
	FETCH benefit_cursor INTO @benefit_id
	WHILE @@FETCH_STATUS = 0
	BEGIN
		EXEC dbo.spAdminGetRandomID '##Provider', 'ID', @ti out
		EXEC dbo.spAdminGetRandomID '##Coverage', 'ID', @tj out
		EXEC dbo.spAdminGetRandomID '##Plan', 'ID', @tk out

		
		EXEC dbo.spAdminRandomString 5, @temp out
		EXEC dbo.spAdminRandomString 1, @t1 out
		EXEC dbo.spAdminGetRandomText @address out
		SELECT @address = SUBSTRING(@address, 1, 50);

		SELECT @tx = @doh + RAND() * 30, @ty = @doh + 30 + RAND() * 30, @tz = NULL
		IF RAND() < 0.2
		BEGIN
			SET @tz = @ty
			SET @ty = NULL
		END

		INSERT EmployeeBenefit(EmployeeID, BenefitID, Provider, [Plan], Coverage, 
			[Individual Policy Number], [Group Policy Number], [Employee Premium], [Employer Premium], 
			[Eligible Day past 1900], [Expires Day past 1900], [First Enrolled Day past 1900], [Last Enrolled Day past 1900], [Declined Day past 1900], Note)
		SELECT @id, @benefit_id, (SELECT Provider FROM ##Provider WHERE [ID] = @ti), (SELECT [Plan] FROM ##Plan WHERE [ID] = @tk), (SELECT Coverage FROM ##Coverage WHERE [ID] = @tj),
			@temp, 'A432' + @t1, 10 + RAND() * 20, 10 + RAND() * 21,
			@tx, NULL, @ty, @ty, @tz, @address
	
		FETCH benefit_cursor INTO @benefit_id
	END
	CLOSE benefit_cursor
	DEALLOCATE benefit_cursor

	-- TDRP
	DECLARE benefit_cursor CURSOR LOCAL FORWARD_ONLY STATIC FOR SELECT TDRPID FROM TDRP
	OPEN benefit_cursor
	FETCH benefit_cursor INTO @benefit_id
	WHILE @@FETCH_STATUS = 0
	BEGIN
		SELECT @tx = @doh + RAND() * 30, @ty = @doh + 30 + RAND() * 30, @tz = NULL
		IF RAND() < 0.2
		BEGIN
			SET @tz = @ty
			SET @ty = NULL
		END

		INSERT EmployeeTDRP(EmployeeID, TDRPID, [Employee Contribution], [Employer Contribution], 
		[Eligible Day past 1900], [Expires Day past 1900], [First Enrolled Day past 1900], [Last Enrolled Day past 1900], [Declined Day past 1900], Note)

		SELECT @id, @benefit_id, 1 + RAND() * 15, 1 + RAND() * 10, 
		@tx, NULL, @ty, @ty, @tz, @address

		FETCH benefit_cursor INTO @benefit_id
	END
	CLOSE benefit_cursor
	DEALLOCATE benefit_cursor

	-- COBRA
	IF @terminated IS NOT NULL
	BEGIN
		UPDATE EmployeeTDRP SET [Expires Day past 1900] = @terminated WHERE [Declined Day past 1900] IS NULL AND EmployeeID = @id

		IF RAND() < 0.5
		BEGIN
			UPDATE EmployeeBenefit SET [Expires Day past 1900] = @terminated + 365  WHERE [Declined Day past 1900] IS NULL AND EmployeeID = @id
			UPDATE Employee SET [Track COBRA] = 1, [COBRA Expires Day past 1900] = @terminated + 365, [First Payment Due Day past 1900] = @terminated + 30, [Next Payment Due Day past 1900] = @terminated + 90, [COBRA First Enrolled Day past 1900] = @terminated WHERE EmployeeID = @id
		END
		ELSE
		BEGIN
			UPDATE EmployeeBenefit SET [Expires Day past 1900] = @terminated WHERE [Declined Day past 1900] IS NULL AND EmployeeID = @id
		END
	END

	

	
	-- Licenses
	SET @i = 0
	WHILE @i < RAND() * 3
	BEGIN
		
		EXEC dbo.spAdminGetRandomID 'License', 'LicenseID', @ti out
		IF NOT EXISTS(SELECT * FROM PersonXLicense WHERE PersonID = @id AND LicenseID = @ti)
		BEGIN
			SET @tj = DATEDIFF(d, 0, GETDATE()) - 2000 + RAND() * 1000
			SET @tk = NULL
			IF RAND() < 0.5 SET @tk = @tj + 760
		
			EXEC dbo.spAdminGetRandomTextSmall @text out
			
			INSERT PersonXLicense(PersonID, LicenseID, [Completed Day past 1900], Jurisdiction, Verified, Comments, [Renewed Day past 1900], [Expires Day past 1900])
			SELECT @id, @ti, @tj, 'US', 1, @text, @tj + 365, @tk
		END
		SET @i = @i + 1
	END

	-- Certifications
	SET @i = 0
	WHILE @i < RAND() * 3
	BEGIN
		
		EXEC dbo.spAdminGetRandomID 'Certification', 'CertificationID', @ti out
		IF NOT EXISTS(SELECT * FROM PersonXCertification WHERE PersonID = @id AND CertificationID = @ti)
		BEGIN
			SET @tj = DATEDIFF(d, 0, GETDATE()) - 2000 + RAND() * 1000
			SET @tk = NULL
			IF RAND() < 0.5 SET @tk = @tj + 760
		
			EXEC dbo.spAdminGetRandomTextSmall @text out
			
			INSERT PersonXCertification(PersonID, CertificationID, [Completed Day past 1900], Verified, Comments, [Renewed Day past 1900], [Expires Day past 1900])
			SELECT @id, @ti, @tj, 1, @text, @tj + 365, @tk
		END
		SET @i = @i + 1
	END

	-- Compensation and position history
	EXEC dbo.spAdminGetRandomID 'EmploymentStatus', 'StatusID', @ti out
	EXEC dbo.spAdminGetRandomID 'Position', 'PositionID', @tj out
	EXEC dbo.spAdminGetRandomID 'PayStep', 'PayStepID', @tk out
	SELECT @t1 = ''
	
	IF RAND() < 0.1 EXEC dbo.spAdminGetRandomText @t1 out
	
	DECLARE @money money
	
	SELECT @tx = PayGradeID FROM Position WHERE PositionID = @tj
	SELECT @money = [Hourly Rate] FROM Pay WHERE PayGradeID = @tx AND PayStepID = @tk
	
	
	EXEC dbo.spAdminGetRandomText @text out
	
	
	INSERT EmployeeCompensation(EmployeeID, PeriodID, EmploymentStatusID, [Start Day past 1900], [Stop Day past 1900], Note, PositionID, PayStepID, [Base Pay], [Other Compensation], Budgeted, StartEventID)
	SELECT @id, 512, @ti, @doh, @terminated, @text, @tj, @tk, @money, @t1, CASE WHEN RAND() < 0.5 THEN 1 ELSE 0 END, (SELECT TOP 1 EventID FROM EmployeeCompensationEventStart WHERE (Flags & 1) = 1)
	
	-- Skills
	EXEC dbo.spAdminGetRandomID 'Skill', 'SkillID', @ti out
	INSERT PersonXSkill(PersonID, SkillID, [Level])
	SELECT @id, @ti, 9

	-- Unions
	EXEC dbo.spAdminGetRandomID 'Union', 'UnionID', @ti out
	SET @tj = DATEDIFF(d, 0, GETDATE()) - RAND() * 3000

	INSERT PersonXUnion(PersonID, UnionID, [Joined Day past 1900])
	SELECT @id, @ti, @tj

	-- Training
	SET @i = 0
	WHILE @i < RAND() * 3
	BEGIN
		EXEC dbo.spAdminGetRandomID 'Course', 'CourseID', @ti out
		SET @tj = DATEDIFF(d, 0, GetDATE()) + 200 - 300 * RAND()

		IF NOT EXISTS(SELECT * FROM EmployeeCourse WHERE EmployeeID = @id AND CourseID = @ti)
		INSERT dbo.EmployeeCourse(EmployeeID, CourseID, [Expires Day past 1900], Flags)
		SELECT @id, @ti, @tj, 1   -- @tj, @tj + 30
		SET @ti = SCOPE_IDENTITY()
		
		SET @tj = @tj + 60 - 120 * RAND()
		
		INSERT dbo.EmployeeCourseEvent(EmployeeCourseID, [Completed Day past 1900], Cost, StatusID, Location, Comment, Flags)
		SELECT @ti, @tj, 0, 1, '', '', 0

		SET @i = @i + 1
	END



	-- Tests
	SET @i = 0
	WHILE @i < RAND() * 3
	BEGIN
		EXEC dbo.spAdminGetRandomID 'Test', 'TestID', @ti out
		SET @tj = DATEDIFF(d, 0, GetDATE()) - 60 - 200 * RAND()
		SET @tk = 50 + RAND() * 50

		IF NOT EXISTS(SELECT * FROM PersonXTest WHERE PersonID = @id AND TestID = @tj)
		INSERT PersonXTest(PersonID, TestID, [Taken Day past 1900], Score)
		SELECT @id, @ti, @tj, @tk

		SET @i = @i + 1
	END

	-- Education
	EXEC dbo.spAdminGetRandomTextSmall @text out
	SET @tj = DATEDIFF(d, 0, GetDATE()) - 60 - 5000 * RAND()
	EXEC dbo.spAdminGetRandomID '##Degree', 'ID', @ti out
	EXEC dbo.spAdminGetRandomID '##University', 'ID', @tk out
	INSERT PersonXEducation(PersonID, Years, [Completed Day past 1900], Location, Degree, University, [Major GPA], GPA, Comment, Verified, Scale)
	SELECT @id, 4, @tj, @address2 + 'ton', (SELECT Degree FROM ##Degree WHERE [ID] = @ti),  (SELECT University FROM ##University WHERE [ID] = @tk), 2 + RAND() * 2, 2 + RAND() * 1.9, @text, 1, 4

	-- Continuing Ed
	SET @i = 0
	WHILE @i < RAND() * 3
	BEGIN
		EXEC dbo.spAdminGetRandomTextSmall @text out
		SET @tj = DATEDIFF(d, 0, GetDATE()) - 60 - 5000 * RAND()
		EXEC dbo.spAdminGetRandomID '##Course', 'ID', @ti out
		INSERT PersonXEducationContinuing(PersonID, Course, Credits, Comment, [Completed Day past 1900], Location, Grade, Verified)
		SELECT @id, (SELECT Course FROM ##Course WHERE [ID] = @ti), 2 + RAND() * 2, @text, @tj, @address3 + 'ton', 'P', 1

		SET @i = @i + 1
	END

	-- Termination checklist
	IF @terminated IS NOT NULL
	BEGIN
		INSERT EmployeeChecklistExit(CheckID, EmployeeID, [Completed Day past 1900])
		SELECT CheckID, @id, @terminated FROM ChecklistExitInterview
	END

	-- New hire checklist
	INSERT EmployeeChecklistNewHire(CheckID, EmployeeID, [Completed Day past 1900])
	SELECT CheckID, @id, @doh FROM ChecklistNewHire

	-- Previous Employers
	INSERT PersonXEmployer(PersonID, Employer, [Start Day past 1900], [Stop Day past 1900], Title, Verified, Manager, Contact, Comment, Pay, PayPeriodID)
	SELECT @id, @address4 + ' Inc', DATEDIFF(d, 0, GETDATE()) - 3600, @doh - 14, 'Assistant', 1, @address2 + ' ' + @address3, LOWER(@address2 + '@' + @address4 + '.com'), '', 20000 + RAND() * 40000, 2
	
	-- Succession
	EXEC dbo.spAdminGetRandomID 'Employee', 'EmployeeID', @ti out
	EXEC dbo.spAdminGetRandomID 'EmployeeSuccessorStage', 'StageID', @tj out
	IF @ti <> @id AND NOT EXISTS(SELECT * FROM EmployeeSuccessor WHERE EmployeeID = @id AND SuccessorID = @ti)
	AND NOT EXISTS(SELECT * FROM EmployeeSuccessor WHERE EmployeeID = @ti AND SuccessorID = @id)
	INSERT EmployeeSuccessor(EmployeeID, SuccessorID, StageID)
	SELECT @id, @ti, @tj

	-- Emergency Contacts
	EXEC dbo.spAdminGetRandomID 'Employee', 'EmployeeID', @ti out
	IF @ti <> @id INSERT EmployeeEmergencyContact(EmployeeID, PersonID, Relationship)
	SELECT @id, @ti, 'Friend'

	-- I9
	IF RAND() < 0.2
	BEGIN
		SELECT @ti = CASE WHEN RAND() < 0.5 THEN 2 ELSE 3 END
		SELECT @tj = NULL, @tk = NULL
		IF RAND() > 0.9 SET @tj = DATEDIFF(d, 0, GETDATE()) - 200 + 600 * RAND()
		IF RAND() > 0.9 SET @tk = DATEDIFF(d, 0, GETDATE()) - 200 + 600 * RAND()

		UPDATE PersonX SET I9StatusID = @ti, [Visa Expires Day past 1900] = @tk, [Passport Expires Day past 1900] = @tj WHERE PersonID = @id
	END
END

-- Equipment
DECLARE e_cursor CURSOR LOCAL FORWARD_ONLY STATIC FOR SELECT EquipmentID FROM Equipment
OPEN e_cursor

FETCH e_cursor INTO @ti

WHILE @@FETCH_STATUS = 0
BEGIN
	EXEC dbo.spAdminGetRandomID 'Employee', 'EmployeeID', @id out
	WHILE EXISTS(SELECT * FROM Employee WHERE [Terminated Day past 1900] IS NOT NULL AND EmployeeID = @id)
	EXEC dbo.spAdminGetRandomID 'Employee', 'EmployeeID', @id out


	UPDATE Equipment SET EmployeeID = @id, [Checked Out Day past 1900] = DATEDIFF(d, 0, GETDATE()) - 30 - 45 * RAND(),
		[Due Day past 1900] = DATEDIFF(d, 0, GETDATE()) - 15 * RAND() WHERE EquipmentID = @ti
	
	FETCH e_cursor INTO @ti
END

CLOSE e_cursor
DEALLOCATE e_cursor


DROP TABLE ##Provider
DROP TABLE ##Course
DROP TABLE ##University
DROP TABLE ##Degree
DROP TABLE ##Coverage
DROP TABLE ##Plan

UPDATE Constant SET [Enable Timecard Trigger] = 1

EXEC dbo.spLeaveCreateRandomData

-- Defines manager
DECLARE manager_cursor CURSOR LOCAL FORWARD_ONLY STATIC FOR SELECT EmployeeID FROM Employee
OPEN manager_cursor
FETCH manager_cursor INTO @id

WHILE @@FETCH_STATUS = 0
BEGIN
	-- Manager
	SELECT @ti = MIN(EmployeeID) FROM Employee
	SELECT @ti = @ti + RAND() * (SELECT COUNT(*) FROM Employee) / 7

	UPDATE Employee SET ManagerID = @ti WHERE EmployeeID = @id AND @id <> @ti AND NOT EXISTS
	(
		SELECT * FROM EmployeeSuperior WHERE EmployeeID = @id AND ManagerID = @ti
	)

	FETCH manager_cursor INTO @id
END


CLOSE manager_cursor
DEALLOCATE manager_cursor
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spEmployeeLeaveUsedGetForAdoption'
GO
ALTER PROC dbo.spEmployeeLeaveUsedGetForAdoption
	@employee_id int,
	@advanced_type_mask int,
	@reference_day int,
	@plus_minus int,
	@leave_id int OUT,
	@entry_type_id int = 0,
	@entry_advanced_type_mask int = 0
AS
DECLARE @authorized bit

SET @leave_id = NULL
EXEC dbo.spPermissionInsureForCurrentUserOnPerson @employee_id, 10001, 1, @authorized out

IF @authorized = 1 
SELECT TOP 1 @leave_id = LeaveID FROM EmployeeLeaveUsed WHERE Status = 2 AND EmployeeID = @employee_id AND @reference_day BETWEEN [Start Day past 1900] - @plus_minus AND [Stop Day past 1900] + @plus_minus
AND (
	(@advanced_type_mask != 0 AND [Advanced Type Mask] = @advanced_type_mask) OR
	([Advanced Type Mask] & @entry_advanced_type_mask) > 0
)
ORDER BY [Stop Day past 1900] DESC
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spEmployeeLeaveUsedSelectForAdoption'
GO
ALTER PROC dbo.spEmployeeLeaveUsedSelectForAdoption
	@employee_id int,
	@advanced_type_mask int,
	@reference_day int,
	@plus_minus int,
	@entry_type_id int = 0,
	@entry_advanced_type_mask int = 0
AS
IF OBJECT_ID('dbo.spEmployeeLeaveUsedSelectForAdoptionOverride') IS NOT NULL
BEGIN
	EXEC sp_executesql N'dbo.spEmployeeLeaveUsedSelectForAdoptionOverride @employee_id, @advanced_type_mask, @reference_day, @plus_minus', 
		N'@employee_id int, @advanced_type_mask int, @reference_day int, @plus_minus int, @entry_type_id int, @entry_advanced_type_mask int',
		@employee_id, @advanced_type_mask, @reference_day, @plus_minus, @entry_type_id, @entry_advanced_type_mask
	RETURN
END

DECLARE @authorized bit
DECLARE @leave_id int

SET NOCOUNT ON

EXEC dbo.spEmployeeLeaveUsedGetForAdoption @employee_id, @advanced_type_mask, @reference_day, @plus_minus, @leave_id OUT, @entry_type_id, @entry_advanced_type_mask
SELECT * FROM vwEmployeeLeaveUsed WHERE LOALeaveID = @leave_id
GO
ALTER PROC dbo.spBenefitList AS SET NOCOUNT ON SELECT * FROM vwBenefit ORDER BY Benefit
GO
IF OBJECT_id('dbo.spBenefitPremiumList') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spBenefitPremiumList AS'
GO
ALTER PROC dbo.spBenefitPremiumList
	@benefit_id int
AS
SET NOCOUNT ON

SELECT * FROM dbo.vwBenefitPremium WHERE BenefitID = @benefit_id ORDER BY Provider, [Plan], Coverage, [Home ZIP]
GO
GRANT EXEC ON dbo.spBenefitPremiumList to public
GO
IF OBJECT_id('dbo.spBenefitSelect') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spBenefitSelect AS'
GO
ALTER PROC dbo.spBenefitSelect @benefit_id int
AS SET NOCOUNT ON SELECT * FROM vwBenefit WHERE BenefitID = @benefit_id
GO
GRANT EXEC ON dbo.spBenefitSelect to public
GO
ALTER PROC dbo.spBenefitUpdate @benefit_id int, @note varchar(4000) = '', @benefit varchar(50), @deduction_code varchar(50) = NULL
AS UPDATE Benefit SET Benefit=@benefit, Note=@note, [Deduction Code]=ISNULL(@deduction_code,[Deduction Code]) WHERE BenefitID = @benefit_id
GO
ALTER PROC dbo.spBenefitInsert @benefit varchar(50), @note varchar(4000) = '', @deduction_code varchar(50) = '', @benefit_id int out
AS INSERT Benefit(Benefit, Note, [Deduction Code]) VALUES (@benefit, @note, @deduction_code)
SELECT @benefit_id = SCOPE_IDENTITY()
GO
ALTER PROCEDURE dbo.spTDRPInsert @max_employee_contribution_percent numeric(9,4), @tdrp varchar(50), @account_number varchar(50), @note varchar(4000),
	@tdrp_id int OUT, @deduction_code varchar(50) = '', @deduction_code_loan_repay varchar(50) = '', @deduction_code_catch_up varchar(50) = ''
AS INSERT TDRP([Account Number], [Max Employee Contribution Percent], TDRP, Note, [Deduction Code], [Deduction Code Loan Repay], [Deduction Code Catch Up])
VALUES (@account_number, @max_employee_contribution_percent, @tdrp, @note, @deduction_code, @deduction_code_loan_repay, @deduction_code_catch_up)
SELECT @tdrp_id = SCOPE_IDENTITY()
GO
ALTER PROCEDURE dbo.spTDRPUpdate
	@tdrp_id int,
	@max_employee_contribution_percent numeric(9,4),
	@tdrp varchar(50),
	@account_number varchar(50),
	@note varchar(4000),
	@deduction_code varchar(50) = NULL,
	@deduction_code_loan_repay varchar(50) = NULL,
	@deduction_code_catch_up varchar(50) = NULL
AS
UPDATE TDRP SET [Max Employee Contribution Percent] = @max_employee_contribution_percent,
[Account Number] = @account_number, TDRP = @tdrp, Note = @note,
[Deduction Code] = ISNULL(@deduction_code, [Deduction Code]),
[Deduction Code Loan Repay] = ISNULL(@deduction_code_loan_repay, [Deduction Code Loan Repay]),
[Deduction Code Catch Up] = ISNULL(@deduction_code_catch_up, [Deduction Code Catch Up])
WHERE TDRPID = @tdrp_id
GO
ALTER PROC dbo.spTDRPList AS SET NOCOUNT ON SELECT * FROM vwTDRP ORDER BY TDRP
GO
ALTER PROCEDURE dbo.spTDRPSelect @tdrp_id int
AS SET NOCOUNT ON SELECT * FROM vwTDRP WHERE TDRPID = @tdrp_id
GO
IF OBJECT_id('dbo.spPersonXEducationContinuingList') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spPersonXEducationContinuingList AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spPersonXEducationContinuingList TO public'
END
GO
ALTER PROC dbo.spPersonXEducationContinuingList
	@person_id int,
	@start int = -2147483648,
	@stop int = 2147483647,
	@extend bit = 0,
	@batch_id int = NULL,
	@authorized bit = 1 OUT
AS
SET NOCOUNT ON

IF @batch_id IS NULL
BEGIN
	SET @batch_id = RAND() * 2147483647
	INSERT dbo.TempX(BatchID,[ID]) SELECT @batch_id, @person_id
END

EXEC dbo.spPermissionGetOnPeopleForCurrentUser2 @batch_id, 10000
DELETE dbo.TempX WHERE BatchID=@batch_id AND (X & 1) = 0
SELECT @authorized = CASE WHEN @@ROWCOUNT=0 THEN 1 ELSE 0 END

IF @extend=0
BEGIN
	SELECT PC.ContinuingID, PC.PersonID, PC.Course, PC.Credits, PC.Comment, PC.[Completed Day past 1900], PC.Location, PC.Grade, PC.Verified, PC.Completed, PC.[List As]
	FROM dbo.vwPersonXEducationContinuing PC
	INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID] = PC.PersonID AND PC.[Completed Day past 1900] BETWEEN @start AND @stop
	ORDER BY PC.[Completed Day past 1900] DESC
END
ELSE
BEGIN
	SELECT PC.ContinuingID, PC.PersonID, PC.Course, PC.Credits, PC.Comment, PC.[Completed Day past 1900], PC.Location, PC.Grade, PC.Verified, PC.Completed, PC.[List As], S.*
	FROM dbo.vwPersonXEducationContinuing PC
	INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID] = PC.PersonID
	INNER JOIN dbo.vwEmployeeSecure S ON S.EID = PC.PersonID AND PC.[Completed Day past 1900] BETWEEN @start AND @stop
	ORDER BY PC.[Completed Day past 1900] DESC
END

DELETE dbo.TempX WHERE BatchID=@batch_id OR DATEDIFF(hour, [Created], GETDATE()) > 1
GO
IF OBJECT_id('dbo.spPersonXEducationContinuingSummary') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spPersonXEducationContinuingSummary AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spPersonXEducationContinuingSummary TO public'
END
GO
ALTER PROC dbo.spPersonXEducationContinuingSummary
	@batch_id int,
	@start int,
	@stop int,
	@credits_min numeric(9,4),
	@credits_max numeric(9,4),
	@extend bit,
	@authorized bit OUT
AS
SET NOCOUNT ON

EXEC dbo.spPermissionGetOnPeopleForCurrentUser2 @batch_id, 4096
DELETE TempX WHERE BatchID = @batch_id AND X & 1 = 0
SELECT @authorized = CASE WHEN @@ROWCOUNT = 0 THEN 1 ELSE 0 END

CREATE TABLE #PC(PersonID int, Courses varchar(4000), LastDay int, LastContinuingID int, Credits numeric(38,4))

INSERT #PC
SELECT X.[ID], '', 2147483647, NULL, 0
FROM dbo.TempX X WHERE X.BatchID = @batch_id


DELETE TempX WHERE BatchID = @batch_id OR DATEDIFF(hh, Created, GETDATE()) > 1

DECLARE @r int
SET @r = 1
WHILE @r > 0
BEGIN
	UPDATE #PC SET LastContinuingID = (
		SELECT TOP 1 PC.ContinuingID FROM PersonXEducationContinuing PC WHERE
		PC.[Completed Day past 1900] BETWEEN @start AND @stop AND
		PC.PersonID = #PC.PersonID AND (
			PC.[Completed Day past 1900] < #PC.LastDay OR 
			PC.[Completed Day past 1900] = #PC.LastDay AND PC.ContinuingID > #PC.LastContinuingID
		)/* AND (
			@exclude_expired IS NULL OR #PC.[Expires Day past 1900] IS NULL OR #PC.[Expires Day past 1900] < @exclude_expired
		)*/
		ORDER BY PC.[Completed Day past 1900] DESC, PC.ContinuingID
	)

	UPDATE #PC SET LastDay = PC.[Completed Day past 1900],
		Courses = SUBSTRING(
			Courses + 
			CASE WHEN LEN(#PC.Courses) = 0 THEN '' ELSE ', ' END + 
			PC.Course +
			' (' + CAST(DATEADD(d, PC.[Completed Day past 1900], 0) AS char(11)) + ')'
		, 1, 4000)
	FROM #PC 
	INNER JOIN PersonXEducationContinuing PC ON #PC.LastContinuingID = PC.ContinuingID

	SET @r = @@ROWCOUNT
END

UPDATE #PC SET Credits = ISNULL((
	SELECT SUM(PC.Credits) FROM dbo.PersonXEducationContinuing PC WHERE PC.PersonID = #PC.PersonID AND
	PC.[Completed Day past 1900] BETWEEN @start AND @stop /* AND
	(
		@exclude_expired IS NULL OR #PC.[Expires Day past 1900] IS NULL OR #PC.[Expires Day past 1900] < @exclude_expired
	) */
),0)


IF @extend = 1
BEGIN
	SELECT Person = P.[Person List As], #PC.Courses, #PC.Credits,
	P.*
	FROM #PC
	INNER JOIN dbo.vwEmployeeSecure P ON #PC.PersonID = P.EID AND LEN(#PC.Courses) > 0 AND #PC.Credits BETWEEN @credits_min AND @credits_max
	ORDER BY P.[Person List As]
END
ELSE
BEGIN
	SELECT Person = dbo.fnGetListAs([First Name], [Middle Name], [Last Name], Suffix), #PC.Courses, #PC.Credits
	FROM #PC
	INNER JOIN dbo.Person P ON #PC.PersonID = P.PersonID AND LEN(#PC.Courses) > 0 AND #PC.Credits BETWEEN @credits_min AND @credits_max
	ORDER BY P.[Last Name], P.[First Name], P.[Middle Name]
END
GO
IF OBJECT_id('dbo.spDeductionInsert') IS NOT NULL DROP PROC dbo.spDeductionInsert
IF OBJECT_id('dbo.spDeductionUpdate') IS NOT NULL DROP PROC dbo.spDeductionUpdate
IF OBJECT_id('dbo.spDeductionDelete') IS NOT NULL DROP PROC dbo.spDeductionDelete
IF OBJECT_id('dbo.spDeductionList') IS NOT NULL DROP PROC dbo.spDeductionList
IF OBJECT_id('dbo.spDeductionSelect') IS NOT NULL DROP PROC dbo.spDeductionSelect
IF OBJECT_id('dbo.spDeductionListUnion') IS NOT NULL DROP PROC dbo.spDeductionListUnion
GO
CREATE PROC dbo.spDeductionInsert @deduction varchar(50), @deduction_code varchar(50), @deduction_id int out
AS INSERT Deduction(Deduction, [Deduction Code]) VALUES (@deduction, @deduction_code) SET @deduction_id=SCOPE_IDENTITY()
GO
CREATE PROC dbo.spDeductionUpdate @deduction varchar(50), @deduction_code varchar(50), @deduction_id int
AS UPDATE Deduction SET Deduction=@deduction, [Deduction Code]=@deduction_code WHERE DeductionID=@deduction_id
GO
CREATE PROC dbo.spDeductionDelete @deduction_id int AS DELETE Deduction WHERE DeductionID=@deduction_id
GO
CREATE PROC dbo.spDeductionList AS SET NOCOUNT ON SELECT * FROM vwDeduction ORDER BY [Deduction]
GO
CREATE PROC dbo.spDeductionSelect @deduction_id int AS SET NOCOUNT ON SELECT * FROM vwDeduction WHERE DeductionID=@deduction_id
GO
CREATE PROC dbo.spDeductionListUnion AS SET NOCOUNT ON SELECT * FROM vwDeductionUnion ORDER BY [Employee Number], [Deduction Code]
GO
GRANT EXEC ON dbo.spDeductionList TO public
GRANT EXEC ON dbo.spDeductionListUnion TO public
GRANT EXEC ON dbo.spDeductionSelect TO public
GO
IF OBJECT_id('dbo.spEmployeeDeductionUpdate') IS NOT NULL DROP PROC dbo.spEmployeeDeductionUpdate
IF OBJECT_id('dbo.spEmployeeDeductionList2') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEmployeeDeductionList2 AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spEmployeeDeductionList2 TO public'
END
GO
ALTER PROC dbo.spEmployeeDeductionList2
	@employee_batch_id int,
	@deduction_batch_id int,
	@authorized bit OUT,
	@flags int = 0 -- 1: join vwemployeesecure
AS
SET NOCOUNT ON

EXEC dbo.spPermissionGetOnPeopleForCurrentUser2 @employee_batch_id, 536870912

DELETE TempX WHERE BatchID=@employee_batch_id AND (X&1)=0
SELECT @authorized = CASE WHEN @@ROWCOUNT=0 THEN 1 ELSE 0 END

IF (@flags & 1) = 1
BEGIN
	SELECT
	ED.ItemID, -- Nullable
	EmployeeID = E.EmployeeID,
	D.DeductionID,
	Amount = ISNULL(ED.Amount, 0),
	Comment = ISNULL(ED.Comment, ''),
	D.Deduction,
	D.[Deduction Code],
	P.[First Name],
	P.[Last Name],
	V.[List As],
	E.[Employee Number],
	Employee = V.[List As],
	SECURE.*

	FROM Employee E
	INNER JOIN TempX ETemp ON ETemp.BatchID = @employee_batch_id AND ETemp.[ID] = E.EmployeeID
	INNER JOIN TempX DTemp ON DTemp.BatchID = @deduction_batch_id
	INNER JOIN Deduction D ON DTemp.[ID] = D.DeductionID
	INNER JOIN vwPersonCalculated V ON E.EmployeeID = V.PersonID
	INNER JOIN Person P ON E.EmployeeID = P.PersonID
	INNER JOIN vwEmployeeSecure SECURE ON SECURE.EID = E.EmployeeID
	LEFT JOIN vwPersonX PX ON PX.PersonID = E.EmployeeID AND (dbo.fnPermissionGetOnPersonForCurrentUser(E.EmployeeID, 4) & 1) = 1
	LEFT JOIN EmployeeDeduction ED ON ED.DeductionID = D.DeductionID AND ED.EmployeeID = E.EmployeeID
	ORDER BY V.[List As], ED.EmployeeID, D.Deduction, D.DeductionID  
END
ELSE
BEGIN
	SELECT
	ED.ItemID, -- Nullable
	EmployeeID = E.EmployeeID,
	D.DeductionID,
	Amount = ISNULL(ED.Amount, 0),
	Comment = ISNULL(ED.Comment, ''),
	D.Deduction,
	D.[Deduction Code],
	P.[First Name],
	P.[Last Name],
	V.[List As],
	E.[Employee Number],
	Employee = V.[List As]

	FROM Employee E
	INNER JOIN TempX ETemp ON ETemp.BatchID = @employee_batch_id AND ETemp.[ID] = E.EmployeeID
	INNER JOIN TempX DTemp ON DTemp.BatchID = @deduction_batch_id
	INNER JOIN Deduction D ON DTemp.[ID] = D.DeductionID
	INNER JOIN vwPersonCalculated V ON E.EmployeeID = V.PersonID
	INNER JOIN Person P ON E.EmployeeID = P.PersonID
	LEFT JOIN vwPersonX PX ON PX.PersonID = E.EmployeeID AND (dbo.fnPermissionGetOnPersonForCurrentUser(E.EmployeeID, 4) & 1) = 1
	LEFT JOIN EmployeeDeduction ED ON ED.DeductionID = D.DeductionID AND ED.EmployeeID = E.EmployeeID
	ORDER BY V.[List As], ED.EmployeeID, D.Deduction, D.DeductionID  
END                                                                                                                                                                                         

DELETE TempX WHERE BatchID IN (@employee_batch_id, @deduction_batch_id) OR DATEDIFF(hh, Created, GETDATE()) > 1
GO
CREATE PROC dbo.spEmployeeDeductionUpdate @employee_id int, @deduction_id int, @amount money, @comment varchar(50)
AS DECLARE @authorized bit
EXEC dbo.spPermissionInsureForCurrentUserOnPerson @employee_id, 536870912, 2, @authorized out
IF @authorized = 1
BEGIN
	DECLARE @item_id int
	SET @item_id = NULL
	SELECT @item_id=ItemID FROM EmployeeDeduction WHERE EmployeeID=@employee_id AND DeductionID=@deduction_id
	IF @amount=0 AND @comment=''
	BEGIN
		IF @item_id IS NOT NULL DELETE EmployeeDeduction WHERE ItemID=@item_id
	END
	ELSE
	BEGIN
		IF @item_id IS NULL INSERT EmployeeDeduction(EmployeeID, DeductionID, Amount, Comment) VALUES(@employee_id, @deduction_id, @amount, @comment)
		ELSE UPDATE EmployeeDeduction SET Amount = @amount, Comment = @comment WHERE EmployeeID = @employee_id AND DeductionID = @deduction_id
	END
END
GO
ALTER PROC dbo.spEmployeeLeavePlanClearAndSetAll_1
	@plan_id int,
	@start_day int,
	@record_unused bit,
	@batch_id int
AS
SET NOCOUNT ON

CREATE TABLE #E(EmployeeID int)

DECLARE @fte numeric(9,4)
SELECT @fte = FTE FROM LeavePlan WHERE PlanID = @plan_id


INSERT #E
SELECT E.EmployeeID FROM Employee E WHERE [Terminated Day past 1900] IS NULL AND
@fte = ISNULL((
	SELECT TOP 1 FTE FROM vwEmployeeCompensation C WHERE E.EmployeeID = C.EmployeeID ORDER BY [Start Day past 1900] DESC
), 1.0000)

CREATE TABLE #ET(EmployeeID int, TypeID int, [Day past 1900] int, Seconds int)
IF @record_unused = 1
BEGIN
	INSERT #ET
	SELECT #E.EmployeeID, T.TypeID, [Day past 1900]= @start_day - 1, Seconds = ISNULL((
		SELECT TOP 1 U.Unused FROM EmployeeLeaveUnused U WHERE U.EmployeeID = #E.EmployeeID AND U.TypeID = T.TypeID AND U.[Day past 1900] < @start_day ORDER BY [Day past 1900] DESC
	), 0)
	FROM Employee #E
	CROSS JOIN LeaveType T

	-- Balances    SELECT * FROM #ET 
	INSERT TempXYZ(BatchID, [ID], X, Y, Z)
	SELECT @batch_id, EmployeeID, TypeID, [Day past 1900], Seconds FROM #ET
END

DELETE EmployeeLeavePlan WHERE EmployeeID IN
(
	SELECT EmployeeID FROM #E
)


INSERT EmployeeLeavePlan(EmployeeID, PlanID, [Start Day past 1900])
SELECT #E.EmployeeID, @plan_id, @start_day FROM #E

SELECT #E.EmployeeID, Employee = P.[List As] FROM #E
INNER JOIN dbo.vwPersonListAs P ON #E.EmployeeID = P.PersonID
GO
EXEC dbo.spAdminCreateSPifNonexistent 'spEmployeeCompensationSelectDefaults2'
GO
ALTER PROC dbo.spEmployeeCompensationSelectDefaults2
	@employee_id int
AS
DECLARE @period_id int
DECLARE @start smalldatetime
DECLARE @stop_day int
DECLARE @employment_status_id int
DECLARE @last_compensation_id int
DECLARE @authorized bit

SET NOCOUNT ON

-- Default period and reason
SET @last_compensation_id = NULL

EXEC dbo.spPermissionGetOnPersonForCurrentUser2 @employee_id, 1024, 1, @authorized out

IF @authorized = 1 SELECT TOP 1 @last_compensation_id = CompensationID FROM EmployeeCompensation WHERE EmployeeID = @employee_id ORDER BY [Start Day past 1900] DESC
IF @last_compensation_id IS NULL
BEGIN
	DECLARE @batch_id int
	SELECT @batch_id=RAND() * 2147483647

	INSERT TempX(BatchID, [ID]) SELECT @batch_id, EmployeeID FROM Employee
	EXEC dbo.spPermissionGetOnPeopleForCurrentUser2 @batch_id, 1024
	DELETE TempX WHERE BatchID=@batch_id AND (X & 1) = 0

	SELECT TOP 1 @last_compensation_id = EC.CompensationID
	FROM EmployeeCompensation EC
	INNER JOIN TempX X ON X.BatchID=@batch_id AND X.[ID]=EC.EmployeeID 
	ORDER BY EC.[Start Day past 1900] DESC

	DELETE TempX WHERE BatchID=@batch_id OR DATEDIFF(hour,0,Created) > 1
END

IF @last_compensation_id IS NULL
BEGIN
	SELECT
	PeriodID = 1,
	EmploymentStatusID = ISNULL((SELECT TOP 1 StatusID FROM EmploymentStatus),0),
	Start = GETDATE(),
	Stop = CAST(NULL AS datetime),
	Note = '',
	PositionID = ISNULL((SELECT TOP 1 PositionID FROM Position),0),
	[Base Pay] = CAST(0 AS money),
	[Other Compensation]= '',
	Budgeted = CAST(0 AS bit),
	PayStepID = ISNULL((SELECT TOP 1 PayStepID FROM PayStep),0),
	StartEventID = ISNULL((SELECT TOP 1 EventID FROM EmployeeCompensationEventStart WHERE (Flags & 1)=1 ORDER BY [Order]),0),
	StopEventID = NULL,
	[Employee Seconds per Week] = NULL
END
ELSE
BEGIN
	SELECT
	PeriodID,
	EmploymentStatusID,
	Start = CASE
		WHEN [Stop Day past 1900] IS NULL OR [Stop Day past 1900] = 0x7FFFFFFF THEN GETDATE()
		ELSE DATEADD(d,1,Stop)
	END,
	Stop = CAST(NULL as datetime),
	Note = '',
	PositionID,
	[Base Pay],
	[Other Compensation],
	Budgeted,
	PayStepID,
	StartEventID,
	StopEventID,
	[Employee Seconds per Week]
	FROM dbo.vwEmployeeCompensation WHERE CompensationID = @last_compensation_id
END
GO
IF OBJECT_id('dbo.spEmployeeDeductionList') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spEmployeeDeductionList AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spEmployeeDeductionList TO public'
END
GO
ALTER PROC dbo.spEmployeeDeductionList
	@employee_id int
AS
DECLARE @employee_batch_id int, @authorized bit, @deduction_batch_id int
EXEC dbo.spAdminGetNextRandom @employee_batch_id out
INSERT TempX(BatchID,[ID]) SELECT @employee_batch_id,@employee_id
EXEC dbo.spAdminGetNextRandom @deduction_batch_id out
INSERT TempX(BatchID,[ID]) SELECT @deduction_batch_id,DeductionID FROM Deduction

EXEC dbo.spEmployeeDeductionList2 @employee_batch_id, @deduction_batch_id, @authorized OUT
GO
GRANT EXEC ON dbo.spEmployeeDeductionUpdate TO public
GO
IF OBJECT_id('dbo.spEmployeeGetHourlyPayRate') IS NOT NULL DROP PROC dbo.spEmployeeGetHourlyPayRate
GO
CREATE PROC dbo.spEmployeeGetHourlyPayRate
	@employee_id int,
	@rate smallmoney OUT
AS
DECLARE @authorized bit
SELECT @rate = 0
EXEC dbo.spPermissionInsureForCurrentUserOnPerson @employee_id, 1024, 1 , @authorized out
IF @authorized = 1 SELECT @rate = [Hourly Pay] FROM vwEmployeeCompensation
WHERE EmployeeID = @employee_id AND Stop IS NULL OR GETDATE() BETWEEN Start AND Stop
GO
GRANT EXEC ON dbo.spEmployeeGetHourlyPayRate TO public
GO
IF OBJECT_ID('dbo.spPersonXEducationContinuingReportColumns') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spPersonXEducationContinuingReportColumns AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spPersonXEducationContinuingReportColumns TO public'
END
GO
ALTER PROC dbo.spPersonXEducationContinuingReportColumns
AS
SET NOCOUNT ON

CREATE TABLE #REPORT_COLUMNS(colid int PRIMARY KEY, [Name] sysname COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL, Caption sysname COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL, [Example] varchar(50) COLLATE SQL_Latin1_General_CP1_CI_AS NULL, [Group] varchar(50) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL, Flags int NOT NULL)

INSERT #REPORT_COLUMNS
SELECT  1000 + CColumns.colid, [Name] = CColumns.[name], Caption = dbo.GetCaptionForColumnName(CColumns.[name]),Example = dbo.GetExampleForColumnName(CColumns.[name], NULL),[Group] = dbo.GetGroupFromColumnName(CColumns.[name], 'Continuing Education'),Flags = 0
FROM syscolumns CColumns
WHERE [ID] = OBJECT_ID('vwEmployeeSecure') AND
[Name] NOT IN (SELECT [Name] FROM #REPORT_COLUMNS) AND dbo.IsColumnVisibleOnReport(CColumns.[name]) = 1

INSERT #REPORT_COLUMNS
SELECT 2000 + CColumns.colid, [Name] = CColumns.[name], Caption = dbo.GetCaptionForColumnName(CColumns.[name]),Example = dbo.GetExampleForColumnName(CColumns.[name], NULL),[Group] = 'Continuing Education', Flags = 0
FROM syscolumns CColumns
WHERE [ID] = OBJECT_ID('vwPersonXEducationContinuing') AND
[Name] NOT IN (SELECT [Name] FROM #REPORT_COLUMNS) AND dbo.IsColumnVisibleOnReport(CColumns.[name]) = 1


EXEC dbo.spReportFillColumnExamples '', ''

DECLARE @i int
SET @i=1
SELECT * FROM #REPORT_COLUMNS ORDER BY CASE WHEN [Group] = 'Name' THEN '__' ELSE '' END + [Group], Caption
GO
IF OBJECT_ID('dbo.spPersonXEducationContinuingReportColumns') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spPersonXEducationContinuingReportColumns AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spPersonXEducationContinuingReportColumns TO public'
END
GO
ALTER PROC dbo.spPersonXEducationContinuingReportColumns
AS
SET NOCOUNT ON

CREATE TABLE #REPORT_COLUMNS(colid int PRIMARY KEY, [Name] sysname COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL, Caption sysname COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL, [Example] varchar(50) COLLATE SQL_Latin1_General_CP1_CI_AS NULL, [Group] varchar(50) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL, Flags int NOT NULL)

INSERT #REPORT_COLUMNS
SELECT  1000 + CColumns.colid, [Name] = CColumns.[name], Caption = dbo.GetCaptionForColumnName(CColumns.[name]),Example = dbo.GetExampleForColumnName(CColumns.[name], NULL),[Group] = dbo.GetGroupFromColumnName(CColumns.[name], 'Leave'),Flags = 0
FROM syscolumns CColumns
WHERE [ID] = OBJECT_ID('vwEmployeeSecure') AND
[Name] NOT IN (SELECT [Name] FROM #REPORT_COLUMNS) AND dbo.IsColumnVisibleOnReport(CColumns.[name]) = 1

INSERT #REPORT_COLUMNS
SELECT 2000 + CColumns.colid, [Name] = CColumns.[name], Caption = dbo.GetCaptionForColumnName(CColumns.[name]),Example = dbo.GetExampleForColumnName(CColumns.[name], NULL),[Group] = dbo.GetGroupFromColumnName(CColumns.[name], 'Leave'),Flags = 0
FROM syscolumns CColumns
WHERE [ID] = OBJECT_ID('vwPersonXEducationContinuing') AND
[Name] NOT IN (SELECT [Name] FROM #REPORT_COLUMNS) AND dbo.IsColumnVisibleOnReport(CColumns.[name]) = 1


EXEC dbo.spReportFillColumnExamples '', ''

DECLARE @i int
SET @i=1
SELECT * FROM #REPORT_COLUMNS ORDER BY CASE WHEN [Group] = 'Name' THEN '__' ELSE '' END + [Group], Caption
GO
IF OBJECT_ID('dbo.spPersonXTrainingSummaryReportColumns') IS NOT NULL DROP PROC dbo.spPersonXTrainingSummaryReportColumns
GO
CREATE PROC dbo.spPersonXTrainingSummaryReportColumns
AS
SET NOCOUNT ON

CREATE TABLE #REPORT_COLUMNS(colid int PRIMARY KEY, [Name] sysname COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL, Caption sysname COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL, [Example] varchar(50) COLLATE SQL_Latin1_General_CP1_CI_AS NULL, [Group] varchar(50) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL, Flags int NOT NULL)

INSERT #REPORT_COLUMNS
SELECT  1000 + CColumns.colid, [Name] = CColumns.[name], Caption = dbo.GetCaptionForColumnName(CColumns.[name]),Example = dbo.GetExampleForColumnName(CColumns.[name], NULL),[Group] = dbo.GetGroupFromColumnName(CColumns.[name], 'Leave'),Flags = 0
FROM syscolumns CColumns
WHERE [ID] = OBJECT_ID('vwEmployeeSecure') AND
[Name] NOT IN (SELECT [Name] FROM #REPORT_COLUMNS) AND dbo.IsColumnVisibleOnReport(CColumns.[name]) = 1

INSERT #REPORT_COLUMNS SELECT -10, [Name] = 'Courses', Caption = 'Courses',Example = '',[Group] = 'Training', Flags = 0
INSERT #REPORT_COLUMNS SELECT -11, [Name] = 'Hours', Caption = 'Hours',Example = '4.00',[Group] = 'Training', Flags = 0
INSERT #REPORT_COLUMNS SELECT -12, [Name] = 'Person', Caption = 'Person',Example = 'Doe, John',[Group] = 'Training', Flags = 0

EXEC dbo.spReportFillColumnExamples '', ''

DECLARE @i int
SET @i=1
SELECT * FROM #REPORT_COLUMNS ORDER BY CASE WHEN [Group] = 'Name' THEN '__' ELSE '' END + [Group], Caption
GO
GRANT EXEC ON dbo.spPersonXTrainingSummaryReportColumns TO public
GO
IF OBJECT_ID('dbo.spPersonXContinuingEdSummaryReportColumns') IS NOT NULL DROP PROC dbo.spPersonXContinuingEdSummaryReportColumns
GO
CREATE PROC dbo.spPersonXContinuingEdSummaryReportColumns
AS
SET NOCOUNT ON

CREATE TABLE #REPORT_COLUMNS(colid int PRIMARY KEY, [Name] sysname COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL, Caption sysname COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL, [Example] varchar(50) COLLATE SQL_Latin1_General_CP1_CI_AS NULL, [Group] varchar(50) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL, Flags int NOT NULL)

INSERT #REPORT_COLUMNS
SELECT  1000 + CColumns.colid, [Name] = CColumns.[name], Caption = dbo.GetCaptionForColumnName(CColumns.[name]),Example = dbo.GetExampleForColumnName(CColumns.[name], NULL),[Group] = dbo.GetGroupFromColumnName(CColumns.[name], 'Leave'),Flags = 0
FROM syscolumns CColumns
WHERE [ID] = OBJECT_ID('vwEmployeeSecure') AND
[Name] NOT IN (SELECT [Name] FROM #REPORT_COLUMNS) AND dbo.IsColumnVisibleOnReport(CColumns.[name]) = 1

INSERT #REPORT_COLUMNS SELECT -10, [Name] = 'Courses', Caption = 'Courses',Example = '',[Group] = 'Training', Flags = 0
INSERT #REPORT_COLUMNS SELECT -11, [Name] = 'Credits', Caption = 'Credits',Example = '4.00',[Group] = 'Training', Flags = 0
INSERT #REPORT_COLUMNS SELECT -12, [Name] = 'Person', Caption = 'Person',Example = 'Doe, John',[Group] = 'Training', Flags = 0

EXEC dbo.spReportFillColumnExamples '', ''

DECLARE @i int
SET @i=1
SELECT * FROM #REPORT_COLUMNS ORDER BY CASE WHEN [Group] = 'Name' THEN '__' ELSE '' END + [Group], Caption
GO
GRANT EXEC ON dbo.spPersonXContinuingEdSummaryReportColumns TO public
GO




IF OBJECT_ID('dbo.spLeaveSummaryListReportColumns') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spLeaveSummaryListReportColumns AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spLeaveSummaryListReportColumns TO public'
END
GO
ALTER PROC dbo.spLeaveSummaryListReportColumns
AS
SET NOCOUNT ON

CREATE TABLE #REPORT_COLUMNS(colid int PRIMARY KEY, [Name] sysname COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL, Caption sysname COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL, [Example] varchar(50) COLLATE SQL_Latin1_General_CP1_CI_AS NULL, [Group] varchar(50) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL, Flags int NOT NULL)

DECLARE @y1 varchar(50), @y2 varchar(50)
SELECT @y1 = YEAR(GETDATE()) - 1, @y2 = YEAR(GETDATE())
 
INSERT #REPORT_COLUMNS VALUES(-20, 'Employee', 'Employee', 'John Doe', 'Name', 0)

INSERT #REPORT_COLUMNS VALUES(-19, 'Accumulated Last Year Hrs', 'Accumulated Hrs ' + @y1, '100.00', 'Leave', 0)
INSERT #REPORT_COLUMNS VALUES(-18, 'Accumulated This Year Hrs', 'Accumulated Hrs ' + @y2, '100.00', 'Leave', 0)
INSERT #REPORT_COLUMNS VALUES(-17, 'Annualized Hrs', 'Annualized Accrual Hrs', '80.00', 'Leave', 0)
INSERT #REPORT_COLUMNS VALUES(-16, 'Available Hrs', 'Available Hrs', '100.00', 'Leave', 0)
INSERT #REPORT_COLUMNS VALUES(-15, 'Accumulated Hrs', 'Accumulated Hrs', '100.00', 'Leave', 0)
INSERT #REPORT_COLUMNS VALUES(-13, 'Scheduled Hrs', 'Scheduled Hrs', '100.00', 'Leave', 0)
INSERT #REPORT_COLUMNS VALUES(-12, 'Used Last Year Hrs', 'Used Hrs ' + @y1, '100.00', 'Leave', 0)
INSERT #REPORT_COLUMNS VALUES(-11, 'Used Rolling Year Hrs', 'Used Hrs Rolling Year', '100.00', 'Leave', 0)
INSERT #REPORT_COLUMNS VALUES(-10, 'Used This Year Hrs', 'Used Hrs ' + @y2, '100.00', 'Leave', 0)
INSERT #REPORT_COLUMNS VALUES(-9, 'Maximum Hrs', 'Maximum Hrs', '100.00', 'Leave', 0)
INSERT #REPORT_COLUMNS VALUES(-27, 'Used Hrs', 'Used Hrs', '100.00', 'Leave', 0)

INSERT #REPORT_COLUMNS VALUES(-39, 'Accumulated Last Year Days', 'Accumulated Days ' + @y1, '100.00', 'Leave', 0)
INSERT #REPORT_COLUMNS VALUES(-38, 'Accumulated This Year Days', 'Accumulated Days ' + @y2, '100.00', 'Leave', 0)
INSERT #REPORT_COLUMNS VALUES(-37, 'Annualized Days', 'Annualized Accrual Days', '80.00', 'Leave', 0)
INSERT #REPORT_COLUMNS VALUES(-36, 'Available Days', 'Available Days', '100.00', 'Leave', 0)
INSERT #REPORT_COLUMNS VALUES(-35, 'Accumulated Days', 'Accumulated Days', '100.00', 'Leave', 0)
INSERT #REPORT_COLUMNS VALUES(-33, 'Scheduled Days', 'Scheduled Days', '100.00', 'Leave', 0)
INSERT #REPORT_COLUMNS VALUES(-32, 'Used Last Year Days', 'Used Days ' + @y1, '100.00', 'Leave', 0)
INSERT #REPORT_COLUMNS VALUES(-31, 'Used Rolling Year Days', 'Used Days Rolling Year', '100.00', 'Leave', 0)
INSERT #REPORT_COLUMNS VALUES(-30, 'Used This Year Days', 'Used Days ' + @y2, '100.00', 'Leave', 0)
INSERT #REPORT_COLUMNS VALUES(-29, 'Maximum Days', 'Maximum Days', '100.00', 'Leave', 0)
INSERT #REPORT_COLUMNS VALUES(-28, 'Used Days', 'Used Days', '100.00', 'Leave', 0)

INSERT #REPORT_COLUMNS VALUES(-14, 'Recent', 'Recent', 'May 5, Feb 4, Jan 3', 'Leave', 0)
INSERT #REPORT_COLUMNS VALUES(-8, 'Last Date Used', 'Last Date Used', 'Feb 2,2000', 'Leave', 0)

INSERT #REPORT_COLUMNS
SELECT  1000 + CColumns.colid, [Name] = CColumns.[name], Caption = dbo.GetCaptionForColumnName(CColumns.[name]),Example = dbo.GetExampleForColumnName(CColumns.[name], NULL),[Group] = dbo.GetGroupFromColumnName(CColumns.[name], 'Leave'),Flags = 0
FROM syscolumns CColumns
WHERE [ID] = OBJECT_ID('vwEmployeeSecure') AND
[Name] NOT IN (SELECT [Name] FROM #REPORT_COLUMNS) AND dbo.IsColumnVisibleOnReport(CColumns.[name]) = 1

INSERT #REPORT_COLUMNS
SELECT 2000 + CColumns.colid, [Name] = CColumns.[name], Caption = dbo.GetCaptionForColumnName(CColumns.[name]),Example = dbo.GetExampleForColumnName(CColumns.[name], NULL),[Group] = dbo.GetGroupFromColumnName(CColumns.[name], 'Leave'),Flags = 0
FROM syscolumns CColumns
WHERE [ID] = OBJECT_ID('vwEmployeeCompensation') AND
[Name] NOT IN (SELECT [Name] FROM #REPORT_COLUMNS) AND dbo.IsColumnVisibleOnReport(CColumns.[name]) = 1


EXEC dbo.spReportFillColumnExamples '', ''

SELECT * FROM #REPORT_COLUMNS ORDER BY CASE WHEN [Group] IN ('Leave') THEN '_' WHEN [Group] = 'Name' THEN '__' ELSE '' END + [Group], Caption
GO
IF OBJECT_ID('dbo.spInvoiceListReportColumns') IS NOT NULL DROP PROC dbo.spInvoiceListReportColumns
GO
CREATE PROC dbo.spInvoiceListReportColumns
AS
SET NOCOUNT ON

CREATE TABLE #REPORT_COLUMNS(colid int PRIMARY KEY, [Name] sysname COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL, Caption sysname COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL, [Example] varchar(50) COLLATE SQL_Latin1_General_CP1_CI_AS NULL, [Group] varchar(50) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL, Flags int NOT NULL)

INSERT #REPORT_COLUMNS
SELECT 
CColumns.colid,
[Name] = CColumns.[name], 
Caption = dbo.GetCaptionForColumnName(CColumns.[name]),
Example = dbo.GetExampleForColumnName(CColumns.[name], NULL),
[Group] = dbo.GetGroupFromColumnName(CColumns.[name], 'Invoice'),
Flags = 0
FROM syscolumns CColumns
WHERE [ID]=OBJECT_ID('vwInvoiceFlat') AND dbo.IsColumnVisibleOnReport(CColumns.[name]) = 1

EXEC dbo.spReportFillColumnExamples 'vwInvoiceFlat', 'InvoiceID'

DECLARE @i int
SET @i=1
SELECT * FROM #REPORT_COLUMNS ORDER BY CASE WHEN [Group] IN ('Invoice') THEN '_' WHEN [Group] = 'Name' THEN '__' ELSE '' END + [Group], Caption
GO
GRANT EXEC ON dbo.spInvoiceListReportColumns TO public
GO
IF OBJECT_ID('dbo.spPaymentListReportColumns') IS NOT NULL DROP PROC dbo.spPaymentListReportColumns
GO
CREATE PROC dbo.spPaymentListReportColumns
AS
SET NOCOUNT ON

CREATE TABLE #REPORT_COLUMNS(colid int PRIMARY KEY, [Name] sysname COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL, Caption sysname COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL, [Example] varchar(50) COLLATE SQL_Latin1_General_CP1_CI_AS NULL, [Group] varchar(50) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL, Flags int NOT NULL)

INSERT #REPORT_COLUMNS
SELECT 
CColumns.colid,
[Name] = CColumns.[name], 
Caption = dbo.GetCaptionForColumnName(CColumns.[name]),
Example = dbo.GetExampleForColumnName(CColumns.[name], NULL),
[Group] = dbo.GetGroupFromColumnName(CColumns.[name], 'Payment'),
Flags = 0
FROM syscolumns CColumns
WHERE [ID]=OBJECT_ID('vwPaymentFlat') AND dbo.IsColumnVisibleOnReport(CColumns.[name]) = 1

EXEC dbo.spReportFillColumnExamples 'vwPaymentFlat', 'PaymentID'

DECLARE @i int
SET @i=1
SELECT * FROM #REPORT_COLUMNS ORDER BY CASE WHEN [Group] IN ('Payment') THEN '_' WHEN [Group] = 'Name' THEN '__' ELSE '' END + [Group], Caption
GO
GRANT EXEC ON dbo.spPaymentListReportColumns TO public
GO
IF OBJECT_ID('dbo.spEmployeeCompensationListReportColumns') IS NOT NULL DROP PROC dbo.spEmployeeCompensationListReportColumns
GO
CREATE PROC dbo.spEmployeeCompensationListReportColumns
AS
SET NOCOUNT ON

CREATE TABLE #REPORT_COLUMNS(colid int PRIMARY KEY, [Name] sysname COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL, Caption sysname COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL, [Example] varchar(50) COLLATE SQL_Latin1_General_CP1_CI_AS NULL, [Group] varchar(50) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL, Flags int NOT NULL)

INSERT #REPORT_COLUMNS
SELECT 
CColumns.colid,
[Name] = CColumns.[name], 
Caption = CASE CColumns.[name]
	WHEN 'Employee Full Name' THEN 'Full Name'
	WHEN 'Start' THEN 'Start Date'
	WHEN 'Stop' THEN 'Stop Date'
	WHEN 'Status' THEN 'Position Status'
	ELSE dbo.GetCaptionForColumnName(CColumns.[name])
END,
Example = dbo.GetExampleForColumnName(CColumns.[name], NULL),
[Group] = CASE
	WHEN CColumns.[name] IN ('Note') THEN 'Employment'
	ELSE dbo.GetGroupFromColumnName(CColumns.[name], 'Compensation')
END,
Flags = 0
FROM syscolumns CColumns
WHERE [ID]=OBJECT_ID('vwEmployeeCompensationFlat') AND dbo.IsColumnVisibleOnReport(CColumns.[name]) = 1

EXEC dbo.spReportFillColumnExamples 'vwEmployeeCompensationFlat', 'CompensationID'

DECLARE @i int
SET @i=1
SELECT * FROM #REPORT_COLUMNS ORDER BY CASE WHEN [Group] IN ('Compensation', 'Position') THEN '_' WHEN [Group] = 'Name' THEN '__' ELSE '' END + [Group], Caption
GO
GRANT EXEC ON dbo.spEmployeeCompensationListReportColumns TO public
GO
IF OBJECT_ID('dbo.spTabularListReportColumns') IS NOT NULL DROP PROC dbo.spTabularListReportColumns
GO
CREATE PROC dbo.spTabularListReportColumns
AS
SET NOCOUNT ON

CREATE TABLE #REPORT_COLUMNS(colid int PRIMARY KEY, [Name] sysname COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL, Caption sysname COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL, [Example] varchar(50) COLLATE SQL_Latin1_General_CP1_CI_AS NULL, [Group] varchar(50) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL, Flags int NOT NULL)

INSERT #REPORT_COLUMNS
SELECT 
CColumns.colid,
[Name] = CColumns.[name], 
Caption = dbo.GetCaptionForColumnName(CColumns.[name]),
Example = dbo.GetExampleForColumnName(CColumns.[name], NULL),
[Group] = dbo.GetGroupFromColumnName(CColumns.[name], 'Other'),
Flags = 0
FROM syscolumns CColumns
WHERE [ID]=OBJECT_ID('vwEmployeeSecure') AND dbo.IsColumnVisibleOnReport(CColumns.[name]) = 1

EXEC dbo.spReportFillColumnExamples 'vwEmployeeSecure', 'EmployeeID'

DECLARE @i int
SET @i=1
SELECT * FROM #REPORT_COLUMNS ORDER BY CASE WHEN [Group] = 'Name' THEN '_' ELSE '' END + [Group], Caption
GO
GRANT EXEC ON dbo.spTabularListReportColumns TO public
GO
IF OBJECT_ID('dbo.spAdvancePayListReportColumns') IS NOT NULL DROP PROC dbo.spAdvancePayListReportColumns
GO
CREATE PROC dbo.spAdvancePayListReportColumns
AS
SET NOCOUNT ON

CREATE TABLE #REPORT_COLUMNS(colid int PRIMARY KEY, [Name] sysname COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL, Caption sysname COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL, [Example] varchar(50) COLLATE SQL_Latin1_General_CP1_CI_AS NULL, [Group] varchar(50) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL, Flags int NOT NULL)

INSERT #REPORT_COLUMNS
SELECT 
CColumns.colid,
[Name] = CColumns.[name], 
Caption = dbo.GetCaptionForColumnName(CColumns.[name]),
Example = dbo.GetExampleForColumnName(CColumns.[name], NULL),
[Group] = dbo.GetGroupFromColumnName(CColumns.[name], 'Other'),
Flags = 0
FROM syscolumns CColumns
WHERE [ID]=OBJECT_ID('vwEmployeeSecure') AND dbo.IsColumnVisibleOnReport(CColumns.[name]) = 1

EXEC dbo.spReportFillColumnExamples 'vwEmployeeSecure', 'EmployeeID'

INSERT #REPORT_COLUMNS(colid,[Name],Caption,Example,[Group],Flags) VALUES(-1, 'Last InvoiceID', 'Last InvoiceID', '1005', 'Invoice', 0)
INSERT #REPORT_COLUMNS(colid,[Name],Caption,Example,[Group],Flags) VALUES(-2, 'Last Invoice Due', 'Last Invoice Due', 'Apr 4,2007', 'Invoice', 0)
INSERT #REPORT_COLUMNS(colid,[Name],Caption,Example,[Group],Flags) VALUES(-3, 'Last Invoice Created', 'Last Invoice Created', 'Feb 4,2007', 'Invoice', 0)
INSERT #REPORT_COLUMNS(colid,[Name],Caption,Example,[Group],Flags) VALUES(-4, 'Last Invoice Total', 'Last Invoice Total', '95.00', 'Invoice', 0)

DECLARE @i int
SET @i=1
SELECT * FROM #REPORT_COLUMNS ORDER BY CASE WHEN [Group] = 'Name' THEN '_' ELSE '' END + [Group], Caption
GO
GRANT EXEC ON dbo.spAdvancePayListReportColumns TO public
GO
IF OBJECT_ID('dbo.spTimeTypeSelect') IS NOT NULL DROP PROC dbo.spTimeTypeSelect
IF OBJECT_ID('dbo.spTimeTypeDelete') IS NOT NULL DROP PROC dbo.spTimeTypeDelete
IF OBJECT_ID('dbo.spTimeTypeMoveDown') IS NOT NULL DROP PROC dbo.spTimeTypeMoveDown
IF OBJECT_ID('dbo.spTimeTypeMoveUp') IS NOT NULL DROP PROC dbo.spTimeTypeMoveUp
GO
IF OBJECT_ID('dbo.spTimeTypeInsert') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spTimeTypeInsert AS'
GO
ALTER PROC dbo.spTimeTypeInsert
	@type varchar(50),
	@abbreviation varchar(4),
	@comp_leave_type_id int,
	@fixed_pay smallmoney,
	@pay_rate smallmoney,
	@pay_rate_m smallmoney,
	@pay_rate_b smallmoney,
	@fixed_billing smallmoney,
	@billing_rate smallmoney,
	@billing_rate_m smallmoney,
	@billing_rate_b smallmoney,
	@type_id int OUT,
	@regular bit = NULL,
	@flags int = NULL,
	@ot_eligible bit = NULL,
	@comp_rate smallmoney = 1
AS
IF @flags IS NULL SET @flags = 0
IF @regular IS NOT NULL SET @flags = @flags | 1
IF @ot_eligible IS NOT NULL SET @flags = @flags | 4

DECLARE @batch_id int, @order int
SET @batch_id=RAND() * 2147483647
INSERT TempX(BatchID,[ID],X) SELECT @batch_id,TypeID,[Order] FROM TimeType
EXEC dbo.spBitFindNextOpenID @batch_id, 50055, @type_id OUT, @order OUT
DELETE TempX WHERE BatchID=@batch_id OR DATEDIFF(hour,Created,GETDATE())>1

IF @type_id IS NOT NULL 
INSERT TimeType(
	[Type],
	Abbreviation,
	CompLeaveTypeID,
	[Fixed Pay],
	[Pay Rate],
	PayRateM,
	PayRateB,
	[Fixed Billing],
	[Billing Rate],
	BillingRateM,
	BillingRateB,
	Flags,
	[Order],
	TypeID,
	[Comp Rate]
)
VALUES
(
	@type,
	@abbreviation,
	@comp_leave_type_id,
	@fixed_pay,
	@pay_rate,
	@pay_rate_m,
	@pay_rate_b,
	@fixed_billing,
	@billing_rate,
	@billing_rate_m,
	@billing_rate_b,
	@flags,
	@order,
	@type_id,
	@comp_rate
)
GO
IF OBJECT_ID('dbo.spTimeTypeUpdate') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spTimeTypeUpdate AS'
GO
ALTER PROC dbo.spTimeTypeUpdate
	@type varchar(50),
	@abbreviation varchar(4),
	@comp_leave_type_id int,
	@fixed_pay smallmoney,
	@pay_rate smallmoney,
	@pay_rate_m smallmoney,
	@pay_rate_b smallmoney,
	@fixed_billing smallmoney,
	@billing_rate smallmoney,
	@billing_rate_m smallmoney,
	@billing_rate_b smallmoney,
	@type_id int,
	@ot_eligible bit = NULL,
	@regular bit = NULL,
	@flags int = NULL,
	@comp_rate smallmoney = NULL
AS
IF @flags IS NULL SET @flags = 0
IF @regular IS NOT NULL SET @flags = @flags | 1
IF @ot_eligible IS NOT NULL SET @flags = @flags | 4

UPDATE TimeType SET [Type]=@type, Abbreviation=@abbreviation, CompLeaveTypeID=@comp_leave_type_id,
[Fixed Pay]=@fixed_pay, [Pay Rate]=@pay_rate, PayRateM=@pay_rate_m, PayRateB=@pay_rate_b,
[Fixed Billing]=@fixed_billing, [Billing Rate]=@billing_rate, BillingRateM=@billing_rate_m, BillingRateB=@billing_rate_b,
Flags = @flags, [Comp Rate] = CASE WHEN @comp_rate IS NULL THEN [Comp Rate] ELSE @comp_rate END
WHERE TypeID=@type_id
GO
CREATE PROC dbo.spTimeTypeDelete @type_id int AS DELETE TimeType WHERE TypeID=@type_id
GO
CREATE PROC dbo.spTimeTypeMoveDown
	@type_id int
AS
DECLARE @next_type_id int, @order int, @next_order int, @batch_id int, @first_type_id int, @first_type2_id int
SELECT TOP 1 @first_type_id = TypeID FROM dbo.TimeType ORDER BY [Order]
SET @batch_id=RAND() * 2147483647
INSERT TempX(BatchID,[ID],X) SELECT @batch_id,TypeID,[Order] FROM TimeType
EXEC dbo.spBitMoveDown @batch_id, @type_id
UPDATE T SET [Order]=X.X FROM TimeType T
INNER JOIN TempX X ON X.BatchID=@batch_id AND X.[ID]=T.TypeID AND X.X<>T.[Order]
DELETE TempX WHERE BatchID=@batch_id OR DATEDIFF(hour,Created,GETDATE())>1
SELECT TOP 1 @first_type2_id = TypeID FROM dbo.TimeType ORDER BY [Order]
IF @first_type_id <> @first_type2_id UPDATE dbo.Employee SET DefaultTimeTypeID = @first_type2_id WHERE DefaultTimeTypeID <> @first_type2_id
GO
CREATE PROC dbo.spTimeTypeMoveUp
	@type_id int
AS
DECLARE @next_type_id int, @order int, @next_order int, @batch_id int, @first_type_id int, @first_type2_id int
SELECT TOP 1 @first_type_id = TypeID FROM dbo.TimeType ORDER BY [Order]
SET @batch_id=RAND() * 2147483647
INSERT TempX(BatchID,[ID],X) SELECT @batch_id,TypeID,[Order] FROM TimeType
EXEC dbo.spBitMoveUp @batch_id, @type_id
UPDATE T SET [Order]=X.X FROM TimeType T
INNER JOIN TempX X ON X.BatchID=@batch_id AND X.[ID]=T.TypeID AND X.X<>T.[Order]
DELETE TempX WHERE BatchID=@batch_id OR DATEDIFF(hour,Created,GETDATE())>1
SELECT TOP 1 @first_type2_id = TypeID FROM dbo.TimeType ORDER BY [Order]
IF @first_type_id <> @first_type2_id UPDATE dbo.Employee SET DefaultTimeTypeID = @first_type2_id WHERE DefaultTimeTypeID <> @first_type2_id
GO
CREATE PROC dbo.spTimeTypeSelect @type_id int AS SELECT * FROM dbo.vwTimeType WHERE TypeID=@type_id
GO
GRANT EXEC ON dbo.spTimeTypeSelect TO public
GO

EXEC dbo.spAdminCreateSPifNonexistent 'spEmployeeTimeBulkInsertPrepare2', 1
GO
ALTER PROC dbo.spEmployeeTimeBulkInsertPrepare2
	@batch_id int,
	@day int,
	@dedup bit,
	@type_id int = NULL, -- nullable
	@seconds int = NULL, -- nullable
	@project_id int = NULL, -- v103
	@ppe int = NULL -- v109
AS
DECLARE @date datetime

SET NOCOUNT ON

CREATE TABLE #E(
	[In] smalldatetime,
	Seconds int,
	EmployeeID int,
	[TypeID] int,
	[Pay Rate] smallmoney DEFAULT(0),
	[Shift Start] int,
	[Seconds per Day] int,
	[Employee Number] varchar(50) COLLATE SQL_Latin1_General_CP1_CI_AS
)

SELECT @date = dbo.GetDateFromDaysPast1900(@day)

INSERT #E([Pay Rate], EmployeeID, 
[Shift Start],
[Seconds per Day],
E.[Employee Number], TypeID)
SELECT ISNULL(C.[Hourly Pay], 0), E.EmployeeID, 
[Shift Start] = ISNULL(SS.[Start Seconds],0),
[Seconds per Day] = CASE 
	WHEN @seconds IS NOT NULL THEN @seconds 
	WHEN SS.[Length Seconds] IS NOT NULL 
	THEN SS.[Length Seconds] ELSE [Seconds per Day]
END,
E.[Employee Number], TimeTypeID = CASE WHEN @type_id IS NULL THEN E.DefaultTimeTypeID ELSE @type_id END
FROM Employee E 
INNER JOIN TempX X ON X.BatchID = @batch_id AND E.EmployeeID = X.[ID] AND (@dedup=0 OR (
	@dedup=1 AND NOT EXISTS
	(SELECT * FROM vwEmployeeLeaveUsedItem I WHERE I.EmployeeID=E.EmployeeID AND I.[Day past 1900] = @day AND I.[Status] <> 4 AND I.Seconds > 0) AND NOT EXISTS
	(SELECT * FROM vwEmployeeTime T WHERE T.EmployeeID=E.EmployeeID AND T.[In Day past 1900] = @day)
))
INNER JOIN dbo.vwEmployeeEffectiveSecondsPerDay SPD ON E.EmployeeID = SPD.EmployeeID
INNER JOIN dbo.vwPersonListAs P ON E.EmployeeID = P.PersonID
INNER JOIN dbo.Shift S ON E.ShiftID=S.ShiftID --AND (S.Flags & 4) = 4
LEFT JOIN dbo.ShiftSchedule SS ON SS.ShiftID=S.ShiftID AND 
SS.[Day of Shift] = (@day-S.[Start Day past 1900])%(S.[Days On] + S.[Days Off] + S.DaysOn2 + S.DaysOff2) 
LEFT JOIN dbo.vwEmployeeCompensationLast C ON E.EmployeeID=C.EmployeeID
ORDER BY P.[List As]

/*UPDATE #E SET HH = ISNULL((
 SELECT AVG(DATEPART(hh, DATEADD(n, 15, T.[In]))) FROM EmployeeTime T WHERE T.EmployeeID = #E.EmployeeID AND DATEPART(hh, T.[In]) BETWEEN 0 AND 10
), 9) */

UPDATE #E SET [Shift Start] = 0 WHERE [Shift Start] + [Seconds per Day] > 86400


UPDATE #E SET [In] = DATEADD(second, #E.[Shift Start], @date), Seconds = #E.[Seconds per Day] FROM #E

DELETE TempX WHERE BatchID = @batch_id OR DATEDIFF(hh, Created, GETDATE()) > 1


SELECT *, TimeTypeID=TypeID, StatusID=1,
[Employee Comment]='',
[Manager Comment]='',
[Billing Rate]=CAST(0 AS smallmoney),
[Fixed Pay]=CAST(0 AS smallmoney),
[Fixed Billing]=CAST(0 AS smallmoney),
TaskID=NULL,
ProjectID=@project_id,
[Odometer Start]=0,
[Odometer Stop]=0,
SourceIn = 'Bulk Insert',
SourceOut = 'Bulk Insert',
PPE = CASE
	WHEN @ppe IS NOT NULL THEN @ppe
	ELSE dbo.GetDateFromDaysPast1900(DATEDIFF(d,0,[In]))
END,
[GMT+Hours] = NULL
FROM #E
GO
IF OBJECT_id('dbo.spReportTemplate3Insert') IS NOT NULL DROP PROC dbo.spReportTemplate3Insert
IF OBJECT_id('dbo.spReportTemplate3Update') IS NOT NULL DROP PROC dbo.spReportTemplate3Update
IF OBJECT_id('dbo.spReportTemplate3UpdateNameAndParentMenuID') IS NOT NULL DROP PROC dbo.spReportTemplate3UpdateNameAndParentMenuID
IF OBJECT_id('dbo.spReportTemplate3Delete') IS NOT NULL DROP PROC dbo.spReportTemplate3Delete
IF OBJECT_id('dbo.spReportTemplate3List') IS NOT NULL DROP PROC dbo.spReportTemplate3List
IF OBJECT_id('dbo.spReportTemplate3List2') IS NOT NULL DROP PROC dbo.spReportTemplate3List2
IF OBJECT_id('dbo.spReportTemplate3Select') IS NOT NULL DROP PROC dbo.spReportTemplate3Select
IF OBJECT_id('dbo.spReportTemplate3SelectDefault') IS NOT NULL DROP PROC dbo.spReportTemplate3SelectDefault
GO
CREATE PROC dbo.spReportTemplate3List @basis_id int AS SET NOCOUNT ON SELECT * FROM vwReportTemplate3noImage WHERE BasisID=@basis_id ORDER BY Flags, Template
GO
CREATE PROC dbo.spReportTemplate3List2 AS SET NOCOUNT ON SELECT * FROM vwReportTemplate3noImage ORDER BY Flags, Template
GO
CREATE PROC dbo.spReportTemplate3Update @template_id int, @template varchar(50), @fields_stream image, @basis_id int, @flags int, @tag int, @parent_menu_id int
AS UPDATE dbo.ReportTemplate3 SET Template=@template,[Fields Stream]=@fields_stream,BasisID=@basis_id,Flags=@flags,Tag=@tag,ParentMenuID=@parent_menu_id WHERE TemplateID=@template_id
GO
CREATE PROC dbo.spReportTemplate3UpdateNameAndParentMenuID @template_id int, @template varchar(50), @parent_menu_id int
AS UPDATE dbo.ReportTemplate3 SET Template=@template,ParentMenuID=@parent_menu_id WHERE TemplateID=@template_id
GO
CREATE PROC dbo.spReportTemplate3Insert @template_id int OUT, @template varchar(50), @fields_stream image, @basis_id int, @flags int, @tag int, @parent_menu_id int
AS INSERT dbo.ReportTemplate3(Template,[Fields Stream],BasisID,Flags,Tag,ParentMenuID) VALUES(@template,@fields_stream,@basis_id,@flags,@tag, @parent_menu_id) SELECT @template_id=SCOPE_IDENTITY()
GO
CREATE PROC dbo.spReportTemplate3Select @template_id int AS SET NOCOUNT ON SELECT * FROM vwReportTemplate3All WHERE TemplateID=@template_id
GO
CREATE PROC dbo.spReportTemplate3SelectDefault @basis_id int AS SET NOCOUNT ON SELECT TOP 1 * FROM vwReportTemplate3All WHERE BasisID=@basis_id AND (Flags & 1) = 1
GO
CREATE PROC dbo.spReportTemplate3Delete @template_id int AS DELETE ReportTemplate3 WHERE TemplateID=@template_id
GO
GRANT EXEC ON dbo.spReportTemplate3List TO public
GRANT EXEC ON dbo.spReportTemplate3List2 TO public
GRANT EXEC ON dbo.spReportTemplate3Select TO public
GRANT EXEC ON dbo.spReportTemplate3SelectDefault TO public
GO
IF OBJECT_id('dbo.spEmployeeLeaveListWithStatus') IS NOT NULL DROP PROC dbo.spEmployeeLeaveListWithStatus
GO
CREATE PROC dbo.spEmployeeLeaveListWithStatus
	@start_min int, @start_max int,
	@stop_min int, @stop_max int,
	@unreconciled bit,
	@order_by int
AS
SET NOCOUNT ON

SELECT U.LOALeaveID, U.LOAEmployeeID
INTO #U
FROM vwEmployeeLeaveUsed U WHERE
([LOA Start Day past 1900] BETWEEN @start_min AND @start_max) AND
([LOA Stop Day past 1900] BETWEEN @stop_min AND @stop_max) AND
(@unreconciled=0 OR @unreconciled=1 AND [LOA Reconciled Day past 1900] IS NULL AND [LOA Expected Return Day past 1900] IS NOT NULL)


DECLARE @batch_id int
SELECT @batch_id=RAND() * 2147483647

INSERT TempX([ID],BatchID) SELECT DISTINCT LOAEmployeeID,@batch_id FROM #U ORDER BY LOAEmployeeID
EXEC dbo.spPermissionGetOnPeopleForCurrentUser2 @batch_id,10002

SELECT U.* FROM #U
INNER JOIN TempX X ON X.BatchID=@batch_id AND #U.LOAEmployeeID=X.[ID]
INNER JOIN vwEmployeeLeaveUsed U ON #U.LOALeaveID=U.LOALeaveID
ORDER BY CASE @order_by 
	WHEN 0 THEN 0
	WHEN 1 THEN YEAR([LOA Start]) * 12 + MONTH([LOA Start])
	WHEN 2 THEN YEAR([LOA Stop]) * 12 + MONTH([LOA Stop])
END, U.[LOA Departing Employee]

DELETE dbo.TempX WHERE BatchID=@batch_id OR DATEDIFF(minute, Created, GETDATE()) > 30
GO
GRANT EXEC ON dbo.spEmployeeLeaveListWithStatus TO public
GO
IF OBJECT_id('dbo.spUsedLeaveCountIncidents') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spUsedLeaveCountIncidents AS'
	EXEC sp_executesql N'GRANT EXEC ON dbo.spUsedLeaveCountIncidents TO public'
END
GO
ALTER PROC dbo.spUsedLeaveCountIncidents
	@type_mask int,
	@year int,
	@batch_id int = NULL
AS
SET NOCOUNT ON

IF @batch_id IS NULL
BEGIN
	EXEC dbo.spAdminGetNextRandom @batch_id out
	INSERT dbo.TempX(BatchID,[ID]) SELECT @batch_id,EmployeeID FROM dbo.Employee
END

DECLARE @jan1 datetime, @jan31 datetime
DECLARE @feb1 datetime, @feb28 datetime
DECLARE @mar1 datetime, @mar31 datetime
DECLARE @apr1 datetime, @apr30 datetime
DECLARE @may1 datetime, @may31 datetime
DECLARE @jun1 datetime, @jun30 datetime
DECLARE @jul1 datetime, @jul31 datetime
DECLARE @aug1 datetime, @aug31 datetime
DECLARE @sep1 datetime, @sep30 datetime
DECLARE @oct1 datetime, @oct31 datetime
DECLARE @nov1 datetime, @nov30 datetime
DECLARE @dec1 datetime, @dec31 datetime
DECLARE @all_types bit

SELECT @feb28 = dbo.GetLastDayOfMonth(2, @year)
SELECT @all_types = 1
SELECT @all_types = 0 FROM LeaveType WHERE (TypeID & @type_mask) = 0

SELECT @jan1 = dbo.GetDateFromMDY(1,1,@year), @jan31 = dbo.GetDateFromMDY(1,31,@year)
SELECT @feb1 = dbo.GetDateFromMDY(2,1,@year), @feb28 = dbo.GetDateFromMDY(2,dbo.GetLastDayOfMonth(2, @year),@year)
SELECT @mar1 = dbo.GetDateFromMDY(3,1,@year), @mar31 = dbo.GetDateFromMDY(3,31,@year)
SELECT @apr1 = dbo.GetDateFromMDY(4,1,@year), @apr30 = dbo.GetDateFromMDY(4,30,@year)
SELECT @may1 = dbo.GetDateFromMDY(5,1,@year), @may31 = dbo.GetDateFromMDY(5,31,@year)
SELECT @jun1 = dbo.GetDateFromMDY(6,1,@year), @jun30 = dbo.GetDateFromMDY(6,30,@year)
SELECT @jul1 = dbo.GetDateFromMDY(7,1,@year), @jul31 = dbo.GetDateFromMDY(7,31,@year)
SELECT @aug1 = dbo.GetDateFromMDY(8,1,@year), @aug31 = dbo.GetDateFromMDY(8,31,@year)
SELECT @sep1 = dbo.GetDateFromMDY(9,1,@year), @sep30 = dbo.GetDateFromMDY(9,30,@year)
SELECT @oct1 = dbo.GetDateFromMDY(10,1,@year), @oct31 = dbo.GetDateFromMDY(10,31,@year)
SELECT @nov1 = dbo.GetDateFromMDY(11,1,@year), @nov30 = dbo.GetDateFromMDY(11,30,@year)
SELECT @dec1 = dbo.GetDateFromMDY(12,1,@year), @dec31 = dbo.GetDateFromMDY(12,31,@year)

SELECT [Order] = 1, Row = 'Requests',
Jan = (SELECT COUNT(*) FROM dbo.vwEmployeeLeaveUsed U INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID]=U.LOAEmployeeID AND (@all_types=1 OR [LOA Extended Type Mask] & @type_mask != 0) AND [LOA Requested] BETWEEN @jan1 AND @jan31),
Feb = (SELECT COUNT(*) FROM dbo.vwEmployeeLeaveUsed U INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID]=U.LOAEmployeeID AND (@all_types=1 OR [LOA Extended Type Mask] & @type_mask != 0) AND [LOA Requested] BETWEEN @feb1 AND @feb28),
Mar = (SELECT COUNT(*) FROM dbo.vwEmployeeLeaveUsed U INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID]=U.LOAEmployeeID AND (@all_types=1 OR [LOA Extended Type Mask] & @type_mask != 0) AND [LOA Requested] BETWEEN @mar1 AND @mar31),
Apr =(SELECT COUNT(*) FROM dbo.vwEmployeeLeaveUsed U INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID]=U.LOAEmployeeID AND (@all_types=1 OR [LOA Extended Type Mask] & @type_mask != 0) AND [LOA Requested] BETWEEN @apr1 AND @apr30),
May = (SELECT COUNT(*) FROM dbo.vwEmployeeLeaveUsed U INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID]=U.LOAEmployeeID AND (@all_types=1 OR [LOA Extended Type Mask] & @type_mask != 0) AND [LOA Requested] BETWEEN @may1 AND @may31),
Jun = (SELECT COUNT(*) FROM dbo.vwEmployeeLeaveUsed U INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID]=U.LOAEmployeeID AND (@all_types=1 OR [LOA Extended Type Mask] & @type_mask != 0) AND [LOA Requested] BETWEEN @jun1 AND @jun30),
Jul = (SELECT COUNT(*) FROM dbo.vwEmployeeLeaveUsed U INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID]=U.LOAEmployeeID AND (@all_types=1 OR [LOA Extended Type Mask] & @type_mask != 0) AND [LOA Requested] BETWEEN @jul1 AND @jul31),
Aug = (SELECT COUNT(*) FROM dbo.vwEmployeeLeaveUsed U INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID]=U.LOAEmployeeID AND (@all_types=1 OR [LOA Extended Type Mask] & @type_mask != 0) AND [LOA Requested] BETWEEN @aug1 AND @aug31),
Sep = (SELECT COUNT(*) FROM dbo.vwEmployeeLeaveUsed U INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID]=U.LOAEmployeeID AND (@all_types=1 OR [LOA Extended Type Mask] & @type_mask != 0) AND [LOA Requested] BETWEEN @sep1 AND @sep30),
Oct = (SELECT COUNT(*) FROM dbo.vwEmployeeLeaveUsed U INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID]=U.LOAEmployeeID AND (@all_types=1 OR [LOA Extended Type Mask] & @type_mask != 0) AND [LOA Requested] BETWEEN @oct1 AND @oct31),
Nov = (SELECT COUNT(*) FROM dbo.vwEmployeeLeaveUsed U INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID]=U.LOAEmployeeID AND (@all_types=1 OR [LOA Extended Type Mask] & @type_mask != 0) AND [LOA Requested] BETWEEN @nov1 AND @nov30),
[Dec] = (SELECT COUNT(*) FROM dbo.vwEmployeeLeaveUsed U INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID]=U.LOAEmployeeID AND (@all_types=1 OR [LOA Extended Type Mask] & @type_mask != 0) AND [LOA Requested] BETWEEN @dec1 AND @dec31)

UNION

SELECT [Order] = 2, Row = 'Approvals',
Jan = (SELECT COUNT(*) FROM dbo.vwEmployeeLeaveUsed U INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID]=U.LOAEmployeeID AND (@all_types=1 OR [LOA Extended Type Mask] & @type_mask != 0) AND [LOA Status] = 2 AND [LOA Requested] BETWEEN @jan1 AND @jan31),
Feb = (SELECT COUNT(*) FROM dbo.vwEmployeeLeaveUsed U INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID]=U.LOAEmployeeID AND (@all_types=1 OR [LOA Extended Type Mask] & @type_mask != 0) AND [LOA Status] = 2 AND [LOA Requested] BETWEEN @feb1 AND @feb28),
Mar = (SELECT COUNT(*) FROM dbo.vwEmployeeLeaveUsed U INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID]=U.LOAEmployeeID AND (@all_types=1 OR [LOA Extended Type Mask] & @type_mask != 0) AND [LOA Status] = 2 AND [LOA Requested] BETWEEN @mar1 AND @mar31),
Apr =(SELECT COUNT(*) FROM dbo.vwEmployeeLeaveUsed U INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID]=U.LOAEmployeeID AND (@all_types=1 OR [LOA Extended Type Mask] & @type_mask != 0) AND [LOA Status] = 2 AND [LOA Requested] BETWEEN @apr1 AND @apr30),
May = (SELECT COUNT(*) FROM dbo.vwEmployeeLeaveUsed U INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID]=U.LOAEmployeeID AND (@all_types=1 OR [LOA Extended Type Mask] & @type_mask != 0) AND [LOA Status] = 2 AND [LOA Requested] BETWEEN @may1 AND @may31),
Jun = (SELECT COUNT(*) FROM dbo.vwEmployeeLeaveUsed U INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID]=U.LOAEmployeeID AND (@all_types=1 OR [LOA Extended Type Mask] & @type_mask != 0) AND [LOA Status] = 2 AND [LOA Requested] BETWEEN @jun1 AND @jun30),
Jul = (SELECT COUNT(*) FROM dbo.vwEmployeeLeaveUsed U INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID]=U.LOAEmployeeID AND (@all_types=1 OR [LOA Extended Type Mask] & @type_mask != 0) AND [LOA Status] = 2 AND [LOA Requested] BETWEEN @jul1 AND @jul31),
Aug = (SELECT COUNT(*) FROM dbo.vwEmployeeLeaveUsed U INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID]=U.LOAEmployeeID AND (@all_types=1 OR [LOA Extended Type Mask] & @type_mask != 0) AND [LOA Status] = 2 AND [LOA Requested] BETWEEN @aug1 AND @aug31),
Sep = (SELECT COUNT(*) FROM dbo.vwEmployeeLeaveUsed U INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID]=U.LOAEmployeeID AND (@all_types=1 OR [LOA Extended Type Mask] & @type_mask != 0) AND [LOA Status] = 2 AND [LOA Requested] BETWEEN @sep1 AND @sep30),
Oct = (SELECT COUNT(*) FROM dbo.vwEmployeeLeaveUsed U INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID]=U.LOAEmployeeID AND (@all_types=1 OR [LOA Extended Type Mask] & @type_mask != 0) AND [LOA Status] = 2 AND [LOA Requested] BETWEEN @oct1 AND @oct31),
Nov = (SELECT COUNT(*) FROM dbo.vwEmployeeLeaveUsed U INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID]=U.LOAEmployeeID AND (@all_types=1 OR [LOA Extended Type Mask] & @type_mask != 0) AND [LOA Status] = 2 AND [LOA Requested] BETWEEN @nov1 AND @nov30),
[Dec] = (SELECT COUNT(*) FROM dbo.vwEmployeeLeaveUsed U INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID]=U.LOAEmployeeID AND (@all_types=1 OR [LOA Extended Type Mask] & @type_mask != 0) AND [LOA Status] = 2 AND [LOA Requested] BETWEEN @dec1 AND @dec31)

UNION

SELECT [Order] = 3, Row = 'Denials',
Jan = (SELECT COUNT(*) FROM dbo.vwEmployeeLeaveUsed U INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID]=U.LOAEmployeeID AND (@all_types=1 OR [LOA Extended Type Mask] & @type_mask != 0) AND [LOA Status] = 4 AND [LOA Requested] BETWEEN @jan1 AND @jan31),
Feb = (SELECT COUNT(*) FROM dbo.vwEmployeeLeaveUsed U INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID]=U.LOAEmployeeID AND (@all_types=1 OR [LOA Extended Type Mask] & @type_mask != 0) AND [LOA Status] = 4 AND [LOA Requested] BETWEEN @feb1 AND @feb28),
Mar = (SELECT COUNT(*) FROM dbo.vwEmployeeLeaveUsed U INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID]=U.LOAEmployeeID AND (@all_types=1 OR [LOA Extended Type Mask] & @type_mask != 0) AND [LOA Status] = 4 AND [LOA Requested] BETWEEN @mar1 AND @mar31),
Apr =(SELECT COUNT(*) FROM dbo.vwEmployeeLeaveUsed U INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID]=U.LOAEmployeeID AND (@all_types=1 OR [LOA Extended Type Mask] & @type_mask != 0) AND [LOA Status] = 4 AND [LOA Requested] BETWEEN @apr1 AND @apr30),
May = (SELECT COUNT(*) FROM dbo.vwEmployeeLeaveUsed U INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID]=U.LOAEmployeeID AND (@all_types=1 OR [LOA Extended Type Mask] & @type_mask != 0) AND [LOA Status] = 4 AND [LOA Requested] BETWEEN @may1 AND @may31),
Jun = (SELECT COUNT(*) FROM dbo.vwEmployeeLeaveUsed U INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID]=U.LOAEmployeeID AND (@all_types=1 OR [LOA Extended Type Mask] & @type_mask != 0) AND [LOA Status] = 4 AND [LOA Requested] BETWEEN @jun1 AND @jun30),
Jul = (SELECT COUNT(*) FROM dbo.vwEmployeeLeaveUsed U INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID]=U.LOAEmployeeID AND (@all_types=1 OR [LOA Extended Type Mask] & @type_mask != 0) AND [LOA Status] = 4 AND [LOA Requested] BETWEEN @jul1 AND @jul31),
Aug = (SELECT COUNT(*) FROM dbo.vwEmployeeLeaveUsed U INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID]=U.LOAEmployeeID AND (@all_types=1 OR [LOA Extended Type Mask] & @type_mask != 0) AND [LOA Status] = 4 AND [LOA Requested] BETWEEN @aug1 AND @aug31),
Sep = (SELECT COUNT(*) FROM dbo.vwEmployeeLeaveUsed U INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID]=U.LOAEmployeeID AND (@all_types=1 OR [LOA Extended Type Mask] & @type_mask != 0) AND [LOA Status] = 4 AND [LOA Requested] BETWEEN @sep1 AND @sep30),
Oct = (SELECT COUNT(*) FROM dbo.vwEmployeeLeaveUsed U INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID]=U.LOAEmployeeID AND (@all_types=1 OR [LOA Extended Type Mask] & @type_mask != 0) AND [LOA Status] = 4 AND [LOA Requested] BETWEEN @oct1 AND @oct31),
Nov = (SELECT COUNT(*) FROM dbo.vwEmployeeLeaveUsed U INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID]=U.LOAEmployeeID AND (@all_types=1 OR [LOA Extended Type Mask] & @type_mask != 0) AND [LOA Status] = 4 AND [LOA Requested] BETWEEN @nov1 AND @nov30),
[Dec] = (SELECT COUNT(*) FROM dbo.vwEmployeeLeaveUsed U INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID]=U.LOAEmployeeID AND (@all_types=1 OR [LOA Extended Type Mask] & @type_mask != 0) AND [LOA Status] = 4 AND [LOA Requested] BETWEEN @dec1 AND @dec31)

UNION

SELECT [Order] = 3, Row = 'Pending',
Jan = (SELECT COUNT(*) FROM dbo.vwEmployeeLeaveUsed U INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID]=U.LOAEmployeeID AND (@all_types=1 OR [LOA Extended Type Mask] & @type_mask != 0) AND [LOA Status] = 1 AND [LOA Requested] BETWEEN @jan1 AND @jan31),
Feb = (SELECT COUNT(*) FROM dbo.vwEmployeeLeaveUsed U INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID]=U.LOAEmployeeID AND (@all_types=1 OR [LOA Extended Type Mask] & @type_mask != 0) AND [LOA Status] = 1 AND [LOA Requested] BETWEEN @feb1 AND @feb28),
Mar = (SELECT COUNT(*) FROM dbo.vwEmployeeLeaveUsed U INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID]=U.LOAEmployeeID AND (@all_types=1 OR [LOA Extended Type Mask] & @type_mask != 0) AND [LOA Status] = 1 AND [LOA Requested] BETWEEN @mar1 AND @mar31),
Apr =(SELECT COUNT(*) FROM dbo.vwEmployeeLeaveUsed U INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID]=U.LOAEmployeeID AND (@all_types=1 OR [LOA Extended Type Mask] & @type_mask != 0) AND [LOA Status] = 1 AND [LOA Requested] BETWEEN @apr1 AND @apr30),
May = (SELECT COUNT(*) FROM dbo.vwEmployeeLeaveUsed U INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID]=U.LOAEmployeeID AND (@all_types=1 OR [LOA Extended Type Mask] & @type_mask != 0) AND [LOA Status] = 1 AND [LOA Requested] BETWEEN @may1 AND @may31),
Jun = (SELECT COUNT(*) FROM dbo.vwEmployeeLeaveUsed U INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID]=U.LOAEmployeeID AND (@all_types=1 OR [LOA Extended Type Mask] & @type_mask != 0) AND [LOA Status] = 1 AND [LOA Requested] BETWEEN @jun1 AND @jun30),
Jul = (SELECT COUNT(*) FROM dbo.vwEmployeeLeaveUsed U INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID]=U.LOAEmployeeID AND (@all_types=1 OR [LOA Extended Type Mask] & @type_mask != 0) AND [LOA Status] = 1 AND [LOA Requested] BETWEEN @jul1 AND @jul31),
Aug = (SELECT COUNT(*) FROM dbo.vwEmployeeLeaveUsed U INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID]=U.LOAEmployeeID AND (@all_types=1 OR [LOA Extended Type Mask] & @type_mask != 0) AND [LOA Status] = 1 AND [LOA Requested] BETWEEN @aug1 AND @aug31),
Sep = (SELECT COUNT(*) FROM dbo.vwEmployeeLeaveUsed U INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID]=U.LOAEmployeeID AND (@all_types=1 OR [LOA Extended Type Mask] & @type_mask != 0) AND [LOA Status] = 1 AND [LOA Requested] BETWEEN @sep1 AND @sep30),
Oct = (SELECT COUNT(*) FROM dbo.vwEmployeeLeaveUsed U INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID]=U.LOAEmployeeID AND (@all_types=1 OR [LOA Extended Type Mask] & @type_mask != 0) AND [LOA Status] = 1 AND [LOA Requested] BETWEEN @oct1 AND @oct31),
Nov = (SELECT COUNT(*) FROM dbo.vwEmployeeLeaveUsed U INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID]=U.LOAEmployeeID AND (@all_types=1 OR [LOA Extended Type Mask] & @type_mask != 0) AND [LOA Status] = 1 AND [LOA Requested] BETWEEN @nov1 AND @nov30),
[Dec] = (SELECT COUNT(*) FROM dbo.vwEmployeeLeaveUsed U INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID]=U.LOAEmployeeID AND (@all_types=1 OR [LOA Extended Type Mask] & @type_mask != 0) AND [LOA Status] = 1 AND [LOA Requested] BETWEEN @dec1 AND @dec31)

UNION

SELECT [Order] = 4, Row = 'Departures',
Jan = (SELECT COUNT(*) FROM dbo.vwEmployeeLeaveUsed U INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID]=U.LOAEmployeeID AND (@all_types=1 OR [LOA Extended Type Mask] & @type_mask != 0) AND [LOA Status] = 2 AND [LOA Start] BETWEEN @jan1 AND @jan31),
Feb = (SELECT COUNT(*) FROM dbo.vwEmployeeLeaveUsed U INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID]=U.LOAEmployeeID AND (@all_types=1 OR [LOA Extended Type Mask] & @type_mask != 0) AND [LOA Status] = 2 AND [LOA Start] BETWEEN @feb1 AND @feb28),
Mar = (SELECT COUNT(*) FROM dbo.vwEmployeeLeaveUsed U INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID]=U.LOAEmployeeID AND (@all_types=1 OR [LOA Extended Type Mask] & @type_mask != 0) AND [LOA Status] = 2 AND [LOA Start] BETWEEN @mar1 AND @mar31),
Apr = (SELECT COUNT(*) FROM dbo.vwEmployeeLeaveUsed U INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID]=U.LOAEmployeeID AND (@all_types=1 OR [LOA Extended Type Mask] & @type_mask != 0) AND [LOA Status] = 2 AND [LOA Start] BETWEEN @apr1 AND @apr30),
May = (SELECT COUNT(*) FROM dbo.vwEmployeeLeaveUsed U INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID]=U.LOAEmployeeID AND (@all_types=1 OR [LOA Extended Type Mask] & @type_mask != 0) AND [LOA Status] = 2 AND [LOA Start] BETWEEN @may1 AND @may31),
Jun = (SELECT COUNT(*) FROM dbo.vwEmployeeLeaveUsed U INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID]=U.LOAEmployeeID AND (@all_types=1 OR [LOA Extended Type Mask] & @type_mask != 0) AND [LOA Status] = 4 AND [LOA Start] BETWEEN @jun1 AND @jun30),
Jul = (SELECT COUNT(*) FROM dbo.vwEmployeeLeaveUsed U INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID]=U.LOAEmployeeID AND (@all_types=1 OR [LOA Extended Type Mask] & @type_mask != 0) AND [LOA Status] = 2 AND [LOA Start] BETWEEN @jul1 AND @jul31),
Aug = (SELECT COUNT(*) FROM dbo.vwEmployeeLeaveUsed U INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID]=U.LOAEmployeeID AND (@all_types=1 OR [LOA Extended Type Mask] & @type_mask != 0) AND [LOA Status] = 2 AND [LOA Start] BETWEEN @aug1 AND @aug31),
Sep = (SELECT COUNT(*) FROM dbo.vwEmployeeLeaveUsed U INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID]=U.LOAEmployeeID AND (@all_types=1 OR [LOA Extended Type Mask] & @type_mask != 0) AND [LOA Status] = 2 AND [LOA Start] BETWEEN @sep1 AND @sep30),
Oct = (SELECT COUNT(*) FROM dbo.vwEmployeeLeaveUsed U INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID]=U.LOAEmployeeID AND (@all_types=1 OR [LOA Extended Type Mask] & @type_mask != 0) AND [LOA Status] = 2 AND [LOA Start] BETWEEN @oct1 AND @oct31),
Nov = (SELECT COUNT(*) FROM dbo.vwEmployeeLeaveUsed U INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID]=U.LOAEmployeeID AND (@all_types=1 OR [LOA Extended Type Mask] & @type_mask != 0) AND [LOA Status] = 2 AND [LOA Start] BETWEEN @nov1 AND @nov30),
[Dec] = (SELECT COUNT(*) FROM dbo.vwEmployeeLeaveUsed U INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID]=U.LOAEmployeeID AND (@all_types=1 OR [LOA Extended Type Mask] & @type_mask != 0) AND [LOA Status] = 2 AND [LOA Start] BETWEEN @dec1 AND @dec31)

UNION

SELECT [Order] = 5, Row = 'Arrivals',
Jan = (SELECT COUNT(*) FROM dbo.vwEmployeeLeaveUsed U INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID]=U.LOAEmployeeID AND (@all_types=1 OR [LOA Extended Type Mask] & @type_mask != 0) AND [LOA Status] = 2 AND [LOA Stop] BETWEEN @jan1 AND @jan31),
Feb = (SELECT COUNT(*) FROM dbo.vwEmployeeLeaveUsed U INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID]=U.LOAEmployeeID AND (@all_types=1 OR [LOA Extended Type Mask] & @type_mask != 0) AND [LOA Status] = 2 AND [LOA Stop] BETWEEN @feb1 AND @feb28),
Mar = (SELECT COUNT(*) FROM dbo.vwEmployeeLeaveUsed U INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID]=U.LOAEmployeeID AND (@all_types=1 OR [LOA Extended Type Mask] & @type_mask != 0) AND [LOA Status] = 2 AND [LOA Stop] BETWEEN @mar1 AND @mar31),
Apr =(SELECT COUNT(*) FROM dbo.vwEmployeeLeaveUsed U INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID]=U.LOAEmployeeID AND (@all_types=1 OR [LOA Extended Type Mask] & @type_mask != 0) AND [LOA Status] = 2 AND [LOA Stop] BETWEEN @apr1 AND @apr30),
May = (SELECT COUNT(*) FROM dbo.vwEmployeeLeaveUsed U INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID]=U.LOAEmployeeID AND (@all_types=1 OR [LOA Extended Type Mask] & @type_mask != 0) AND [LOA Status] = 2 AND [LOA Stop] BETWEEN @may1 AND @may31),
Jun = (SELECT COUNT(*) FROM dbo.vwEmployeeLeaveUsed U INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID]=U.LOAEmployeeID AND (@all_types=1 OR [LOA Extended Type Mask] & @type_mask != 0) AND [LOA Status] = 2 AND [LOA Stop] BETWEEN @jun1 AND @jun30),
Jul = (SELECT COUNT(*) FROM dbo.vwEmployeeLeaveUsed U INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID]=U.LOAEmployeeID AND (@all_types=1 OR [LOA Extended Type Mask] & @type_mask != 0) AND [LOA Status] = 2 AND [LOA Stop] BETWEEN @jul1 AND @jul31),
Aug = (SELECT COUNT(*) FROM dbo.vwEmployeeLeaveUsed U INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID]=U.LOAEmployeeID AND (@all_types=1 OR [LOA Extended Type Mask] & @type_mask != 0) AND [LOA Status] = 2 AND [LOA Stop] BETWEEN @aug1 AND @aug31),
Sep = (SELECT COUNT(*) FROM dbo.vwEmployeeLeaveUsed U INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID]=U.LOAEmployeeID AND (@all_types=1 OR [LOA Extended Type Mask] & @type_mask != 0) AND [LOA Status] = 2 AND [LOA Stop] BETWEEN @sep1 AND @sep30),
Oct = (SELECT COUNT(*) FROM dbo.vwEmployeeLeaveUsed U INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID]=U.LOAEmployeeID AND (@all_types=1 OR [LOA Extended Type Mask] & @type_mask != 0) AND [LOA Status] = 2 AND [LOA Stop] BETWEEN @oct1 AND @oct31),
Nov = (SELECT COUNT(*) FROM dbo.vwEmployeeLeaveUsed U INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID]=U.LOAEmployeeID AND (@all_types=1 OR [LOA Extended Type Mask] & @type_mask != 0) AND [LOA Status] = 2 AND [LOA Stop] BETWEEN @nov1 AND @nov30),
[Dec] = (SELECT COUNT(*) FROM dbo.vwEmployeeLeaveUsed U INNER JOIN dbo.TempX X ON X.BatchID=@batch_id AND X.[ID]=U.LOAEmployeeID AND (@all_types=1 OR [LOA Extended Type Mask] & @type_mask != 0) AND [LOA Status] = 2 AND [LOA Stop] BETWEEN @dec1 AND @dec31)

ORDER BY [Order]

DELETE dbo.TempX WHERE BatchID=@batch_id OR DATEDIFF(hh,Created,GETDATE()) > 1
GO
IF OBJECT_id('dbo.spInvoiceCreditDelete') IS NOT NULL DROP PROC dbo.spInvoiceCreditDelete
IF OBJECT_id('dbo.spInvoiceCreditInsert') IS NOT NULL DROP PROC dbo.spInvoiceCreditInsert
IF OBJECT_id('dbo.spInvoiceCreditUpdate') IS NOT NULL DROP PROC dbo.spInvoiceCreditUpdate
IF OBJECT_id('dbo.spInvoiceCreditList') IS NOT NULL DROP PROC dbo.spInvoiceCreditList
GO
CREATE PROC dbo.spInvoiceCreditDelete @credit_id int AS
DECLARE @old_invoice_id int
SELECT @old_invoice_id=InvoiceID FROM InvoiceCredit WHERE CreditID=@credit_id
DELETE InvoiceCredit WHERE CreditID=@credit_id
EXEC dbo.spInvoiceCalc @old_invoice_id
GO
CREATE PROC dbo.spInvoiceCreditInsert
	@invoice_id int,
	@day int,
	@comment varchar(50),
	@amount money,
	@credit_id int out
AS
INSERT InvoiceCredit(InvoiceID, [Day past 1900], Comment, Amount)
SELECT @invoice_id, @day, @comment, @amount

SELECT @credit_id=SCOPE_IDENTITY()
GO
CREATE PROC dbo.spInvoiceCreditList @invoice_id int AS
SET NOCOUNT ON SELECT * FROM vwInvoiceCredit WHERE InvoiceID=@invoice_id
GO
CREATE PROC dbo.spInvoiceCreditUpdate
	@day int,
	@comment varchar(50),
	@amount money,
	@credit_id int
AS
UPDATE InvoiceCredit SET [Day past 1900]=@day, Comment=@comment, Amount=@amount WHERE CreditID=@credit_id
GO
GRANT EXEC ON dbo.spInvoiceCreditDelete TO public
GRANT EXEC ON dbo.spInvoiceCreditInsert TO public
GRANT EXEC ON dbo.spInvoiceCreditList TO public
GRANT EXEC ON dbo.spInvoiceCreditUpdate TO public
GO
/*IF OBJECT_ID('dbo.spPersonUpdateLDAP') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spPersonUpdateLDAP AS'

ALTER PROC dbo.spPersonUpdateLDAP
	@person_id int,
	@ldap_guid binary(16)
AS
DECLARE @authorized bit
EXEC dbo.spPermissionInsureForCurrentUserOnPerson @person_id, 129, 2, @authorized out
IF @authorized = 1  UPDATE dbo.Person SET LDAPGuid = @ldap_guid WHERE PersonID=@person_id

GRANT EXEC ON dbo.spPersonUpdateLDAP TO public
*/
IF OBJECT_ID('dbo.spEmployeeBatchWindowsUsers') IS NULL EXEC sp_executesql N'CREATE PROC dbo.spEmployeeBatchWindowsUsers AS'
GO
ALTER PROC dbo.spEmployeeBatchWindowsUsers @batch_id int
AS
INSERT dbo.TempX(BatchID,[ID])
SELECT @batch_id,EmployeeID FROM dbo.Employee E
WHERE SUSER_SNAME(E.[SID]) IS NOT NULL
GO
GRANT EXEC ON dbo.spEmployeeBatchWindowsUsers TO public
GO
EXEC dbo.spEmployeeBenefitCreateFlatView
GO
IF OBJECT_ID('dbo.spPermissionAssociateIDsForStoredProcsWithAffectedTable') IS NULL
BEGIN
	EXEC sp_executesql N'CREATE PROC dbo.spPermissionAssociateIDsForStoredProcsWithAffectedTable AS'
	--EXEC sp_executesql N'GRANT EXEC ON dbo.spPermissionAssociateIDsForStoredProcsWithAffectedTable TO public'
END
GO
ALTER PROC dbo.spPermissionAssociateIDsForStoredProcsWithAffectedTable
AS
DELETE dbo.PermissionObjectX
DELETE dbo.PermissionObject

EXEC dbo.spPermissionObjectInsert 1,'Organizational Departments',NULL,'dbo.spDepartmentUpdate','dbo.spDepartmentInsert','dbo.spDepartmentDelete',14
EXEC dbo.spPermissionObjectInsert 2,'Organizational Divisions',NULL,'dbo.spDivisionUpdate','dbo.spDivisionInsert','dbo.spDivisionDelete',14
EXEC dbo.spPermissionObjectInsert 3,'Job Categories',NULL,'dbo.spJobCategoryUpdate','dbo.spJobCategoryInsert','dbo.spJobCategoryDelete',14
EXEC dbo.spPermissionObjectInsert 4,'Certifications',NULL,'dbo.spCertificationUpdate','dbo.spCertificationInsert','dbo.spCertificationDelete',14
EXEC dbo.spPermissionObjectInsert 5,'Unions',NULL,'dbo.spUnionUpdate','dbo.spUnionInsert','dbo.spUnionDelete',14
EXEC dbo.spPermissionObjectInsert 6,'Organizational Locations',NULL,'dbo.spLocationUpdate','dbo.spLocationInsert','dbo.spLocationDelete',14
EXEC dbo.spPermissionObjectInsert 7,'Employee Review Rating Choices',NULL,'dbo.spEmployeeReviewRatingUpdate','dbo.spEmployeeReviewRatingInsert','dbo.spEmployeeReviewRatingDelete',14
EXEC dbo.spPermissionObjectInsert 8,'Employee Review Type Choices',NULL,'dbo.spEmployeeReviewTypeUpdate','dbo.spEmployeeReviewTypeInsert','dbo.spEmployeeReviewTypeDelete',14
EXEC dbo.spPermissionObjectInsert 9,'Employment Summary Reports','dbo.spTurnover',NULL,NULL,NULL,1
EXEC dbo.spPermissionObjectXInsert 9,1,'dbo.spEmployeeCountEEO2'
EXEC dbo.spPermissionObjectXInsert 9,1,'dbo.spEmployeeCountEEO4'
EXEC dbo.spPermissionObjectXInsert 9,1,'dbo.spEmployeeCountEEOList'
EXEC dbo.spPermissionObjectXInsert 9,1,'dbo.spEmployeeCountEEO'
EXEC dbo.spPermissionObjectXInsert 9,1,'dbo.spTurnoverDetailHired'
EXEC dbo.spPermissionObjectXInsert 9,1,'dbo.spTurnoverDetailSeparated'
EXEC dbo.spPermissionObjectXInsert 9,1,'dbo.spTurnoverItemize'

EXEC dbo.spPermissionObjectInsert 10,'Tests',NULL,'dbo.spTestUpdate','dbo.spTestInsert','dbo.spTestDelete',14
EXEC dbo.spPermissionObjectInsert 11,'Training Courses',NULL,'dbo.spTrainingUpdate','dbo.spTrainingInsert','dbo.spTrainingDelete',14
EXEC dbo.spPermissionObjectXInsert 11,2,'dbo.spCourseUpdate'
EXEC dbo.spPermissionObjectXInsert 11,4,'dbo.spCourseInsert'
EXEC dbo.spPermissionObjectXInsert 11,8,'dbo.spCourseDelete'

EXEC dbo.spPermissionObjectInsert 12,'Employee Successor Stages',NULL,'dbo.spEmployeeSuccessorStageUpdate','dbo.spEmployeeSuccessorStageInsert','dbo.spEmployeeSuccessorStageDelete',14
EXEC dbo.spPermissionObjectInsert 13,'Positions','dbo.spPositionSelect','dbo.spPositionUpdate','dbo.spPositionInsert','dbo.spPositionDelete',15

EXEC dbo.spPermissionObjectXInsert 13,1,'dbo.spPositionList'
EXEC dbo.spPermissionObjectXInsert 13,2,'dbo.spPositionInactivate'
EXEC dbo.spPermissionObjectXInsert 13,8,'dbo.spPositionDeleteAll'

EXEC dbo.spPermissionObjectInsert 14,'Custom Fields',NULL,'dbo.spCustomFieldUpdate','dbo.spCustomFieldInsert','dbo.spCustomFieldDelete',14
EXEC dbo.spPermissionObjectXInsert 14,2,'dbo.spCustomFieldMoveUp'
EXEC dbo.spPermissionObjectXInsert 14,2,'dbo.spCustomFieldMoveDown'
EXEC dbo.spPermissionObjectXInsert 14,2,'dbo.spCustomFieldItemUpdate'
EXEC dbo.spPermissionObjectXInsert 14,4,'dbo.spCustomFieldItemInsert'
EXEC dbo.spPermissionObjectXInsert 14,8,'dbo.spCustomFieldItemDelete'

EXEC dbo.spPermissionObjectInsert 15,'Form I9 Choices',NULL,'dbo.spI9StatusUpdate','dbo.spI9StatusInsert','dbo.spI9StatusDelete',14
EXEC dbo.spPermissionObjectInsert 16,'Marital Status',NULL,'dbo.spMaritalStatusUpdate','dbo.spMaritalStatusInsert','dbo.spMaritalStatusDelete',14
EXEC dbo.spPermissionObjectInsert 17,'Races',NULL,'dbo.spRaceUpdate','dbo.spRaceInsert','dbo.spRaceDelete',14
EXEC dbo.spPermissionObjectInsert 19,'Injury Results',NULL,'dbo.spInjuryResultUpdate','dbo.spInjuryResultInsert','dbo.spInjuryResultDelete',14
EXEC dbo.spPermissionObjectInsert 20,'Skills',NULL,'dbo.spSkillUpdate','dbo.spSkillInsert','dbo.spSkillDelete',14
EXEC dbo.spPermissionObjectInsert 21,'Organizational Shifts',NULL,'dbo.spShiftUpdate','dbo.spShiftInsert','dbo.spShiftDelete',14

EXEC dbo.spPermissionObjectXInsert 24,14,'dbo.spShiftScheduleInsert'
EXEC dbo.spPermissionObjectXInsert 24,14,'dbo.spShiftScheduleClear'

EXEC dbo.spPermissionObjectInsert 22,'Employee Creation\Deletion',NULL,NULL,'dbo.spEmployeeInsert','dbo.spEmployeeDelete',12
EXEC dbo.spPermissionObjectInsert 23,'Checklist for Termination',NULL,'dbo.spChecklistExitInterviewUpdate','dbo.spChecklistExitInterviewInsert','dbo.spChecklistExitInterviewDelete',14
EXEC dbo.spPermissionObjectInsert 24,'Benefits, TDRPs & Deductions',NULL,'dbo.spBenefitUpdate','dbo.spBenefitInsert','dbo.spBenefitDelete',14

EXEC dbo.spPermissionObjectXInsert 24,2,'dbo.spDeductionUpdate'
EXEC dbo.spPermissionObjectXInsert 24,2,'dbo.spBenefitPremiumPush'
EXEC dbo.spPermissionObjectXInsert 24,2,'dbo.spBenefitUpdate'
EXEC dbo.spPermissionObjectXInsert 24,2,'dbo.spTDRPUpdate'
EXEC dbo.spPermissionObjectXInsert 24,2,'dbo.spTDRPMatchingUpdate'
EXEC dbo.spPermissionObjectXInsert 24,2,'dbo.spBenefitPremiumUpdate'
EXEC dbo.spPermissionObjectXInsert 24,4,'dbo.spDeductionInsert'
EXEC dbo.spPermissionObjectXInsert 24,4,'dbo.spBenefitInsert'
EXEC dbo.spPermissionObjectXInsert 24,4,'dbo.spTDRPInsert'
EXEC dbo.spPermissionObjectXInsert 24,4,'dbo.spTDRPMatchingInsert'
EXEC dbo.spPermissionObjectXInsert 24,4,'dbo.spBenefitPremiumInsert'
EXEC dbo.spPermissionObjectXInsert 24,8,'dbo.spDeductionDelete'
EXEC dbo.spPermissionObjectXInsert 24,8,'dbo.spTDRPMatchingDelete'
EXEC dbo.spPermissionObjectXInsert 24,8,'dbo.spBenefitPremiumDelete'

EXEC dbo.spPermissionObjectInsert 25,'Equipment','dbo.spEquipmentSelect','dbo.spEquipmentUpdate','dbo.spEquipmentInsert','dbo.spEquipmentDelete',15

EXEC dbo.spPermissionObjectXInsert 25,1,'dbo.spEquipmentList'
EXEC dbo.spPermissionObjectXInsert 25,1,'dbo.spEquipmentListCheckedIn'
EXEC dbo.spPermissionObjectXInsert 25,1,'dbo.spEquipmentListCheckedOut'
EXEC dbo.spPermissionObjectXInsert 25,1,'dbo.spEquipmentListForEmployee'

EXEC dbo.spPermissionObjectXInsert 25,4,'dbo.spEquipmentAccessoryInsert'
EXEC dbo.spPermissionObjectXInsert 25,4,'dbo.spEquipmentAccessoryUpdate'
EXEC dbo.spPermissionObjectXInsert 25,4,'dbo.spEquipmentAccessoryDelete'
EXEC dbo.spPermissionObjectXInsert 25,4,'dbo.spEquipmentAccessoryDelete2'

EXEC dbo.spPermissionObjectInsert 26,'Leave Plans',NULL,'dbo.spLeavePlanUpdate','dbo.spLeavePlanInsert','dbo.spLeavePlanDelete',14

EXEC dbo.spPermissionObjectXInsert 26,4,'dbo.spLeavePlanAutoCreate'
EXEC dbo.spPermissionObjectXInsert 26,4,'dbo.spLeaveRateCopy'
EXEC dbo.spPermissionObjectXInsert 26,2,'dbo.spLeaveRateInsert'
EXEC dbo.spPermissionObjectXInsert 26,2,'dbo.spCompanyUpdateCarryover'
EXEC dbo.spPermissionObjectXInsert 26,1,'dbo.spLeaveRateList'
EXEC dbo.spPermissionObjectXInsert 26,2,'dbo.spLeaveRateClear'
EXEC dbo.spPermissionObjectXInsert 26,1,'dbo.spLeaveLimitList'
EXEC dbo.spPermissionObjectXInsert 26,1,'dbo.spLeaveLimitSelect'
EXEC dbo.spPermissionObjectXInsert 26,2,'dbo.spLeaveLimitUnlimit'
EXEC dbo.spPermissionObjectXInsert 26,2,'dbo.spLeaveLimitUpdate'

EXEC dbo.spPermissionObjectInsert 27,'Holidays and Holiday Plans',NULL,'dbo.spHolidayUpdate','dbo.spHolidayInsert','dbo.spHolidayDelete',14
EXEC dbo.spPermissionObjectXInsert 27,2,'dbo.spHolidayPlanUpdate'
EXEC dbo.spPermissionObjectXInsert 27,4,'dbo.spHolidayPlanInsert'
EXEC dbo.spPermissionObjectXInsert 27,8,'dbo.spHolidayPlanDelete'

EXEC dbo.spPermissionObjectInsert 28,'Leave Denial Reasons',NULL,'dbo.spDenialReasonUpdate','dbo.spDenialReasonInsert','dbo.spDenialReasonDelete',14
EXEC dbo.spPermissionObjectInsert 30,'Standard Tasks',NULL,'dbo.spStandardTaskUpdate','dbo.spStandardTaskInsert','dbo.spStandardTaskDelete',14
EXEC dbo.spPermissionObjectInsert 32,'Licensing',NULL,'dbo.spLicenseUpdate','dbo.spLicenseInsert','dbo.spLicenseDelete',14
EXEC dbo.spPermissionObjectInsert 33,'Pay Grades',NULL,'dbo.spPayGradeUpdate','dbo.spPayGradeInsert','dbo.spPayGradeDelete',15

EXEC dbo.spPermissionObjectXInsert 33,2,'dbo.spPayTableUpdate'
EXEC dbo.spPermissionObjectXInsert 33,4,'dbo.spPayTableInsert'
EXEC dbo.spPermissionObjectXInsert 33,8,'dbo.spPayTableDelete'
EXEC dbo.spPermissionObjectXInsert 33,2,'dbo.spPayStepUpdate'
EXEC dbo.spPermissionObjectXInsert 33,4,'dbo.spPayStepInsert'
EXEC dbo.spPermissionObjectXInsert 33,8,'dbo.spPayStepDelete'
EXEC dbo.spPermissionObjectXInsert 33,1,'dbo.spPayList'
EXEC dbo.spPermissionObjectXInsert 33,2,'dbo.spPayUpdate'

EXEC dbo.spPermissionObjectInsert 34,'Leave Notes',NULL,'dbo.spLeaveNoteUpdate','dbo.spLeaveNoteInsert','dbo.spLeaveNoteDelete',14
EXEC dbo.spPermissionObjectInsert 35,'Leave Types',NULL,'dbo.spLeaveTypeUpdate','dbo.spLeaveTypeInsert','dbo.spLeaveTypeDelete',14

EXEC dbo.spPermissionObjectXInsert 35,2,'dbo.spLeaveTypeMoveUp'
EXEC dbo.spPermissionObjectXInsert 35,2,'dbo.spLeaveTypeMoveDown'
EXEC dbo.spPermissionObjectXInsert 35,2,'dbo.spLeaveTypeAddStateFML'

EXEC dbo.spPermissionObjectInsert 36,'Position Status',NULL,'dbo.spPositionStatusUpdate','dbo.spPositionStatusInsert','dbo.spPositionStatusDelete',14
EXEC dbo.spPermissionObjectInsert 37,'Employment Status',NULL,'dbo.spEmploymentStatusUpdate','dbo.spEmploymentStatusInsert','dbo.spEmploymentStatusDelete',14
EXEC dbo.spPermissionObjectInsert 38,'Checklist for New Hires',NULL,'dbo.spChecklistNewHireUpdate','dbo.spChecklistNewHireInsert','dbo.spChecklistNewHireDelete',14
EXEC dbo.spPermissionObjectInsert 39,'Leave Approval Types',NULL,'dbo.spChecklistNewHireUpdate','dbo.spChecklistNewHireInsert','dbo.spChecklistNewHireDelete',14
EXEC dbo.spPermissionObjectInsert 40,'Leave Cal Remark, Creator',NULL,'dbo.spCalendarRemarkUpdate','dbo.spCalendarRemarkInsert','dbo.spCalendarRemarkDelete',14
EXEC dbo.spPermissionObjectInsert 68,'Leave Cal Remark, Others',NULL,'dbo.spCalendarRemarkUpdateOthers',NULL,'dbo.spCalendarRemarkDeleteOthers',10

EXEC dbo.spPermissionObjectInsert 41,'Languages',NULL,'dbo.spLanguageUpdate','dbo.spLanguageInsert','dbo.spLanguageDelete',14
EXEC dbo.spPermissionObjectInsert 42,'Filters',NULL,'dbo.spFilterUpdate','dbo.spFilterInsert','dbo.spFilterDelete',14
EXEC dbo.spPermissionObjectInsert 43,'Projects',NULL,'dbo.spProjectUpdate','dbo.spProjectInsert','dbo.spProjectDelete',14

EXEC dbo.spPermissionObjectXInsert 43,2,'dbo.spProjectClassUpdate'
EXEC dbo.spPermissionObjectXInsert 43,4,'dbo.spProjectClassInsert'
EXEC dbo.spPermissionObjectXInsert 43,8,'dbo.spProjectClassDelete'
EXEC dbo.spPermissionObjectInsert 44,'Timecard Schema',NULL,'dbo.spTimeSchemaUpdate','dbo.spTimeSchemaInsert','dbo.spTimeSchemaDelete',14



EXEC dbo.spPermissionObjectXInsert 44,2,'dbo.spTimeSchemaSetDefault'
EXEC dbo.spPermissionObjectXInsert 44,2,'dbo.spTimeSchemaSlantUpdate'
EXEC dbo.spPermissionObjectXInsert 44,2,'dbo.spTimeSchemaBreakUpdate'

EXEC dbo.spPermissionObjectXInsert 44,4,'dbo.spTimeSchemaSlantInsert'
EXEC dbo.spPermissionObjectXInsert 44,4,'dbo.spTimeSchemaBreakInsert'

EXEC dbo.spPermissionObjectXInsert 44,8,'dbo.spTimeSchemaSlantDelete'
EXEC dbo.spPermissionObjectXInsert 44,8,'dbo.spTimeSchemaBreakDelete'

--EXEC dbo.spPermissionObjectInsert 45,'Flags (Custom)',NULL,'dbo.spFlagUpdate','dbo.spFlagInsert','dbo.spFlagDelete',14
EXEC dbo.spPermissionObjectInsert 46,'Note Classes',NULL,'dbo.spNoteClassUpdate','dbo.spNoteClassInsert','dbo.spNoteClassDelete',14
EXEC dbo.spPermissionObjectInsert 47,'COBRA Qualifying Events',NULL,'dbo.spCOBRAQEUpdate','dbo.spCOBRAQEInsert','dbo.spCOBRAQEDelete',14

EXEC dbo.spPermissionObjectInsert 48,'Time In Out Choices',NULL,'dbo.spInOutStatusUpdate','dbo.spInOutStatusInsert','dbo.spInOutStatusDelete',14
EXEC dbo.spPermissionObjectXInsert 48, 2, 'dbo.spInOutStatusMoveUp'
EXEC dbo.spPermissionObjectXInsert 48, 2, 'dbo.spInOutStatusMoveDown'

EXEC dbo.spPermissionObjectInsert 49,'Audit Trail','dbo.spAuditTrailList',NULL, NULL,NULL,1
EXEC dbo.spPermissionObjectInsert 50,'FLSA Status Choices', NULL,'dbo.spFLSAUpdate','dbo.spFLSAInsert','dbo.spFLSADelete',1
EXEC dbo.spPermissionObjectInsert 51,'Expense Accounts', NULL,'dbo.spExpenseAccountUpdate','dbo.spExpenseAccountInsert','dbo.spExpenseAccountDelete',1
EXEC dbo.spPermissionObjectInsert 52,'Occurrence Types', NULL,'dbo.spOccurrenceTypeUpdate','dbo.spOccurrenceTypeInsert','dbo.spOccurrenceTypeDelete',1

EXEC dbo.spPermissionObjectInsert 53,'Reports, Custom', NULL,'dbo.spReportTemplate2Update','dbo.spReportTemplate2Insert','dbo.spReportTemplate2Delete',14

EXEC dbo.spPermissionObjectXInsert 53,2,'dbo.spReportTemplate3UpdateNameAndParentMenuID'
EXEC dbo.spPermissionObjectXInsert 53,2,'dbo.spReportTemplate3Update'
EXEC dbo.spPermissionObjectXInsert 53,4,'dbo.spReportTemplate3Insert'
EXEC dbo.spPermissionObjectXInsert 53,8,'dbo.spReportTemplate3Delete'


EXEC dbo.spPermissionObjectInsert 54,'E-mailed Reminders Log', 'dbo.spTaskEmailList',NULL,NULL,NULL,1
EXEC dbo.spPermissionObjectInsert 55,'Termination Reasons',NULL,'dbo.spTerminationReasonUpdate','dbo.spTerminationReasonInsert','dbo.spTerminationReasonDelete',14

EXEC dbo.spPermissionObjectInsert 56, 'Terminals', 'dbo.spTerminalSelect', 'dbo.spTerminalUpdate', 'dbo.spTerminalInsert', 'dbo.spTerminalDelete', 15

-- EXEC dbo.spPermissionObjectXInsert 56,1,'dbo.spTerminalList'
EXEC dbo.spPermissionObjectXInsert 56,2,'dbo.spTerminalUpdateLastResult'
EXEC dbo.spPermissionObjectXInsert 56,2,'dbo.spTerminalConstantUpdateLastResult'
EXEC dbo.spPermissionObjectXInsert 56,2,'dbo.spTerminalConstantSet'
EXEC dbo.spPermissionObjectXInsert 56,2,'dbo.spTerminalConstantSet2'
EXEC dbo.spPermissionObjectXInsert 56,4,'dbo.spTerminalPunch'

EXEC dbo.spPermissionObjectInsert 57, 'Compensation Events', NULL, 'dbo.spEmployeeCompensationEventStartUpdate', 'dbo.spEmployeeCompensationEventStartInsert', 'dbo.spEmployeeCompensationEventStartDelete', 14

EXEC dbo.spPermissionObjectXInsert 57,2,'dbo.spEmployeeCompensationEventStopUpdate'
EXEC dbo.spPermissionObjectXInsert 57,4,'dbo.spEmployeeCompensationEventStopInsert'
EXEC dbo.spPermissionObjectXInsert 57,8,'dbo.spEmployeeCompensationEventStopDelete'

EXEC dbo.spPermissionObjectInsert 58,'Benefit Invoices and Payments','dbo.spInvoiceSelect','dbo.spInvoiceUpdate','dbo.spInvoiceInsert','dbo.spInvoiceDelete',14

EXEC dbo.spPermissionObjectXInsert 58,1,'dbo.spStatement'
EXEC dbo.spPermissionObjectXInsert 58,1,'dbo.spInvoiceList'
EXEC dbo.spPermissionObjectXInsert 58,1,'dbo.spInvoiceList2'
EXEC dbo.spPermissionObjectXInsert 58,1,'dbo.spInvoiceList3'
EXEC dbo.spPermissionObjectXInsert 58,1,'dbo.spPaymentList'
EXEC dbo.spPermissionObjectXInsert 58,1,'dbo.spPaymentDetailList'
EXEC dbo.spPermissionObjectXInsert 58,1,'dbo.spPaymentRefundList'
EXEC dbo.spPermissionObjectXInsert 58,1,'dbo.spInvoiceDetailList'
EXEC dbo.spPermissionObjectXInsert 58,1,'dbo.spPaymentSelect'
EXEC dbo.spPermissionObjectXInsert 58,2,'dbo.spPaymentUpdate'
EXEC dbo.spPermissionObjectXInsert 58,2,'dbo.spPaymentDetailUpdate'
EXEC dbo.spPermissionObjectXInsert 58,2,'dbo.spInvoiceDetailUpdate'
EXEC dbo.spPermissionObjectXInsert 58,2,'dbo.spPaymentRefundUpdate'
EXEC dbo.spPermissionObjectXInsert 58,4,'dbo.spInvoiceInsertBatch'
EXEC dbo.spPermissionObjectXInsert 58,4,'dbo.spPaymentInsert'
EXEC dbo.spPermissionObjectXInsert 58,4,'dbo.spPaymentDetailInsert'
EXEC dbo.spPermissionObjectXInsert 58,4,'dbo.spPaymentRefundInsert'
EXEC dbo.spPermissionObjectXInsert 58,4,'dbo.spInvoiceDetailUpdate'
EXEC dbo.spPermissionObjectXInsert 58,8,'dbo.spPaymentDelete'
EXEC dbo.spPermissionObjectXInsert 58,8,'dbo.spPaymentDetailDelete'
EXEC dbo.spPermissionObjectXInsert 58,8,'dbo.spPaymentRefundDelete'
EXEC dbo.spPermissionObjectXInsert 58,8,'dbo.spInvoiceDetailDelete'

EXEC dbo.spPermissionObjectInsert 59,'Time Types',NULL,'dbo.spTimeTypeUpdate','dbo.spTimeTypeInsert','dbo.spTimeTypeDelete',14

EXEC dbo.spPermissionObjectXInsert 59,2,'dbo.spTimeTypeMoveUp'
EXEC dbo.spPermissionObjectXInsert 59,2,'dbo.spTimeTypeMoveDown'

EXEC dbo.spPermissionObjectInsert 60,'Invoice Templates',NULL,'dbo.spInvoiceTemplateUpdate','dbo.spInvoiceTemplateInsert','dbo.spInvoiceTemplateDelete',14

EXEC dbo.spPermissionObjectInsert 61,'Injury Types',NULL,'dbo.spInjuryTypeUpdate','dbo.spInjuryTypeInsert','dbo.spInjuryTypeDelete',14


IF OBJECT_ID('dbo.spCourseTypeUpdate') IS NOT NULL AND OBJECT_ID('dbo.spCourseTypeInsert') IS NOT NULL AND OBJECT_ID('dbo.spCourseTypeDelete') IS NOT NULL
EXEC dbo.spPermissionObjectInsert 62,'Course Types',NULL,'dbo.spCourseTypeUpdate','dbo.spCourseTypeInsert','dbo.spCourseTypeDelete',14

IF OBJECT_ID('dbo.spCreditTypeUpdate') IS NOT NULL AND OBJECT_ID('dbo.spCreditTypeInsert') IS NOT NULL AND OBJECT_ID('dbo.spCreditTypeDelete') IS NOT NULL
EXEC dbo.spPermissionObjectInsert 63,'Credit Types',NULL,'dbo.spCreditTypeUpdate','dbo.spCreditTypeInsert','dbo.spCreditTypeDelete',14

EXEC dbo.spPermissionObjectInsert 64,'Equipment Types',NULL,'dbo.spEquipmentTypeUpdate','dbo.spEquipmentTypeInsert','dbo.spEquipmentTypeDelete',14

EXEC dbo.spPermissionObjectXInsert 64,4,'dbo.spEquipmentTypeAccessoryInsert'
EXEC dbo.spPermissionObjectXInsert 64,4,'dbo.spEquipmentTypeAccessoryUpdate'
EXEC dbo.spPermissionObjectXInsert 64,4,'dbo.spEquipmentTypeAccessoryDelete'

EXEC dbo.spPermissionObjectInsert 65,'RTW Items',NULL,'dbo.spRTWItemUpdate','dbo.spRTWItemInsert','dbo.spRTWItemDelete',14

EXEC dbo.spPermissionObjectInsert 66,'Visa Status',NULL,'dbo.spVisaStatusUpdate','dbo.spVisaStatusInsert','dbo.spVisaStatusDelete',14

EXEC dbo.spPermissionObjectInsert 67,'Audit Settings','dbo.spAuditSettingList','dbo.spAuditSettingUpdate',NULL,NULL,3

EXEC dbo.spPermissionObjectXInsert 67,1,'dbo.spAuditSettingGetPurge'
EXEC dbo.spPermissionObjectXInsert 67,2,'dbo.spAuditSettingUpdatePurge'
GO
EXEC dbo.spPermissionAssociateIDsForStoredProcsWithAffectedTable
GO
-- Sets proper permission on Benefits, PayTable, PayStep, Pay, and Leave Notes
DECLARE @scope_id int, @uid int, @permission_mask int, @attribute_id int

DECLARE p_cursor CURSOR LOCAL FORWARD_ONLY STATIC FOR SELECT ScopeID, AttributeID, UID, [Permission Mask] FROM dbo.PermissionScopeAttribute

OPEN p_cursor
FETCH p_cursor INTO @scope_id, @attribute_id, @uid, @permission_mask
WHILE @@FETCH_STATUS = 0
BEGIN
	EXEC dbo.spPermissionUpdateForUserScopeOnAttribute @scope_id, @attribute_id, @uid, @permission_mask
	FETCH p_cursor INTO @scope_id, @attribute_id, @uid, @permission_mask
END
CLOSE p_cursor
DEALLOCATE p_cursor
GO
-- In SQL 2000, PersonCustomFieldFlat table is insecure because it is controlled by dynamic sql and sp_executesql cannot impersonate dbo
-- In SQL 2005, PersonCustomFieldFlat table is secure because sp_executesql can impersonate dbo
IF EXISTS(SELECT * FROM dbo.Constant WHERE ([Version Update Flags] & 2) = 2)
BEGIN
	REVOKE INSERT ON dbo.PersonCustomFieldFlat TO public
	REVOKE DELETE ON dbo.PersonCustomFieldFlat TO public
	REVOKE UPDATE ON dbo.PersonCustomFieldFlat TO public
	REVOKE SELECT ON dbo.PersonCustomFieldFlat TO public
	REVOKE SELECT ON dbo.vwPersonCustomField TO public

	REVOKE INSERT ON dbo.PersonXLanguageFlat TO public
	REVOKE DELETE ON dbo.PersonXLanguageFlat TO public
	REVOKE UPDATE ON dbo.PersonXLanguageFlat TO public
	REVOKE SELECT ON dbo.PersonXLanguageFlat TO public
	-- REVOKE ALTER ON dbo.PersonCustomFieldFlat TO public
END
ELSE
BEGIN
	GRANT INSERT ON dbo.PersonCustomFieldFlat TO public
	GRANT DELETE ON dbo.PersonCustomFieldFlat TO public
	GRANT UPDATE ON dbo.PersonCustomFieldFlat TO public
	GRANT SELECT ON dbo.PersonCustomFieldFlat TO public
	GRANT SELECT ON dbo.vwPersonCustomField TO public

	GRANT INSERT ON dbo.PersonXLanguageFlat TO public
	GRANT DELETE ON dbo.PersonXLanguageFlat TO public
	GRANT UPDATE ON dbo.PersonXLanguageFlat TO public
	GRANT SELECT ON dbo.PersonXLanguageFlat TO public
	-- GRANT ALTER ON dbo.PersonCustomFieldFlat TO public : Needed, but not supported in 2000
END
GO
DELETE dbo.TempX
DELETE dbo.TempXYZ
GO
EXEC dbo.spAdminTestDboImpersonationPrepare
GO
-- PersonCustomFieldFlat is corrupt if it references custom fields that don't exist
IF (SELECT COUNT(*) FROM syscolumns WHERE ID = OBJECT_ID('dbo.PersonCustomFieldFlat')) = 1
OR
EXISTS (
	SELECT SUBSTRING(C.[name],4,LEN(C.[name]) - 10) FROM syscolumns C
	LEFT JOIN dbo.CustomField CF ON CF.FieldID = SUBSTRING(C.[name],4,LEN(C.[name]) - 10)
	WHERE C.ID = OBJECT_ID('dbo.vwPersonCustomFieldFlatSecure') AND 
	C.[name] LIKE 'CF%' AND C.[name] LIKE '%[_]XValue' AND
	CF.FieldID IS NULL
)
OR NOT EXISTS (SELECT * FROM PersonCustomFieldFlat)
DROP TABLE dbo.PersonCustomFieldFlat
GO
IF OBJECT_ID('dbo.PersonCustomFieldFlat') IS NULL
BEGIN
	CREATE TABLE dbo.PersonCustomFieldFlat(PCFPersonID int PRIMARY KEY NOT NULL)
	ALTER TABLE dbo.PersonCustomFieldFlat ADD 
	CONSTRAINT FK_PersonCustomFieldFlat_Person FOREIGN KEY 
	(
		PCFPersonID
	) REFERENCES dbo.Person (
		PersonID
	) ON DELETE CASCADE

	INSERT dbo.PersonCustomFieldFlat(PCFPersonID) SELECT PersonID FROM Person

	BEGIN TRAN

	DECLARE f_cursor CURSOR LOCAL FORWARD_ONLY STATIC FOR SELECT FieldID FROM CustomField
	DECLARE @field_id int, @first_field_id int
	
	SET @first_field_id = null
	OPEN f_cursor FETCH f_cursor INTO @first_field_id
	
	IF @@FETCH_STATUS=0 FETCH f_cursor INTO @field_id
	WHILE @@FETCH_STATUS=0
	BEGIN
		EXEC dbo.spPersonCustomFieldInsertFlatTableColumn @field_id, 1, 0
		FETCH f_cursor INTO @field_id
	END

	IF @first_field_id IS NOT NULL
	EXEC dbo.spPersonCustomFieldInsertFlatTableColumn @first_field_id, 1, 1

	CLOSE f_cursor DEALLOCATE f_cursor

	COMMIT TRAN
END
GO
update pcf set [value]=CAST(0 AS bit) 
from personcustomfield pcf
inner join customfield cf on pcf.fieldid=cf.fieldid and pcf.[value]=0 and cf.typeid=3 and SQL_VARIANT_PROPERTY( pcf.[value],'BaseType') != 'bit'
GO
update pcf set [value]=CAST(0 AS decimal(29,6)) 
from personcustomfield pcf
inner join customfield cf on pcf.fieldid=cf.fieldid and pcf.[value]=0 and cf.typeid=2 and SQL_VARIANT_PROPERTY( pcf.[value],'BaseType') != 'decimal'
GO
IF OBJECT_ID('dbo.spAdminTestDboImpersonation') IS NOT NULL EXEC sp_executesql N'EXEC dbo.spAdminTestDboImpersonation 0,'''',0'
GO
UPDATE Constant SET [Server Version] = 250
GO
DELETE dbo.EmployeeTimeCached
DBCC CHECKIDENT ('EmployeeTimeCached', RESEED, 0)
DELETE dbo.PermissionCached
GO
-- Fixes a duplicate carryover calculation issue
IF EXISTS(SELECT * FROM dbo.EmployeeLeaveEarned WHERE [Auto]=3 GROUP BY EmployeeID, TypeID, [Day past 1900] HAVING COUNT(*) > 1 )
EXEC dbo.spEmployeeLeaveCalcAll
GO
-- Fixes old comp time calculation error
declare @comp_type_id int
select top 1 @comp_type_id = CompLeaveTypeID FROM dbo.TimeType where CompLeaveTypeID is not null

if @comp_type_id is not null and ( 
	exists(select * from employeeleaveunused where typeid=@comp_type_id and unused > 3600000) or 
	not exists(select * from employeeleaveunused where typeid=@comp_type_id)
) exec spemployeeleavecalcfortype @comp_type_id
GO
-- Encountered some older installations where LastCompensationID was set to impossible values
UPDATE Employee SET LastCompensationID = (
	SELECT TOP 1 EC.CompensationID FROM EmployeeCompensation EC WHERE EC.EmployeeID = E.EmployeeID
	ORDER BY EC.[Start Day past 1900] DESC
) 
FROM Employee E
GO
UPDATE dbo.AttachmentTemp SET [Name] = REPLACE([Name],',','_')
UPDATE dbo.EmployeeExpense SET [Attachment Name] = REPLACE([Attachment Name],',','_')
GO
EXEC dbo.spPersonCustomFieldBuildSecureView
GO
DECLARE @sql nvarchar(4000)
SET @sql='DELETE dbo.HolidayCalculated'
EXEC dbo.spAdminExecuteSQLIgnoreErrors @sql
GO
DECLARE @sql nvarchar(4000)
SET @sql='EXEC dbo.spHolidayRecalc'
EXEC dbo.spAdminExecuteSQLIgnoreErrors @sql
GO
DECLARE @sql nvarchar(4000)
SET @sql='if OBJECT_ID(''tempdb..#DEPENDENT_VIEWS'') IS NULL CREATE TABLE #DEPENDENT_VIEWS(ID int, [Order] int NOT NULL identity(1,1))
EXEC dbo.spAdminDependentViews_Identify ''dbo.vwPersonListAs''
EXEC dbo.spAdminDependentViews_Refresh
DELETE #DEPENDENT_VIEWS
EXEC dbo.spAdminDependentViews_Identify ''dbo.vwPersonCalculated''
EXEC dbo.spAdminDependentViews_Refresh'
EXEC dbo.spAdminExecuteSQLIgnoreErrors @sql
GO
DECLARE @sql nvarchar(4000)
SET @sql='EXEC dbo.sp_MSforeachtable @command1="DBCC DBREINDEX (''?'') WITH NO_INFOMSGS"'
EXEC dbo.spAdminExecuteSQLIgnoreErrors @sql
GO
DECLARE @sql nvarchar(4000)
SET @sql='DBCC DBREINDEX (''dbo.vwPersonCustomField2'', '' '', 90) WITH NO_INFOMSGS'
EXEC dbo.spAdminExecuteSQLIgnoreErrors @sql
GO
DECLARE @sql nvarchar(4000)
SET @sql='DBCC DBREINDEX (''dbo.vwEmployeeBenefit'', '' '', 90) WITH NO_INFOMSGS'
EXEC dbo.spAdminExecuteSQLIgnoreErrors @sql
GO
DECLARE @sql nvarchar(4000)
SET @sql='EXEC dbo.sp_updatestats'
EXEC dbo.spAdminExecuteSQLIgnoreErrors @sql
GO
-- Proc will not exist in SQL 2000. Throws warning ( if dbo cannot 
IF OBJECT_ID('dbo.spAdminTestDboImpersonation') IS NOT NULL EXEC sp_executesql N'EXEC dbo.spAdminTestDboImpersonation 1,N''The update succeeded.'',0'
GO